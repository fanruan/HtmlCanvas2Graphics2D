/* version: 1.7.0; hash: 46b6ae5; buildTime: 2020-1-8 14:41:49 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@/util/Zousan')) :
    typeof define === 'function' && define.amd ? define(['@/util/Zousan'], factory) :
    (global = global || self, global.Van = factory(global.Zousan));
}(this, function (Zousan) { 'use strict';

    Zousan = Zousan && Zousan.hasOwnProperty('default') ? Zousan['default'] : Zousan;

    var forOwn = function forOwn(obj, cb) {
      for (var n in obj) {
        if (obj.hasOwnProperty(n)) {
          if (cb(obj[n], n) === false) {
            return;
          }
        }
      }
    };

    /**
     * Created by Jeffrey on 2018/1/17.
     */

    var assign = Object.assign || function (target) {
      for (var j = 1, len = arguments.length; j < len; j++) {
        forOwn(arguments[j], function (value, key) {
          target[key] = value;
        });
      }

      return target;
    };

    /**
     * INTERNAL_LAYER_PREFIX The id prefix of internal layers
     * @global
     */
    var INTERNAL_LAYER_PREFIX = '_maptalks__internal_layer_';
    var GEOMETRY_COLLECTION_TYPES = ['MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
    var GEOJSON_TYPES = ['FeatureCollection', 'Feature', 'Point', 'LineString', 'Polygon'].concat(GEOMETRY_COLLECTION_TYPES);
    /**
     * Symbol properties containing external resources
     */

    var RESOURCE_PROPERTIES = ['markerFile', 'polygonPatternFile', 'linePatternFile', 'markerFillPatternFile', 'markerLinePatternFile'];
    /**
     * Corresponding size properties for the above resource properties
     */

    var RESOURCE_SIZE_PROPERTIES = [['markerWidth', 'markerHeight'], [], [null, 'lineWidth'], [], [null, 'markerLineWidth']];
    /**
     * numeric symbol properties
     */

    var NUMERICAL_PROPERTIES = {
      'lineWidth': 1,
      'lineOpacity': 1,
      'lineDx': 1,
      'lineDy': 1,
      'polygonOpacity': 1,
      'markerWidth': 1,
      'markerHeight': 1,
      'markerDx': 1,
      'markerDy': 1,
      'markerOpacity': 1,
      'markerFillOpacity': 1,
      'markerLineWidth': 1,
      'markerLineOpacity': 1,
      'textSize': 1,
      'textOpacity': 1,
      'textHaloRadius': 1,
      'textWrapWidth': 1,
      'textLineSpacing': 1,
      'textDx': 1,
      'textDy': 1
    };
    /**
     *  color symbol properties
     */

    var COLOR_PROPERTIES = ['lineColor', 'polygonFill', 'markerFill', 'markerLineColor', 'textFill'];
    var DEFAULT_TEXT_SIZE = 14;

    function now() {
      return Date.now();
    }
    /**
     * @classdesc
     * Utilities methods used internally. It is static and should not be initiated.
     * @class
     * @static
     * @category core
     * @name Util
     */

    /**
     * Merges the properties of sources into destination object.
     * @param  {Object} dest   - object to extend
     * @param  {...Object} src - sources
     * @return {Object}
     * @memberOf Util
     */

    function extend(dest) {
      // (Object[, Object, ...]) ->
      for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];

        for (var k in src) {
          dest[k] = src[k];
        }
      }

      return dest;
    }
    /**
     * Whether the object is null or undefined.
     * @param  {Object}  obj - object
     * @return {Boolean}
     * @memberOf Util
     */

    function isNil(obj) {
      return obj == null;
    }
    /**
     * Whether val is a number and not a NaN.
     * @param  {Object}  val - val
     * @return {Boolean}
     * @memberOf Util
     */

    function isNumber(val) {
      return typeof val === 'number' && !isNaN(val);
    }
    /**
     * Whether a number is an integer
     * @param  {Number}  n
     * @return {Boolean}
     * @memberOf Util
     */

    function isInteger(n) {
      return (n | 0) === n;
    }
    /**
     * Whether the obj is a javascript object.
     * @param  {Object}  obj  - object
     * @return {Boolean}
     * @memberOf Util
     */

    function isObject(obj) {
      return typeof obj === 'object' && !!obj;
    }
    /**
     * Check whether the object is a string
     * @param {Object} obj
     * @return {Boolean}
     * @memberOf Util
     */

    function isString(obj) {
      if (isNil(obj)) {
        return false;
      }

      return typeof obj === 'string' || obj.constructor !== null && obj.constructor === String;
    }
    /**
     * Check whether the object is a function
     * @param {Object} obj
     * @return {Boolean}
     * @memberOf Util
     */

    function isFunction(obj) {
      if (isNil(obj)) {
        return false;
      }

      return typeof obj === 'function' || obj.constructor !== null && obj.constructor === Function;
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * Check whether the object owns the property.
     * @param  {Object}  obj - object
     * @param  {String}  key - property
     * @return {Boolean}
     * @memberOf Util
     */

    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    /**
     * Join an array, standard or a typed one.
     * @param  {Object[]} arr       array to join
     * @param  {String} seperator  seperator
     * @return {String}           result string
     * @private
     * @memberOf Util
     */

    function join(arr, seperator) {
      if (arr.join) {
        return arr.join(seperator || ',');
      } else {
        return Array.prototype.join.call(arr, seperator || ',');
      }
    }
    /**
     * Determine if an object has any properties.
     * @param object The object to check.
     * @returns {boolean} The object is empty
     */

    function isEmpty(object) {
      var property;

      for (property in object) {
        return false;
      }

      return !property;
    }
    var pi = Math.PI / 180;
    function toRadian(d) {
      return d * pi;
    }
    function toDegree(r) {
      return r / pi;
    }

    /**
     * from detect-node
     * https://github.com/iliakan/detect-node
     *
     * @property {boolean} IS_NODE - whether running in nodejs but not on electron,node-webkit
     * @global
     * @name IS_NODE
     */
    var IS_NODE = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && !process.versions['electron'] && !process.versions['nw'] && !process.versions['node-webkit'];

    var requestAnimFrame, cancelAnimFrame;
    /* istanbul ignore next */

    (function () {
      if (IS_NODE) {
        requestAnimFrame = function requestAnimFrame(fn) {
          return setTimeout(fn, 16);
        };

        cancelAnimFrame = clearTimeout;
        return;
      }

      var requestFn, cancelFn; // slow down fps in IE9 for performance

      var timeToCall = 1000 / 30;

      function timeoutDefer(fn) {
        return setTimeout(fn, timeToCall);
      }

      function getPrefixed(name) {
        return window['webkit' + name] || window['moz' + name] || window['ms' + name];
      }

      if (typeof window != 'undefined') {
        // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        requestFn = window['requestAnimationFrame'] || getPrefixed('RequestAnimationFrame') || timeoutDefer;

        cancelFn = window['cancelAnimationFrame'] || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
          window.clearTimeout(id);
        };
      } else {
        requestFn = timeoutDefer;
        cancelFn = clearTimeout;
      }
      /**
       * Polyfill of RequestAnimationFrame
       * @param  {Function} fn callback
       * @return {Number}      request id
       * @memberOf Util
       */


      requestAnimFrame = function requestAnimFrame(fn) {
        return requestFn(fn);
      };
      /**
       * Polyfill of cancelAnimationFrame
       * @param  {Number}      request id
       * @memberOf Util
       */


      cancelAnimFrame = function cancelAnimFrame(id) {
        if (id) {
          cancelFn(id);
        }
      };
    })();
    function isSVG(url) {
      var prefix = 'data:image/svg+xml';

      if (url.length > 4 && url.slice(-4) === '.svg') {
        return 1;
      } else if (url.slice(0, prefix.length) === prefix) {
        return 2;
      }

      return 0;
    }
    /**
     * Load a image, can be a remote one or a local file. <br>
     * If in node, a SVG image will be converted to a png file by [svg2img]{@link https://github.com/FuZhenn/node-svg2img}<br>
     * @param  {Image} img  - the image object to load.
     * @param  {Object[]} imgDesc - image's descriptor, it's an array. imgUrl[0] is the url string, imgUrl[1] is the width, imgUrl[2] is the height.
     * @private
     * @memberOf Util
     */

    function loadImage(img, imgDesc) {
      /* istanbul ignore next */
      if (IS_NODE && loadImage.node) {
        loadImage.node(img, imgDesc);
        return;
      }

      img.src = imgDesc[0];
    }
    var uid = 0;
    function UID() {
      return uid++;
    }
    var GUID = UID;
    /**
     * Parse a JSON string to a object
     * @param {String} str      - a JSON string
     * @return {Object}
     * @memberOf Util
     */

    function parseJSON(str) {
      if (!str || !isString(str)) {
        return str;
      }

      return JSON.parse(str);
    }
    function pushIn(dest) {
      for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];

        if (src) {
          for (var ii = 0, ll = src.length; ii < ll; ii++) {
            dest.push(src[ii]);
          }
        }
      }

      return dest.length;
    }
    function removeFromArray(obj, array) {
      var i = array.indexOf(obj);

      if (i > -1) {
        array.splice(i, 1);
      }
    }
    function forEachCoord(arr, fn, context) {
      if (!Array.isArray(arr)) {
        return context ? fn.call(context, arr) : fn(arr);
      }

      var result = [];
      var p, pp;

      for (var i = 0, len = arr.length; i < len; i++) {
        p = arr[i];

        if (isNil(p)) {
          result.push(null);
          continue;
        }

        if (Array.isArray(p)) {
          result.push(forEachCoord(p, fn, context));
        } else {
          pp = context ? fn.call(context, p) : fn(p);
          result.push(pp);
        }
      }

      return result;
    }
    function getValueOrDefault(v, d) {
      return v === undefined ? d : v;
    }
    /**
     * Polyfill for Math.sign
     * @param  {Number} x
     * @return {Number}
     * @memberOf Util
     */

    /* istanbul ignore next */

    function sign(x) {
      if (Math.sign) {
        return Math.sign(x);
      }

      x = +x; // convert to a number

      if (x === 0 || isNaN(x)) {
        return Number(x);
      }

      return x > 0 ? 1 : -1;
    }
    function log2(x) {
      if (Math.log2) {
        return Math.log2(x);
      }

      var v = Math.log(x) * Math.LOG2E;
      var rounded = Math.round(v);

      if (Math.abs(rounded - v) < 1E-14) {
        return rounded;
      } else {
        return v;
      }
    }
    /*
     * Interpolate between two number.
     *
     * @param {Number} from
     * @param {Number} to
     * @param {Number} t interpolation factor between 0 and 1
     * @returns {Number} interpolated color
     */

    function interpolate(a, b, t) {
      return a * (1 - t) + b * t;
    }
    /*
     * constrain n to the given range, via modular arithmetic
     * @param {Number} n value
     * @param {Number} min the minimum value to be returned, inclusive
     * @param {Number} max the maximum value to be returned, inclusive
     * @returns {Number} constrained number
     * @private
     */

    function wrap(n, min, max) {
      if (n === max || n === min) {
        return n;
      }

      var d = max - min;
      var w = ((n - min) % d + d) % d + min;
      return w;
    }
    /**
     * constrain n to the given range via min + max
     *
     * @param {Number} n value
     * @param {Number} min the minimum value to be returned
     * @param {Number} max the maximum value to be returned
     * @returns {Number} the clamped value
     * @private
     */

    function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }
    /*
     * Is object an array and not empty.
     * @param {Object} obj
     * @return {Boolean} true|false
     * @private
     * @memberOf Util
     */

    function isArrayHasData(obj) {
      return Array.isArray(obj) && obj.length > 0;
    }
    /**
     * Whether the input string is a valid url.
     * @param  {String}  url - url to check
     * @return {Boolean}
     * @memberOf Util
     * @private
     */

    function isURL(url) {
      if (!url) {
        return false;
      }

      var head = url.slice(0, 6);

      if (head === 'http:/' || head === 'https:' || head === 'file:/') {
        return true;
      }

      return false;
    } //改原先的regex名字为xWithQuote；不带引号的regex，/^url\(([^\'\"].*[^\'\"])\)$/i，为xWithoutQuote。然后在is函数里||测试，extract函数里if...else处理。没引号的匹配后，取matches[1]
    // match: url('x'), url("x").
    // TODO: url(x)

    var cssUrlReWithQuote = /^url\((['"])(.+)\1\)$/i;
    var cssUrlRe = /^url\(([^'"].*[^'"])\)$/i;
    function isCssUrl(str) {
      if (!isString(str)) {
        return 0;
      }

      var head = str.slice(0, 6);

      if (head === 'http:/' || head === 'https:') {
        return 3;
      }

      if (cssUrlRe.test(str)) {
        return 1;
      }

      if (cssUrlReWithQuote.test(str)) {
        return 2;
      }

      return 0;
    }
    function extractCssUrl(str) {
      var test = isCssUrl(str);
      var matches;

      if (test === 3) {
        return str;
      }

      if (test === 1) {
        matches = cssUrlRe.exec(str);
        return matches[1];
      } else if (test === 2) {
        matches = cssUrlReWithQuote.exec(str);
        return matches[2];
      } else {
        // return as is if not an css url
        return str;
      }
    }
    var b64chrs = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    /**
     * btoa or a polyfill in old browsers. <br>
     * Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.<br>
     * From https://github.com/davidchambers/Base64.js
     * @param  {Buffer} input - input string to convert
     * @return {String} ascii
     * @memberOf Util
     * @example
     *     const encodedData = Util.btoa(stringToEncode);
     */

    /* istanbul ignore next */

    function btoa(input) {
      if (typeof window !== 'undefined' && window.btoa) {
        return window.btoa(input);
      }

      var str = String(input);
      var output = '';

      for ( // initialize result and counter
      var block, charCode, idx = 0, map = b64chrs; // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1); // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
        charCode = str.charCodeAt(idx += 3 / 4);

        if (charCode > 0xFF) {
          throw new Error('\'btoa\' failed: The string to be encoded contains characters outside of the Latin1 range.');
        }

        block = block << 8 | charCode;
      }

      return output;
    }
    function b64toBlob(b64Data, contentType) {
      var byteCharacters = atob(b64Data);
      var arraybuffer = new ArrayBuffer(byteCharacters.length);
      var view = new Uint8Array(arraybuffer);

      for (var i = 0; i < byteCharacters.length; i++) {
        view[i] = byteCharacters.charCodeAt(i) & 0xff;
      }

      var blob = new Blob([arraybuffer], {
        type: contentType
      });
      return blob;
    }
    /**
     * Compute degree bewteen 2 points.
     * @param  {Point} p1 point 1
     * @param  {Point} p2 point 2
     * @return {Number}    degree between 2 points
     * @memberOf Util
     */

    function computeDegree(x0, y0, x1, y1) {
      var dx = x1 - x0;
      var dy = y1 - y0;
      return Math.atan2(dy, dx);
    }
    /**
     * Transparent 1X1 gif image
     * from https://css-tricks.com/snippets/html/base64-encode-of-1x1px-transparent-gif/
     * @type {String}
     * @memberOf Util
     */

    var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    /**
     * shallow equal
     * @param  {Object} obj1
     * @param  {Object} obj2
     * @return {Boolean}
     * @private
     * @memberOf Util
     */

    function equalMapView(obj1, obj2) {
      if (!obj1 && !obj2) {
        return true;
      } else if (!obj1 || !obj2) {
        return false;
      }

      for (var p in obj1) {
        if (p === 'center') {
          if (!obj2[p] || !approx(obj1[p][0], obj2[p][0]) || !approx(obj1[p][1], obj2[p][1])) {
            return false;
          }
        } else if (obj1[p] !== obj2[p]) {
          return false;
        }
      }

      return true;
    }

    function approx(val, expected, delta) {
      if (delta == null) {
        delta = 1e-6;
      }

      return val >= expected - delta && val <= expected + delta;
    }
    /**
     * Flash something, show and hide by certain internal for times of count.
     *
     * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)
     * @param {Number} [count=4]          - flash times
     * @param {Function} [cb=null]        - callback function when flash ended
     * @param {*} [context=null]          - callback context
     * @return {*} this
     * @private
     * @memberOf Util
     */


    function flash(interval, count, cb, context) {
      if (!interval) {
        interval = 100;
      }

      if (!count) {
        count = 4;
      }

      var me = this;
      count *= 2;

      if (this._flashTimeout) {
        clearTimeout(this._flashTimeout);
      }

      function flashGeo() {
        if (count === 0) {
          me.show();

          if (cb) {
            if (context) {
              cb.call(context);
            } else {
              cb();
            }
          }

          return;
        }

        if (count % 2 === 0) {
          me.hide();
        } else {
          me.show();
        }

        count--;
        me._flashTimeout = setTimeout(flashGeo, interval);
      }

      this._flashTimeout = setTimeout(flashGeo, interval);
      return this;
    }
    function _defaults(obj, defaults) {
      var keys = Object.getOwnPropertyNames(defaults);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = Object.getOwnPropertyDescriptor(defaults, key);

        if (value && value.configurable && obj[key] === undefined) {
          Object.defineProperty(obj, key, value);
        }
      }

      return obj;
    }

    /*!
        Feature Filter by

        (c) mapbox 2016 and maptalks 2018
        www.mapbox.com | www.maptalks.org
        License: MIT, header required.
    */
    var types = ['Unknown', 'Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
    /**
     * Given a filter expressed as nested arrays, return a new function
     * that evaluates whether a given feature (with a .properties or .tags property)
     * passes its test.
     *
     * @param {Array} filter mapbox gl filter
     * @returns {Function} filter-evaluating function
     */

    function createFilter(filter) {
      return new Function('f', "var p = (f && f.properties || {}); return " + compile(filter));
    }

    function compile(filter) {
      if (!filter) return 'true';
      var op = filter[0];
      if (filter.length <= 1) return op === 'any' ? 'false' : 'true';
      var str = op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) : op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) : op === '<' || op === '>' || op === '<=' || op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) : op === 'any' ? compileLogicalOp(filter.slice(1), '||') : op === 'all' ? compileLogicalOp(filter.slice(1), '&&') : op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) : op === 'in' ? compileInOp(filter[1], filter.slice(2)) : op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) : op === 'has' ? compileHasOp(filter[1]) : op === '!has' ? compileNegation(compileHasOp(filter[1])) : 'true';
      return "(" + str + ")";
    }

    function compilePropertyReference(property) {
      // const ref =
      //     property === '$type' ? 'f.type' :
      //         property === '$id' ? 'f.id' : `p[${JSON.stringify(property)}]`;
      // return ref;
      return property[0] === '$' ? 'f.' + property.substring(1) : 'p[' + JSON.stringify(property) + ']';
    }

    function compileComparisonOp(property, value, op, checkType) {
      var left = compilePropertyReference(property);
      var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
      return (checkType ? "typeof " + left + "=== typeof " + right + "&&" : '') + left + op + right;
    }

    function compileLogicalOp(expressions, op) {
      return expressions.map(compile).join(op);
    }

    function compileInOp(property, values) {
      if (property === '$type') values = values.map(function (value) {
        return types.indexOf(value);
      });
      var left = JSON.stringify(values.sort(compare));
      var right = compilePropertyReference(property);
      if (values.length <= 200) return left + ".indexOf(" + right + ") !== -1";
      return "function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(" + right + ", " + left + ",0," + (values.length - 1) + ")";
    }

    function compileHasOp(property) {
      return property === '$id' ? '"id" in f' : JSON.stringify(property) + " in p";
    }

    function compileNegation(expression) {
      return "!(" + expression + ")";
    } // Comparison function to sort numbers and strings


    function compare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    /**
     * Get feature object from a geometry for filter functions.
     * @param  {Geometry} geometry geometry
     * @return {Object}          feature for filter functions
     */


    function getFilterFeature(geometry) {
      var json = geometry._toJSON(),
          g = json['feature'];

      g['type'] = types.indexOf(g['geometry']['type']);
      g['subType'] = json['subType'];
      return g;
    }
    /**
     * Compile layer's style, styles to symbolize layer's geometries, e.g.<br>
     * <pre>
     * [
     *   {
     *     'filter' : ['==', 'foo', 'val'],
     *     'symbol' : {'markerFile':'foo.png'}
     *   }
     * ]
     * </pre>
     * @param  {Object|Object[]} styles - style to compile
     * @return {Object[]}       compiled styles
     */

    function compileStyle(styles) {
      if (!Array.isArray(styles)) {
        return compileStyle([styles]);
      }

      var compiled = [];

      for (var i = 0; i < styles.length; i++) {
        var filter = void 0;

        if (styles[i]['filter'] === true) {
          filter = function filter() {
            return true;
          };
        } else {
          filter = createFilter(styles[i]['filter']);
        }

        compiled.push(extend$1({}, styles[i], {
          filter: filter
        }));
      }

      return compiled;
    }

    function extend$1(dest) {
      // (Object[, Object, ...]) ->
      for (var i = 1; i < arguments.length; i++) {
        var src = arguments[i];

        for (var k in src) {
          dest[k] = src[k];
        }
      }

      return dest;
    }

    /*eslint-disable no-var, prefer-const*/
    function createFunction(parameters, defaultType) {
      var fun;
      var isFeatureConstant, isZoomConstant;

      if (!isFunctionDefinition(parameters)) {
        fun = function fun() {
          return parameters;
        };

        isFeatureConstant = true;
        isZoomConstant = true;
      } else {
        var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        var zoomDependent = zoomAndFeatureDependent || !featureDependent;
        var type = parameters.type || defaultType || 'exponential';
        var innerFun;

        if (type === 'exponential') {
          innerFun = evaluateExponentialFunction;
        } else if (type === 'interval') {
          innerFun = evaluateIntervalFunction;
        } else if (type === 'categorical') {
          innerFun = evaluateCategoricalFunction;
        } else if (type === 'identity') {
          innerFun = evaluateIdentityFunction;
        } else {
          throw new Error('Unknown function type "' + type + '"');
        }

        if (zoomAndFeatureDependent) {
          var featureFunctions = {};
          var featureFunctionStops = [];

          for (var s = 0; s < parameters.stops.length; s++) {
            var stop = parameters.stops[s];

            if (featureFunctions[stop[0].zoom] === undefined) {
              featureFunctions[stop[0].zoom] = {
                zoom: stop[0].zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default,
                stops: []
              };
            }

            featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
          }

          for (var z in featureFunctions) {
            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
          }

          fun = function fun(zoom, feature) {
            var value = evaluateExponentialFunction({
              stops: featureFunctionStops,
              base: parameters.base
            }, zoom)(zoom, feature);
            return typeof value === 'function' ? value(zoom, feature) : value;
          };

          isFeatureConstant = false;
          isZoomConstant = false;
        } else if (zoomDependent) {
          fun = function fun(zoom) {
            var value = innerFun(parameters, zoom);
            return typeof value === 'function' ? value(zoom) : value;
          };

          isFeatureConstant = true;
          isZoomConstant = false;
        } else {
          fun = function fun(zoom, feature) {
            var value = innerFun(parameters, feature ? feature[parameters.property] : null);
            return typeof value === 'function' ? value(zoom, feature) : value;
          };

          isFeatureConstant = false;
          isZoomConstant = true;
        }
      }

      fun.isZoomConstant = isZoomConstant;
      fun.isFeatureConstant = isFeatureConstant;
      return fun;
    }

    function coalesce(a, b, c) {
      if (a !== undefined) return a;
      if (b !== undefined) return b;
      if (c !== undefined) return c;
      return null;
    }

    function evaluateCategoricalFunction(parameters, input) {
      for (var i = 0; i < parameters.stops.length; i++) {
        if (input === parameters.stops[i][0]) {
          return parameters.stops[i][1];
        }
      }

      return parameters.default;
    }

    function evaluateIntervalFunction(parameters, input) {
      for (var i = 0; i < parameters.stops.length; i++) {
        if (input < parameters.stops[i][0]) break;
      }

      return parameters.stops[Math.max(i - 1, 0)][1];
    }

    function evaluateExponentialFunction(parameters, input) {
      var base = parameters.base !== undefined ? parameters.base : 1;
      var i = 0;

      while (true) {
        if (i >= parameters.stops.length) break;else if (input <= parameters.stops[i][0]) break;else i++;
      }

      if (i === 0) {
        return parameters.stops[i][1];
      } else if (i === parameters.stops.length) {
        return parameters.stops[i - 1][1];
      } else {
        return interpolate$1(input, base, parameters.stops[i - 1][0], parameters.stops[i][0], parameters.stops[i - 1][1], parameters.stops[i][1]);
      }
    }

    function evaluateIdentityFunction(parameters, input) {
      return coalesce(input, parameters.default);
    }

    function interpolate$1(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      if (typeof outputLower === 'function') {
        return function () {
          var evaluatedLower = outputLower.apply(undefined, arguments);
          var evaluatedUpper = outputUpper.apply(undefined, arguments);
          return interpolate$1(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
        };
      } else if (outputLower.length) {
        return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
      } else {
        return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
      }
    }

    function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      var difference = inputUpper - inputLower;
      var progress = input - inputLower;
      var ratio;

      if (base === 1) {
        ratio = progress / difference;
      } else {
        ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
      }

      return outputLower * (1 - ratio) + outputUpper * ratio;
    }

    function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
      var output = [];

      for (var i = 0; i < outputLower.length; i++) {
        output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
      }

      return output;
    }
    /**
     * Check if object is a definition of function type
     * @param  {Object}  obj object
     * @return {Boolean}
     * @memberOf MapboxUtil
     */


    function isFunctionDefinition(obj) {
      return obj && typeof obj === 'object' && (obj.stops || obj.property && obj.type === 'identity');
    }
    /**
     * Check if obj's properties has function definition
     * @param  {Object}  obj object to check
     * @return {Boolean}
     * @memberOf MapboxUtil
     */

    function hasFunctionDefinition(obj) {
      for (var p in obj) {
        if (isFunctionDefinition(obj[p])) {
          return true;
        }
      }

      return false;
    }
    function interpolated(parameters) {
      return createFunction1(parameters, 'exponential');
    }
    function piecewiseConstant(parameters) {
      return createFunction1(parameters, 'interval');
    }
    /**
     * Load function types defined in object
     * @param  {Object[]} parameters parameters
     * @return {Object}   loaded object
     * @memberOf MapboxUtil
     */

    function loadFunctionTypes(obj, argFn) {
      if (!obj) {
        return null;
      }

      var hit = false;

      if (Array.isArray(obj)) {
        var multResult = [],
            loaded;

        for (var i = 0; i < obj.length; i++) {
          loaded = loadFunctionTypes(obj[i], argFn);

          if (!loaded) {
            multResult.push(obj[i]);
          } else {
            multResult.push(loaded);
            hit = true;
          }
        }

        return hit ? multResult : obj;
      }

      var result = {
        '__fn_types_loaded': true
      },
          props = [],
          p;

      for (p in obj) {
        if (obj.hasOwnProperty(p)) {
          props.push(p);
        }
      }

      var buildFn = function buildFn(p) {
        Object.defineProperty(result, p, {
          get: function get() {
            if (!this['__fn_' + p]) {
              this['__fn_' + p] = interpolated(this['_' + p]);
            }

            return this['__fn_' + p].apply(this, argFn());
          },
          set: function set(v) {
            this['_' + p] = v;
          },
          configurable: true,
          enumerable: true
        });
      };

      for (var _i = 0, len = props.length; _i < len; _i++) {
        p = props[_i];

        if (isFunctionDefinition(obj[p])) {
          hit = true;
          result['_' + p] = obj[p];
          buildFn(p);
        } else {
          result[p] = obj[p];
        }
      }

      return hit ? result : obj;
    }
    /**
     * Get external resources in the function type
     * @param  {Object} t Function type definition
     * @return {String[]}   resouces
     * @memberOf MapboxUtil
     */

    function getFunctionTypeResources(t) {
      if (!t || !t.stops) {
        return [];
      }

      var res = [];

      for (var i = 0, l = t.stops.length; i < l; i++) {
        res.push(t.stops[i][1]);
      }

      return res;
    }
    /*eslint-enable no-var, prefer-const*/

    function createFunction1(parameters, defaultType) {
      if (!isFunctionDefinition(parameters)) {
        return function () {
          return parameters;
        };
      }

      parameters = JSON.parse(JSON.stringify(parameters));
      var isZoomConstant = true;
      var isFeatureConstant = true;
      var stops = parameters.stops;

      if (stops) {
        for (var i = 0; i < stops.length; i++) {
          if (isFunctionDefinition(stops[i][1])) {
            var _fn = createFunction1(stops[i][1], defaultType);

            isZoomConstant = isZoomConstant && _fn.isZoomConstant;
            isFeatureConstant = isFeatureConstant && _fn.isFeatureConstant;
            stops[i] = [stops[i][0], _fn];
          }
        }
      }

      var fn = createFunction(parameters, defaultType);
      fn.isZoomConstant = isZoomConstant && fn.isZoomConstant;
      fn.isFeatureConstant = isFeatureConstant && fn.isFeatureConstant;
      return fn;
    }

    /**
     * @classdesc
     * Utilities from mapbox or implementations of mapbox specifications. It is static and should not be initiated.
     * @class
     * @category core
     * @name MapboxUtil
     */

    var index = /*#__PURE__*/Object.freeze({
        createFilter: createFilter,
        getFilterFeature: getFilterFeature,
        compileStyle: compileStyle,
        isFunctionDefinition: isFunctionDefinition,
        hasFunctionDefinition: hasFunctionDefinition,
        interpolated: interpolated,
        piecewiseConstant: piecewiseConstant,
        loadFunctionTypes: loadFunctionTypes,
        getFunctionTypeResources: getFunctionTypeResources
    });

    /**
     * Translate symbol properties to SVG properties
     * @param  {Object} s - object with symbol properties
     * @return {Object}   object with SVG properties
     * @memberOf Util
     */

    function translateToSVGStyles(s) {
      var result = {
        'stroke': {
          'stroke': s['markerLineColor'],
          'stroke-width': s['markerLineWidth'],
          'stroke-opacity': s['markerLineOpacity'],
          'stroke-dasharray': null,
          'stroke-linecap': 'butt',
          'stroke-linejoin': 'round'
        },
        'fill': {
          'fill': s['markerFill'],
          'fill-opacity': s['markerFillOpacity']
        }
      };

      if (result['stroke']['stroke-width'] === 0) {
        result['stroke']['stroke-opacity'] = 0;
      }

      return result;
    }
    /**
     * Get SVG Base64 String from a marker symbol with (markerType : path)
     * @param  {Object} symbol - symbol with markerType of path
     * @return {String}        SVG Base64 String
     * @memberOf Util
     */

    function getMarkerPathBase64(symbol, width, height) {
      if (!symbol['markerPath']) {
        return null;
      }

      var op = 1;
      var styles = translateToSVGStyles(symbol); //context.globalAlpha doesn't take effect with drawing SVG in IE9/10/11 and EGDE, so set opacity in SVG element.

      if (isNumber(symbol['markerOpacity'])) {
        op = symbol['markerOpacity'];
      }

      if (isNumber(symbol['opacity'])) {
        op *= symbol['opacity'];
      }

      var svgStyles = {};

      if (styles) {
        for (var p in styles['stroke']) {
          if (styles['stroke'].hasOwnProperty(p)) {
            if (!isNil(styles['stroke'][p])) {
              svgStyles[p] = styles['stroke'][p];
            }
          }
        }

        for (var _p in styles['fill']) {
          if (styles['fill'].hasOwnProperty(_p)) {
            if (!isNil(styles['fill'][_p])) {
              svgStyles[_p] = styles['fill'][_p];
            }
          }
        }
      }

      var pathes = Array.isArray(symbol['markerPath']) ? symbol['markerPath'] : [symbol['markerPath']];
      var path;
      var pathesToRender = [];

      for (var i = 0; i < pathes.length; i++) {
        path = isString(pathes[i]) ? {
          'path': pathes[i]
        } : pathes[i];
        path = extend({}, path, svgStyles);
        path['d'] = path['path'];
        delete path['path'];
        pathesToRender.push(path);
      }

      var svg = ['<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"'];

      if (op < 1) {
        svg.push('opacity="' + op + '"');
      } // if (symbol['markerWidth'] && symbol['markerHeight']) {
      //     svg.push('height="' + symbol['markerHeight'] + '" width="' + symbol['markerWidth'] + '"');
      // }


      if (symbol['markerPathWidth'] && symbol['markerPathHeight']) {
        svg.push('viewBox="0 0 ' + symbol['markerPathWidth'] + ' ' + symbol['markerPathHeight'] + '"');
      }

      svg.push('preserveAspectRatio="none"');

      if (width) {
        svg.push('width="' + width + '"');
      }

      if (height) {
        svg.push('height="' + height + '"');
      }

      svg.push('><defs></defs>');

      for (var _i = 0; _i < pathesToRender.length; _i++) {
        var strPath = '<path ';

        for (var _p2 in pathesToRender[_i]) {
          if (pathesToRender[_i].hasOwnProperty(_p2)) {
            strPath += ' ' + _p2 + '="' + pathesToRender[_i][_p2] + '"';
          }
        }

        strPath += '></path>';
        svg.push(strPath);
      }

      svg.push('</svg>');
      var b64 = 'data:image/svg+xml;base64,' + btoa(svg.join(' '));
      return b64;
    }
    /**
     * Get external resources from the given symbol
     * @param  {Object} symbol      - symbol
     * @param  {Boolean} toAbsolute - whether convert url to aboslute
     * @return {String[]}           - resource urls
     * @memberOf Util
     */

    function getExternalResources(symbol, toAbsolute) {
      if (!symbol) {
        return [];
      }

      var symbols = symbol;

      if (!Array.isArray(symbol)) {
        symbols = [symbol];
      }

      var resources = [];
      var props = RESOURCE_PROPERTIES;
      var res, resSizeProp;
      var w, h;

      for (var i = symbols.length - 1; i >= 0; i--) {
        symbol = symbols[i];

        if (!symbol) {
          continue;
        }

        if (toAbsolute) {
          symbol = convertResourceUrl(symbol);
        }

        for (var ii = 0; ii < props.length; ii++) {
          res = symbol[props[ii]];

          if (isFunctionDefinition(res)) {
            res = getFunctionTypeResources(res);
          }

          if (!res) {
            continue;
          }

          if (!Array.isArray(res)) {
            res = [res];
          }

          for (var iii = 0; iii < res.length; iii++) {
            if (res[iii].slice(0, 4) === 'url(') {
              res[iii] = extractCssUrl(res[iii]);
            }

            resSizeProp = RESOURCE_SIZE_PROPERTIES[ii];
            resources.push([res[iii], symbol[resSizeProp[0]], symbol[resSizeProp[1]]]);
          }
        }

        if (symbol['markerType'] === 'path' && symbol['markerPath']) {
          w = isFunctionDefinition(symbol['markerWidth']) ? 200 : symbol['markerWidth'];
          h = isFunctionDefinition(symbol['markerHeight']) ? 200 : symbol['markerHeight'];

          if (isFunctionDefinition(symbol['markerPath'])) {
            res = getFunctionTypeResources(symbol['markerPath']);
            var path = symbol['markerPath'];

            for (var _iii = 0; _iii < res.length; _iii++) {
              symbol['markerPath'] = res[_iii];
              resources.push([getMarkerPathBase64(symbol), w, h]);
            }

            symbol['markerPath'] = path;
          } else {
            resources.push([getMarkerPathBase64(symbol), w, h]);
          }
        }
      }

      return resources;
    }
    /**
     * Convert symbol's resources' urls from relative path to an absolute path.
     * @param  {Object} symbol
     * @private
     * @memberOf Util
     */

    function convertResourceUrl(symbol) {
      if (!symbol) {
        return null;
      }

      var s = symbol;

      if (IS_NODE) {
        return s;
      }

      var props = RESOURCE_PROPERTIES;
      var res;

      for (var ii = 0, len = props.length; ii < len; ii++) {
        res = s[props[ii]];

        if (!res) {
          continue;
        }

        s[props[ii]] = _convertUrlToAbsolute(res);
      }

      return s;
    }

    function _convertUrlToAbsolute(res) {
      if (isFunctionDefinition(res)) {
        var stops = res.stops;

        for (var i = 0; i < stops.length; i++) {
          stops[i][1] = _convertUrlToAbsolute(stops[i][1]);
        }

        return res;
      }

      var embed = 'data:';

      if (res.slice(0, 4) === 'url(') {
        res = extractCssUrl(res);
      }

      if (!isURL(res) && (res.length <= embed.length || res.substring(0, embed.length) !== embed)) {
        res = _absolute(location.href, res);
      }

      return res;
    }

    function _absolute(base, relative) {
      var stack = base.split('/'),
          parts = relative.split('/');

      if (relative.slice(0, 1) === 0) {
        return stack.slice(0, 3).join('/') + relative;
      } else {
        stack.pop(); // remove current file name (or empty string)
        // (omit if "base" is the current folder without trailing slash)

        for (var i = 0; i < parts.length; i++) {
          if (parts[i] === '.') continue;
          if (parts[i] === '..') stack.pop();else stack.push(parts[i]);
        }

        return stack.join('/');
      }
    }

    /**
     * Whether the color is a gradient
     * @param  {Object}  g - color to test
     * @return {Boolean}
     * @memberOf Util
     */

    function isGradient(g) {
      return g && g['colorStops'];
    }
    /**
     * Get stamp of a gradient color object.
     * @param  {Object} g gradient color object
     * @return {String}     gradient stamp
     * @memberOf Util
     */

    function getGradientStamp(g) {
      var keys = [g['type']];

      if (g['places']) {
        keys.push(g['places'].join());
      }

      if (g['colorStops']) {
        var stops = [];

        for (var i = g['colorStops'].length - 1; i >= 0; i--) {
          stops.push(g['colorStops'][i].join());
        }

        keys.push(stops.join(','));
      }

      return keys.join('_');
    }
    /**
     * Get stamp of a symbol
     * @param  {Object|Object[]} symbol symbol
     * @return {String}        symbol's stamp
     * @memberOf Util
     */

    function getSymbolStamp(symbol) {
      var keys = [];

      if (Array.isArray(symbol)) {
        for (var i = 0; i < symbol.length; i++) {
          keys.push(getSymbolStamp(symbol[i]));
        }

        return '[ ' + keys.join(' , ') + ' ]';
      }

      for (var p in symbol) {
        if (hasOwn(symbol, p)) {
          if (!isFunction(symbol[p])) {
            if (isGradient(symbol[p])) {
              keys.push(p + '=' + getGradientStamp(symbol[p]));
            } else {
              keys.push(p + '=' + symbol[p]);
            }
          }
        }
      }

      return keys.join(';');
    }
    /**
     * Reduce opacity of the color by ratio
     * @param  {Object|Object[]} symbol symbols to set
     * @param  {Number} ratio  ratio of opacity to reduce
     * @return {Object|Object[]}      new symbol or symbols
     * @memberOf Util
     */

    function lowerSymbolOpacity(symbol, ratio) {
      function s(_symbol, _ratio) {
        var op = _symbol['opacity'];

        if (isNil(op)) {
          _symbol['opacity'] = _ratio;
        } else {
          _symbol['opacity'] *= _ratio;
        }
      }

      var lower;

      if (Array.isArray(symbol)) {
        lower = [];

        for (var i = 0; i < symbol.length; i++) {
          var d = extend({}, symbol[i]);
          s(d, ratio);
          lower.push(d);
        }
      } else {
        lower = extend({}, symbol);
        s(lower, ratio);
      }

      return lower;
    }
    /**
     * Merges the properties of sources into the symbol. <br>
     * @param  {Object|Object[]} symbol symbol to extend
     * @param  {...Object} src - sources
     * @return {Object|Object[]}        merged symbol
     * @memberOf Util
     */

    function extendSymbol(symbol) {
      var sources = Array.prototype.slice.call(arguments, 1);

      if (!sources || !sources.length) {
        sources = [{}];
      }

      if (Array.isArray(symbol)) {
        var s, dest;
        var result = [];

        for (var i = 0, l = symbol.length; i < l; i++) {
          s = symbol[i];
          dest = {};

          for (var ii = 0, ll = sources.length; ii < ll; ii++) {
            if (!Array.isArray(sources[ii])) {
              extend(dest, s, sources[ii] ? sources[ii] : {});
            } else if (!isNil(sources[ii][i])) {
              extend(dest, s, sources[ii][i]);
            } else {
              extend(dest, s ? s : {});
            }
          }

          result.push(dest);
        }

        return result;
      } else {
        var args = [{}, symbol];
        args.push.apply(args, sources);
        return extend.apply(this, args);
      }
    }



    var index$1 = /*#__PURE__*/Object.freeze({
        now: now,
        extend: extend,
        isNil: isNil,
        isNumber: isNumber,
        isInteger: isInteger,
        isObject: isObject,
        isString: isString,
        isFunction: isFunction,
        hasOwn: hasOwn,
        join: join,
        isEmpty: isEmpty,
        toRadian: toRadian,
        toDegree: toDegree,
        IS_NODE: IS_NODE,
        get requestAnimFrame () { return requestAnimFrame; },
        get cancelAnimFrame () { return cancelAnimFrame; },
        isSVG: isSVG,
        loadImage: loadImage,
        UID: UID,
        GUID: GUID,
        parseJSON: parseJSON,
        pushIn: pushIn,
        removeFromArray: removeFromArray,
        forEachCoord: forEachCoord,
        getValueOrDefault: getValueOrDefault,
        sign: sign,
        log2: log2,
        interpolate: interpolate,
        wrap: wrap,
        clamp: clamp,
        isArrayHasData: isArrayHasData,
        isURL: isURL,
        isCssUrl: isCssUrl,
        extractCssUrl: extractCssUrl,
        btoa: btoa,
        b64toBlob: b64toBlob,
        computeDegree: computeDegree,
        emptyImageUrl: emptyImageUrl,
        equalMapView: equalMapView,
        flash: flash,
        _defaults: _defaults,
        translateToSVGStyles: translateToSVGStyles,
        getMarkerPathBase64: getMarkerPathBase64,
        getExternalResources: getExternalResources,
        convertResourceUrl: convertResourceUrl,
        isGradient: isGradient,
        getGradientStamp: getGradientStamp,
        getSymbolStamp: getSymbolStamp,
        lowerSymbolOpacity: lowerSymbolOpacity,
        extendSymbol: extendSymbol
    });

    var Browser = {};

    if (!IS_NODE) {
      var ua = navigator.userAgent.toLowerCase(),
          doc = document.documentElement,
          ie = 'ActiveXObject' in window,
          webkit = ua.indexOf('webkit') !== -1,
          phantomjs = ua.indexOf('phantom') !== -1,
          android23 = ua.search('android [23]') !== -1,
          chrome = ua.indexOf('chrome') !== -1,
          gecko = ua.indexOf('gecko') !== -1 && !webkit && !window.opera && !ie,
          mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
          msPointer = !window.PointerEvent && window.MSPointerEvent,
          pointer = window.PointerEvent && navigator.pointerEnabled || msPointer,
          ie3d = ie && 'transition' in doc.style,
          webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23,
          gecko3d = 'MozPerspective' in doc.style,
          opera12 = 'OTransition' in doc.style,
          any3d = (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs;
      var chromeVersion = 0;

      if (chrome) {
        chromeVersion = ua.match(/chrome\/([\d.]+)/)[1];
      }

      var touch = !phantomjs && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);
      var webgl;

      try {
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        webgl = gl && gl instanceof WebGLRenderingContext;
      } catch (err) {
        webgl = false;
      }

      var devicePixelRatio = window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
      Browser = {
        ie: ie,
        ielt9: ie && !document.addEventListener,
        edge: 'msLaunchUri' in navigator && !('documentMode' in document),
        webkit: webkit,
        gecko: gecko,
        android: ua.indexOf('android') !== -1,
        android23: android23,
        chrome: chrome,
        chromeVersion: chromeVersion,
        safari: !chrome && ua.indexOf('safari') !== -1,
        phantomjs: phantomjs,
        ie3d: ie3d,
        webkit3d: webkit3d,
        gecko3d: gecko3d,
        opera12: opera12,
        any3d: any3d,
        mobile: mobile,
        mobileWebkit: mobile && webkit,
        mobileWebkit3d: mobile && webkit3d,
        mobileOpera: mobile && window.opera,
        mobileGecko: mobile && gecko,
        touch: !!touch,
        msPointer: !!msPointer,
        pointer: !!pointer,
        retina: devicePixelRatio > 1,
        devicePixelRatio: devicePixelRatio,
        language: navigator.browserLanguage ? navigator.browserLanguage : navigator.language,
        ie9: ie && document.documentMode === 9,
        ie10: ie && document.documentMode === 10,
        webgl: webgl
      };
    }

    var Browser$1 = Browser;

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /**
     * Abstract parent class for Point and Coordinate
     * @abstract
     * @category basic types
     */

    var Position =
    /*#__PURE__*/
    function () {
      function Position(x, y) {
        if (!isNil(x) && !isNil(y)) {
          /**
           * @property x {Number} - x value
           */
          this.x = +x;
          /**
           * @property y {Number} - y value
           */

          this.y = +y;
        } else if (!isNil(x.x) && !isNil(x.y)) {
          this.x = +x.x;
          this.y = +x.y;
        } else if (Array.isArray(x)) {
          this.x = +x[0];
          this.y = +x[1];
        }

        if (this._isNaN()) {
          throw new Error('Position is NaN');
        }
      }
      /**
       * Set point or coordinate's x, y value
       * @params {Number} x - x value
       * @params {Number} y - y value
       * @return {Coordinate|Point} this
       */


      var _proto = Position.prototype;

      _proto.set = function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
      /**
       * Return abs value of the point
       * @return {Coordinate|Point} abs point
       */
      ;

      _proto.abs = function abs() {
        return new this.constructor(Math.abs(this.x), Math.abs(this.y));
      } //destructive abs
      ;

      _proto._abs = function _abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        return this;
      };

      _proto._round = function _round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      /**
       * Like math.round, rounding the point's xy.
       * @return {Coordinate|Point} rounded point
       */
      ;

      _proto.round = function round() {
        return new this.constructor(Math.round(this.x), Math.round(this.y));
      };

      _proto._ceil = function _ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      };

      _proto.ceil = function ceil() {
        return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
      };

      _proto._floor = function _floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      };

      _proto.floor = function floor() {
        return new this.constructor(Math.floor(this.x), Math.floor(this.y));
      }
      /**
       * Returns a copy of the coordinate
       * @return {Coordinate|Point} copy
       */
      ;

      _proto.copy = function copy() {
        return new this.constructor(this.x, this.y);
      } //destructive add
      ;

      _proto._add = function _add(x, y) {
        if (!isNil(x.x)) {
          this.x += x.x;
          this.y += x.y;
        } else if (!isNil(x[0])) {
          this.x += x[0];
          this.y += x[1];
        } else {
          this.x += x;
          this.y += y;
        }

        return this;
      }
      /**
       * Returns the result of addition of another coordinate.
       * @param {Coordinate|Point|Array|Number} x - coordinate to add
       * @param {Number} [y=undefined] - optional, coordinate to add
       * @return {Coordinate|Point} result
       */
      ;

      _proto.add = function add(x, y) {
        var nx, ny;

        if (!isNil(x.x)) {
          nx = this.x + x.x;
          ny = this.y + x.y;
        } else if (!isNil(x[0])) {
          nx = this.x + x[0];
          ny = this.y + x[1];
        } else {
          nx = this.x + x;
          ny = this.y + y;
        }

        return new this.constructor(nx, ny);
      } //destructive substract
      ;

      _proto._sub = function _sub(x, y) {
        if (!isNil(x.x)) {
          this.x -= x.x;
          this.y -= x.y;
        } else if (!isNil(x[0])) {
          this.x -= x[0];
          this.y -= x[1];
        } else {
          this.x -= x;
          this.y -= y;
        }

        return this;
      };

      _proto._substract = function _substract() {
        return this._sub.apply(this, arguments);
      }
      /**
       * Returns the result of subtraction of another coordinate.
       * @param {Coordinate|Point|Array|Number} x - coordinate to add
       * @param {Number} [y=undefined] - optional, coordinate to add
       * @return {Coordinate|Point} result
       */
      ;

      _proto.sub = function sub(x, y) {
        var nx, ny;

        if (!isNil(x.x)) {
          nx = this.x - x.x;
          ny = this.y - x.y;
        } else if (!isNil(x[0])) {
          nx = this.x - x[0];
          ny = this.y - x[1];
        } else {
          nx = this.x - x;
          ny = this.y - y;
        }

        return new this.constructor(nx, ny);
      }
      /**
       * Alias for sub
       * @param {Coordinate|Point|Array|Number} x - coordinate to add
       * @param {Number} [y=undefined] - optional, coordinate to add
       * @return {Coordinate|Point} result
       */
      ;

      _proto.substract = function substract() {
        return this.sub.apply(this, arguments);
      }
      /**
       * Returns the result of multiplication of the current coordinate by the given number.
       * @param {Number} ratio - ratio to multi
       * @return {Coordinate|Point} result
       */
      ;

      _proto.multi = function multi(ratio) {
        return new this.constructor(this.x * ratio, this.y * ratio);
      };

      _proto._multi = function _multi(ratio) {
        this.x *= ratio;
        this.y *= ratio;
        return this;
      }
      /**
       * Returns the result of division of the current point by the given number.
       * @param {Number} n - number to div
       * @return {Coordinate|Point} result
       */
      ;

      _proto.div = function div(n) {
        return this.multi(1 / n);
      };

      _proto._div = function _div(n) {
        return this._multi(1 / n);
      }
      /**
       * Compare with another coordinate to see whether they are equal.
       * @param {Coordinate|Point} c - coordinate to compare
       * @return {Boolean}
       */
      ;

      _proto.equals = function equals(c) {
        if (!(c instanceof this.constructor)) {
          return false;
        }

        return this.x === c.x && this.y === c.y;
      }
      /**
       * Whether the coordinate is NaN
       * @return {Boolean}
       * @private
       */
      ;

      _proto._isNaN = function _isNaN() {
        return isNaN(this.x) || isNaN(this.y);
      }
      /**
       * Whether the coordinate/point is zero
       */
      ;

      _proto.isZero = function isZero() {
        return this.x === 0 && this.y === 0;
      }
      /**
       * Convert to a number array [x, y]
       * @return {Number[]} number array
       */
      ;

      _proto.toArray = function toArray() {
        return [this.x, this.y];
      }
      /**
       * Formats coordinate number using fixed-point notation.
       * @param  {Number} n The number of digits to appear after the decimal point
       * @return {Coordinate}   fixed coordinate
       */
      ;

      _proto.toFixed = function toFixed(n) {
        return new this.constructor(this.x.toFixed(n), this.y.toFixed(n));
      }
      /**
       * Convert to a json object {x : .., y : ..}
       * @return {Object} json
       */
      ;

      _proto.toJSON = function toJSON() {
        return {
          x: this.x,
          y: this.y
        };
      };

      return Position;
    }();

    /**
     * Represents a 2d point.<br>
     * Can be created in serveral ways:
     * @example
     * var point = new Point(1000, 1000);
     * @example
     * var point = new Point([1000,1000]);
     * @example
     * var point = new Point({x:1000, y:1000});
     * @category basic types
     */

    var Point =
    /*#__PURE__*/
    function (_Position) {
      _inheritsLoose(Point, _Position);

      function Point() {
        return _Position.apply(this, arguments) || this;
      }

      var _proto = Point.prototype;

      /**
       * Compare with another point with a delta
       * @param {Point} p
       * @param {Number} delta
       * @return {Boolean}
       */
      _proto.closeTo = function closeTo(p, delta) {
        if (!delta) {
          delta = 0;
        }

        return this.x >= p.x - delta && this.x <= p.x + delta && this.y >= p.y - delta && this.y <= p.y + delta;
      }
      /**
       * Returns the distance between the current and the given point.
       * @param  {Point} point - another point
       * @return {Number} distance
       */
      ;

      _proto.distanceTo = function distanceTo(point) {
        var x = point.x - this.x,
            y = point.y - this.y;
        return Math.sqrt(x * x + y * y);
      }
      /**
       * Return the magitude of this point: this is the Euclidean
       * distance from the 0, 0 coordinate to this point's x and y
       * coordinates.
       * @return {Number} magnitude
       */
      ;

      _proto.mag = function mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      /**
       * Calculate this point but as a unit vector from 0, 0, meaning
       * that the distance from the resulting point to the 0, 0
       * coordinate will be equal to 1 and the angle from the resulting
       * point to the 0, 0 coordinate will be the same as before.
       * @return {Point} unit vector point
       */
      ;

      _proto.unit = function unit() {
        return this.copy()._unit();
      };

      _proto._unit = function _unit() {
        this._div(this.mag());

        return this;
      }
      /**
       * Compute a perpendicular point, where the new y coordinate
       * is the old x coordinate and the new x coordinate is the old y
       * coordinate multiplied by -1
       * @return {Point} perpendicular point
       */
      ;

      _proto.perp = function perp() {
        return this.copy()._perp();
      };

      _proto._perp = function _perp() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
      }
      /**
       * Get the angle between this point and another point, in radians
       * from mapbox/point-geometry
       * @param {Point} b the other point
       * @return {Number} angle
       */
      ;

      _proto.angleWith = function angleWith(b) {
        return this.angleWithSep(b.x, b.y);
      }
      /*
       * Find the angle of the two vectors, solving the formula for
       * the cross product a x b = |a||b|sin(θ) for θ.
       * from mapbox/point-geometry
       *
       * @param {Number} x the x-coordinate
       * @param {Number} y the y-coordinate
       * @return {Number} the angle in radians
       */
      ;

      _proto.angleWithSep = function angleWithSep(x, y) {
        return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
      };

      _proto._rotate = function _rotate(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
      }
      /**
       * Rotate this point around the 0, 0 origin by an angle a,
       * given in radians
       * from mapbox/point-geometry
       *
       * @param {Number} a angle to rotate around, in radians
       * @return {Point} output point
       */
      ;

      _proto.rotate = function rotate(a) {
        return this.copy()._rotate(a);
      };

      return Point;
    }(Position);

    /**
     * Represents a size.
     * @category basic types
     */

    var Size =
    /*#__PURE__*/
    function () {
      /**
       * @param {Number} width - width value
       * @param {Number} height - height value
       */
      function Size(width, height) {
        if (isNumber(width) && isNumber(height)) {
          /**
           * @property {Number} width - width
           */
          this.width = width;
          /**
           * @property {Number} height - height
           */

          this.height = height;
        } else if (isNumber(width['width'])) {
          this.width = width.width;
          this.height = width.height;
        } else if (Array.isArray(width)) {
          this.width = width[0];
          this.height = width[1];
        }
      }
      /**
       * Returns a copy of the size
       * @return {Size} copy
       */


      var _proto = Size.prototype;

      _proto.copy = function copy() {
        return new Size(this['width'], this['height']);
      }
      /**
       * Returns the result of addition of another size.
       * @param {Size} size - size to add
       * @return {Size} result
       */
      ;

      _proto.add = function add(x, y) {
        var w, h;

        if (x instanceof Size) {
          w = this.width + x.width;
          h = this.height + x.height;
        } else {
          w = this.width + x;
          h = this.height + y;
        }

        return new Size(w, h);
      }
      /**
       * Compare with another size to see whether they are equal.
       * @param {Size} size - size to compare
       * @return {Boolean}
       */
      ;

      _proto.equals = function equals(size) {
        return this['width'] === size['width'] && this['height'] === size['height'];
      }
      /**
       * Returns the result of multiplication of the current size by the given number.
       * @param {Number} ratio - ratio to multi
       * @return {Size} result
       */
      ;

      _proto.multi = function multi(ratio) {
        return new Size(this['width'] * ratio, this['height'] * ratio);
      };

      _proto._multi = function _multi(ratio) {
        this['width'] *= ratio;
        this['height'] *= ratio;
        return this;
      };

      _proto._round = function _round() {
        this['width'] = Math.round(this['width']);
        this['height'] = Math.round(this['height']);
        return this;
      }
      /**
       * Converts the size object to a [Point]{Point}
       * @return {Point} point
       */
      ;

      _proto.toPoint = function toPoint() {
        return new Point(this['width'], this['height']);
      }
      /**
       * Converts the size object to an array [width, height]
       * @return {Number[]}
       */
      ;

      _proto.toArray = function toArray() {
        return [this['width'], this['height']];
      }
      /**
       * Convert the size object to a json object {width : .., height : ..}
       * @return {Object} json
       */
      ;

      _proto.toJSON = function toJSON() {
        return {
          'width': this['width'],
          'height': this['height']
        };
      };

      return Size;
    }();

    /**
     * @classdesc
     * Utilities methods for Strings used internally. It is static and should not be initiated.
     * @class
     * @static
     * @category core
     * @name StringUtil
     */

    /**
     * Trim the string
     * @param {String} str
     * @return {String}
     * @memberOf StringUtil
     */

    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }
    var specialPattern = /[\b\t\r\v\f]/igm;
    /**
     * Escape special characters from string.
     * Including: \b \t \r \v \f
     * @param  {String} str string to escape
     * @return {String}
     * @memberOf StringUtil
     */

    function escapeSpecialChars(str) {
      if (!isString(str)) {
        return str;
      }

      return str.replace(specialPattern, '');
    }
    /**
     * Split string by specified char
     * @param {String} chr - char to split
     * @return {String[]}
     * @memberOf StringUtil
     */

    function splitWords(chr) {
      return trim(chr).split(/\s+/);
    }
    var rulerCtx = typeof document !== 'undefined' ? document.createElement('canvas').getContext('2d') : null;
    /**
     * Gets width of the text with a certain font.
     * More performant than stringLength.
     * @param {String} text - text to measure
     * @param {String} font - font of the text, same as the CSS font.
     * @return {Number}
     * @memberOf StringUtil
     */

    function stringWidth(text, font) {
      if (stringWidth.node) {
        return stringWidth.node(text, font);
      }

      rulerCtx.font = font;
      return rulerCtx.measureText(text).width;
    } // const fontHeight = {};

    /**
     * Gets size in pixel of the text with a certain font.
     * @param {String} text - text to measure
     * @param {String} font - font of the text, same as the CSS font.
     * @return {Size}
     * @memberOf StringUtil
     */

    function stringLength(text, font, size) {
      var w = stringWidth(text, font); // if (!font) {
      //     font = '_default_';
      // }
      // if (!fontHeight[font]) {
      //     fontHeight[font] = getFontHeight(font);
      // }
      // return new Size(w, fontHeight[font]);

      return new Size(w, size || DEFAULT_TEXT_SIZE);
    }
    function getFontHeight(font) {
      //dom
      var domRuler = getDomRuler('span');

      if (font !== '_default_') {
        domRuler.style.font = font;
      }

      domRuler.innerHTML = '秦';
      var h = domRuler.clientHeight; //if not removed, the canvas container on chrome will turn to unexpected blue background.
      // Reason is unknown.

      removeDomNode(domRuler);
      return h;
    }
    /**
     * Split text content by dom.
     * @param {String} content - content to split
     * @param {String} font - font of the text, same as the CSS font.
     * @return {Number} wrapWidth - width to wrap
     * @return {String[]}
     * @memberOf StringUtil
     */

    function splitContent(content, font, wrapWidth, textWidth) {
      if (!content || content.length === 0) {
        return [{
          'text': '',
          'width': 0
        }];
      }

      var width = isNil(textWidth) ? stringWidth(content, font) : textWidth;
      var chrWidth = width / content.length,
          minChrCount = Math.floor(wrapWidth / chrWidth / 2);

      if (chrWidth >= wrapWidth || minChrCount <= 0) {
        return [{
          'text': '',
          'width': wrapWidth
        }];
      }

      if (width <= wrapWidth) return [{
        'text': content,
        'width': width
      }];
      var result = [];
      var testStr = content.substring(0, minChrCount),
          prew = chrWidth * minChrCount;

      for (var i = minChrCount, l = content.length; i < l; i++) {
        var chr = content[i];
        var w = stringWidth(testStr + chr);

        if (w >= wrapWidth) {
          result.push({
            'text': testStr,
            'width': prew
          });
          testStr = content.substring(i, minChrCount + i);
          i += minChrCount - 1;
          prew = chrWidth * minChrCount;
        } else {
          testStr += chr;
          prew = w;
        }

        if (i >= l - 1) {
          prew = stringWidth(testStr);
          result.push({
            'text': testStr,
            'width': prew
          });
        }
      }

      return result;
    }
    var contentExpRe = /\{([\w_]+)\}/g;
    /**
     * Replace variables wrapped by square brackets ({foo}) with actual values in props.
     * @example
     *     // will returns 'John is awesome'
     *     const actual = replaceVariable('{foo} is awesome', {'foo' : 'John'});
     * @param {String} str      - string to replace
     * @param {Object} props    - variable value properties
     * @return {String}
     * @memberOf StringUtil
     */

    function replaceVariable(str, props) {
      if (!isString(str)) {
        return str;
      }

      return str.replace(contentExpRe, function (str, key) {
        if (!props) {
          return '';
        }

        var value = props[key];

        if (isNil(value)) {
          return '';
        } else if (Array.isArray(value)) {
          return value.join();
        }

        return value;
      });
    }
    /**
     * Gets text's align point according to the horizontalAlignment and verticalAlignment
     * @param  {Size} size                  - text size
     * @param  {String} horizontalAlignment - horizontalAlignment: left/middle/right
     * @param  {String} verticalAlignment   - verticalAlignment: top/middle/bottom
     * @return {Point}
     * @memberOf StringUtil
     */

    function getAlignPoint(size, horizontalAlignment, verticalAlignment) {
      var width = size['width'],
          height = size['height'];
      var alignW, alignH;

      if (horizontalAlignment === 'left') {
        alignW = -width;
      } else if (horizontalAlignment === 'right') {
        alignW = 0;
      } else {
        alignW = -width / 2;
      }

      if (verticalAlignment === 'top') {
        alignH = -height;
      } else if (verticalAlignment === 'bottom') {
        alignH = 0;
      } else {
        alignH = -height / 2;
      }

      return new Point(alignW, alignH);
    }
    var DEFAULT_FONT = 'monospace';
    /**
     * Returns CSS Font from a symbol with text styles.
     * @param  {Object} style symbol with text styles
     * @return {String}       CSS Font String
     * @memberOf StringUtil
     */

    function getFont(style) {
      if (style['textFont']) {
        return style['textFont'];
      } else {
        return (style['textStyle'] && style['textStyle'] !== 'normal' ? style['textStyle'] + ' ' : '') + (style['textWeight'] && style['textWeight'] !== 'normal' ? style['textWeight'] + ' ' : '') + style['textSize'] + 'px ' + (!style['textFaceName'] ? DEFAULT_FONT : style['textFaceName'][0] === '"' ? style['textFaceName'] : '"' + style['textFaceName'] + '"');
      }
    }
    /**
     * Split a text to multiple rows according to the style.
     * @param {String} text     - text to split
     * @param {Object} style    - text style
     * @return {Object[]} the object's structure: { rowNum: rowNum, textSize: textSize, rows: textRows, rawSize : rawSize }
     * @memberOf StringUtil
     */

    function splitTextToRow(text, style) {
      var font = getFont(style),
          lineSpacing = style['textLineSpacing'] || 0,
          size = stringLength(text, font, style['textSize']),
          textWidth = size['width'],
          textHeight = size['height'],
          wrapChar = style['textWrapCharacter'],
          textRows = [];
      var wrapWidth = style['textWrapWidth'];

      if (!wrapWidth || wrapWidth > textWidth) {
        wrapWidth = textWidth;
      }

      if (!isString(text)) {
        text += '';
      }

      var actualWidth = 0;

      if (wrapChar && text.indexOf(wrapChar) >= 0) {
        var texts = text.split(wrapChar);

        for (var i = 0, l = texts.length; i < l; i++) {
          var t = texts[i];
          var tWidth = stringWidth(t, font);

          if (tWidth > wrapWidth) {
            var contents = splitContent(t, font, wrapWidth, tWidth);

            for (var ii = 0, ll = contents.length; ii < ll; ii++) {
              var w = contents[ii].width;

              if (w > actualWidth) {
                actualWidth = w;
              }

              textRows.push({
                'text': contents[ii].text,
                'size': new Size(w, textHeight)
              });
            }
          } else {
            if (tWidth > actualWidth) {
              actualWidth = tWidth;
            }

            textRows.push({
              'text': t,
              'size': new Size(tWidth, textHeight)
            });
          }
        }
      } else if (textWidth > wrapWidth) {
        var _contents = splitContent(text, font, wrapWidth, textWidth);

        for (var _i = 0; _i < _contents.length; _i++) {
          var _w = _contents[_i].width;

          if (_w > actualWidth) {
            actualWidth = _w;
          }

          textRows.push({
            'text': _contents[_i].text,
            'size': new Size(_w, textHeight)
          });
        }
      } else {
        if (textWidth > actualWidth) {
          actualWidth = textWidth;
        }

        textRows.push({
          'text': text,
          'size': size
        });
      }

      var rowNum = textRows.length;
      var textSize = new Size(actualWidth, textHeight * rowNum + lineSpacing * (rowNum - 1));
      return {
        'total': rowNum,
        'size': textSize,
        'rows': textRows,
        'rawSize': size
      };
    }

    var strings = /*#__PURE__*/Object.freeze({
        trim: trim,
        escapeSpecialChars: escapeSpecialChars,
        splitWords: splitWords,
        stringWidth: stringWidth,
        stringLength: stringLength,
        getFontHeight: getFontHeight,
        splitContent: splitContent,
        replaceVariable: replaceVariable,
        getAlignPoint: getAlignPoint,
        getFont: getFont,
        splitTextToRow: splitTextToRow
    });

    /**
     * DOM utilities used internally.
     * Learned a lot from Leaflet.DomUtil
     * @class
     * @category core
     * @name DomUtil
     */

    var first = function first(props) {
      return props[0];
    };
    /**
     * From Leaflet.DomUtil
     * Goes through the array of style names and returns the first name
     * that is a valid style name for an element. If no such name is found,
     * it returns false. Useful for vendor-prefixed styles like `transform`.
     * @param  {String[]} props
     * @return {Boolean}
     * @memberOf DomUtil
     * @private
     */


    var testProp = IS_NODE ? first : function (props) {
      var style = document.documentElement.style;

      for (var i = 0; i < props.length; i++) {
        if (props[i] in style) {
          return props[i];
        }
      }

      return false;
    }; // prefix style property names

    /**
     * Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
     * @property {String} TRANSFORM
     * @memberOf DomUtil
     * @type {String}
     */

    var TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);
    /**
     * Vendor-prefixed tfransform-origin name (e.g. `'webkitTransformOrigin'` for WebKit).
     * @property {String} TRANSFORMORIGIN
     * @memberOf DomUtil
     * @type {String}
     */

    var TRANSFORMORIGIN = testProp(['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin']);
    /**
     * Vendor-prefixed transition name (e.g. `'WebkitTransition'` for WebKit).
     * @property {String} TRANSITION
     * @memberOf DomUtil
     * @type {String}
     */

    var TRANSITION = testProp(['transition', 'WebkitTransition', 'OTransition', 'MozTransition', 'msTransition']);
    /**
     * Vendor-prefixed filter name (e.g. `'WebkitFilter'` for WebKit).
     * @property {String} FILTER
     * @memberOf DomUtil
     * @type {String}
     */

    var CSSFILTER = testProp(['filter', 'WebkitFilter', 'OFilter', 'MozFilter', 'msFilter']);
    /**
     * Create a html element.
     * @param {String} tagName
     * @returns {HTMLElement}
     * @memberOf DomUtil
     */

    function createEl(tagName, className) {
      var el = document.createElement(tagName);

      if (className) {
        setClass(el, className);
      }

      return el;
    }
    /**
     * Create a html element on the specified container
     * @param {String} tagName
     * @param {String} style - css styles
     * @param {HTMLElement} container
     * @return {HTMLElement}
     * @memberOf DomUtil
     */

    function createElOn(tagName, style, container) {
      var el = createEl(tagName);

      if (style) {
        setStyle(el, style);
      }

      if (container) {
        container.appendChild(el);
      }

      return el;
    }
    /**
     * Removes a html element.
     * @param {HTMLElement} node
     * @memberOf DomUtil
     */

    /* istanbul ignore next */

    function removeDomNode(node) {
      if (!node) {
        return this;
      }

      if (Browser$1.ielt9 || Browser$1.ie9) {
        //fix memory leak in IE9-
        //http://com.hemiola.com/2009/11/23/memory-leaks-in-ie8/
        var d = createEl('div');
        d.appendChild(node);
        d.innerHTML = '';
        d = null;
      } else if (node.parentNode) {
        node.parentNode.removeChild(node);
      }

      return this;
    }
    /**
     * Adds a event listener to the dom element.
     * @param {HTMLElement} obj     - dom element to listen on
     * @param {String} typeArr      - event types, seperated by space
     * @param {Function} handler    - listener function
     * @param {Object} context      - function context
     * @memberOf DomUtil
     */

    function addDomEvent(obj, typeArr, handler, context) {
      if (!obj || !obj.addEventListener || !typeArr || !handler) {
        return this;
      }

      var eventHandler = function eventHandler(e) {
        if (!e) {
          e = window.event;
        }

        handler.call(context || obj, e);
        return;
      };

      var types = typeArr.split(' ');

      for (var i = types.length - 1; i >= 0; i--) {
        var type = types[i];

        if (!type) {
          continue;
        }

        if (!obj['Z__' + type]) {
          obj['Z__' + type] = [];
        }

        var hit = listensDomEvent(obj, type, handler);

        if (hit >= 0) {
          removeDomEvent(obj, type, handler);
        }

        obj['Z__' + type].push({
          callback: eventHandler,
          src: handler
        }); //firefox

        if (type === 'mousewheel' && Browser$1.gecko) {
          type = 'DOMMouseScroll';
        }

        obj.addEventListener(type, eventHandler, false);
      }

      return this;
    }
    /**
     * Removes event listener from a dom element
     * @param {HTMLElement} obj         - dom element
     * @param {String} typeArr          - event types, separated by space
     * @param {Function} handler        - listening function
     * @memberOf DomUtil
     */

    function removeDomEvent(obj, typeArr, handler) {
      function doRemove(type, callback) {
        //mouse wheel in firefox
        if (type === 'mousewheel' && Browser$1.gecko) {
          type = 'DOMMouseScroll';
        }

        obj.removeEventListener(type, callback, false);
      }

      if (!obj || !obj.removeEventListener || !typeArr) {
        return this;
      }

      var types = typeArr.split(' ');

      for (var i = types.length - 1; i >= 0; i--) {
        var type = types[i];

        if (!type) {
          continue;
        } //remove all the listeners if handler is not given.


        if (!handler && obj['Z__' + type]) {
          var handlers = obj['Z__' + type];

          for (var j = 0, jlen = handlers.length; j < jlen; j++) {
            doRemove(handlers[j].callback);
          }

          delete obj['Z__' + type];
          return this;
        }

        var hit = listensDomEvent(obj, type, handler);

        if (hit < 0) {
          return this;
        }

        var hitHandler = obj['Z__' + type][hit];
        doRemove(type, hitHandler.callback);
        obj['Z__' + type].splice(hit, 1);
      }

      return this;
    }
    /**
     * Check if event type of the dom is listened by the handler
     * @param {HTMLElement} obj     - dom element to check
     * @param {String} typeArr      - event
     * @param {Function} handler    - the listening function
     * @return {Number} - the handler's index in the listener chain, returns -1 if not.
     * @memberOf DomUtil
     */

    function listensDomEvent(obj, type, handler) {
      if (!obj || !obj['Z__' + type] || !handler) {
        return -1;
      }

      var handlers = obj['Z__' + type];

      for (var i = 0, len = handlers.length; i < len; i++) {
        if (handlers[i].src === handler) {
          return i;
        }
      }

      return -1;
    }
    /**
     * Prevent default behavior of the browser. <br/>
     * preventDefault Cancels the event if it is cancelable, without stopping further propagation of the event.
     * @param {Event} event - browser event
     * @memberOf DomUtil
     */

    function preventDefault(event) {
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        event.returnValue = false;
      }

      return this;
    }
    /**
     * Stop browser event propagation
     * @param  {Event} e - browser event.
     * @memberOf DomUtil
     */

    function stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }

      return this;
    }
    function preventSelection(dom) {
      dom.onselectstart = function () {
        return false;
      };

      dom.ondragstart = function () {
        return false;
      };

      dom.setAttribute('unselectable', 'on');
      return this;
    }
    /**
     * Get the dom element's current position or offset its position by offset
     * @param  {HTMLElement} dom - HTMLElement
     * @param  {Point} [offset=null] - position to set.
     * @return {Point} - dom element's current position if offset is null.
     * @memberOf DomUtil
     */

    function offsetDom(dom, offset) {
      if (!dom) {
        return null;
      }

      if (Browser$1.any3d) {
        setTransform(dom, offset);
      } else {
        dom.style.left = offset.x + 'px';
        dom.style.top = offset.y + 'px';
      }

      return offset;
    }
    /**
     * Compute dom's position
     * @param  {HTMLElement} dom
     * @return {Number[]}
     * @memberOf DomUtil
     */

    function computeDomPosition(dom) {
      var style = window.getComputedStyle(dom);
      var padding = [parseInt(style['padding-left']), parseInt(style['padding-top'])];
      var rect = dom.getBoundingClientRect(); //fix #450, inspired by https://github.com/Leaflet/Leaflet/pull/5794/files

      var offsetWidth = dom.offsetWidth,
          offsetHeight = dom.offsetHeight;
      var scaleX = offsetWidth ? rect.width / offsetWidth : 1,
          scaleY = offsetHeight ? rect.height / offsetHeight : 1;
      dom.__position = [rect.left + padding[0], rect.top + padding[1], scaleX, scaleY];
      return dom.__position;
    }
    /**
     * Get event's position from the top-left corner of the dom container
     * @param {Event} ev    event
     * @return {Point}
     * @memberOf DomUtil
     */

    function getEventContainerPoint(ev, dom) {
      if (!ev) {
        ev = window.event;
      }

      var domPos = dom.__position;

      if (!domPos) {
        domPos = computeDomPosition(dom);
      } // div by scaleX, scaleY to fix #450


      return new Point((ev.clientX - domPos[0] - dom.clientLeft) / domPos[2], (ev.clientY - domPos[1] - dom.clientTop) / domPos[3]);
    }

    function endsWith(str, suffix) {
      var l = str.length - suffix.length;
      return l >= 0 && str.indexOf(suffix, l) === l;
    }
    /**
     * set css style to the dom element
     * @param {HTMLElement} dom dom element
     * @param {String} strCss css text
     * @memberOf DomUtil
     */


    function setStyle(dom, strCss) {
      var cssText = dom.style.cssText;

      if (!endsWith(cssText, ';')) {
        cssText += ';';
      }

      dom.style.cssText = cssText + strCss;
      return this;
    }
    /**
     * Whether the dom has the given css class.
     * @param {HTMLElement} el HTML Element
     * @param {String} name css class
     * @memberOf DomUtil
     */

    function hasClass(el, name) {
      if (el.classList !== undefined) {
        return el.classList.contains(name);
      }

      var className = getClass(el);
      return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    }
    /**
     * add css class to dom element
     * @param {HTMLElement} el HTML Element
     * @param {String} name css class
     * @memberOf DomUtil
     */

    function addClass(el, name) {
      if (el.classList !== undefined && !hasClass(el, name)) {
        var classes = splitWords(name);

        for (var i = 0, len = classes.length; i < len; i++) {
          el.classList.add(classes[i]);
        }
      } else {
        var className = getClass(el);
        setClass(el, (className ? className + ' ' : '') + name);
      }

      return this;
    }
    /**
     * Set dom's css class
     * @param {HTMLElement} el HTML Element
     * @param {String} name css class
     * @memberOf DomUtil
     */

    function setClass(el, name) {
      if (isNil(el.className.baseVal)) {
        el.className = name;
      } else {
        el.className.baseVal = name;
      }

      return this;
    }
    /**
     * Get dom's css class
     * @param {String} name css class
     * @retrun {String} class字符串
     * @memberOf DomUtil
     */

    function getClass(el) {
      return isNil(el.className.baseVal) ? el.className : el.className.baseVal;
    }
    function setOpacity(el, value) {
      el.style.opacity = value;
      return this;
    } // export function copyCanvas(src) {
    //     if (IS_NODE) {
    //         return null;
    //     }
    //     const target = createEl('canvas');
    //     target.width = src.width;
    //     target.height = src.height;
    //     target.getContext('2d').drawImage(src, 0, 0);
    //     return target;
    // }

    /**
     * Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
     * @param {HTMLElement} el
     * @param {Point} offset
     * @memberOf DomUtil
     */

    function setTransform(el, offset) {
      var pos = offset || new Point(0, 0);
      el.style[TRANSFORM] = Browser$1.any3d ? 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0px)' : 'translate(' + pos.x + 'px,' + pos.y + 'px)';
      return this;
    }
    function setTransformMatrix(el, m) {
      var text = 'matrix(' + (isString(m) ? m : m.join()) + ')';

      if (el.style[TRANSFORM] !== text) {
        el.style[TRANSFORM] = text;
      }

      return this;
    }
    function removeTransform(el) {
      if (el.style[TRANSFORM]) {
        el.style[TRANSFORM] = '';
      }

      return this;
    }
    function isHTML(str) {
      return /<[a-z\][\s\S]*>/i.test(str);
    }
    function measureDom(parentTag, dom) {
      var ruler = getDomRuler(parentTag);

      if (isString(dom)) {
        ruler.innerHTML = dom;
      } else {
        ruler.appendChild(dom);
      }

      var result = new Size(ruler.clientWidth, ruler.clientHeight);
      removeDomNode(ruler);
      return result;
    }
    function getDomRuler(tag) {
      var span = document.createElement(tag);
      span.style.cssText = 'position:absolute;left:-10000px;top:-10000px;';
      document.body.appendChild(span);
      return span;
    }
    /**
     * Alias for [addDomEvent]{@link DomUtil.addDomEvent}
     * @param {HTMLElement} obj     - dom element to listen on
     * @param {String} typeArr      - event types, seperated by space
     * @param {Function} handler    - listener function
     * @param {Object} context      - function context
     * @static
     * @function
     * @return {DomUtil}
     * @memberOf DomUtil
     */

    var on = addDomEvent;
    /**
     * Alias for [removeDomEvent]{@link DomUtil.removeDomEvent}
     * @param {HTMLElement} obj         - dom element
     * @param {String} typeArr          - event types, separated by space
     * @param {Function} handler        - listening function
     * @static
     * @function
     * @return {DomUtil}
     * @memberOf DomUtil
     */

    var off = removeDomEvent;

    var dom = /*#__PURE__*/Object.freeze({
        TRANSFORM: TRANSFORM,
        TRANSFORMORIGIN: TRANSFORMORIGIN,
        TRANSITION: TRANSITION,
        CSSFILTER: CSSFILTER,
        createEl: createEl,
        createElOn: createElOn,
        removeDomNode: removeDomNode,
        addDomEvent: addDomEvent,
        removeDomEvent: removeDomEvent,
        listensDomEvent: listensDomEvent,
        preventDefault: preventDefault,
        stopPropagation: stopPropagation,
        preventSelection: preventSelection,
        offsetDom: offsetDom,
        computeDomPosition: computeDomPosition,
        getEventContainerPoint: getEventContainerPoint,
        setStyle: setStyle,
        hasClass: hasClass,
        addClass: addClass,
        setClass: setClass,
        getClass: getClass,
        setOpacity: setOpacity,
        setTransform: setTransform,
        setTransformMatrix: setTransformMatrix,
        removeTransform: removeTransform,
        isHTML: isHTML,
        measureDom: measureDom,
        getDomRuler: getDomRuler,
        on: on,
        off: off
    });

    /**
     * @classdesc
     * Ajax Utilities. It is static and should not be initiated.
     * @class
     * @static
     * @category core
     */

    var Ajax = {
      /**
       * Get JSON data by jsonp
       * from https://gist.github.com/gf3/132080/110d1b68d7328d7bfe7e36617f7df85679a08968
       * @param  {String}   url - resource url
       * @param  {Function} cb  - callback function when completed
       */
      jsonp: function jsonp(url, callback) {
        // INIT
        var name = '_maptalks_jsonp_' + UID();
        if (url.match(/\?/)) url += '&callback=' + name;else url += '?callback=' + name; // Create script

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = url; // Setup handler

        window[name] = function (data) {
          callback(null, data);
          document.getElementsByTagName('head')[0].removeChild(script);
          script = null;
          delete window[name];
        }; // Load JSON


        document.getElementsByTagName('head')[0].appendChild(script);
        return this;
      },

      /**
       * Fetch remote resource by HTTP "GET" method
       * @param  {String}   url - resource url
       * @param  {Object}   [options=null] - request options
       * @param  {Object}   [options.headers=null] - HTTP headers
       * @param  {String}   [options.responseType=null] - responseType
       * @param  {String}   [options.credentials=null]  - if with credentials, set it to "include"
       * @param  {Function} cb  - callback function when completed
       * @return {Ajax}  Ajax
       * @example
       * maptalks.Ajax.get(
       *     'url/to/resource',
       *     (err, data) => {
       *         if (err) {
       *             throw new Error(err);
       *         }
       *         // do things with data
       *     }
       * );
       */
      get: function get(url, options, cb) {
        if (isFunction(options)) {
          var t = cb;
          cb = options;
          options = t;
        }

        if (IS_NODE && Ajax.get.node) {
          return Ajax.get.node(url, cb, options);
        }

        var client = Ajax._getClient(cb);

        client.open('GET', url, true);

        if (options) {
          for (var k in options.headers) {
            client.setRequestHeader(k, options.headers[k]);
          }

          client.withCredentials = options.credentials === 'include';

          if (options['responseType']) {
            client.responseType = options['responseType'];
          }
        }

        client.send(null);
        return client;
      },

      /**
       * Fetch remote resource by HTTP "POST" method
       * @param  {String}   url - resource url
       * @param  {Object}   options - request options
       * @param  {String|Object}  options.postData - post data
       * @param  {Object}   [options.headers=null]  - HTTP headers
       * @param  {Function} cb  - callback function when completed
       * @return {Ajax}  Ajax
       * @example
       * maptalks.Ajax.post(
       *   'url/to/post',
       *   {
       *     postData : {
       *       'param0' : 'val0',
       *       'param1' : 1
       *     }
       *   },
       *   (err, data) => {
       *     if (err) {
       *       throw new Error(err);
       *     }
       *     // do things with data
       *   }
       * );
       */
      post: function post(url, options, cb) {
        var postData;

        if (!isString(url)) {
          //for compatible
          //options, postData, cb
          var t = cb;
          postData = options;
          options = url;
          url = options.url;
          cb = t;
        } else {
          if (isFunction(options)) {
            var _t = cb;
            cb = options;
            options = _t;
          }

          options = options || {};
          postData = options.postData;
        }

        if (IS_NODE && Ajax.post.node) {
          options.url = url;
          return Ajax.post.node(options, postData, cb);
        }

        var client = Ajax._getClient(cb);

        client.open('POST', options.url, true);

        if (!options.headers) {
          options.headers = {};
        }

        if (!options.headers['Content-Type']) {
          options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }

        if ('setRequestHeader' in client) {
          for (var p in options.headers) {
            if (options.headers.hasOwnProperty(p)) {
              client.setRequestHeader(p, options.headers[p]);
            }
          }
        }

        if (!isString(postData)) {
          postData = JSON.stringify(postData);
        }

        client.send(postData);
        return client;
      },
      _wrapCallback: function _wrapCallback(client, cb) {
        return function () {
          if (client.readyState === 4) {
            if (client.status === 200) {
              if (client.responseType === 'arraybuffer') {
                var response = client.response;

                if (response.byteLength === 0) {
                  cb(new Error('http status 200 returned without content.'));
                } else {
                  cb(null, {
                    data: client.response,
                    cacheControl: client.getResponseHeader('Cache-Control'),
                    expires: client.getResponseHeader('Expires'),
                    contentType: client.getResponseHeader('Content-Type')
                  });
                }
              } else {
                cb(null, client.responseText);
              }
            } else {
              cb(new Error(client.statusText + ',' + client.status));
            }
          }
        };
      },
      _getClient: function _getClient(cb) {
        /*eslint-disable no-empty, no-undef*/
        var client;

        try {
          client = new XMLHttpRequest();
        } catch (e) {
          try {
            client = new ActiveXObject('Msxml2.XMLHTTP');
          } catch (e) {
            try {
              client = new ActiveXObject('Microsoft.XMLHTTP');
            } catch (e) {}
          }
        }

        client.onreadystatechange = Ajax._wrapCallback(client, cb);
        return client;
        /*eslint-enable no-empty, no-undef*/
      },

      /**
       * Fetch resource as arraybuffer.
       * @param {String} url    - url
       * @param {Object} [options=null] - options, same as Ajax.get
       * @param {Function} cb   - callback function when completed.
       * @example
       * maptalks.Ajax.getArrayBuffer(
       *     'url/to/resource.bin',
       *     (err, data) => {
       *         if (err) {
       *             throw new Error(err);
       *         }
       *         // data is a binary array
       *     }
       * );
       */
      getArrayBuffer: function getArrayBuffer(url, options, cb) {
        if (isFunction(options)) {
          var t = cb;
          cb = options;
          options = t;
        }

        if (!options) {
          options = {};
        }

        options['responseType'] = 'arraybuffer';
        return Ajax.get(url, options, cb);
      },
      // from mapbox-gl-js
      getImage: function getImage(img, url, options) {
        return Ajax.getArrayBuffer(url, options, function (err, imgData) {
          if (err) {
            if (img.onerror) {
              img.onerror(err);
            }
          } else if (imgData) {
            var URL = window.URL || window.webkitURL;
            var onload = img.onload;

            img.onload = function () {
              if (onload) {
                onload();
              }

              URL.revokeObjectURL(img.src);
            };

            var blob = new Blob([new Uint8Array(imgData.data)], {
              type: imgData.contentType
            });
            img.cacheControl = imgData.cacheControl;
            img.expires = imgData.expires;
            img.src = imgData.data.byteLength ? URL.createObjectURL(blob) : emptyImageUrl;
          }
        });
      }
    };
    /**
     * Fetch resource as a JSON Object.
     * @param {String} url          - json's url
     * @param {Object} [options=null]        - optional options
     * @param {String} [options.jsonp=false] - fetch by jsonp, false by default
     * @param {Function} cb   - callback function when completed.
     * @example
     * maptalks.Ajax.getJSON(
     *     'url/to/resource.json',
     *     { jsonp : true },
     *     (err, json) => {
     *         if (err) {
     *             throw new Error(err);
     *         }
     *         // json is a JSON Object
     *         console.log(json.foo);
     *     }
     * );
     * @static
     */

    Ajax.getJSON = function (url, options, cb) {
      if (isFunction(options)) {
        var t = cb;
        cb = options;
        options = t;
      }

      var callback = function callback(err, resp) {
        var data = resp ? parseJSON(resp) : null;
        cb(err, data);
      };

      if (options && options['jsonp']) {
        return Ajax.jsonp(url, callback);
      }

      return Ajax.get(url, options, callback);
    };

    var DEFAULT_STROKE_COLOR = '#000';
    var DEFAULT_FILL_COLOR = 'rgba(255,255,255,0)';
    var DEFAULT_TEXT_COLOR = '#000';
    var hitTesting = false;
    var TEMP_CANVAS = null;
    var Canvas$1 = {
      setHitTesting: function setHitTesting(testing) {
        hitTesting = testing;
      },
      createCanvas: function createCanvas(width, height, canvasClass) {
        var canvas;

        if (!IS_NODE) {
          canvas = createEl('canvas');
          canvas.width = width;
          canvas.height = height;
        } else {
          //can be node-canvas or any other canvas mock
          canvas = new canvasClass(width, height);
        }

        return canvas;
      },
      prepareCanvasFont: function prepareCanvasFont(ctx, style) {
        ctx.textBaseline = 'top';
        ctx.font = getFont(style);
        var fill = style['textFill'];

        if (!fill) {
          fill = DEFAULT_TEXT_COLOR;
        }

        ctx.fillStyle = Canvas$1.getRgba(fill, style['textOpacity']);
      },

      /**
       * Set canvas's fill and stroke style
       * @param {CanvasRenderingContext2D} ctx
       * @param {Object} style
       * @param {Object} resources
       * @param {Boolean} testing  - paint for testing, ignore stroke and fill patterns
       */
      prepareCanvas: function prepareCanvas(ctx, style, resources, testing) {
        if (!style) {
          return;
        }

        var strokeWidth = style['lineWidth'];

        if (!isNil(strokeWidth) && ctx.lineWidth !== strokeWidth) {
          ctx.lineWidth = strokeWidth;
        }

        var strokeColor = style['linePatternFile'] || style['lineColor'] || DEFAULT_STROKE_COLOR;

        if (testing) {
          ctx.strokeStyle = '#000';
        } else if (isImageUrl(strokeColor) && resources) {
          var patternOffset;

          if (style['linePatternDx'] || style['linePatternDy']) {
            patternOffset = [style['linePatternDx'], style['linePatternDy']];
          }

          Canvas$1._setStrokePattern(ctx, strokeColor, strokeWidth, patternOffset, resources); //line pattern will override stroke-dasharray


          style['lineDasharray'] = [];
        } else if (isGradient(strokeColor)) {
          if (style['lineGradientExtent']) {
            ctx.strokeStyle = Canvas$1._createGradient(ctx, strokeColor, style['lineGradientExtent']);
          } else {
            ctx.strokeStyle = DEFAULT_STROKE_COLOR;
          }
        } else
          /*if (ctx.strokeStyle !== strokeColor)*/
          {
            ctx.strokeStyle = strokeColor;
          }

        if (style['lineJoin']) {
          ctx.lineJoin = style['lineJoin'];
        }

        if (style['lineCap']) {
          ctx.lineCap = style['lineCap'];
        }

        if (ctx.setLineDash && isArrayHasData(style['lineDasharray'])) {
          ctx.setLineDash(style['lineDasharray']);
        }

        var fill = style['polygonPatternFile'] || style['polygonFill'] || DEFAULT_FILL_COLOR;

        if (testing) {
          ctx.fillStyle = '#000';
        } else if (isImageUrl(fill) && resources) {
          var fillImgUrl = extractImageUrl(fill);
          var fillTexture = resources.getImage([fillImgUrl, null, null]);

          if (!fillTexture) {
            //if the linestring has a arrow and a linePatternFile, polygonPatternFile will be set with the linePatternFile.
            fillTexture = resources.getImage([fillImgUrl + '-texture', null, strokeWidth]);
          }

          if (isSVG(fillImgUrl) && fillTexture instanceof Image && (Browser$1.edge || Browser$1.ie)) {
            //opacity of svg img painted on canvas is always 1, so we paint svg on a canvas at first.
            var w = fillTexture.width || 20,
                h = fillTexture.height || 20;
            var canvas = Canvas$1.createCanvas(w, h);
            Canvas$1.image(canvas.getContext('2d'), fillTexture, 0, 0, w, h);
            fillTexture = canvas;
          }

          if (!fillTexture) {
            if (typeof console !== 'undefined') {
              console.warn('img not found for', fillImgUrl);
            }
          } else {
            ctx.fillStyle = ctx.createPattern(fillTexture, 'repeat');

            if (style['polygonPatternDx'] || style['polygonPatternDy']) {
              ctx.fillStyle['polygonPatternOffset'] = [style['polygonPatternDx'], style['polygonPatternDy']];
            }
          }
        } else if (isGradient(fill)) {
          if (style['polygonGradientExtent']) {
            ctx.fillStyle = Canvas$1._createGradient(ctx, fill, style['polygonGradientExtent']);
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0)';
          }
        } else
          /*if (ctx.fillStyle !== fill)*/
          {
            ctx.fillStyle = fill;
          }
      },
      _createGradient: function _createGradient(ctx, g, extent) {
        var gradient = null,
            places = g['places'];
        var min = extent.getMin(),
            max = extent.getMax(),
            width = extent.getWidth(),
            height = extent.getHeight();

        if (!g['type'] || g['type'] === 'linear') {
          if (!places) {
            places = [min.x, min.y, max.x, min.y];
          } else {
            if (places.length !== 4) {
              throw new Error('A linear gradient\'s places should have 4 numbers.');
            }

            places = [min.x + places[0] * width, min.y + places[1] * height, min.x + places[2] * width, min.y + places[3] * height];
          }

          gradient = ctx.createLinearGradient.apply(ctx, places);
        } else if (g['type'] === 'radial') {
          if (!places) {
            var c = extent.getCenter()._round();

            places = [c.x, c.y, Math.abs(c.x - min.x), c.x, c.y, 0];
          } else {
            if (places.length !== 6) {
              throw new Error('A radial gradient\'s places should have 6 numbers.');
            }

            places = [min.x + places[0] * width, min.y + places[1] * height, width * places[2], min.x + places[3] * width, min.y + places[4] * height, width * places[5]];
          }

          gradient = ctx.createRadialGradient.apply(ctx, places);
        }

        g['colorStops'].forEach(function (stop) {
          gradient.addColorStop.apply(gradient, stop);
        });
        return gradient;
      },
      _setStrokePattern: function _setStrokePattern(ctx, strokePattern, strokeWidth, linePatternOffset, resources) {
        var imgUrl = extractImageUrl(strokePattern);
        var imageTexture;

        if (IS_NODE) {
          imageTexture = resources.getImage([imgUrl, null, strokeWidth]);
        } else {
          var key = imgUrl + '-texture-' + strokeWidth;
          imageTexture = resources.getImage(key);

          if (!imageTexture) {
            var imageRes = resources.getImage([imgUrl, null, null]);

            if (imageRes) {
              var w;

              if (!imageRes.width || !imageRes.height) {
                w = strokeWidth;
              } else {
                w = Math.round(imageRes.width * strokeWidth / imageRes.height);
              }

              var patternCanvas = Canvas$1.createCanvas(w, strokeWidth, ctx.canvas.constructor);
              Canvas$1.image(patternCanvas.getContext('2d'), imageRes, 0, 0, w, strokeWidth);
              resources.addResource([key, null, strokeWidth], patternCanvas);
              imageTexture = patternCanvas;
            }
          }
        }

        if (imageTexture) {
          ctx.strokeStyle = ctx.createPattern(imageTexture, 'repeat');
          ctx.strokeStyle['linePatternOffset'] = linePatternOffset;
        } else if (typeof console !== 'undefined') {
          console.warn('img not found for', imgUrl);
        }
      },
      clearRect: function clearRect(ctx, x1, y1, x2, y2) {
        ctx.canvas._drawn = false;
        ctx.clearRect(x1, y1, x2, y2);
      },
      fillCanvas: function fillCanvas(ctx, fillOpacity, x, y) {
        if (hitTesting) {
          fillOpacity = 1;
        }

        ctx.canvas._drawn = true;

        if (fillOpacity === 0) {
          return;
        }

        var isPattern = Canvas$1._isPattern(ctx.fillStyle);

        var offset = ctx.fillStyle && ctx.fillStyle['polygonPatternOffset'];
        var dx = offset ? offset[0] : 0,
            dy = offset ? offset[1] : 0;

        if (isNil(fillOpacity)) {
          fillOpacity = 1;
        }

        var alpha;

        if (fillOpacity < 1) {
          alpha = ctx.globalAlpha;
          ctx.globalAlpha *= fillOpacity;
        }

        if (isPattern) {
          x = x || 0;
          y = y || 0; // x = round(x);
          // y = round(y);

          ctx.translate(x + dx, y + dy);
        }

        ctx.fill();

        if (isPattern) {
          ctx.translate(-x - dx, -y - dy);
        }

        if (fillOpacity < 1) {
          ctx.globalAlpha = alpha;
        }
      },
      // hexColorRe: /^#([0-9a-f]{6}|[0-9a-f]{3})$/i,
      // support #RRGGBB/#RGB now.
      // if color was like [red, orange...]/rgb(a)/hsl(a), op will not combined to result
      getRgba: function getRgba(color, op) {
        if (isNil(op)) {
          op = 1;
        }

        if (color[0] !== '#') {
          return color;
        }

        var r, g, b;

        if (color.length === 7) {
          r = parseInt(color.substring(1, 3), 16);
          g = parseInt(color.substring(3, 5), 16);
          b = parseInt(color.substring(5, 7), 16);
        } else {
          r = parseInt(color.substring(1, 2), 16) * 17;
          g = parseInt(color.substring(2, 3), 16) * 17;
          b = parseInt(color.substring(3, 4), 16) * 17;
        }

        return 'rgba(' + r + ',' + g + ',' + b + ',' + op + ')';
      },
      image: function image(ctx, img, x, y, width, height) {
        ctx.canvas._drawn = true;

        try {
          if (isNumber(width) && isNumber(height)) {
            ctx.drawImage(img, x, y, width, height);
          } else {
            ctx.drawImage(img, x, y);
          }
        } catch (error) {
          if (console) {
            console.warn('error when drawing image on canvas:', error);
            console.warn(img);
          }
        }
      },
      text: function text(ctx, _text, pt, style, textDesc) {
        Canvas$1._textOnMultiRow(ctx, textDesc['rows'], style, pt, textDesc['size'], textDesc['rawSize']);
      },
      _textOnMultiRow: function _textOnMultiRow(ctx, texts, style, point, splitTextSize, textSize) {
        var ptAlign = getAlignPoint(splitTextSize, style['textHorizontalAlignment'], style['textVerticalAlignment']),
            lineHeight = textSize['height'] + style['textLineSpacing'],
            basePoint = point.add(0, ptAlign.y),
            maxHeight = style['textMaxHeight'];
        var text,
            rowAlign,
            height = 0;

        for (var i = 0, len = texts.length; i < len; i++) {
          text = texts[i]['text'];
          rowAlign = getAlignPoint(texts[i]['size'], style['textHorizontalAlignment'], style['textVerticalAlignment']);

          Canvas$1._textOnLine(ctx, text, basePoint.add(rowAlign.x, i * lineHeight), style['textHaloRadius'], style['textHaloFill'], style['textHaloOpacity']);

          if (maxHeight > 0) {
            height += lineHeight;

            if (height + textSize['height'] >= maxHeight) {
              break;
            }
          }
        }
      },
      _textOnLine: function _textOnLine(ctx, text, pt, textHaloRadius, textHaloFill, textHaloAlpha) {
        if (hitTesting) {
          textHaloAlpha = 1;
        }

        var drawHalo = textHaloAlpha !== 0 && textHaloRadius !== 0; // pt = pt._round();

        ctx.textBaseline = 'top';
        var gco, fill;
        var shadowBlur = ctx.shadowBlur,
            shadowOffsetX = ctx.shadowOffsetX,
            shadowOffsetY = ctx.shadowOffsetY;

        if (drawHalo) {
          var alpha = ctx.globalAlpha; //http://stackoverflow.com/questions/14126298/create-text-outline-on-canvas-in-javascript
          //根据text-horizontal-alignment和text-vertical-alignment计算绘制起始点偏移量

          ctx.globalAlpha *= textHaloAlpha;
          ctx.miterLimit = 2;
          ctx.lineJoin = 'round';
          ctx.lineCap = 'round';
          ctx.lineWidth = textHaloRadius * 2;
          ctx.strokeStyle = textHaloFill;
          ctx.strokeText(text, Math.round(pt.x), Math.round(pt.y));
          ctx.miterLimit = 10; //default

          ctx.globalAlpha = alpha;
          gco = ctx.globalCompositeOperation;
          ctx.globalCompositeOperation = 'destination-out';
          fill = ctx.fillStyle;
          ctx.fillStyle = '#000';
        }

        if (shadowBlur && drawHalo) {
          ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
        }

        Canvas$1.fillText(ctx, text, pt);

        if (gco) {
          ctx.globalCompositeOperation = gco;
          Canvas$1.fillText(ctx, text, pt, fill);

          if (shadowBlur) {
            ctx.shadowBlur = shadowBlur;
            ctx.shadowOffsetX = shadowOffsetX;
            ctx.shadowOffsetY = shadowOffsetY;
          }
        }
      },
      fillText: function fillText(ctx, text, pt, rgba) {
        ctx.canvas._drawn = true;

        if (rgba) {
          ctx.fillStyle = rgba;
        }

        ctx.fillText(text, Math.round(pt.x), Math.round(pt.y));
      },
      _stroke: function _stroke(ctx, strokeOpacity, x, y) {
        if (hitTesting) {
          strokeOpacity = 1;
        }

        ctx.canvas._drawn = true;

        if (strokeOpacity === 0) {
          return;
        }

        var offset = ctx.strokeStyle && ctx.strokeStyle['linePatternOffset'];
        var dx = offset ? offset[0] : 0,
            dy = offset ? offset[1] : 0;
        var isPattern = Canvas$1._isPattern(ctx.strokeStyle) && (!isNil(x) && !isNil(y) || !isNil(dx) && !isNil(dy));

        if (isNil(strokeOpacity)) {
          strokeOpacity = 1;
        }

        var alpha;

        if (strokeOpacity < 1) {
          alpha = ctx.globalAlpha;
          ctx.globalAlpha *= strokeOpacity;
        }

        if (isPattern) {
          x = x || 0;
          y = y || 0; // x = round(x);
          // y = round(y);

          ctx.translate(x + dx, y + dy);
        }

        ctx.stroke();

        if (isPattern) {
          ctx.translate(-x - dx, -y - dy);
        }

        if (strokeOpacity < 1) {
          ctx.globalAlpha = alpha;
        }
      },
      _path: function _path(ctx, points, lineDashArray, lineOpacity, ignoreStrokePattern) {
        if (!isArrayHasData(points)) {
          return;
        }

        function fillWithPattern(p1, p2) {
          var degree = computeDegree(p1.x, p1.y, p2.x, p2.y);
          ctx.save();
          var cosd = Math.cos(degree);

          if (Math.abs(cosd) < 1E-7) {
            //a vertical line
            ctx.translate(p1.x - ctx.lineWidth / 2, p1.y);
          } else {
            ctx.translate(p1.x, p1.y - ctx.lineWidth / 2 / cosd);
          }

          ctx.rotate(degree);

          Canvas$1._stroke(ctx, lineOpacity);

          ctx.restore();
        }

        var isDashed = isArrayHasData(lineDashArray);
        var isPatternLine = ignoreStrokePattern === true ? false : Canvas$1._isPattern(ctx.strokeStyle);
        var point, prePoint, nextPoint;

        for (var i = 0, len = points.length; i < len; i++) {
          point = points[i];

          if (!isDashed || ctx.setLineDash) {
            //IE9+
            ctx.lineTo(point.x, point.y);

            if (isPatternLine && i > 0) {
              prePoint = points[i - 1];
              fillWithPattern(prePoint, point);
              ctx.beginPath();
              ctx.moveTo(point.x, point.y);
            }
          } else if (isDashed) {
            if (i === len - 1) {
              break;
            }

            nextPoint = points[i + 1];
            drawDashLine(ctx, point, nextPoint, lineDashArray, isPatternLine);
          }
        }
      },
      path: function path(ctx, points, lineOpacity, fillOpacity, lineDashArray) {
        if (!isArrayHasData(points)) {
          return;
        }

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        Canvas$1._path(ctx, points, lineDashArray, lineOpacity);

        Canvas$1._stroke(ctx, lineOpacity);
      },
      _multiClip: function _multiClip(ctx, points) {
        if (!points || points.length === 0) return; //not Handle holes

        points = points[0];

        for (var i = 0, len = points.length; i < len; i++) {
          var point = points[i];
          var x = point.x,
              y = point.y;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }

          if (i === len - 1) {
            x = points[0].x;
            y = points[0].y;
            ctx.lineTo(x, y);
          }
        }
      },
      polygon: function polygon(ctx, points, lineOpacity, fillOpacity, lineDashArray, smoothness) {
        // if MultiClip
        if (ctx.isMultiClip) {
          Canvas$1._multiClip(ctx, points);

          return;
        }

        if (!isArrayHasData(points)) {
          return;
        }

        var isPatternLine = Canvas$1._isPattern(ctx.strokeStyle),
            fillFirst = isArrayHasData(lineDashArray) && !ctx.setLineDash || isPatternLine && !smoothness;

        if (!isArrayHasData(points[0])) {
          points = [points];
        }

        var savedCtx = ctx;

        if (points.length > 1 && !IS_NODE) {
          if (!TEMP_CANVAS) {
            TEMP_CANVAS = Canvas$1.createCanvas(1, 1);
          }

          ctx.canvas._drawn = false;
          TEMP_CANVAS.width = ctx.canvas.width;
          TEMP_CANVAS.height = ctx.canvas.height;
          ctx = TEMP_CANVAS.getContext('2d');
          copyProperties(ctx, savedCtx);
        } // function fillPolygon(points, i, op) {
        //     Canvas.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);
        // }


        var op, i, len;

        if (fillFirst) {
          //因为canvas只填充moveto,lineto,lineto的空间, 而dashline的moveto不再构成封闭空间, 所以重新绘制图形轮廓用于填充
          ctx.save();

          for (i = 0, len = points.length; i < len; i++) {
            if (!isArrayHasData(points[i])) {
              continue;
            }

            Canvas$1._ring(ctx, points[i], null, 0, true);

            op = fillOpacity;

            if (i > 0) {
              ctx.globalCompositeOperation = 'destination-out';
              op = 1;
            }

            Canvas$1.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);

            if (i > 0) {
              ctx.globalCompositeOperation = 'source-over';
            } else if (len > 1) {
              // make sure 'destination-out'
              ctx.fillStyle = '#fff';
            }

            Canvas$1._stroke(ctx, 0);
          }

          ctx.restore();
        }

        for (i = 0, len = points.length; i < len; i++) {
          if (!isArrayHasData(points[i])) {
            continue;
          }

          if (smoothness) {
            Canvas$1.paintSmoothLine(ctx, points[i], lineOpacity, smoothness, true);
            ctx.closePath();
          } else {
            Canvas$1._ring(ctx, points[i], lineDashArray, lineOpacity);
          }

          if (!fillFirst) {
            op = fillOpacity;

            if (i > 0) {
              ctx.globalCompositeOperation = 'destination-out';
              op = 1;
            }

            Canvas$1.fillCanvas(ctx, op, points[i][0].x, points[i][0].y);

            if (i > 0) {
              //return to default compositeOperation to display strokes.
              ctx.globalCompositeOperation = 'source-over';
            } else if (len > 1) {
              // make sure 'destination-out'
              ctx.fillStyle = '#fff';
            }
          }

          Canvas$1._stroke(ctx, lineOpacity);
        }

        if (points.length > 1 && !IS_NODE) {
          savedCtx.drawImage(TEMP_CANVAS, 0, 0);
          savedCtx.canvas._drawn = ctx.canvas._drawn;
          copyProperties(savedCtx, ctx);
        }
      },
      _ring: function _ring(ctx, ring, lineDashArray, lineOpacity, ignorePattern) {
        var isPattern = Canvas$1._isPattern(ctx.strokeStyle);

        if (!ignorePattern && isPattern && !ring[0].equals(ring[ring.length - 1])) {
          ring = ring.concat([ring[0]]);
        }

        ctx.beginPath();
        ctx.moveTo(ring[0].x, ring[0].y);

        Canvas$1._path(ctx, ring, lineDashArray, lineOpacity, ignorePattern);

        if (!isPattern) {
          ctx.closePath();
        }
      },
      paintSmoothLine: function paintSmoothLine(ctx, points, lineOpacity, smoothValue, close, tailIdx, tailRatio) {
        if (!points) {
          return;
        }

        if (points.length <= 2 || !smoothValue) {
          Canvas$1.path(ctx, points, lineOpacity);
          return;
        } //推算 cubic 贝塞尔曲线片段的起终点和控制点坐标
        //t0: 片段起始比例 0-1
        //t1: 片段结束比例 0-1
        //x1, y1, 曲线起点
        //bx1, by1, bx2, by2，曲线控制点
        //x2, y2  曲线终点
        //结果是曲线片段的起点，2个控制点坐标和终点坐标
        //https://stackoverflow.com/questions/878862/drawing-part-of-a-b%C3%A9zier-curve-by-reusing-a-basic-b%C3%A9zier-curve-function/879213#879213


        function interpolate$$1(t0, t1, x1, y1, bx1, by1, bx2, by2, x2, y2) {
          var u0 = 1.0 - t0;
          var u1 = 1.0 - t1;
          var qxa = x1 * u0 * u0 + bx1 * 2 * t0 * u0 + bx2 * t0 * t0;
          var qxb = x1 * u1 * u1 + bx1 * 2 * t1 * u1 + bx2 * t1 * t1;
          var qxc = bx1 * u0 * u0 + bx2 * 2 * t0 * u0 + x2 * t0 * t0;
          var qxd = bx1 * u1 * u1 + bx2 * 2 * t1 * u1 + x2 * t1 * t1;
          var qya = y1 * u0 * u0 + by1 * 2 * t0 * u0 + by2 * t0 * t0;
          var qyb = y1 * u1 * u1 + by1 * 2 * t1 * u1 + by2 * t1 * t1;
          var qyc = by1 * u0 * u0 + by2 * 2 * t0 * u0 + y2 * t0 * t0;
          var qyd = by1 * u1 * u1 + by2 * 2 * t1 * u1 + y2 * t1 * t1; // const xa = qxa * u0 + qxc * t0;

          var xb = qxa * u1 + qxc * t1;
          var xc = qxb * u0 + qxd * t0;
          var xd = qxb * u1 + qxd * t1; // const ya = qya * u0 + qyc * t0;

          var yb = qya * u1 + qyc * t1;
          var yc = qyb * u0 + qyd * t0;
          var yd = qyb * u1 + qyd * t1;
          return [xb, yb, xc, yc, xd, yd];
        } //from http://www.antigrain.com/research/bezier_interpolation/


        function getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, t) {
          // Assume we need to calculate the control
          // points between (x1,y1) and (x2,y2).
          // Then x0,y0 - the previous vertex,
          //      x3,y3 - the next one.
          var xc1 = (x0 + x1) / 2.0,
              yc1 = (y0 + y1) / 2.0;
          var xc2 = (x1 + x2) / 2.0,
              yc2 = (y1 + y2) / 2.0;
          var xc3 = (x2 + x3) / 2.0,
              yc3 = (y2 + y3) / 2.0;
          var len1 = Math.sqrt((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0));
          var len2 = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          var len3 = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));
          var k1 = len1 / (len1 + len2);
          var k2 = len2 / (len2 + len3);
          var xm1 = xc1 + (xc2 - xc1) * k1,
              ym1 = yc1 + (yc2 - yc1) * k1;
          var xm2 = xc2 + (xc3 - xc2) * k2,
              ym2 = yc2 + (yc3 - yc2) * k2; // Resulting control points. Here smoothValue is mentioned
          // above coefficient K whose value should be in range [0...1].

          var ctrl1X = xm1 + (xc2 - xm1) * smoothValue + x1 - xm1,
              ctrl1Y = ym1 + (yc2 - ym1) * smoothValue + y1 - ym1,
              ctrl2X = xm2 + (xc2 - xm2) * smoothValue + x2 - xm2,
              ctrl2Y = ym2 + (yc2 - ym2) * smoothValue + y2 - ym2;
          var ctrlPoints = [ctrl1X, ctrl1Y, ctrl2X, ctrl2Y];

          if (t < 1) {
            return interpolate$$1(0, t, x1, y1, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, x2, y2);
          } else {
            return ctrlPoints;
          }
        }

        var count = points.length;
        var l = close ? count : count - 1;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        if (tailRatio !== undefined) l -= Math.max(l - tailIdx - 1, 0);
        var preCtrlPoints;

        for (var i = 0; i < l; i++) {
          var x1 = points[i].x,
              y1 = points[i].y;
          var x0 = void 0,
              y0 = void 0,
              x2 = void 0,
              y2 = void 0,
              x3 = void 0,
              y3 = void 0;

          if (i - 1 < 0) {
            if (!close) {
              x0 = points[i + 1].x;
              y0 = points[i + 1].y;
            } else {
              x0 = points[l - 1].x;
              y0 = points[l - 1].y;
            }
          } else {
            x0 = points[i - 1].x;
            y0 = points[i - 1].y;
          }

          if (i + 1 < count) {
            x2 = points[i + 1].x;
            y2 = points[i + 1].y;
          } else {
            x2 = points[i + 1 - count].x;
            y2 = points[i + 1 - count].y;
          }

          if (i + 2 < count) {
            x3 = points[i + 2].x;
            y3 = points[i + 2].y;
          } else if (!close) {
            x3 = points[i].x;
            y3 = points[i].y;
          } else {
            x3 = points[i + 2 - count].x;
            y3 = points[i + 2 - count].y;
          }

          var ctrlPoints = getCubicControlPoints(x0, y0, x1, y1, x2, y2, x3, y3, smoothValue, i === l - 1 ? tailRatio : 1);

          if (i === l - 1 && tailRatio >= 0 && tailRatio < 1) {
            ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], ctrlPoints[4], ctrlPoints[5]);
            points.splice(l - 1, count - (l - 1) - 1);
            var lastPoint = new Point(ctrlPoints[4], ctrlPoints[5]);
            lastPoint.prevCtrlPoint = new Point(ctrlPoints[2], ctrlPoints[3]);
            points.push(lastPoint);
            count = points.length;
          } else {
            ctx.bezierCurveTo(ctrlPoints[0], ctrlPoints[1], ctrlPoints[2], ctrlPoints[3], x2, y2);
          }

          points[i].nextCtrlPoint = ctrlPoints.slice(0, 2);
          points[i].prevCtrlPoint = preCtrlPoints ? preCtrlPoints.slice(2) : null;
          preCtrlPoints = ctrlPoints;
        }

        if (!close && points[1].prevCtrlPoint) {
          points[0].nextCtrlPoint = points[1].prevCtrlPoint;
          delete points[0].prevCtrlPoint;
        }

        if (!points[count - 1].prevCtrlPoint) {
          points[count - 1].prevCtrlPoint = points[count - 2].nextCtrlPoint;
        }

        Canvas$1._stroke(ctx, lineOpacity);
      },

      /**
       * draw an arc from p1 to p2 with degree of (p1, center) and (p2, center)
       * @param  {Context} ctx    canvas context
       * @param  {Point} p1      point 1
       * @param  {Point} p2      point 2
       * @param  {Number} degree arc degree between p1 and p2
       */
      _arcBetween: function _arcBetween(ctx, p1, p2, degree) {
        var a = degree,
            dist = p1.distanceTo(p2),
            //radius of circle
        r = dist / 2 / Math.sin(a / 2); //angle between p1 and p2

        var p1p2 = Math.asin((p2.y - p1.y) / dist);

        if (p1.x > p2.x) {
          p1p2 = Math.PI - p1p2;
        } //angle between circle center and p2


        var cp2 = 90 * Math.PI / 180 - a / 2,
            da = p1p2 - cp2;
        var dx = Math.cos(da) * r,
            dy = Math.sin(da) * r,
            cx = p1.x + dx,
            cy = p1.y + dy;
        var startAngle = Math.asin((p2.y - cy) / r);

        if (cx > p2.x) {
          startAngle = Math.PI - startAngle;
        }

        var endAngle = startAngle + a;
        ctx.beginPath();
        ctx.arc(cx, cy, r, startAngle, endAngle);
        return [cx, cy];
      },
      _lineTo: function _lineTo(ctx, p) {
        ctx.lineTo(p.x, p.y);
      },
      bezierCurveAndFill: function bezierCurveAndFill(ctx, points, lineOpacity, fillOpacity) {
        ctx.beginPath();
        var start = points[0];
        ctx.moveTo(start.x, start.y);
        var args = [ctx];
        args.push.apply(args, points.splice(1));

        Canvas$1._bezierCurveTo.apply(Canvas$1, args);

        Canvas$1.fillCanvas(ctx, fillOpacity);

        Canvas$1._stroke(ctx, lineOpacity);
      },
      _bezierCurveTo: function _bezierCurveTo(ctx, p1, p2, p3) {
        ctx.bezierCurveTo(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
      },
      //各种图形的绘制方法
      ellipse: function ellipse(ctx, pt, width, height, lineOpacity, fillOpacity) {
        function bezierEllipse(x, y, a, b) {
          var k = 0.5522848,
              ox = a * k,
              oy = b * k;
          ctx.moveTo(x - a, y);
          ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
          ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
          ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
          ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
          ctx.closePath();
        }

        ctx.beginPath();

        if (width === height) {
          ctx.arc(pt.x, pt.y, width, 0, 2 * Math.PI);
        } else if (ctx.ellipse) {
          ctx.ellipse(pt.x, pt.y, width, height, 0, 0, Math.PI / 180 * 360);
        } else {
          // IE
          bezierEllipse(pt.x, pt.y, width, height);
        }

        Canvas$1.fillCanvas(ctx, fillOpacity, pt.x - width, pt.y - height);

        Canvas$1._stroke(ctx, lineOpacity, pt.x - width, pt.y - height);
      },
      rectangle: function rectangle(ctx, pt, size, lineOpacity, fillOpacity) {
        // pt = pt._round();
        var x = pt.x,
            y = pt.y;
        ctx.beginPath();
        ctx.rect(x, y, size['width'], size['height']);
        Canvas$1.fillCanvas(ctx, fillOpacity, x, y);

        Canvas$1._stroke(ctx, lineOpacity, x, y);
      },
      sector: function sector(ctx, pt, size, angles, lineOpacity, fillOpacity) {
        var rad = Math.PI / 180;
        var startAngle = angles[0],
            endAngle = angles[1];

        function sector(ctx, x, y, radius, startAngle, endAngle) {
          var sDeg = rad * -endAngle;
          var eDeg = rad * -startAngle;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.arc(x, y, radius, sDeg, eDeg);
          ctx.lineTo(x, y);
          Canvas$1.fillCanvas(ctx, fillOpacity, x - radius, y - radius);

          Canvas$1._stroke(ctx, lineOpacity, x - radius, y - radius);
        }

        sector(ctx, pt.x, pt.y, size, startAngle, endAngle);
      },
      _isPattern: function _isPattern(style) {
        return !isString(style) && !('addColorStop' in style);
      },
      drawCross: function drawCross(ctx, x, y, lineWidth, color) {
        ctx.canvas._drawn = true;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(x - 5, y);
        ctx.lineTo(x + 5, y);
        ctx.moveTo(x, y - 5);
        ctx.lineTo(x, y + 5);
        ctx.stroke();
      },
      copy: function copy(canvas, c) {
        var target = c || createEl('canvas');
        target.width = canvas.width;
        target.height = canvas.height;
        target.getContext('2d').drawImage(canvas, 0, 0);
        return target;
      }
    };
    /* istanbul ignore next */

    function drawDashLine(ctx, startPoint, endPoint, dashArray) {
      //https://davidowens.wordpress.com/2010/09/07/html-5-canvas-and-dashed-lines/
      //
      // Our growth rate for our line can be one of the following:
      //   (+,+), (+,-), (-,+), (-,-)
      // Because of this, our algorithm needs to understand if the x-coord and
      // y-coord should be getting smaller or larger and properly cap the values
      // based on (x,y).
      var fromX = startPoint.x,
          fromY = startPoint.y,
          toX = endPoint.x,
          toY = endPoint.y;
      var pattern = dashArray;

      var lt = function lt(a, b) {
        return a <= b;
      };

      var gt = function gt(a, b) {
        return a >= b;
      };

      var capmin = function capmin(a, b) {
        return Math.min(a, b);
      };

      var capmax = function capmax(a, b) {
        return Math.max(a, b);
      };

      var checkX = {
        thereYet: gt,
        cap: capmin
      };
      var checkY = {
        thereYet: gt,
        cap: capmin
      };

      if (fromY - toY > 0) {
        checkY.thereYet = lt;
        checkY.cap = capmax;
      }

      if (fromX - toX > 0) {
        checkX.thereYet = lt;
        checkX.cap = capmax;
      }

      ctx.moveTo(fromX, fromY);
      var offsetX = fromX;
      var offsetY = fromY;
      var idx = 0,
          dash = true;
      var ang, len;

      while (!(checkX.thereYet(offsetX, toX) && checkY.thereYet(offsetY, toY))) {
        ang = Math.atan2(toY - fromY, toX - fromX);
        len = pattern[idx];
        offsetX = checkX.cap(toX, offsetX + Math.cos(ang) * len);
        offsetY = checkY.cap(toY, offsetY + Math.sin(ang) * len);

        if (dash) {
          ctx.lineTo(offsetX, offsetY);
        } else {
          ctx.moveTo(offsetX, offsetY);
        }

        idx = (idx + 1) % pattern.length;
        dash = !dash;
      }
    }

    var prefix = 'data:image/';

    function isImageUrl(url) {
      return url.length > prefix.length && url.substring(0, prefix.length) === prefix || isCssUrl(url);
    }

    function extractImageUrl(url) {
      if (url.substring(0, prefix.length) === prefix) {
        return url;
      }

      return extractCssUrl(url);
    }

    function copyProperties(ctx, savedCtx) {
      ctx.filter = savedCtx.filter;
      ctx.fillStyle = savedCtx.fillStyle;
      ctx.globalAlpha = savedCtx.globalAlpha;
      ctx.lineCap = savedCtx.lineCap;
      ctx.lineDashOffset = savedCtx.lineDashOffset;
      ctx.lineJoin = savedCtx.lineJoin;
      ctx.lineWidth = savedCtx.lineWidth;
      ctx.shadowBlur = savedCtx.shadowBlur;
      ctx.shadowColor = savedCtx.shadowColor;
      ctx.shadowOffsetX = savedCtx.shadowOffsetX;
      ctx.shadowOffsetY = savedCtx.shadowOffsetY;
      ctx.strokeStyle = savedCtx.strokeStyle;
    }

    // zousan - A Lightning Fast, Yet Very Small Promise A+ Compliant Implementation
    // https://github.com/bluejava/zousan
    // Author: Glenn Crownover <glenn@bluejava.com> (http://www.bluejava.com)
    // Version 2.3.3
    // License: MIT
    // https://github.com/bluejava/zousan/blob/567e5d9f17cd9a78e4b95dce1dee4e58830e293d/src/zousan.js
    var global = window || global || {};

    var STATE_PENDING,
        // These are the three possible states (PENDING remains undefined - as intended)
    STATE_FULFILLED = 'fulfilled',
        // a promise can be in.  The state is stored
    STATE_REJECTED = 'rejected',
        // in this.state as read-only
    _undefined,
        // let the obfiscator compress these down
    _undefinedString = 'undefined'; // by assigning them to variables (debatable "optimization")
    // See http://www.bluejava.com/4NS/Speed-up-your-Websites-with-a-Faster-setTimeout-using-soon
    // This is a very fast "asynchronous" flow control - i.e. it yields the thread and executes later,
    // but not much later. It is far faster and lighter than using setTimeout(fn,0) for yielding threads.
    // Its also faster than other setImmediate shims, as it uses Mutation Observer and "mainlines" successive
    // calls internally.
    // WARNING: This does not yield to the browser UI loop, so by using this repeatedly
    // 		you can starve the UI and be unresponsive to the user.
    // This is an even FASTER version of https://gist.github.com/bluejava/9b9542d1da2a164d0456 that gives up
    // passing context and arguments, in exchange for a 25x speed increase. (Use anon function to pass context/args)


    var soon = function () {
      var fq = [],
          // function queue;
      fqStart = 0,
          // avoid using shift() by maintaining a start pointer - and remove items in chunks of 1024 (bufferSize)
      bufferSize = 1024;

      function callQueue() {
        while (fq.length - fqStart) {
          // this approach allows new yields to pile on during the execution of these
          try {
            fq[fqStart]();
          } catch (err) {
            // no context or args..
            if (global.console) global.console.error(err);
          }

          fq[fqStart++] = _undefined; // increase start pointer and dereference function just called

          if (fqStart == bufferSize) {
            fq.splice(0, bufferSize);
            fqStart = 0;
          }
        }
      } // run the callQueue function asyncrhonously, as fast as possible


      var cqYield = function () {
        // This is the fastest way browsers have to yield processing
        if (typeof MutationObserver !== _undefinedString) {
          // first, create a div not attached to DOM to "observe"
          var dd = document.createElement('div');
          var mo = new MutationObserver(callQueue);
          mo.observe(dd, {
            attributes: true
          });
          return function () {
            dd.setAttribute('a', 0);
          }; // trigger callback to
        } // if No MutationObserver - this is the next best thing - handles Node and MSIE


        if (typeof setImmediate !== _undefinedString) return function () {
          setImmediate(callQueue);
        }; // final fallback - shouldn't be used for much except very old browsers

        return function () {
          setTimeout(callQueue, 0);
        };
      }(); // this is the function that will be assigned to soon
      // it takes the function to call and examines all arguments


      return function (fn) {
        // push the function and any remaining arguments along with context
        fq.push(fn);
        if (fq.length - fqStart == 1) // upon adding our first entry, kick off the callback
          cqYield();
      };
    }(); // -------- BEGIN our main "class" definition here -------------


    function Zousan$1(func) {
      //  this.state = STATE_PENDING;	// Inital state (PENDING is undefined, so no need to actually have this assignment)
      //this.c = [];			// clients added while pending.   <Since 1.0.2 this is lazy instantiation>
      // If a function was specified, call it back with the resolve/reject functions bound to this context
      if (func) {
        var me = this;
        func(function (arg) {
          me.resolve(arg);
        }, // the resolve function bound to this context.
        function (arg) {
          me.reject(arg);
        }); // the reject function bound to this context
      }
    }

    Zousan$1.prototype = {
      // Add 6 functions to our prototype: "resolve", "reject", "then", "catch", "finally" and "timeout"
      resolve: function resolve(value) {
        if (this.state !== STATE_PENDING) return;
        if (value === this) return this.reject(new TypeError('Attempt to resolve promise with self'));
        var me = this; // preserve this

        if (value && (typeof value === 'function' || typeof value === 'object')) {
          try {
            var first = true; // first time through?

            var then = value.then;

            if (typeof then === 'function') {
              // and call the value.then (which is now in "then") with value as the context and the resolve/reject functions per thenable spec
              then.call(value, function (ra) {
                if (first) {
                  first = false;
                  me.resolve(ra);
                }
              }, function (rr) {
                if (first) {
                  first = false;
                  me.reject(rr);
                }
              });
              return;
            }
          } catch (e) {
            if (first) this.reject(e);
            return;
          }
        }

        this.state = STATE_FULFILLED;
        this.v = value;
        if (me.c) soon(function () {
          for (var n = 0, l = me.c.length; n < l; n++) {
            resolveClient(me.c[n], value);
          }
        });
      },
      reject: function reject(reason) {
        if (this.state !== STATE_PENDING) return;
        this.state = STATE_REJECTED;
        this.v = reason;
        var clients = this.c;
        if (clients) soon(function () {
          for (var n = 0, l = clients.length; n < l; n++) {
            rejectClient(clients[n], reason);
          }
        });else if (!Zousan$1.suppressUncaughtRejectionError && global.console) {
          // global.console.log("You upset Zousan. Please catch rejections: ", reason, reason ? reason.stack : null)
          global.console.log('You upset Zousan. Please catch rejections');
          throw reason;
        }
      },
      then: function then(onF, onR) {
        var p = new Zousan$1();
        var client = {
          y: onF,
          n: onR,
          p: p
        };

        if (this.state === STATE_PENDING) {
          // we are pending, so client must wait - so push client to end of this.c array (create if necessary for efficiency)
          if (this.c) this.c.push(client);else this.c = [client];
        } // if state was NOT pending, then we can just immediately (soon) call the resolve/reject handler
        else {
            var s = this.state,
                a = this.v;
            soon(function () {
              // we are not pending, so yield script and resolve/reject as needed
              if (s === STATE_FULFILLED) resolveClient(client, a);else rejectClient(client, a);
            });
          }

        return p;
      },
      catch: function _catch(cfn) {
        return this.then(null, cfn);
      },
      // convenience method
      finally: function _finally(cfn) {
        return this.then(cfn, cfn);
      },
      // convenience method
      // new for 1.2  - this returns a new promise that times out if original promise does not resolve/reject before the time specified.
      // Note: this has no effect on the original promise - which may still resolve/reject at a later time.
      timeout: function timeout(ms, timeoutMsg) {
        timeoutMsg = timeoutMsg || 'Timeout';
        var me = this;
        return new Zousan$1(function (resolve, reject) {
          setTimeout(function () {
            reject(Error(timeoutMsg)); // This will fail silently if promise already resolved or rejected
          }, ms);
          me.then(function (v) {
            resolve(v);
          }, // This will fail silently if promise already timed out
          function (er) {
            reject(er);
          }); // This will fail silently if promise already timed out
        });
      }
    }; // END of prototype function list

    function resolveClient(c, arg) {
      if (typeof c.y === 'function') {
        try {
          var yret = c.y.call(_undefined, arg);
          c.p.resolve(yret);
        } catch (err) {
          c.p.reject(err);
        }
      } else c.p.resolve(arg); // pass this along...

    }

    function rejectClient(c, reason) {
      if (typeof c.n === 'function') {
        try {
          var yret = c.n.call(_undefined, reason);
          c.p.resolve(yret);
        } catch (err) {
          c.p.reject(err);
        }
      } else c.p.reject(reason); // pass this along...

    } // "Class" functions follow (utility functions that live on the Zousan function object itself)


    Zousan$1.resolve = function (val) {
      var z = new Zousan$1();
      z.resolve(val);
      return z;
    };

    Zousan$1.reject = function (err) {
      var z = new Zousan$1();
      z.reject(err);
      return z;
    };

    Zousan$1.all = function (pa) {
      var results = [],
          rc = 0,
          retP = new Zousan$1(); // results and resolved count

      function rp(p, i) {
        if (!p || typeof p.then !== 'function') p = Zousan$1.resolve(p);
        p.then(function (yv) {
          results[i] = yv;
          rc++;
          if (rc == pa.length) retP.resolve(results);
        }, function (nv) {
          retP.reject(nv);
        });
      }

      for (var x = 0; x < pa.length; x++) {
        rp(pa[x], x);
      } // For zero length arrays, resolve immediately


      if (!pa.length) retP.resolve(results);
      return retP;
    };

    Zousan$1.soon = soon;

    var promise;

    if (typeof Zousan$1 !== 'undefined') {
      // built-in Promise
      promise = Zousan$1;
    } else {
      promise = Zousan;
    }

    var Promise$1 = promise;

    /**
     * This provides methods used for event handling. It's a mixin and not meant to be used directly.
     * @mixin Eventable
     */

    var Eventable = function Eventable(Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          var _proto = _class.prototype;

          /**
           * Register a handler function to be called whenever this event is fired.
           *
           * @param {String} eventsOn                  - event types to register, seperated by space if more than one.
           * @param {Function} handler                 - handler function to be called
           * @param {Object} [context=null]            - the context of the handler
           * @return {Any} this
           * @function Eventable.on
           * @example
           * foo.on('mousedown mousemove mouseup', onMouseEvent, foo);
           */
          _proto.on = function on$$1(eventsOn, handler, context) {
            if (!eventsOn) {
              return this;
            }

            if (!isString(eventsOn)) {
              return this._switch('on', eventsOn, handler);
            }

            if (!handler) {
              return this;
            }

            if (!this._eventMap) {
              this._eventMap = {};
            }

            var eventTypes = eventsOn.toLowerCase().split(' ');
            var evtType;

            if (!context) {
              context = this;
            }

            var handlerChain;

            for (var ii = 0, ll = eventTypes.length; ii < ll; ii++) {
              evtType = eventTypes[ii];
              handlerChain = this._eventMap[evtType];

              if (!handlerChain) {
                handlerChain = [];
                this._eventMap[evtType] = handlerChain;
              }

              var l = handlerChain.length;

              if (l > 0) {
                for (var i = 0; i < l; i++) {
                  if (handler === handlerChain[i].handler && handlerChain[i].context === context) {
                    return this;
                  }
                }
              }

              handlerChain.push({
                handler: handler,
                context: context
              });
            }

            return this;
          }
          /**
           * Alias for [on]{@link Eventable.on}
           *
           * @param {String} eventTypes     - event types to register, seperated by space if more than one.
           * @param {Function} handler                 - handler function to be called
           * @param {Object} [context=null]            - the context of the handler
           * @return {} this
           * @function Eventable.addEventListener
           */
          ;

          _proto.addEventListener = function addEventListener() {
            return this.on.apply(this, arguments);
          }
          /**
           * Same as on, except the listener will only get fired once and then removed.
           *
           * @param {String} eventTypes                - event types to register, seperated by space if more than one.
           * @param {Function} handler                 - listener handler
           * @param {Object} [context=null]            - the context of the handler
           * @return {} this
           * @example
           * foo.once('mousedown mousemove mouseup', onMouseEvent, foo);
           * @function Eventable.once
           */
          ;

          _proto.once = function once(eventTypes, handler, context) {
            if (!isString(eventTypes)) {
              var once = {};

              for (var p in eventTypes) {
                if (eventTypes.hasOwnProperty(p)) {
                  once[p] = this._wrapOnceHandler(p, eventTypes[p], context);
                }
              }

              return this._switch('on', once);
            }

            var evetTypes = eventTypes.split(' ');

            for (var i = 0, l = evetTypes.length; i < l; i++) {
              this.on(evetTypes[i], this._wrapOnceHandler(evetTypes[i], handler, context));
            }

            return this;
          }
          /**
           * Unregister the event handler for the specified event types.
           *
           * @param {String} eventsOff                - event types to unregister, seperated by space if more than one.
           * @param {Function} handler                - listener handler
           * @param {Object} [context=null]           - the context of the handler
           * @return {} this
           * @example
           * foo.off('mousedown mousemove mouseup', onMouseEvent, foo);
           * @function Eventable.off
           */
          ;

          _proto.off = function off$$1(eventsOff, handler, context) {
            if (!this._eventMap || !eventsOff) {
              return this;
            }

            if (!isString(eventsOff)) {
              return this._switch('off', eventsOff, handler);
            }

            if (!handler) {
              return this;
            }

            var eventTypes = eventsOff.split(' ');
            var eventType, listeners, wrapKey;

            if (!context) {
              context = this;
            }

            for (var j = 0, jl = eventTypes.length; j < jl; j++) {
              eventType = eventTypes[j].toLowerCase();
              wrapKey = 'Z__' + eventType;
              listeners = this._eventMap[eventType];

              if (!listeners) {
                return this;
              }

              for (var i = listeners.length - 1; i >= 0; i--) {
                var listener = listeners[i];

                if ((handler === listener.handler || handler === listener.handler[wrapKey]) && listener.context === context) {
                  delete listener.handler[wrapKey];
                  listeners.splice(i, 1);
                }
              }

              if (!listeners.length) {
                delete this._eventMap[eventType];
              }
            }

            return this;
          }
          /**
           * Alias for [off]{@link Eventable.off}
           *
           * @param {String} eventTypes    - event types to unregister, seperated by space if more than one.
           * @param {Function} handler                - listener handler
           * @param {Object} [context=null]           - the context of the handler
           * @return {} this
           * @function Eventable.removeEventListener
           */
          ;

          _proto.removeEventListener = function removeEventListener() {
            return this.off.apply(this, arguments);
          }
          /**
           * Returns listener's count registered for the event type.
           *
           * @param {String} eventType        - an event type
           * @param {Function} [hanlder=null] - listener function
           * @param {Object} [context=null]   - the context of the handler
           * @return {Number}
           * @function Eventable.listens
           */
          ;

          _proto.listens = function listens(eventType, handler, context) {
            if (!this._eventMap || !isString(eventType)) {
              return 0;
            }

            var handlerChain = this._eventMap[eventType.toLowerCase()];

            if (!handlerChain || !handlerChain.length) {
              return 0;
            }

            if (!handler) {
              return handlerChain.length;
            }

            for (var i = 0, len = handlerChain.length; i < len; i++) {
              if (handler === handlerChain[i].handler && (isNil(context) || handlerChain[i].context === context)) {
                return 1;
              }
            }

            return 0;
          }
          /**
           * Get all the listening event types
           *
           * @returns {String[]} events
           */
          ;

          _proto.getListeningEvents = function getListeningEvents() {
            if (!this._eventMap) {
              return [];
            }

            return Object.keys(this._eventMap);
          }
          /**
           * Copy all the event listener to the target object
           * @param {Object} target - target object to copy to.
           * @return {} this
           * @function Eventable.copyEventListeners
           */
          ;

          _proto.copyEventListeners = function copyEventListeners(target) {
            var eventMap = target._eventMap;

            if (!eventMap) {
              return this;
            }

            var handlerChain;

            for (var eventType in eventMap) {
              handlerChain = eventMap[eventType];

              for (var i = 0, len = handlerChain.length; i < len; i++) {
                this.on(eventType, handlerChain[i].handler, handlerChain[i].context);
              }
            }

            return this;
          }
          /**
           * Fire an event, causing all handlers for that event name to run.
           *
           * @param  {String} eventType - an event type to fire
           * @param  {Object} param     - parameters for the listener function.
           * @return {} this
           * @function Eventable.fire
           */
          ;

          _proto.fire = function fire() {
            if (this._eventParent) {
              return this._eventParent.fire.apply(this._eventParent, arguments);
            }

            return this._fire.apply(this, arguments);
          };

          _proto._wrapOnceHandler = function _wrapOnceHandler(evtType, handler, context) {
            var me = this;
            var key = 'Z__' + evtType;
            var called = false;

            var fn = function onceHandler() {
              if (called) {
                return;
              }

              delete fn[key];
              called = true;

              if (context) {
                handler.apply(context, arguments);
              } else {
                handler.apply(this, arguments);
              }

              me.off(evtType, onceHandler, this);
            };

            fn[key] = handler;
            return fn;
          };

          _proto._switch = function _switch(to, eventKeys, context) {
            for (var p in eventKeys) {
              if (eventKeys.hasOwnProperty(p)) {
                this[to](p, eventKeys[p], context);
              }
            }

            return this;
          };

          _proto._clearListeners = function _clearListeners(eventType) {
            if (!this._eventMap || !isString(eventType)) {
              return;
            }

            var handlerChain = this._eventMap[eventType.toLowerCase()];

            if (!handlerChain) {
              return;
            }

            this._eventMap[eventType] = null;
          };

          _proto._clearAllListeners = function _clearAllListeners() {
            this._eventMap = null;
          }
          /**
           * Set a event parent to handle all the events
           * @param {Any} parent - event parent
           * @return {Any} this
           * @private
           * @function Eventable._setEventParent
           */
          ;

          _proto._setEventParent = function _setEventParent(parent) {
            this._eventParent = parent;
            return this;
          };

          _proto._setEventTarget = function _setEventTarget(target) {
            this._eventTarget = target;
            return this;
          };

          _proto._fire = function _fire(eventType, param) {
            if (!this._eventMap) {
              return this;
            }

            var handlerChain = this._eventMap[eventType.toLowerCase()];

            if (!handlerChain) {
              return this;
            }

            if (!param) {
              param = {};
            }

            param['type'] = eventType;
            param['target'] = this._eventTarget || this; //in case of deleting a listener in a execution, copy the handlerChain to execute.

            var queue = handlerChain.slice(0);
            var context, bubble, passed;

            for (var i = 0, len = queue.length; i < len; i++) {
              if (!queue[i]) {
                continue;
              }

              context = queue[i].context;
              bubble = true;
              passed = extend({}, param);

              if (context) {
                bubble = queue[i].handler.call(context, passed);
              } else {
                bubble = queue[i].handler(passed);
              } //stops the event propagation if the handler returns false.


              if (bubble === false) {
                if (param['domEvent']) {
                  stopPropagation(param['domEvent']);
                }
              }
            }

            return this;
          };

          return _class;
        }(Base)
      );
    };

    /**
     * Base class for all the interaction handlers
     * @category handler
     * @abstract
     * @protected
     */

    var Handler =
    /*#__PURE__*/
    function () {
      function Handler(target) {
        this.target = target;
      }
      /**
       * Enables the handler
       * @return {Handler} this
       */


      var _proto = Handler.prototype;

      _proto.enable = function enable() {
        if (this._enabled) {
          return this;
        }

        this._enabled = true;
        this.addHooks();
        return this;
      }
      /**
       * Disablesthe handler
       * @return {Handler} this
       */
      ;

      _proto.disable = function disable() {
        if (!this._enabled) {
          return this;
        }

        this._enabled = false;
        this.removeHooks();
        return this;
      }
      /**
       * Returns true if the handler is enabled.
       * @return {Boolean}
       */
      ;

      _proto.enabled = function enabled() {
        return !!this._enabled;
      };

      _proto.remove = function remove() {
        this.disable();
        delete this.target;
        delete this.dom;
      };

      return Handler;
    }();

    var Handler$1 = Eventable(Handler);

    /**
     * This library uses ES2015 class system. <br />
     * Class is the root class of class hierachy. <br />
     * It provides utility methods to make it easier to manage configration options, merge mixins and add init hooks.
     * @example
     * var defaultOptions = {
     *     'foo' : 'bar'
     * };
     * class Foo extends maptalks.Class {
     *     constructor(id, options) {
     *         super(options);
     *         this.setId(id);
     *     }
     *
     *     setId(id) {
     *         this.id = id;
     *     }
     *
     *     whenCreated() {
     *         // .....
     *     }
     * }
     *
     * Foo.mergeOptions(defaultOptions);
     *
     * Foo.addInitHook('whenCreated');
     * @category core
     * @abstract
     */

    var Class =
    /*#__PURE__*/
    function () {
      /**
       * Create an object, set options if given and call all the init hooks.<br />
       * Options is where the object manages its configuration. Options passed to the object will be merged with parent's instead of overriding it.
       *
       * @param  {Object} options - options to set
       */
      function Class(options) {
        if (!this || !this.setOptions) {
          throw new Error('Class instance is being created without "new" operator.');
        }

        this.setOptions(options);
        this.callInitHooks();
      }
      /**
       * Visit and call all the init hooks defined on Class and its parents.
       * @return {Class} this
       */


      var _proto = Class.prototype;

      _proto.callInitHooks = function callInitHooks() {
        var proto = Object.getPrototypeOf(this);

        this._visitInitHooks(proto);

        return this;
      }
      /**
       * Merges options with the default options of the object.
       * @param {Object} options - options to set
       * @return {Class} this
       */
      ;

      _proto.setOptions = function setOptions(options) {
        if (!this.hasOwnProperty('options')) {
          this.options = this.options ? Object.create(this.options) : {};
        }

        if (!options) {
          return this;
        }

        for (var i in options) {
          this.options[i] = options[i];
        }

        return this;
      }
      /**
       * 1. Return object's options if no parameter is provided. <br/>
       *
       * 2. update an option and enable/disable the handler if a handler with the same name existed.
       * @example
       * // Get marker's options;
       * var options = marker.config();
       * // Set map's option "draggable" to false and disable map's draggable handler.
       * map.config('draggable', false);
       * // You can update more than one options like this:
       * map.config({
       *     'scrollWheelZoom' : false,
       *     'doubleClickZoom' : false
       * });
       * @param  {Object} conf - config to update
       * @return {Class} this
       */
      ;

      _proto.config = function config(conf) {
        if (!conf) {
          var config = {};

          for (var p in this.options) {
            if (this.options.hasOwnProperty(p)) {
              config[p] = this.options[p];
            }
          }

          return config;
        } else {
          if (arguments.length === 2) {
            var t = {};
            t[conf] = arguments[1];
            conf = t;
          }

          for (var i in conf) {
            this.options[i] = conf[i]; // enable/disable handler

            if (this[i] && this[i] instanceof Handler$1) {
              if (conf[i]) {
                this[i].enable();
              } else {
                this[i].disable();
              }
            }
          } // callback when set config


          this.onConfig(conf);
        }

        return this;
      }
      /**
       * Default callback when config is called
       */
      ;

      _proto.onConfig = function onConfig()
      /*conf*/
      {};

      _proto._visitInitHooks = function _visitInitHooks(proto) {
        if (this._initHooksCalled) {
          return;
        }

        var parentProto = Object.getPrototypeOf(proto);

        if (parentProto._visitInitHooks) {
          parentProto._visitInitHooks.call(this, parentProto);
        }

        this._initHooksCalled = true;
        var hooks = proto._initHooks;

        if (hooks && hooks !== parentProto._initHooks) {
          for (var i = 0; i < hooks.length; i++) {
            hooks[i].call(this);
          }
        }
      }
      /**
       * Add an init hook, which will be called when the object is initiated. <br>
       * It is useful in plugin developing to do things when creating objects without changing class's constructor.
       * @param {String|Function} fn - a hook function or name of the hook function
       * @param {Any[]} args         - arguments for the init hook function
       */
      ;

      Class.addInitHook = function addInitHook(fn) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var init = typeof fn === 'function' ? fn : function () {
          this[fn].apply(this, args);
        };
        var proto = this.prototype;
        var parentProto = Object.getPrototypeOf(proto);

        if (!proto._initHooks || proto._initHooks === parentProto._initHooks) {
          proto._initHooks = [];
        }

        proto._initHooks.push(init);

        return this;
      }
      /**
       * Mixin the specified objects into the class as prototype properties or methods.
       * @param  {...Object} sources - objects to mixin
       */
      ;

      Class.include = function include() {
        for (var i = 0; i < arguments.length; i++) {
          extend(this.prototype, i < 0 || arguments.length <= i ? undefined : arguments[i]);
        }

        return this;
      }
      /**
       * Mixin options with the class's default options. <br />
       * @param  {Object} options - options to merge.
       */
      ;

      Class.mergeOptions = function mergeOptions(options) {
        var proto = this.prototype;
        var parentProto = Object.getPrototypeOf(proto);

        if (!proto.options || proto.options === parentProto.options) {
          proto.options = proto.options ? Object.create(proto.options) : {};
        }

        extend(proto.options, options);
        return this;
      };

      return Class;
    }();

    var registeredTypes = {};
    /**
     * A helper mixin for JSON serialization.
     * @mixin JSONAble
     */

    var JSONAble = (function (Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          /**
           * It is a static method. <br>
           * Register layer for JSON serialization and assign a JSON type.
           * @param  {String} type - JSON type
           * @function JSONAble.registerJSONType
           */
          _class.registerJSONType = function registerJSONType(type) {
            if (!type) {
              return this;
            }

            registeredTypes[type] = this;
            return this;
          }
          /**
           * It is a static method. <br>
           * Get class of input JSON type
           * @param  {String} type - JSON type
           * @return {Class}      Class
           * @function JSONAble.getJSONClass
           */
          ;

          _class.getJSONClass = function getJSONClass(type) {
            if (!type) {
              return null;
            }

            return registeredTypes[type];
          }
          /**
           * Get object's JSON Type
           * @return {String}
           * @function JSONAble.getJSONType
           */
          ;

          var _proto = _class.prototype;

          _proto.getJSONType = function getJSONType() {
            if (this._jsonType === undefined) {
              var clazz = Object.getPrototypeOf(this).constructor;

              for (var p in registeredTypes) {
                if (registeredTypes[p] === clazz) {
                  this._jsonType = p;
                  break;
                }
              }
            }

            if (!this._jsonType) {
              throw new Error('Found an unregistered geometry class!');
            }

            return this._jsonType;
          };

          return _class;
        }(Base)
      );
    });

    /**
     * A mixin, to enable a class with [interaction handlers]{@link Handler}
     * @protected
     * @category handler
     * @mixin Handlerable
     */
    function Handlerable (Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          var _proto = _class.prototype;

          /**
           * Register a handler
           * @param {String} name       - name of the handler
           * @param {Handler}           - handler class
           * @return {*} this
           * @protected
           * @function Handerable.addHandler
           */
          _proto.addHandler = function addHandler(name, handlerClass) {
            if (!handlerClass) {
              return this;
            }

            if (!this._handlers) {
              this._handlers = [];
            } //handler已经存在


            if (this[name]) {
              this[name].enable();
              return this;
            }

            var handler = this[name] = new handlerClass(this);

            this._handlers.push(handler);

            if (this.options[name]) {
              handler.enable();
            }

            return this;
          }
          /**
           * Removes a handler
           * @param {String} name       - name of the handler
           * @return {*} this
           * @protected
           * @function Handerable.removeHandler
           */
          ;

          _proto.removeHandler = function removeHandler(name) {
            if (!name) {
              return this;
            }

            var handler = this[name];

            if (handler) {
              //handler registered
              var hit = this._handlers.indexOf(handler);

              if (hit >= 0) {
                this._handlers.splice(hit, 1);
              }

              this[name].remove();
              delete this[name];
            }

            return this;
          };

          _proto._clearHandlers = function _clearHandlers() {
            for (var i = 0, len = this._handlers.length; i < len; i++) {
              this._handlers[i].remove();
            }

            this._handlers = [];
          };

          return _class;
        }(Base)
      );
    }

    var START_EVENTS = 'touchstart mousedown';
    var MOVE_EVENTS = {
      mousedown: 'mousemove',
      touchstart: 'touchmove',
      pointerdown: 'touchmove',
      MSPointerDown: 'touchmove'
    };
    var END_EVENTS = {
      mousedown: 'mouseup',
      touchstart: 'touchend',
      pointerdown: 'touchend',
      MSPointerDown: 'touchend'
    };
    /**
     * Drag handler
     * @category handler
     * @protected
     * @extends Handler
     */

    var DragHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(DragHandler, _Handler);

      function DragHandler(dom, options) {
        var _this;

        if (options === void 0) {
          options = {};
        }

        _this = _Handler.call(this, null) || this;
        _this.dom = dom;
        _this.options = options;
        return _this;
      }

      var _proto = DragHandler.prototype;

      _proto.enable = function enable() {
        if (!this.dom) {
          return this;
        } //create a dynamic method to resolve conflicts with other drag handler


        this._onMouseDown = function (e) {
          return this.onMouseDown(e);
        };

        on(this.dom, START_EVENTS, this._onMouseDown, this);
        return this;
      };

      _proto.disable = function disable() {
        if (!this.dom) {
          return this;
        }

        this._offEvents();

        off(this.dom, START_EVENTS, this._onMouseDown);
        delete this._onMouseDown;
        return this;
      };

      _proto.onMouseDown = function onMouseDown(event) {
        if (!this.options['rightclick'] && event.button === 2) {
          //ignore right mouse down
          return;
        }

        if (event.touches && event.touches.length > 1) {
          return;
        }

        if (this.options['cancelOn'] && this.options['cancelOn'](event) === true) {
          return;
        }

        var dom = this.dom;

        if (dom.setCapture) {
          dom.setCapture();
        } else if (window.captureEvents) {
          window.captureEvents(window['Event'].MOUSEMOVE | window['Event'].MOUSEUP);
        }

        dom['ondragstart'] = function () {
          return false;
        };

        delete this.moved;
        var actual = event.touches ? event.touches[0] : event;
        this.startPos = new Point(actual.clientX, actual.clientY);
        on(document, MOVE_EVENTS[event.type], this.onMouseMove, this);
        on(document, END_EVENTS[event.type], this.onMouseUp, this);

        if (!this.options['ignoreMouseleave']) {
          on(this.dom, 'mouseleave', this.onMouseUp, this);
        }

        this.fire('mousedown', {
          'domEvent': event,
          'mousePos': new Point(actual.clientX, actual.clientY)
        });
      };

      _proto.onMouseMove = function onMouseMove(event) {
        if (event.touches && event.touches.length > 1) {
          if (this.moved) {
            this.interupted = true;
            this.onMouseUp(event);
          }

          return;
        }

        var actual = event.touches ? event.touches[0] : event;
        var newPos = new Point(actual.clientX, actual.clientY),
            offset = newPos.sub(this.startPos);

        if (!offset.x && !offset.y) {
          return;
        }

        if (!this.moved) {
          this.fire('dragstart', {
            'domEvent': event,
            'mousePos': this.startPos.copy()
          });
          this.moved = true;
        } else {
          this.fire('dragging', {
            'domEvent': event,
            'mousePos': new Point(actual.clientX, actual.clientY)
          });
        }
      };

      _proto.onMouseUp = function onMouseUp(event) {
        var actual = event.changedTouches ? event.changedTouches[0] : event;

        this._offEvents();

        var param = {
          'domEvent': event
        };

        if (isNumber(actual.clientX)) {
          param['mousePos'] = new Point(parseInt(actual.clientX, 0), parseInt(actual.clientY, 0));
        }

        if (this.moved
        /* && this.moving*/
        ) {
            param.interupted = this.interupted;
            this.fire('dragend', param);
            delete this.interupted;
            delete this.moved;
          }

        this.fire('mouseup', param);
      };

      _proto._offEvents = function _offEvents() {
        var dom = this.dom;
        off(dom, 'mouseleave', this.onMouseUp, this);

        if (typeof document === 'undefined' || typeof window === 'undefined') {
          return;
        }

        for (var i in MOVE_EVENTS) {
          off(document, MOVE_EVENTS[i], this.onMouseMove, this);
          off(document, END_EVENTS[i], this.onMouseUp, this);
        }

        if (dom['releaseCapture']) {
          dom['releaseCapture']();
        } else if (window.captureEvents) {
          window.captureEvents(window['Event'].MOUSEMOVE | window['Event'].MOUSEUP);
        }
      };

      return DragHandler;
    }(Handler$1);

    /**
     * Represents a coordinate point <br>
     * e.g. <br>
     * A geographical point (longitude, latitude)
     * @example
     * var coord = new Coordinate(0, 0);
     * @example
     * var coord = new Coordinate([ 0, 0 ]);
     * @example
     * var coord = new Coordinate({ x : 0, y : 0 });
     * @category basic types
     */

    var Coordinate =
    /*#__PURE__*/
    function (_Position) {
      _inheritsLoose(Coordinate, _Position);

      function Coordinate() {
        return _Position.apply(this, arguments) || this;
      }

      /**
       * Convert one or more Coordinate objects to GeoJSON style coordinates
       * @param  {Coordinate|Coordinate[]} coordinates - coordinates to convert
       * @return {Number[]|Number[][]}
       * @example
       * // result is [[100,0], [101,1]]
       * var numCoords = Coordinate.toNumberArrays([new Coordinate(100,0), new Coordinate(101,1)]);
       */
      Coordinate.toNumberArrays = function toNumberArrays(coordinates) {
        if (!Array.isArray(coordinates)) {
          return [coordinates.x, coordinates.y];
        }

        return forEachCoord(coordinates, function (coord) {
          return [coord.x, coord.y];
        });
      }
      /**
       * Convert one or more GeoJSON style coordiantes to Coordinate objects
       * @param  {Number[]|Number[][]} coordinates - coordinates to convert
       * @return {Coordinate|Coordinate[]}
       * @example
       * var coordinates = Coordinate.toCoordinates([[100,0], [101,1]]);
       */
      ;

      Coordinate.toCoordinates = function toCoordinates(coordinates) {
        if (isNumber(coordinates[0]) && isNumber(coordinates[1])) {
          return new Coordinate(coordinates);
        }

        var result = [];

        for (var i = 0, len = coordinates.length; i < len; i++) {
          var child = coordinates[i];

          if (Array.isArray(child)) {
            if (isNumber(child[0])) {
              result.push(new Coordinate(child));
            } else {
              result.push(Coordinate.toCoordinates(child));
            }
          } else {
            result.push(new Coordinate(child));
          }
        }

        return result;
      };

      return Coordinate;
    }(Position);

    /**
     * Represent CRS defined by [GeoJSON]{@link http://geojson.org/geojson-spec.html#coordinate-reference-system-objects}
     *
     * @category geo
     */
    var CRS =
    /*#__PURE__*/
    function () {
      /**
       * @param {String} type          - type of the CRS
       * @param {Object} properties    - CRS's properties
       */
      function CRS(type, properties) {
        this.type = type;
        this.properties = properties;
      }
      /**
       * Create a [proj4]{@link https://github.com/OSGeo/proj.4} style CRS used by maptalks <br>
       * @example
       * {
       *     "type"       : "proj4",
       *     "properties" : {
       *         "proj"   : "+proj=longlat +datum=WGS84 +no_defs"
       *     }
       * }
       * var crs_wgs84 = CRS.createProj4("+proj=longlat +datum=WGS84 +no_defs");
       * @param  {String} proj - a proj4 projection string.
       * @return {CRS}
       */


      CRS.createProj4 = function createProj4(proj) {
        return new CRS('proj4', {
          'proj': proj
        });
      };

      CRS.fromProjectionCode = function fromProjectionCode(code) {
        if (!code) {
          return null;
        }

        code = code.toUpperCase().replace(':', '');
        return CRS[code] || null;
      };

      return CRS;
    }(); // some common CRS definitions

    /**
     * Predefined CRS of well-known WGS84 (aka EPSG:4326)
     * @type {CRS}
     * @constant
     */


    CRS.WGS84 = CRS.createProj4('+proj=longlat +datum=WGS84 +no_defs');
    /**
     * Alias for CRS.WGS84
     * @type {CRS}
     * @constant
     */

    CRS.EPSG4326 = CRS.WGS84;
    /**
     * Projected Coordinate System used by google maps that has the following alias: 'EPSG:3785', 'GOOGLE', 'EPSG:900913'
     * @type {CRS}
     * @constant
     */

    CRS.EPSG3857 = CRS.createProj4('+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs');
    /**
     * A CRS represents a simple Cartesian coordinate system. <br>
     * Maps x, y directly, is useful for maps of flat surfaces (e.g. indoor maps, game maps).
     * @type {CRS}
     * @constant
     */

    CRS.IDENTITY = CRS.createProj4('+proj=identity +no_defs');
    /**
     * Official coordinate system in China (aka EPSG:4490), in most cases, it can be considered the same with WGS84.
     * @type {CRS}
     * @see  {@link http://spatialreference.org/ref/sr-org/7408/}
     * @constant
     */

    CRS.CGCS2000 = CRS.createProj4('+proj=longlat +datum=CGCS2000');
    /**
     * Alias for CRS.CGCS2000
     * @type {CRS}
     * @constant
     */

    CRS.EPSG4490 = CRS.CGCS2000;
    /**
     * Projection used by [Baidu Map]{@link http://map.baidu.com}, a popular web map service in China.
     * @type {CRS}
     * @constant
     */

    CRS.BD09LL = CRS.createProj4('+proj=longlat +datum=BD09');
    /**
     * A encrypted CRS usded in the most online map services in China..
     * @type {CRS}
     * @see {@link https://en.wikipedia.org/wiki/Restrictions_on_geographic_data_in_China}
     * @constant
     */

    CRS.GCJ02 = CRS.createProj4('+proj=longlat +datum=GCJ02');

    var TEMP_POINT0 = new Point(0, 0);
    var TEMP_COORD0 = new Coordinate(0, 0);
    var TEMP_COORD1 = new Coordinate(0, 0);
    var TEMP_COORD2 = new Coordinate(0, 0);
    var TEMP_COORD3 = new Coordinate(0, 0);
    var TEMP_COORD4 = new Coordinate(0, 0);
    var TEMP_COORD5 = new Coordinate(0, 0);
    var TEMP_COORD6 = new Coordinate(0, 0);
    var TEMP_COORD7 = new Coordinate(0, 0);
    var MINMAX = [];
    /* eslint-disable prefer-const */

    var TEMP_EXTENT;
    /* eslint-enable prefer-const */

    var TEMP_COMBINE = [];
    /**
     * Represent a bounding box on the map, a rectangular geographical area with minimum and maximum coordinates. <br>
     * There are serveral ways to create a extent:
     * @category basic types
     * @example
     * //with 4 numbers: xmin, ymin, xmax and ymax
     * var extent = new Extent(100, 10, 120, 20);
     * @example
     * //with 2 coordinates
     * var extent = new Extent(new Coordinate(100, 10), new Coordinate(120, 20));
     * @example
     * //with a json object containing xmin, ymin, xmax and ymax
     * var extent = new Extent({xmin : 100, ymin: 10, xmax: 120, ymax:20});
     * @example
     * var extent1 = new Extent(100, 10, 120, 20);
     * //with another extent
     * var extent2 = new Extent(extent1);
     */

    var Extent =
    /*#__PURE__*/
    function () {
      /**
       * @param {Number} x1   - x of coordinate 1
       * @param {Number} y1   - y of coordinate 1
       * @param {Number} x2   - x of coordinate 2
       * @param {Number} y2   - y of coordinate 2
       */
      function Extent(p1, p2, p3, p4) {
        this._clazz = Coordinate;
        var l = arguments.length;
        var proj = l > 0 ? arguments[l - 1] : null;

        if (proj && proj.unproject) {
          this.projection = arguments[l - 1];
        }

        this._dirty = true;

        this._initialize(p1, p2, p3, p4);
      }

      var _proto = Extent.prototype;

      _proto._initialize = function _initialize(p1, p2, p3, p4) {
        /**
         * @property {Number} xmin - minimum x
         */
        this.xmin = null;
        /**
         * @property {Number} xmax - maximum x
         */

        this.xmax = null;
        /**
         * @property {Number} ymin - minimum y
         */

        this.ymin = null;
        /**
         * @property {Number} ymax - maximum y
         */

        this.ymax = null;

        if (isNil(p1)) {
          return;
        }

        var projection = this.projection; //Constructor 1: all numbers

        if (isNumber(p1) && isNumber(p2) && isNumber(p3) && isNumber(p4)) {
          if (projection) {
            this.set(p1, p2, p3, p4);
          } else {
            this.set(Math.min(p1, p3), Math.min(p2, p4), Math.max(p1, p3), Math.max(p2, p4));
          }

          return;
        } else if (Array.isArray(p1)) {
          if (projection) {
            this.set(p1[0], p1[1], p1[2], p1[3]);
          } else {
            this.set(Math.min(p1[0], p1[2]), Math.min(p1[1], p1[3]), Math.max(p1[0], p1[2]), Math.max(p1[1], p1[3]));
          }
        } else if (isNumber(p1.x) && isNumber(p2.x) && isNumber(p1.y) && isNumber(p2.y)) {
          //Constructor 2: two coordinates
          if (projection) {
            this.set(p1.x, p1.y, p2.x, p2.y);
          } else {
            if (p1.x > p2.x) {
              this['xmin'] = p2.x;
              this['xmax'] = p1.x;
            } else {
              this['xmin'] = p1.x;
              this['xmax'] = p2.x;
            }

            if (p1.y > p2.y) {
              this['ymin'] = p2.y;
              this['ymax'] = p1.y;
            } else {
              this['ymin'] = p1.y;
              this['ymax'] = p2.y;
            }
          } //constructor 3: another extent or a object containing xmin, ymin, xmax and ymax

        } else if (isNumber(p1['xmin']) && isNumber(p1['xmax']) && isNumber(p1['ymin']) && isNumber(p1['ymax'])) {
          this.set(p1['xmin'], p1['ymin'], p1['xmax'], p1['ymax']);
        }
      };

      _proto._add = function _add(p) {
        this._dirty = true;

        if (!isNil(p.x)) {
          this['xmin'] += p.x;
          this['ymin'] += p.y;
          this['xmax'] += p.x;
          this['ymax'] += p.y;
        } else if (!isNil(p.xmin)) {
          this['xmin'] += p.xmin;
          this['ymin'] += p.ymin;
          this['xmax'] += p.xmax;
          this['ymax'] += p.ymax;
        } else if (!isNil(p[0])) {
          this['xmin'] += p[0];
          this['ymin'] += p[1];
          this['xmax'] += p[0];
          this['ymax'] += p[1];
        }

        return this;
      }
      /**
       * Add the extent with a coordinate or a point.
       * @param {Coordinate|Point} p - point or coordinate to add
       * @returns {Extent} a new extent
       */
      ;

      _proto.add = function add() {
        var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
        return e._add.apply(e, arguments);
      };

      _proto._scale = function _scale(s) {
        this._dirty = true;
        this['xmin'] *= s;
        this['ymin'] *= s;
        this['xmax'] *= s;
        this['ymax'] *= s;
        return this;
      };

      _proto._sub = function _sub(p) {
        this._dirty = true;

        if (!isNil(p.x)) {
          this['xmin'] -= p.x;
          this['ymin'] -= p.y;
          this['xmax'] -= p.x;
          this['ymax'] -= p.y;
        } else if (!isNil(p.xmin)) {
          this['xmin'] -= p.xmin;
          this['ymin'] -= p.ymin;
          this['xmax'] -= p.xmax;
          this['ymax'] -= p.ymax;
        } else if (!isNil(p[0])) {
          this['xmin'] -= p[0];
          this['ymin'] -= p[1];
          this['xmax'] -= p[0];
          this['ymax'] -= p[1];
        }

        return this;
      };

      _proto._substract = function _substract() {
        return this._sub.apply(this, arguments);
      }
      /**
       * Substract the extent with a coordinate or a point.
       * @param {Coordinate|Point} p - point or coordinate to substract
       * @returns {Extent} a new extent
       */
      ;

      _proto.sub = function sub() {
        var e = new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
        return e._sub.apply(e, arguments);
      }
      /**
       * Alias for sub
       * @param {Coordinate|Point} p - point or coordinate to substract
       * @returns {Extent} a new extent
       */
      ;

      _proto.substract = function substract() {
        return this.sub.apply(this, arguments);
      }
      /**
       * Round the extent
       * @return {Extent} rounded extent
       */
      ;

      _proto.round = function round() {
        return new this.constructor(Math.round(this['xmin']), Math.round(this['ymin']), Math.round(this['xmax']), Math.round(this['ymax']), this.projection);
      };

      _proto._round = function _round() {
        this._dirty = true;
        this['xmin'] = Math.round(this['xmin']);
        this['ymin'] = Math.round(this['ymin']);
        this['xmax'] = Math.round(this['xmax']);
        this['ymax'] = Math.round(this['ymax']);
        return this;
      }
      /**
       * Get the minimum point
       * @params {Coorindate} [out=undefined] - optional point to receive result
       * @return {Coordinate}
       */
      ;

      _proto.getMin = function getMin(out) {
        if (out) {
          out.set(this['xmin'], this['ymin']);
          return out;
        }

        return new this._clazz(this['xmin'], this['ymin']);
      }
      /**
       * Get the maximum point
       * @params {Coorindate} [out=undefined] - optional point to receive result
       * @return {Coordinate}
       */
      ;

      _proto.getMax = function getMax(out) {
        if (out) {
          out.set(this['xmax'], this['ymax']);
          return out;
        }

        return new this._clazz(this['xmax'], this['ymax']);
      }
      /**
       * Get center of the extent.
       * @params {Coorindate} [out=undefined] - optional point to receive result
       * @return {Coordinate}
       */
      ;

      _proto.getCenter = function getCenter(out) {
        var x = (this['xmin'] + this['xmax']) / 2;
        var y = (this['ymin'] + this['ymax']) / 2;

        if (out) {
          out.set(x, y);
          return out;
        }

        return new this._clazz(x, y);
      }
      /**
       * Whether the extent is valid
       * @protected
       * @return {Boolean}
       */
      ;

      _proto.isValid = function isValid() {
        return !isNil(this['xmin']) && !isNil(this['ymin']) && !isNil(this['xmax']) && !isNil(this['ymax']);
      }
      /**
       * Compare with another extent to see whether they are equal.
       * @param  {Extent}  ext2 - extent to compare
       * @return {Boolean}
       */
      ;

      _proto.equals = function equals(ext2) {
        return this['xmin'] === ext2['xmin'] && this['xmax'] === ext2['xmax'] && this['ymin'] === ext2['ymin'] && this['ymax'] === ext2['ymax'];
      }
      /**
       * Whether it intersects with another extent
       * @param  {Extent}  ext2 - another extent
       * @return {Boolean}
       */
      ;

      _proto.intersects = function intersects(ext2) {
        this._project(this);

        this._project(ext2);

        var rxmin = Math.max(this['pxmin'], ext2['pxmin']);
        var rymin = Math.max(this['pymin'], ext2['pymin']);
        var rxmax = Math.min(this['pxmax'], ext2['pxmax']);
        var rymax = Math.min(this['pymax'], ext2['pymax']);
        var intersects = !(rxmin > rxmax || rymin > rymax);
        return intersects;
      }
      /**
       * Whether the extent is within another extent
       * @param  {Extent}  ext2 - another extent
       * @returns {Boolean}
       */
      ;

      _proto.within = function within(extent) {
        this._project(this);

        this._project(extent);

        return this.pxmin >= extent.pxmin && this.pxmax <= extent.pxmax && this.pymin >= extent.pymin && this.pymax <= extent.pymax;
      }
      /**
       * Whether the extent contains the input point.
       * @param  {Coordinate|Number[]} coordinate - input point
       * @returns {Boolean}
       */
      ;

      _proto.contains = function contains(c) {
        if (!c) {
          return false;
        }

        this._project(this);

        var proj = this.projection;

        if (proj) {
          if (c.x !== undefined) {
            var coord = TEMP_COORD0;

            if (Array.isArray(c)) {
              coord.x = c[0];
              coord.y = c[1];
            } else {
              coord.x = c.x;
              coord.y = c.y;
            }

            c = proj.project(coord, coord);
          } else if (c.xmin !== undefined) {
            this._project(c);
          }
        }

        return (c.x || c.pxmin || 0) >= this.pxmin && (c.x || c.pxmax || 0) <= this.pxmax && (c.y || c.pymin || 0) >= this.pymin && (c.y || c.pymax || 0) <= this.pymax;
      }
      /**
       * Get the width of the Extent
       * @return {Number}
       */
      ;

      _proto.getWidth = function getWidth() {
        return Math.abs(this['xmax'] - this['xmin']);
      }
      /**
       * Get the height of the Extent
       * @return {Number}
       */
      ;

      _proto.getHeight = function getHeight() {
        return Math.abs(this['ymax'] - this['ymin']);
      }
      /**
       * Get size of the Extent
       * @return {Size}
       */
      ;

      _proto.getSize = function getSize() {
        return new Size(this.getWidth(), this.getHeight());
      };

      _proto.set = function set(xmin, ymin, xmax, ymax) {
        this.xmin = xmin;
        this.ymin = ymin;
        this.xmax = xmax;
        this.ymax = ymax;
        this._dirty = true;
        return this;
      };

      _proto.__combine = function __combine(extent) {
        if (extent.x !== undefined) {
          TEMP_EXTENT.xmin = TEMP_EXTENT.xmax = extent.x;
          TEMP_EXTENT.ymin = TEMP_EXTENT.ymax = extent.y;
          extent = TEMP_EXTENT;
        }

        this._project(extent);

        this._project(this);

        var inited = isNumber(this.pxmin);
        var xmin, ymin, xmax, ymax;

        if (!inited) {
          xmin = extent['pxmin'];
          ymin = extent['pymin'];
          xmax = extent['pxmax'];
          ymax = extent['pymax'];
        } else {
          xmin = Math.min(this['pxmin'], extent['pxmin']);
          ymin = Math.min(this['pymin'], extent['pymin']);
          xmax = Math.max(this['pxmax'], extent['pxmax']);
          ymax = Math.max(this['pymax'], extent['pymax']);
        }

        var proj = this.projection;

        if (proj) {
          TEMP_COORD1.set(xmin, ymin);
          TEMP_COORD2.set(xmax, ymax);
          var min = proj.unproject(TEMP_COORD1, TEMP_COORD1),
              max = proj.unproject(TEMP_COORD2, TEMP_COORD2);
          xmin = min.x;
          ymin = min.y;
          xmax = max.x;
          ymax = max.y;
        }

        TEMP_COMBINE[0] = xmin;
        TEMP_COMBINE[1] = ymin;
        TEMP_COMBINE[2] = xmax;
        TEMP_COMBINE[3] = ymax;
        return TEMP_COMBINE;
      };

      _proto._combine = function _combine(extent) {
        if (!extent || extent.isValid && !extent.isValid()) {
          return this;
        }

        var ext = this.__combine(extent);

        this.set(ext[0], ext[1], ext[2], ext[3]);
        this._dirty = true;
        return this;
      }
      /**
       * Combine it with another extent to a larger extent.
       * @param  {Extent|Coordinate|Point} extent - extent/coordinate/point to combine into
       * @returns {Extent} extent combined
       */
      ;

      _proto.combine = function combine(extent) {
        if (!extent || extent.isValid && !extent.isValid()) {
          return this;
        }

        var ext = this.__combine(extent);

        return new this.constructor(ext[0], ext[1], ext[2], ext[3], this.projection);
      }
      /**
       * Gets the intersection extent of this and another extent.
       * @param  {Extent} extent - another extent
       * @return {Extent} intersection extent
       */
      ;

      _proto.intersection = function intersection(extent) {
        if (!this.intersects(extent)) {
          return null;
        }

        TEMP_COORD3.x = Math.max(this['pxmin'], extent['pxmin']);
        TEMP_COORD3.y = Math.max(this['pymin'], extent['pymin']);
        TEMP_COORD4.x = Math.min(this['pxmax'], extent['pxmax']);
        TEMP_COORD4.y = Math.min(this['pymax'], extent['pymax']);
        var min = TEMP_COORD3,
            max = TEMP_COORD4;
        var proj = this.projection;

        if (proj) {
          min = proj.unproject(min, min);
          max = proj.unproject(max, max);
        }

        return new this.constructor(min, max, proj);
      }
      /**
       * Expand the extent by distance
       * @param  {Size|Number} distance  - distance to expand
       * @returns {Extent} a new extent expanded from
       */
      ;

      _proto.expand = function expand(distance) {
        var w, h;

        if (!isNumber(distance)) {
          w = distance['width'] || distance['x'] || distance[0] || 0;
          h = distance['height'] || distance['y'] || distance[1] || 0;
        } else {
          w = h = distance;
        }

        return new this.constructor(this['xmin'] - w, this['ymin'] - h, this['xmax'] + w, this['ymax'] + h, this.projection);
      };

      _proto._expand = function _expand(distance) {
        var w, h;

        if (!isNumber(distance)) {
          w = distance['width'] || distance['x'] || distance[0] || 0;
          h = distance['height'] || distance['y'] || distance[1] || 0;
        } else {
          w = h = distance;
        }

        this['xmin'] -= w;
        this['ymin'] -= h;
        this['xmax'] += w;
        this['ymax'] += h;
        this._dirty = true;
        return this;
      }
      /**
       * Get extent's JSON object.
       * @return {Object} jsonObject
       * @example
       * // {xmin : 100, ymin: 10, xmax: 120, ymax:20}
       * var json = extent.toJSON();
       */
      ;

      _proto.toJSON = function toJSON() {
        return {
          'xmin': this['xmin'],
          'ymin': this['ymin'],
          'xmax': this['xmax'],
          'ymax': this['ymax']
        };
      }
      /**
       * Get a coordinate array of extent's rectangle area, containing 5 coordinates in which the first equals with the last.
       * @return {Coordinate[]} coordinates array
       */
      ;

      _proto.toArray = function toArray() {
        var xmin = this['xmin'],
            ymin = this['ymin'],
            xmax = this['xmax'],
            ymax = this['ymax'];
        return [new this._clazz([xmin, ymax]), new this._clazz([xmax, ymax]), new this._clazz([xmax, ymin]), new this._clazz([xmin, ymin]), new this._clazz([xmin, ymax])];
      };

      _proto.toString = function toString() {
        return this.xmin + "," + this.ymin + "," + this.xmax + "," + this.ymax;
      }
      /**
       * Get a copy of the extent.
       * @return {Extent} copy
       */
      ;

      _proto.copy = function copy() {
        return new this.constructor(this['xmin'], this['ymin'], this['xmax'], this['ymax'], this.projection);
      }
      /**
       * Convert to a new extent
       * @param  {Function} fn convert function on each point
       * @return {Extent}
       */
      ;

      _proto.convertTo = function convertTo(fn, out) {
        if (!this.isValid()) {
          return null;
        }

        var e = out || new this.constructor();

        if (out) {
          e.set(null, null, null, null);
        }

        var coord;

        if (this._clazz === Coordinate) {
          coord = TEMP_COORD5;
        } else if (this._clazz === Point) {
          coord = TEMP_POINT0;
        }

        coord.x = this.xmin;
        coord.y = this.ymax;

        e._combine(fn(coord));

        coord.x = this.xmax;

        e._combine(fn(coord));

        coord.y = this.ymin;

        e._combine(fn(coord));

        coord.x = this.xmin;

        e._combine(fn(coord));

        return e;
      };

      _proto._project = function _project(ext) {
        if (!ext || !ext.isValid()) {
          if (ext) {
            ext.pxmin = ext.pxmax = ext.pymin = ext.pymax = null;
          }

          return;
        }

        var proj = this.projection;

        if (proj) {
          //FIXME a rare but potential bug:
          //An extent may be projected by multiple projection
          if (ext._dirty) {
            TEMP_COORD6.set(ext.xmax, ext.ymin);
            TEMP_COORD7.set(ext.xmin, ext.ymax);
            MINMAX[0] = TEMP_COORD6;
            MINMAX[1] = TEMP_COORD7;
            var minmax = proj.projectCoords(MINMAX);
            var min = minmax[0],
                max = minmax[1];
            ext.pxmin = Math.min(min.x, max.x);
            ext.pymin = Math.min(min.y, max.y);
            ext.pxmax = Math.max(min.x, max.x);
            ext.pymax = Math.max(min.y, max.y);
          }

          delete ext._dirty;
        } else {
          ext.pxmin = ext.xmin;
          ext.pxmax = ext.xmax;
          ext.pymin = ext.ymin;
          ext.pymax = ext.ymax;
        }
      };

      return Extent;
    }();

    TEMP_EXTENT = new Extent(0, 0, 0, 0);

    /**
     * Represent a bounding box on 2d surface , a rectangular area with minimum and maximum points. <br>
     * There are serveral ways to create a PointExtent:
     * @category basic types
     * @extends Extent
     * @example
     * //with 4 numbers
     * var extent = new PointExtent(100, 10, 120, 20);
     * @example
     * //with 2 points
     * var extent = new PointExtent(new Point(100, 10), new Point(120, 20));
     * @example
     * //with a json object containing xmin, ymin, xmax and ymax
     * var extent = new PointExtent({xmin : 100, ymin: 10, xmax: 120, ymax:20});
     * @example
     * var extent1 = new PointExtent(100, 10, 120, 20);
     * //with another extent
     * var extent2 = new PointExtent(extent1);
     */

    var PointExtent =
    /*#__PURE__*/
    function (_Extent) {
      _inheritsLoose(PointExtent, _Extent);

      /**
       * @param {Number} x1   - x of point 1
       * @param {Number} y1   - y of point 1
       * @param {Number} x2   - x of point 2
       * @param {Number} y2   - y of point 2
       */
      function PointExtent(p1, p2, p3, p4) {
        var _this;

        _this = _Extent.call(this, p1, p2, p3, p4) || this;
        _this._clazz = Point;
        return _this;
      }

      return PointExtent;
    }(Extent);

    /**
     * Transformation between projected coordinates and base 2d point system.
     * A core class used internally for mapping map's (usually geographical) coordinates to 2d points.<br>
     *
     * @category geo
     * @protected
     */

    var Transformation =
    /*#__PURE__*/
    function () {
      /**
       * The base 2d point system is a fixed system that is consistent with HTML coordinate system: on X-Axis, left is smaller and right is larger; on Y-Axis, top is smaller and bottom is larger. <br>
       * As map's coordinates may not be in the same order(e.g. on a mercator projected earth, top is larger and bottom is smaller), <br>
       * transformation provides mapping functions to map arbitrary coordinates system to the fixed 2d point system. <br>
       * How to transform is decided by the constructor parameters which is a 4 number array [a, b, c, d]:<br>
       * a : the order scale of X-axis values 1 means right is larger and -1 means the reverse, left is larger;<br>
       * b : the order scale of Y-axis values 1 means bottom is larger and -1 means the reverse, top is larger;<br>
       * c : x of the origin point of the projected coordinate system <br>
       * d : y of the origin point of the projected coordinate system <br>
       * e.g.: Transformation parameters for Google map: [1, -1, -20037508.34, 20037508.34] <br>
       * @param  {Number[]} matrix transformation array
       */
      function Transformation(matrix) {
        this.matrix = matrix;
      }
      /**
       * Transform a projected coordinate to a 2d point. <br>
       * Parameter scale in transform/untransform method is used to scale the result 2d points on map's different zoom levels.
       * @param  {Number[]|Coordinate} coordinates - projected coordinate to transform
       * @param  {Number} scale                              - transform scale
       * @return {Point} 2d point.
       */


      var _proto = Transformation.prototype;

      _proto.transform = function transform(coordinates, scale, out) {
        var x = this.matrix[0] * (coordinates.x - this.matrix[2]) / scale;
        var y = -this.matrix[1] * (coordinates.y - this.matrix[3]) / scale;

        if (out) {
          out.x = x;
          out.y = y;
          return out;
        }

        return new Point(x, y);
      }
      /**
       * Transform a 2d point to a projected coordinate.
       * @param  {Point} point   - 2d point
       * @param  {Number} scale           - transform scale
       * @return {Coordinate}  projected coordinate.
       */
      ;

      _proto.untransform = function untransform(point, scale, out) {
        var x = point.x * scale / this.matrix[0] + this.matrix[2];
        var y = point.y * scale / -this.matrix[1] + this.matrix[3];

        if (out) {
          out.x = x;
          out.y = y;
          return out;
        }

        return new Coordinate(x, y);
      };

      return Transformation;
    }();

    /**
     * Common Methods of Projections.
     * @mixin
     * @protected
     * @memberOf projection
     * @name Common
     */

    var Common = /** @lends projection.Common */
    {
      /**
       * Project a geographical coordinate to a projected coordinate (2d coordinate)
       * @param  {Coordinate} p - coordinate to project
       * @return {Coordinate}
       * @function projection.Common.project
       */
      project: function project() {},

      /**
       * Unproject a projected coordinate to a geographical coordinate (2d coordinate)
       * @param  {Coordinate} p - coordinate to project
       * @return {Coordinate}
       * @function projection.Common.unproject
       */
      unproject: function unproject() {},

      /**
       * Project a group of geographical coordinates to projected coordinates.
       * @param  {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates - coordinates to project
       * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]}
       * @function projection.Common.projectCoords
       */
      projectCoords: function projectCoords(coordinates) {
        var _this = this;

        if (!coordinates) {
          return [];
        }

        if (!Array.isArray(coordinates)) {
          return this.project(coordinates);
        }

        if (coordinates.length === 0) {
          return [];
        }

        if (!this.isSphere()) {
          return forEachCoord(coordinates, this.project, this);
        }

        if (Array.isArray(coordinates[0])) {
          return coordinates.map(function (coords) {
            return _this.projectCoords(coords);
          });
        } else {
          var circum = this.getCircum();
          var extent = this.getSphereExtent(),
              sx = extent.sx,
              sy = extent.sy;
          var wrapX, wrapY;
          var pre = coordinates[0],
              current,
              dx,
              dy,
              p;
          var prj = [this.project(pre)];

          for (var i = 1, l = coordinates.length; i < l; i++) {
            current = coordinates[i];
            dx = current.x - pre.x;
            dy = current.y - pre.y;
            p = this.project(current);

            if (Math.abs(dx) > 180) {
              if (wrapX === undefined) {
                wrapX = current.x > pre.x;
              }

              if (wrapX) {
                p._add(-circum.x * sign(dx) * sx, 0);

                current._add(-360 * sign(dx), 0);
              }
            }

            if (Math.abs(dy) > 90) {
              if (wrapY === undefined) {
                wrapY = current.y < pre.y;
              }

              if (wrapY) {
                p._add(0, -circum.y * sign(dy) * sy);

                current._add(0, -180 * sign(dy));
              }
            }

            pre = current;
            prj.push(p);
          }

          return prj;
        }
      },

      /**
       * Unproject a group of projected coordinates to geographical coordinates.
       * @param  {Coordinate[]|Coordinate[][]|Coordinate[][][]} projCoords - projected coordinates to unproject
       * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]}
       * @function projection.Common.unprojectCoords
       */
      unprojectCoords: function unprojectCoords(projCoords) {
        if (!projCoords) {
          return [];
        }

        if (!Array.isArray(projCoords)) {
          return this.unproject(projCoords);
        }

        return forEachCoord(projCoords, this.unproject, this);
      },

      /**
       * Whether the projection is spherical
       * @return {Boolean}
       */
      isSphere: function isSphere() {
        return !!this.sphere;
      },

      /**
       * If the projected coord out of the sphere
       * @param  {Coordinate}  pcoord projected coord
       * @return {Boolean}
       */
      isOutSphere: function isOutSphere(pcoord) {
        if (!this.isSphere()) {
          return false;
        }

        var extent = this.getSphereExtent();
        return !extent.contains(pcoord);
      },

      /**
       * Wrap the projected coord in the sphere
       * @param  {Coordinate} pcoord projected coord
       * @return {Coordinate} wrapped projected coord
       */
      wrapCoord: function wrapCoord(pcoord) {
        if (!this.isSphere()) {
          return pcoord;
        }

        var extent = this.getSphereExtent();
        var wrapped = new Coordinate(pcoord);

        if (!extent.contains(wrapped)) {
          wrapped.x = wrap(pcoord.x, extent.xmin, extent.xmax);
          wrapped.y = wrap(pcoord.y, extent.ymin, extent.ymax);
        }

        return wrapped;
      },
      getCircum: function getCircum() {
        if (!this.circum && this.isSphere()) {
          var extent = this.getSphereExtent();
          this.circum = {
            x: extent.getWidth(),
            y: extent.getHeight()
          };
        }

        return this.circum;
      },
      getSphereExtent: function getSphereExtent() {
        if (!this.extent && this.isSphere()) {
          var max = this.project(new Coordinate(180, 90)),
              min = this.project(new Coordinate(-180, -90));
          this.extent = new Extent(min, max, this);
          this.extent.sx = max.x > min.x ? 1 : -1;
          this.extent.sy = max.y > min.y ? 1 : -1;
        }

        return this.extent;
      }
    };

    /**
     * This provides methods used for event handling. It's a mixin and not meant to be used directly.
     * @mixin Common
     * @memberOf measurer
     * @protected
     */
    var Common$1 = {
      /**
       * Measure length between coordinate c1 and coordinate c2
       * @param  {coordinate} c1 coordinate
       * @param  {coordinate} c2 coordinate
       * @return {Number}    length
       * @function measurer.Common.measureLength
       */
      measureLength: function measureLength(c1, c2) {
        if (!Array.isArray(c1)) {
          return this.measureLenBetween(c1, c2);
        }

        var len = 0;

        for (var i = 0, l = c1.length; i < l - 1; i++) {
          len += this.measureLenBetween(c1[i], c1[i + 1]);
        }

        return len;
      }
    };

    /**
     * Identity measurer, a measurer for Cartesian coordinate system.
     *
     * @class
     * @category geo
     * @protected
     * @memberOf measurer
     * @name Identity
     * @mixes measurer.Common
     */

    var Identity = extend(
    /** @lends measurer.Identity */
    {
      /**
       * the code of the measurer
       * @static
       * @type {String}
       */
      'measure': 'IDENTITY',

      /**
       * Measure the length between 2 coordinates.
       * @param  {Coordinate} c1
       * @param  {Coordinate} c2
       * @return {Number}
       */
      measureLenBetween: function measureLenBetween(c1, c2) {
        if (!c1 || !c2) {
          return 0;
        }

        try {
          return Math.sqrt(Math.pow(c1.x - c2.x, 2) + Math.pow(c1.y - c2.y, 2));
        } catch (err) {
          return 0;
        }
      },

      /**
       * Measure the area closed by the given coordinates.
       * @param  {Coordinate[]} coordinates
       * @return {number}
       */
      measureArea: function measureArea(coordinates) {
        if (!Array.isArray(coordinates)) {
          return 0;
        }

        var area = 0;

        for (var i = 0, len = coordinates.length; i < len; i++) {
          var c1 = coordinates[i];
          var c2 = null;

          if (i === len - 1) {
            c2 = coordinates[0];
          } else {
            c2 = coordinates[i + 1];
          }

          area += c1.x * c2.y - c1.y * c2.x;
        }

        return Math.abs(area / 2);
      },
      locate: function locate(c, xDist, yDist) {
        c = new Coordinate(c.x, c.y);
        return this._locate(c, xDist, yDist);
      },

      /**
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param  {Coordinate} c     - source coordinate
       * @param  {Number} xDist     - x-axis distance
       * @param  {Number} yDist     - y-axis distance
       * @return {Coordinate}
       */
      _locate: function _locate(c, xDist, yDist) {
        if (!c) {
          return null;
        }

        if (!xDist) {
          xDist = 0;
        }

        if (!yDist) {
          yDist = 0;
        }

        if (!xDist && !yDist) {
          return c;
        }

        c.x = c.x + xDist;
        c.y = c.y + yDist;
        return c;
      },
      rotate: function rotate(c, pivot, angle) {
        c = new Coordinate(c.x, c.y);
        return this._rotate(c, pivot, angle);
      },

      /**
       * Rotate a coordinate of given angle around pivot
       * @param {Coordinate} c  - source coordinate
       * @param {Coordinate} pivot - pivot
       * @param {Number} angle - angle in degree
       * @return {Coordinate}
       */
      _rotate: function () {
        var tmp = new Point(0, 0);
        return function (c, pivot, angle) {
          tmp.x = c.x - pivot.x;
          tmp.y = c.y - pivot.y;

          tmp._rotate(angle * Math.PI / 180);

          c.x = pivot.x + tmp.x;
          c.y = pivot.y + tmp.y;
          return c;
        };
      }()
    }, Common$1);

    /**
     * A helper class with common measure methods for Sphere.
     * @memberOf measurer
     * @private
     */

    var Sphere =
    /*#__PURE__*/
    function () {
      /**
       * @param  {Number} radius Sphere's radius
       */
      function Sphere(radius) {
        this.radius = radius;
      }

      var _proto = Sphere.prototype;

      _proto.measureLenBetween = function measureLenBetween(c1, c2) {
        if (!c1 || !c2) {
          return 0;
        }

        var b = toRadian(c1.y);
        var d = toRadian(c2.y),
            e = b - d,
            f = toRadian(c1.x) - toRadian(c2.x);
        b = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(e / 2), 2) + Math.cos(b) * Math.cos(d) * Math.pow(Math.sin(f / 2), 2)));
        b *= this.radius;
        return Math.round(b * 1E5) / 1E5;
      };

      _proto.measureArea = function measureArea(coordinates) {
        var a = toRadian(this.radius);
        var b = 0,
            c = coordinates,
            d = c.length;

        if (d < 3) {
          return 0;
        }

        var i;

        for (i = 0; i < d - 1; i++) {
          var e = c[i],
              f = c[i + 1];
          b += e.x * a * Math.cos(toRadian(e.y)) * f.y * a - f.x * a * Math.cos(toRadian(f.y)) * e.y * a;
        }

        d = c[i];
        c = c[0];
        b += d.x * a * Math.cos(toRadian(d.y)) * c.y * a - c.x * a * Math.cos(toRadian(c.y)) * d.y * a;
        return 0.5 * Math.abs(b);
      };

      _proto.locate = function locate(c, xDist, yDist) {
        c = new Coordinate(c.x, c.y);
        return this._locate(c, xDist, yDist);
      };

      _proto._locate = function _locate(c, xDist, yDist) {
        if (!c) {
          return null;
        }

        if (!xDist) {
          xDist = 0;
        }

        if (!yDist) {
          yDist = 0;
        }

        if (!xDist && !yDist) {
          return c;
        }

        var x, y;
        var ry = toRadian(c.y);

        if (yDist !== 0) {
          var dy = Math.abs(yDist);
          var sy = Math.sin(dy / (2 * this.radius)) * 2;
          ry = ry + sy * (yDist > 0 ? 1 : -1);
          y = wrap(ry * 180 / Math.PI, -90, 90);
        } else {
          y = c.y;
        }

        if (xDist !== 0) {
          // distance per degree
          var dx = Math.abs(xDist);
          var rx = toRadian(c.x);
          var sx = 2 * Math.sqrt(Math.pow(Math.sin(dx / (2 * this.radius)), 2) / Math.pow(Math.cos(ry), 2));
          rx = rx + sx * (xDist > 0 ? 1 : -1);
          x = wrap(rx * 180 / Math.PI, -180, 180);
        } else {
          x = c.x;
        }

        c.x = x;
        c.y = y;
        return c;
      };

      _proto.rotate = function rotate(c, pivot, angle) {
        c = new Coordinate(c);
        return this._rotate(c, pivot, angle);
      }
      /**
       * Rotate a coordinate of given angle around pivot
       * @param {Coordinate} c  - source coordinate
       * @param {Coordinate} pivot - pivot
       * @param {Number} angle - angle in degree
       * @return {Coordinate}
       */
      ;

      _proto._rotate = function _rotate(c, pivot, angle) {
        var initialAngle = rhumbBearing(pivot, c);
        var finalAngle = initialAngle - angle;
        var distance = this.measureLenBetween(pivot, c);
        c.x = pivot.x;
        c.y = pivot.y;
        return calculateRhumbDestination(c, distance, finalAngle, this.radius);
      };

      return Sphere;
    }(); // from turf.js


    function rhumbBearing(start, end, options) {
      if (options === void 0) {
        options = {};
      }

      var bear360;
      if (options.final) bear360 = calculateRhumbBearing(end, start);else bear360 = calculateRhumbBearing(start, end);
      var bear180 = bear360 > 180 ? -(360 - bear360) : bear360;
      return bear180;
    }

    function calculateRhumbBearing(from, to) {
      // φ => phi
      // Δλ => deltaLambda
      // Δψ => deltaPsi
      // θ => theta
      var phi1 = toRadian(from.y);
      var phi2 = toRadian(to.y);
      var deltaLambda = toRadian(to.x - from.x); // if deltaLambdaon over 180° take shorter rhumb line across the anti-meridian:

      if (deltaLambda > Math.PI) deltaLambda -= 2 * Math.PI;
      if (deltaLambda < -Math.PI) deltaLambda += 2 * Math.PI;
      var deltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var theta = Math.atan2(deltaLambda, deltaPsi);
      return (toDegree(theta) + 360) % 360;
    }

    function calculateRhumbDestination(origin, distance, bearing, radius) {
      // φ => phi
      // λ => lambda
      // ψ => psi
      // Δ => Delta
      // δ => delta
      // θ => theta
      var delta = distance / radius; // angular distance in radians

      var lambda1 = origin.x * Math.PI / 180; // to radians, but without normalize to 𝜋

      var phi1 = toRadian(origin.y);
      var theta = toRadian(bearing);
      var DeltaPhi = delta * Math.cos(theta);
      var phi2 = phi1 + DeltaPhi; // check for some daft bugger going past the pole, normalise latitude if so

      if (Math.abs(phi2) > Math.PI / 2) phi2 = phi2 > 0 ? Math.PI - phi2 : -Math.PI - phi2;
      var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));
      var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1); // E-W course becomes ill-conditioned with 0/0

      var DeltaLambda = delta * Math.sin(theta) / q;
      var lambda2 = lambda1 + DeltaLambda;
      origin.x = (lambda2 * 180 / Math.PI + 540) % 360 - 180;
      origin.y = phi2 * 180 / Math.PI;
      return origin; // normalise to −180..+180°
    }
    /**
     * WGS84 Sphere measurer.
     * @class
     * @category geo
     * @protected
     * @memberOf measurer
     * @name WGS84Sphere
     * @mixes measurer.Common
     */


    var WGS84Sphere = extend(
    /** @lends measurer.WGS84Sphere */
    {
      'measure': 'EPSG:4326',
      sphere: new Sphere(6378137),

      /**
       * Measure the length between 2 coordinates.
       * @param  {Coordinate} c1
       * @param  {Coordinate} c2
       * @return {Number}
       */
      measureLenBetween: function measureLenBetween() {
        return this.sphere.measureLenBetween.apply(this.sphere, arguments);
      },

      /**
       * Measure the area closed by the given coordinates.
       * @param  {Coordinate[]} coordinates
       * @return {number}
       */
      measureArea: function measureArea() {
        return this.sphere.measureArea.apply(this.sphere, arguments);
      },
      _locate: function _locate() {
        return this.sphere._locate.apply(this.sphere, arguments);
      },

      /**
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param  {Coordinate} c     - source coordinate
       * @param  {Number} xDist              - x-axis distance
       * @param  {Number} yDist              - y-axis distance
       * @return {Coordinate}
       */
      locate: function locate() {
        return this.sphere.locate.apply(this.sphere, arguments);
      },
      _rotate: function _rotate() {
        return this.sphere._rotate.apply(this.sphere, arguments);
      },

      /**
       * Rotate a coordinate of given angle around pivot
       * @param {Coordinate} c  - source coordinate
       * @param {Coordinate} pivot - pivot
       * @param {Number} angle - angle in degree
       * @return {Coordinate}
       */
      rotate: function rotate() {
        return this.sphere.rotate.apply(this.sphere, arguments);
      }
    }, Common$1);
    /**
     * Baidu sphere measurer
     * @class
     * @category geo
     * @protected
     * @memberOf measurer
     * @name BaiduSphere
     * @mixes measurer.Common
     */

    var BaiduSphere = extend(
    /** @lends measurer.BaiduSphere */
    {
      'measure': 'BAIDU',
      sphere: new Sphere(6370996.81),

      /**
       * Measure the length between 2 coordinates.
       * @param  {Coordinate} c1
       * @param  {Coordinate} c2
       * @return {Number}
       */
      measureLenBetween: function measureLenBetween() {
        return this.sphere.measureLenBetween.apply(this.sphere, arguments);
      },

      /**
       * Measure the area closed by the given coordinates.
       * @param  {Coordinate[]} coordinates
       * @return {number}
       */
      measureArea: function measureArea() {
        return this.sphere.measureArea.apply(this.sphere, arguments);
      },
      _locate: function _locate() {
        return this.sphere._locate.apply(this.sphere, arguments);
      },

      /**
       * Locate a coordinate from the given source coordinate with a x-axis distance and a y-axis distance.
       * @param  {Coordinate} c     - source coordinate
       * @param  {Number} xDist              - x-axis distance
       * @param  {Number} yDist              - y-axis distance
       * @return {Coordinate}
       */
      locate: function locate() {
        return this.sphere.locate.apply(this.sphere, arguments);
      },
      _rotate: function _rotate() {
        return this.sphere._rotate.apply(this.sphere, arguments);
      },

      /**
       * Rotate a coordinate of given angle around pivot
       * @param {Coordinate} c  - source coordinate
       * @param {Coordinate} pivot - pivot
       * @param {Number} angle - angle in degree
       * @return {Coordinate}
       */
      rotate: function rotate() {
        return this.sphere.rotate.apply(this.sphere, arguments);
      }
    }, Common$1);

    /** @namespace measurer */
    /**
     * Default measurer, [WGS84Sphere]{@link measurer.WGS84Sphere}
     *
     * @class
     * @category geo
     * @protected
     * @memberOf measurer
     * @name DEFAULT
     * @extends measurer.WGS84Sphere
     */

    var DEFAULT = WGS84Sphere;
    var measurers = {};

    function registerMeasurer(m) {
      measurers[m.measure] = m;
    }

    registerMeasurer(Identity);
    registerMeasurer(WGS84Sphere);
    registerMeasurer(BaiduSphere);
    /**
     * @classdesc
     * Utilities with measurers. It is static and should not be initiated.<br>
     * Measurer provides methods for geographical computations such as length and area measuring, etc.
     * @class
     * @name Measurer
     * @memberOf measurer
     * @category geo
     */

    var Measurer = {
      /**
       * Get a measurer instance.
       * @param  {String} name - code of the measurer: 'EPSG:4326', 'Identity', 'BAIDU'
       * @return {Object} a measurer object
       * @function measurer.Measurer.getInstance
       */
      getInstance: function getInstance(name) {
        if (!name) {
          return DEFAULT;
        }

        for (var p in measurers) {
          if (hasOwn(measurers, p)) {
            var mName = measurers[p]['measure'];

            if (!mName) {
              continue;
            }

            if (name.toLowerCase() === mName.toLowerCase()) {
              return measurers[p];
            }
          }
        }

        return null;
      }
    };

    var index$2 = /*#__PURE__*/Object.freeze({
        Identity: Identity,
        DEFAULT: DEFAULT,
        Measurer: Measurer,
        WGS84Sphere: WGS84Sphere,
        BaiduSphere: BaiduSphere
    });

    var delta = 1E-7;
    /**
     * Well-known projection used by Google maps or Open Street Maps, aka Mercator Projection.<br>
     * It is map's default projection.
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name EPSG3857
     * @mixes projection.Common
     * @mixes measurer.WGS84Sphere
     */

    var EPSG3857 = extend({}, Common,
    /** @lends projection.EPSG3857 */
    {
      /**
       * "EPSG:3857", Code of the projection
       * @type {String}
       * @constant
       */
      code: 'EPSG:3857',
      rad: Math.PI / 180,
      metersPerDegree: 6378137 * Math.PI / 180,
      maxLatitude: 85.0511287798,
      project: function project(lnglat, out) {
        var rad = this.rad,
            metersPerDegree = this.metersPerDegree,
            max = this.maxLatitude;
        var lng = lnglat.x,
            lat = Math.max(Math.min(max, lnglat.y), -max);
        var c;

        if (lat === 0) {
          c = 0;
        } else {
          c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;
        }

        var x = lng * metersPerDegree;
        var y = c * metersPerDegree;

        if (out) {
          out.x = x;
          out.y = y;
          return out;
        }

        return new Coordinate(x, y);
      },
      unproject: function unproject(pLnglat, out) {
        var rad = this.rad;
        var metersPerDegree = this.metersPerDegree;
        var x = pLnglat.x / metersPerDegree;
        var y = pLnglat.y;
        var c;

        if (y === 0) {
          c = 0;
        } else {
          c = y / metersPerDegree;
          c = (2 * Math.atan(Math.exp(c * rad)) - Math.PI / 2) / rad;
        }

        if (Math.abs(Math.abs(x) - 180) < delta) {
          x = sign(x) * 180;
        }

        if (Math.abs(Math.abs(c) - this.maxLatitude) < delta) {
          c = sign(c) * this.maxLatitude;
        }

        var rx = wrap(x, -180, 180);
        var ry = wrap(c, -this.maxLatitude, this.maxLatitude);

        if (out) {
          out.x = rx;
          out.y = ry;
          return out;
        }

        return new Coordinate(rx, ry);
      }
    }, WGS84Sphere);

    /**
     * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
     *
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name EPSG4326
     * @mixes projection.Common
     * @mixes measurer.WGS84Sphere
     */

    var PROJ4326 = extend({}, Common,
    /** @lends projection.EPSG4326 */
    {
      /**
       * "EPSG:4326", Code of the projection
       * @type {String}
       * @constant
       */
      code: 'EPSG:4326',
      project: function project(p, out) {
        if (out) {
          out.x = p.x;
          out.y = p.y;
          return out;
        }

        return new Coordinate(p);
      },
      unproject: function unproject(p, out) {
        if (out) {
          out.x = p.x;
          out.y = p.y;
          return out;
        }

        return new Coordinate(p);
      }
    }, WGS84Sphere);

    /**
     * For CGCS2000
     *
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name EPSG4490
     * @mixes projection.EPSG4326
     * @mixes measurer.WGS84Sphere
     */

    var Projection_EPSG4490 = extend({}, PROJ4326,
    /** @lends projection.EPSG4490 */
    {
      /**
       * "EPSG:4490", Code of the projection
       * @type {String}
       * @constant
       */
      code: 'EPSG:4490'
    });

    /**
     * Projection used by [Baidu Map]{@link http://map.baidu.com}
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name BAIDU
     * @mixes projection.Common
     * @mixes measurer.BaiduSphere
     */

    var Projection_Baidu = extend({}, Common,
    /** @lends projection.BAIDU */
    {
      /**
       * "BAIDU", Code of the projection
       * @type {String}
       * @constant
       */
      code: 'BAIDU',
      project: function project(p, out) {
        return this.convertLL2MC(p, out);
      },
      unproject: function unproject(p, out) {
        return this.convertMC2LL(p, out);
      }
    }, BaiduSphere, {
      EARTHRADIUS: 6370996.81,
      MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
      LLBAND: [75, 60, 45, 30, 15, 0],
      MC2LL: [[1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2], [-7.435856389565537e-9, 0.000008983055097726239, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37], [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062, 23.10934304144901, -0.00023663490511, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8, 7.47137025468032, -0.00000353937994, -0.02145144861037, -0.00001234426596, 0.00010322952773, -0.00000323890364, 826088.5]],
      LL2MC: [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [0.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-0.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-0.0003218135878613132, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]],
      convertMC2LL: function convertMC2LL(cB, out) {
        var cE;

        for (var cD = 0, len = this.MCBAND.length; cD < len; cD++) {
          if (Math.abs(cB.y) >= this.MCBAND[cD]) {
            cE = this.MC2LL[cD];
            break;
          }
        }

        var T = this.convertor(cB, cE, out);
        return T;
      },
      convertLL2MC: function convertLL2MC(T, out) {
        var cD, cC, len;
        T.x = this.getLoop(T.x, -180, 180);
        T.y = this.getRange(T.y, -74, 74);
        var cB = new Coordinate(T.x, T.y);

        for (cC = 0, len = this.LLBAND.length; cC < len; cC++) {
          if (cB.y >= this.LLBAND[cC]) {
            cD = this.LL2MC[cC];
            break;
          }
        }

        if (!cD) {
          for (cC = this.LLBAND.length - 1; cC >= 0; cC--) {
            if (cB.y <= -this.LLBAND[cC]) {
              cD = this.LL2MC[cC];
              break;
            }
          }
        }

        var cE = this.convertor(T, cD, out);
        return cE;
      },
      convertor: function convertor(cC, cD, out) {
        if (!cC || !cD) {
          return null;
        }

        var T = cD[0] + cD[1] * Math.abs(cC.x);
        var cB = Math.abs(cC.y) / cD[9];
        var cE = cD[2] + cD[3] * cB + cD[4] * cB * cB + cD[5] * cB * cB * cB + cD[6] * cB * cB * cB * cB + cD[7] * cB * cB * cB * cB * cB + cD[8] * cB * cB * cB * cB * cB * cB;
        T *= cC.x < 0 ? -1 : 1;
        cE *= cC.y < 0 ? -1 : 1;

        if (out) {
          out.x = T;
          out.y = cE;
          return out;
        }

        return new Coordinate(T, cE);
      },
      toRadians: function toRadians(T) {
        return Math.PI * T / 180;
      },
      toDegrees: function toDegrees(T) {
        return 180 * T / Math.PI;
      },
      getRange: function getRange(cC, cB, T) {
        if (cB != null) {
          cC = Math.max(cC, cB);
        }

        if (T != null) {
          cC = Math.min(cC, T);
        }

        return cC;
      },
      getLoop: function getLoop(cC, cB, T) {
        if (cC === Infinity) {
          return T;
        } else if (cC === -Infinity) {
          return cB;
        }

        while (cC > T) {
          cC -= T - cB;
        }

        while (cC < cB) {
          cC += T - cB;
        }

        return cC;
      }
    });

    /**
     * A projection based on Cartesian coordinate system.<br>
     * This projection maps x, y directly, it is useful for maps of flat surfaces (e.g. indoor maps, game maps).
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name IDENTITY
     * @mixes projection.Common
     * @mixes measurer.Identity
     */

    var Projection_IDENTITY = extend({}, Common,
    /** @lends projection.IDENTITY */
    {
      /**
       * "IDENTITY", Code of the projection
       * @type {String}
       * @constant
       */
      code: 'IDENTITY',
      project: function project(p, out) {
        if (out) {
          out.x = p.x;
          out.y = p.y;
          return out;
        }

        return p.copy();
      },
      unproject: function unproject(p, out) {
        if (out) {
          out.x = p.x;
          out.y = p.y;
          return out;
        }

        return p.copy();
      }
    }, Identity);

    /** @namespace projection */
    /**
     * Default projection, [EPSG3857]{@link projection.EPSG3857}
     *
     * @class
     * @category geo
     * @protected
     * @memberOf projection
     * @name DEFAULT
     * @extends projection.EPSG3857
     */

    var DEFAULT$1 = EPSG3857;

    var projections = /*#__PURE__*/Object.freeze({
        EPSG3857: EPSG3857,
        DEFAULT: DEFAULT$1,
        EPSG4326: PROJ4326,
        EPSG4490: Projection_EPSG4490,
        BAIDU: Projection_Baidu,
        IDENTITY: Projection_IDENTITY,
        Common: Common
    });

    /**
     * Common methods for classes can be rendered, e.g. Map, Layers
     * @mixin Renderable
     * @protected
     */
    var Renderable = (function (Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          /**
           * Register a renderer class with the given name.
           * @param  {String} name  - renderer's register key
           * @param  {Function} clazz - renderer's class, a function (not necessarily a [Class]{@link Class}).
           * @return {*} this
           * @function Renderable.registerRenderer
           */
          _class.registerRenderer = function registerRenderer(name, clazz) {
            var proto = this.prototype;
            var parentProto = Object.getPrototypeOf(proto);

            if (!proto._rendererClasses || proto._rendererClasses === parentProto._rendererClasses) {
              proto._rendererClasses = proto._rendererClasses ? Object.create(proto._rendererClasses) : {};
            }

            proto._rendererClasses[name.toLowerCase()] = clazz;
            return this;
          }
          /**
           * Get the registered renderer class by the given name
           * @param  {String} name  - renderer's register key
           * @return {Function} renderer's class
           * @function Renderable.getRendererClass
           */
          ;

          _class.getRendererClass = function getRendererClass(name) {
            var proto = this.prototype;

            if (!proto._rendererClasses) {
              return null;
            }

            return proto._rendererClasses[name.toLowerCase()];
          };

          return _class;
        }(Base)
      );
    });

    /**
     * @classdesc
     * Base Class to render layer on HTMLCanvasElement
     * @abstract
     * @protected
     * @memberOf renderer
     * @extends Class
     */

    var CanvasRenderer =
    /*#__PURE__*/
    function (_Class) {
      _inheritsLoose(CanvasRenderer, _Class);

      /**
       * @param  {Layer} layer the layer to render
       */
      function CanvasRenderer(layer) {
        var _this;

        _this = _Class.call(this) || this;
        _this.layer = layer;
        _this._painted = false;
        _this._drawTime = 0;

        _this.setToRedraw();

        return _this;
      }
      /**
       * Render the layer.
       * Call checkResources
       */


      var _proto = CanvasRenderer.prototype;

      _proto.render = function render(framestamp) {
        var _this2 = this;

        this.prepareRender();

        if (!this.getMap() || !this.layer.isVisible()) {
          return;
        }

        if (!this.resources) {
          /* eslint-disable no-use-before-define */
          this.resources = new ResourceCache();
          /* eslint-enable no-use-before-define */
        }

        if (this.checkResources) {
          var resources = this.checkResources();

          if (resources.length > 0) {
            this._loadingResource = true;
            this.loadResources(resources).then(function () {
              _this2._loadingResource = false;

              if (_this2.layer) {
                /**
                 * resourceload event, fired when external resources of the layer complete loading.
                 *
                 * @event Layer#resourceload
                 * @type {Object}
                 * @property {String} type     - resourceload
                 * @property {Layer} target    - layer
                 */
                _this2.layer.fire('resourceload');

                _this2.setToRedraw();
              }
            });
          } else {
            this._tryToDraw(framestamp);
          }
        } else {
          this._tryToDraw(framestamp);
        }
      }
      /**
       * Check if has any external resources to load
       * If yes, load the resources before calling draw method
       * @abstract
       * @method checkResources
       * @instance
       * @returns {Array[]} an array of resource arrays [ [url1, width, height], [url2, width, height], [url3, width, height] .. ]
       * @memberOf renderer.CanvasRenderer
       */

      /**
       * a required abstract method to implement
       * draw the layer when map is not interacting
       * @abstract
       * @instance
       * @method draw
       * @memberOf renderer.CanvasRenderer
       */

      /**
       * an optional abstract method to implement
       * draw the layer when map is interacting (moving/zooming/dragrotating)
       * @abstract
       * @instance
       * @method drawOnInteracting
       * @param {Object} eventParam event parameters
       * @memberOf renderer.CanvasRenderer
       */

      /**
       * @private
       */
      ;

      _proto.testIfNeedRedraw = function testIfNeedRedraw() {
        var map = this.getMap();

        if (this._loadingResource) {
          return false;
        }

        if (this._toRedraw) {
          return true;
        }

        if (map.isInteracting() && !this.drawOnInteracting) {
          return false;
        }

        if (this.needToRedraw()) {
          return true;
        }

        return false;
      }
      /**
       * Ask whether the layer renderer needs to redraw
       * @return {Boolean}
       */
      ;

      _proto.needToRedraw = function needToRedraw() {
        var map = this.getMap();

        if (map.isInteracting() || map.getRenderer().isViewChanged()) {
          // don't redraw when map is moving without any pitch
          return !(!map.getPitch() && map.isMoving() && !map.isZooming() && !map.isRotating() && !this.layer.options['forceRenderOnMoving']);
        }

        return false;
      }
      /**
       * A callback for overriding when drawOnInteracting is skipped due to low fps
       */
      ;

      _proto.onSkipDrawOnInteracting = function onSkipDrawOnInteracting() {};

      _proto.isLoadingResource = function isLoadingResource() {
        return this._loadingResource;
      };

      _proto.isRenderComplete = function isRenderComplete() {
        return !!this._renderComplete;
      }
      /**
       * Whether must call render instead of drawOnInteracting when map is interacting
       */
      ;

      _proto.mustRenderOnInteracting = function mustRenderOnInteracting() {
        return !this._painted || this.checkResources && this.checkResources().length > 0;
      }
      /**
       * Set to redraw, ask map to call draw/drawOnInteracting to redraw the layer
       */
      ;

      _proto.setToRedraw = function setToRedraw() {
        this._toRedraw = true;
        return this;
      }
      /**
       *  Mark layer's canvas updated
       */
      ;

      _proto.setCanvasUpdated = function setCanvasUpdated() {
        this._canvasUpdated = true;
        return this;
      }
      /**
       * Only called by map's renderer to check whether the layer's canvas is updated
       * @protected
       * @return {Boolean}
       */
      ;

      _proto.isCanvasUpdated = function isCanvasUpdated() {
        return !!this._canvasUpdated;
      }
      /**
       * Remove the renderer, will be called when layer is removed
       */
      ;

      _proto.remove = function remove() {
        this.onRemove();
        delete this._loadingResource;
        delete this.southWest;
        delete this.canvas;
        delete this.context;
        delete this.canvasExtent2D;
        delete this._extent2D;
        delete this.resources;
        delete this.layer;
      };

      _proto.onRemove = function onRemove() {};

      _proto.onAdd = function onAdd() {}
      /**
       * Get map
       * @return {Map}
       */
      ;

      _proto.getMap = function getMap() {
        if (!this.layer) {
          return null;
        }

        return this.layer.getMap();
      }
      /**
       * Get renderer's Canvas image object
       * @return {HTMLCanvasElement}
       */
      ;

      _proto.getCanvasImage = function getCanvasImage() {
        var map = this.getMap();
        this._canvasUpdated = false;

        if (this._renderZoom !== map.getZoom() || !this.canvas || !this._extent2D) {
          return null;
        }

        if (this.isBlank()) {
          return null;
        }

        if (this.layer.isEmpty && this.layer.isEmpty()) {
          return null;
        } // size = this._extent2D.getSize(),


        var containerPoint = map._pointToContainerPoint(this.southWest)._add(0, -map.height);

        return {
          'image': this.canvas,
          'layer': this.layer,
          'point': containerPoint
          /* ,
          'size': size */

        };
      }
      /**
       * Clear canvas
       */
      ;

      _proto.clear = function clear() {
        this.clearCanvas();
      }
      /**
       * A method to help improve performance.
       * If you are sure that layer's canvas is blank, returns true to save unnecessary layer works of maps.
       * @return {Boolean}
       */
      ;

      _proto.isBlank = function isBlank() {
        if (!this._painted) {
          return true;
        }

        return false;
      }
      /**
       * Show the layer
       */
      ;

      _proto.show = function show() {
        this.setToRedraw();
      }
      /**
       * Hide the layer
       */
      ;

      _proto.hide = function hide() {
        this.clear();
        this.setToRedraw();
      }
      /**
       * Set z-index of layer
       */
      ;

      _proto.setZIndex = function setZIndex()
      /*z*/
      {
        this.setToRedraw();
      }
      /**
       * Detect if there is anything painted on the given point
       * @param  {Point} point containerPoint
       * @return {Boolean}
       */
      ;

      _proto.hitDetect = function hitDetect(point) {
        if (!this.context || this.layer.isEmpty && this.layer.isEmpty() || this.isBlank() || this._errorThrown) {
          return false;
        }

        var map = this.getMap();
        var r = map.getDevicePixelRatio();
        var size = map.getSize();

        if (point.x < 0 || point.x > size['width'] * r || point.y < 0 || point.y > size['height'] * r) {
          return false;
        }

        try {
          var imgData = this.context.getImageData(r * point.x, r * point.y, 1, 1).data;

          if (imgData[3] > 0) {
            return true;
          }
        } catch (error) {
          if (!this._errorThrown) {
            if (console) {
              console.warn('hit detect failed with tainted canvas, some geometries have external resources in another domain:\n', error);
            }

            this._errorThrown = true;
          } //usually a CORS error will be thrown if the canvas uses resources from other domain.
          //this may happen when a geometry is filled with pattern file.


          return false;
        }

        return false;
      }
      /**
       * loadResource from resourceUrls
       * @param  {String[]} resourceUrls    - Array of urls to load
       * @param  {Function} onComplete          - callback after loading complete
       * @param  {Object} context         - callback's context
       * @returns {Promise[]}
       */
      ;

      _proto.loadResources = function loadResources(resourceUrls) {
        if (!this.resources) {
          /* eslint-disable no-use-before-define */
          this.resources = new ResourceCache();
          /* eslint-enable no-use-before-define */
        }

        var resources = this.resources,
            promises = [];

        if (isArrayHasData(resourceUrls)) {
          var cache = {};

          for (var i = resourceUrls.length - 1; i >= 0; i--) {
            var url = resourceUrls[i];

            if (!url || !url.length || cache[url.join('-')]) {
              continue;
            }

            cache[url.join('-')] = 1;

            if (!resources.isResourceLoaded(url, true)) {
              //closure it to preserve url's value
              promises.push(new Promise$1(this._promiseResource(url)));
            }
          }
        }

        return Promise$1.all(promises);
      }
      /**
       * Prepare rendering
       * Set necessary properties, like this._renderZoom/ this.canvasExtent2D, this.southWest
       * @private
       */
      ;

      _proto.prepareRender = function prepareRender() {
        delete this._renderComplete;
        var map = this.getMap();
        this._renderZoom = map.getZoom();
        this.canvasExtent2D = this._extent2D = map._get2DExtent(); //change from northWest to southWest, because northwest's point <=> containerPoint changes when pitch >= 72

        this.southWest = map._containerPointToPoint(new Point(0, map.height));
      }
      /**
       * Create renderer's Canvas
       */
      ;

      _proto.createCanvas = function createCanvas() {
        if (this.canvas) {
          return;
        }

        var map = this.getMap();
        var size = map.getSize();
        var r = map.getDevicePixelRatio(),
            w = r * size.width,
            h = r * size.height;

        if (this.layer._canvas) {
          var canvas = this.layer._canvas;
          canvas.width = w;
          canvas.height = h;

          if (canvas.style) {
            canvas.style.width = size.width + 'px';
            canvas.style.height = size.height + 'px';
          }

          this.canvas = this.layer._canvas;
        } else {
          this.canvas = Canvas$1.createCanvas(w, h, map.CanvasClass);
        }

        this.onCanvasCreate();
      };

      _proto.onCanvasCreate = function onCanvasCreate() {};

      _proto.createContext = function createContext() {
        //Be compatible with layer renderers that overrides create canvas and create gl/context
        if (this.gl && this.gl.canvas === this.canvas || this.context) {
          return;
        }

        this.context = this.canvas.getContext('2d');

        if (!this.context) {
          return;
        }

        if (this.layer.options['globalCompositeOperation']) {
          this.context.globalCompositeOperation = this.layer.options['globalCompositeOperation'];
        }

        var dpr = this.getMap().getDevicePixelRatio();

        if (dpr !== 1) {
          this.context.scale(dpr, dpr);
        }
      };

      _proto.resetCanvasTransform = function resetCanvasTransform() {
        if (!this.context) {
          return;
        }

        var dpr = this.getMap().getDevicePixelRatio();
        this.context.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      /**
       * Resize the canvas
       * @param  {Size} canvasSize the size resizing to
       */
      ;

      _proto.resizeCanvas = function resizeCanvas(canvasSize) {
        var canvas = this.canvas;

        if (!canvas) {
          return;
        }

        var size = canvasSize || this.getMap().getSize();
        var r = this.getMap().getDevicePixelRatio();

        if (canvas.width === r * size.width && canvas.height === r * size.height) {
          return;
        } //retina support


        canvas.height = r * size.height;
        canvas.width = r * size.width;

        if (r !== 1 && this.context) {
          this.context.scale(r, r);
        }

        if (this.layer._canvas && canvas.style) {
          canvas.style.width = size.width + 'px';
          canvas.style.height = size.height + 'px';
        }
      }
      /**
       * Clear the canvas to blank
       */
      ;

      _proto.clearCanvas = function clearCanvas() {
        if (!this.context) {
          return;
        }

        Canvas$1.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
      }
      /**
       * Prepare the canvas for rendering. <br>
       * 1. Clear the canvas to blank. <br>
       * 2. Clip the canvas by mask if there is any and return the mask's extent
       * @return {PointExtent} mask's extent of current zoom's 2d point.
       */
      ;

      _proto.prepareCanvas = function prepareCanvas() {
        if (!this.canvas) {
          this.createCanvas();
          this.createContext();
          this.layer.onCanvasCreate();
          /**
           * canvascreate event, fired when canvas created.
           *
           * @event Layer#canvascreate
           * @type {Object}
           * @property {String} type     - canvascreate
           * @property {Layer} target    - layer
           * @property {CanvasRenderingContext2D} context - canvas's context
           * @property {WebGLRenderingContext2D} gl  - canvas's webgl context
           */

          this.layer.fire('canvascreate', {
            'context': this.context,
            'gl': this.gl
          });
        } else {
          this.resetCanvasTransform();
          this.clearCanvas();
          this.resizeCanvas();
        }

        delete this._maskExtent;
        var mask = this.layer.getMask(); // this.context may be not available

        if (!mask) {
          this.layer.fire('renderstart', {
            'context': this.context,
            'gl': this.gl
          });
          return null;
        }

        var maskExtent2D = this._maskExtent = mask._getPainter().get2DExtent();

        if (!maskExtent2D.intersects(this._extent2D)) {
          this.layer.fire('renderstart', {
            'context': this.context,
            'gl': this.gl
          });
          return maskExtent2D;
        }
        /**
         * renderstart event, fired when layer starts to render.
         *
         * @event Layer#renderstart
         * @type {Object}
         * @property {String} type              - renderstart
         * @property {Layer} target    - layer
         * @property {CanvasRenderingContext2D} context - canvas's context
         */


        this.layer.fire('renderstart', {
          'context': this.context,
          'gl': this.gl
        });
        return maskExtent2D;
      };

      _proto.clipCanvas = function clipCanvas(context) {
        var mask = this.layer.getMask();

        if (!mask) {
          return false;
        }

        var old = this.southWest;
        var map = this.getMap(); //when clipping, layer's southwest needs to be reset for mask's containerPoint conversion

        this.southWest = map._containerPointToPoint(new Point(0, map.height));
        context.save();
        var dpr = map.getDevicePixelRatio();

        if (dpr !== 1) {
          context.save();
          context.scale(dpr, dpr);
        } // Handle MultiPolygon


        if (mask.getGeometries) {
          context.isMultiClip = true;
          var masks = mask.getGeometries() || [];
          context.beginPath();
          masks.forEach(function (_mask) {
            var painter = _mask._getPainter();

            painter.paint(null, context);
          });
          context.stroke();
          delete context.isMultiClip;
        } else {
          var painter = mask._getPainter();

          painter.paint(null, context);
        }

        if (dpr !== 1) {
          context.restore();
        }

        context.clip();
        this.southWest = old;
        return true;
      }
      /**
       * Get renderer's current view extent in 2d point
       * @return {Object} view.extent, view.maskExtent, view.zoom, view.southWest
       */
      ;

      _proto.getViewExtent = function getViewExtent() {
        return {
          'extent': this._extent2D,
          'maskExtent': this._maskExtent,
          'zoom': this._renderZoom,
          'southWest': this.southWest
        };
      }
      /**
       * call when rendering completes, this will fire necessary events and call setCanvasUpdated
       */
      ;

      _proto.completeRender = function completeRender() {
        if (this.getMap()) {
          this._renderComplete = true;
          /**
           * renderend event, fired when layer ends rendering.
           *
           * @event Layer#renderend
           * @type {Object}
           * @property {String} type              - renderend
           * @property {Layer} target    - layer
           * @property {CanvasRenderingContext2D} context - canvas's context
           */

          this.layer.fire('renderend', {
            'context': this.context,
            'gl': this.gl
          });
          this.setCanvasUpdated();
        }
      }
      /**
       * Get renderer's event map registered on the map
       * @return {Object} events
       */
      ;

      _proto.getEvents = function getEvents() {
        return {
          '_zoomstart': this.onZoomStart,
          '_zooming': this.onZooming,
          '_zoomend': this.onZoomEnd,
          '_resize': this.onResize,
          '_movestart': this.onMoveStart,
          '_moving': this.onMoving,
          '_moveend': this.onMoveEnd,
          '_dragrotatestart': this.onDragRotateStart,
          '_dragrotating': this.onDragRotating,
          '_dragrotateend': this.onDragRotateEnd,
          '_spatialreferencechange': this.onSpatialReferenceChange
        };
      }
      /**
      /**
       * onZoomStart
       * @param  {Object} param event parameters
       */
      ;

      _proto.onZoomStart = function onZoomStart() {}
      /**
      * onZoomEnd
      * @param  {Object} param event parameters
      */
      ;

      _proto.onZoomEnd = function onZoomEnd() {
        this.setToRedraw();
      }
      /**
      * onZooming
      * @param  {Object} param event parameters
      */
      ;

      _proto.onZooming = function onZooming() {}
      /**
      * onMoveStart
      * @param  {Object} param event parameters
      */
      ;

      _proto.onMoveStart = function onMoveStart() {}
      /**
      * onMoving
      * @param  {Object} param event parameters
      */
      ;

      _proto.onMoving = function onMoving() {}
      /**
      * onMoveEnd
      * @param  {Object} param event parameters
      */
      ;

      _proto.onMoveEnd = function onMoveEnd() {
        this.setToRedraw();
      }
      /**
      * onResize
      * @param  {Object} param event parameters
      */
      ;

      _proto.onResize = function onResize() {
        delete this._extent2D;
        this.resizeCanvas();
        this.setToRedraw();
      }
      /**
      * onDragRotateStart
      * @param  {Object} param event parameters
      */
      ;

      _proto.onDragRotateStart = function onDragRotateStart() {}
      /**
      * onDragRotating
      * @param  {Object} param event parameters
      */
      ;

      _proto.onDragRotating = function onDragRotating() {}
      /**
      * onDragRotateEnd
      * @param  {Object} param event parameters
      */
      ;

      _proto.onDragRotateEnd = function onDragRotateEnd() {
        this.setToRedraw();
      }
      /**
      * onSpatialReferenceChange
      * @param  {Object} param event parameters
      */
      ;

      _proto.onSpatialReferenceChange = function onSpatialReferenceChange() {}
      /**
       * Get ellapsed time of previous drawing
       * @return {Number}
       */
      ;

      _proto.getDrawTime = function getDrawTime() {
        return this._drawTime;
      };

      _proto._tryToDraw = function _tryToDraw(framestamp) {
        this._toRedraw = false;

        if (!this.canvas && this.layer.isEmpty && this.layer.isEmpty()) {
          this._renderComplete = true; // not to create canvas when layer is empty

          return;
        }

        this._drawAndRecord(framestamp);
      };

      _proto._drawAndRecord = function _drawAndRecord(framestamp) {
        if (!this.getMap()) {
          return;
        }

        var painted = this._painted;
        this._painted = true;
        var t = now();
        this.draw(framestamp);
        t = now() - t; //reduce some time in the first draw

        this._drawTime = painted ? t : t / 2;

        if (painted && this.layer && this.layer.options['logDrawTime']) {
          console.log(this.layer.getId(), 'frameTimeStamp:', framestamp, 'drawTime:', this._drawTime);
        }
      };

      _proto._promiseResource = function _promiseResource(url) {
        var me = this,
            resources = this.resources,
            crossOrigin = this.layer.options['crossOrigin'];
        return function (resolve) {
          if (resources.isResourceLoaded(url, true)) {
            resolve(url);
            return;
          }

          var img = new Image();

          if (!isNil(crossOrigin)) {
            img['crossOrigin'] = crossOrigin;
          }

          if (isSVG(url[0]) && !IS_NODE) {
            //amplify the svg image to reduce loading.
            if (url[1]) {
              url[1] *= 2;
            }

            if (url[2]) {
              url[2] *= 2;
            }
          }

          img.onload = function () {
            me._cacheResource(url, img);

            resolve(url);
          };

          img.onabort = function (err) {
            if (console) {
              console.warn('image loading aborted: ' + url[0]);
            }

            if (err) {
              if (console) {
                console.warn(err);
              }
            }

            resolve(url);
          };

          img.onerror = function (err) {
            // if (console) { console.warn('image loading failed: ' + url[0]); }
            if (err && typeof console !== 'undefined') {
              console.warn(err);
            }

            resources.markErrorResource(url);
            resolve(url);
          };

          loadImage(img, url);
        };
      };

      _proto._cacheResource = function _cacheResource(url, img) {
        if (!this.layer || !this.resources) {
          return;
        }

        var w = url[1],
            h = url[2];

        if (this.layer.options['cacheSvgOnCanvas'] && isSVG(url[0]) === 1 && (Browser$1.edge || Browser$1.ie)) {
          //opacity of svg img painted on canvas is always 1, so we paint svg on a canvas at first.
          if (isNil(w)) {
            w = img.width || this.layer.options['defaultIconSize'][0];
          }

          if (isNil(h)) {
            h = img.height || this.layer.options['defaultIconSize'][1];
          }

          var canvas = Canvas$1.createCanvas(w, h);
          Canvas$1.image(canvas.getContext('2d'), img, 0, 0, w, h);
          img = canvas;
        }

        this.resources.addResource(url, img);
      };

      return CanvasRenderer;
    }(Class);
    var ResourceCache =
    /*#__PURE__*/
    function () {
      function ResourceCache() {
        this.resources = {};
        this._errors = {};
      }

      var _proto2 = ResourceCache.prototype;

      _proto2.addResource = function addResource(url, img) {
        this.resources[url[0]] = {
          image: img,
          width: +url[1],
          height: +url[2]
        };
      };

      _proto2.isResourceLoaded = function isResourceLoaded(url, checkSVG) {
        if (!url) {
          return false;
        }

        var imgUrl = this._getImgUrl(url);

        if (this._errors[imgUrl]) {
          return true;
        }

        var img = this.resources[imgUrl];

        if (!img) {
          return false;
        }

        if (checkSVG && isSVG(url[0]) && (+url[1] > img.width || +url[2] > img.height)) {
          return false;
        }

        return true;
      };

      _proto2.getImage = function getImage(url) {
        var imgUrl = this._getImgUrl(url);

        if (!this.isResourceLoaded(url) || this._errors[imgUrl]) {
          return null;
        }

        return this.resources[imgUrl].image;
      };

      _proto2.markErrorResource = function markErrorResource(url) {
        this._errors[this._getImgUrl(url)] = 1;
      };

      _proto2.merge = function merge(res) {
        if (!res) {
          return this;
        }

        for (var p in res.resources) {
          var img = res.resources[p];
          this.addResource([p, img.width, img.height], img.image);
        }

        return this;
      };

      _proto2.forEach = function forEach(fn) {
        if (!this.resources) {
          return this;
        }

        for (var p in this.resources) {
          if (hasOwn(this.resources, p)) {
            fn(p, this.resources[p]);
          }
        }

        return this;
      };

      _proto2._getImgUrl = function _getImgUrl(url) {
        if (!Array.isArray(url)) {
          return url;
        }

        return url[0];
      };

      return ResourceCache;
    }();

    function clipLine(points, bounds, round, noCut) {
      var parts = [];
      var k = 0,
          segment;

      for (var j = 0, l = points.length; j < l - 1; j++) {
        segment = clipSegment(points[j], points[j + 1], bounds, j, round, noCut);

        if (!segment) {
          continue;
        }

        parts[k] = parts[k] || [];
        parts[k].push({
          'point': segment[0],
          'index': j
        }); // if segment goes out of screen, or it's the last one, it's the end of the line part

        if (segment[1] !== points[j + 1] || j === l - 2) {
          // parts[k].push(segment[1]);
          parts[k].push({
            'point': segment[1],
            'index': j + 1
          });
          k++;
        }
      }

      return parts;
    }

    var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
    // Clips the segment a to b by rectangular bounds with the
    // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
    // (modifying the segment points directly!). Used by Leaflet to only show polyline
    // points that are on the screen or near, increasing performance.
    // @copyright Leaflet


    function clipSegment(a, b, bounds, useLastCode, round, noCut) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
          codeB = _getBitCode(b, bounds),
          codeOut,
          p,
          newCode; // save 2nd code to avoid calculating it on the next segment


      _lastCode = codeB;

      while (true) {
        // if a,b is inside the clip window (trivial accept)
        if (!(codeA | codeB)) {
          return [a, b];
        } // if a,b is outside the clip window (trivial reject)


        if (codeA & codeB) {
          return false;
        }

        if (noCut) {
          return [a, b];
        } // other cases


        codeOut = codeA || codeB;
        p = _getEdgeIntersection(a, b, codeOut, bounds, round);
        newCode = _getBitCode(p, bounds);

        if (codeOut === codeA) {
          a = p;
          codeA = newCode;
        } else {
          b = p;
          codeB = newCode;
        }
      }
    }
    /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
     * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
     * Used by Leaflet to only show polygon points that are on the screen or near, increasing
     * performance. Note that polygon points needs different algorithm for clipping
     * than polyline, so there's a seperate method for it.
     * @copyright Leaflet
     */

    function clipPolygon(points, bounds, round) {
      var edges = [1, 4, 2, 8];
      var clippedPoints, i, j, k, a, b, len, edge, p;

      for (i = 0, len = points.length; i < len; i++) {
        points[i]._code = _getBitCode(points[i], bounds);
      } // for each edge (left, bottom, right, top)


      for (k = 0; k < 4; k++) {
        edge = edges[k];
        clippedPoints = [];

        for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
          a = points[i];
          b = points[j]; // if a is inside the clip window

          if (!(a._code & edge)) {
            // if b is outside the clip window (a->b goes out of screen)
            if (b._code & edge) {
              p = _getEdgeIntersection(b, a, edge, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }

            clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)
          } else if (!(b._code & edge)) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }
        }

        points = clippedPoints;
      }

      return points;
    }

    function _getEdgeIntersection(a, b, code, bounds, round) {
      var dx = b.x - a.x,
          dy = b.y - a.y,
          min = bounds.getMin(),
          max = bounds.getMax();
      var x, y;

      if (code & 8) {
        // top
        x = a.x + dx * (max.y - a.y) / dy;
        y = max.y;
      } else if (code & 4) {
        // bottom
        x = a.x + dx * (min.y - a.y) / dy;
        y = min.y;
      } else if (code & 2) {
        // right
        x = max.x;
        y = a.y + dy * (max.x - a.x) / dx;
      } else if (code & 1) {
        // left
        x = min.x;
        y = a.y + dy * (min.x - a.x) / dx;
      }

      var p = new Point(x, y);

      if (round) {
        p._round();
      }

      return p;
    }

    function _getBitCode(p, bounds) {
      var code = 0;

      if (p.x < bounds.getMin().x) {
        // left
        code |= 1;
      } else if (p.x > bounds.getMax().x) {
        // right
        code |= 2;
      }

      if (p.y < bounds.getMin().y) {
        // bottom
        code |= 4;
      } else if (p.y > bounds.getMax().y) {
        // top
        code |= 8;
      }

      return code;
    }
    /**
     * Is the point within an ellipse
     * @param {Point} point
     * @param {Point} center ellipse's center
     * @param {Point} southeast ellipse's southeast point
     * @param {Number} tolerance
     * @returns {Boolean}
     * @private
     * @memberOf Util
     */


    function withInEllipse(point, center, southeast, tolerance) {
      point = new Point(point);
      var a = Math.abs(southeast.x - center.x),
          b = Math.abs(southeast.y - center.y),
          c = Math.sqrt(Math.abs(a * a - b * b)),
          xfocus = a >= b;
      var f1, f2, d;

      if (xfocus) {
        f1 = new Point(center.x - c, center.y);
        f2 = new Point(center.x + c, center.y);
        d = a * 2;
      } else {
        f1 = new Point(center.x, center.y - c);
        f2 = new Point(center.x, center.y + c);
        d = b * 2;
      }
      /*
      L1 + L2 = D
      L1 + t >= L1'
      L2 + t >= L2'
      D + 2t >= L1' + L2'
      */


      return point.distanceTo(f1) + point.distanceTo(f2) <= d + 2 * tolerance;
    }

    /**
     * @classdesc
     * Base class for all the symbolilzers
     * @class
     * @extends Class
     * @abstract
     * @private
     */

    var Symbolizer =
    /*#__PURE__*/
    function () {
      function Symbolizer() {}

      var _proto = Symbolizer.prototype;

      _proto.getMap = function getMap() {
        return this.geometry.getMap();
      };

      _proto.getPainter = function getPainter() {
        return this.painter;
      };

      _proto.isDynamicSize = function isDynamicSize() {
        return false;
      }
      /**
       * Test if the property is a property related with coloring
       * @param {String} prop - property name to test
       * @static
       * @function
       * @return {Boolean}
       * @memberof symbolizer.Symbolizer
       */
      ;

      Symbolizer.testColor = function testColor(prop) {
        if (!prop || !isString(prop)) {
          return false;
        }

        if (COLOR_PROPERTIES.indexOf(prop) >= 0) {
          return true;
        }

        return false;
      };

      return Symbolizer;
    }();

    /**
     * @classdesc
     * Base symbolizer class for all the symbolizers base on HTML5 Canvas2D
     * @abstract
     * @class
     * @private
     * @memberOf symbolizer
     * @name CanvasSymbolizer
     * @extends {Symbolizer}
     */

    var CanvasSymbolizer =
    /*#__PURE__*/
    function (_Symbolizer) {
      _inheritsLoose(CanvasSymbolizer, _Symbolizer);

      function CanvasSymbolizer() {
        return _Symbolizer.apply(this, arguments) || this;
      }

      var _proto = CanvasSymbolizer.prototype;

      _proto._prepareContext = function _prepareContext(ctx) {
        if (isNumber(this.symbol['opacity'])) {
          if (ctx.globalAlpha !== this.symbol['opacity']) {
            ctx.globalAlpha = this.symbol['opacity'];
          }
        } else if (ctx.globalAlpha !== 1) {
          ctx.globalAlpha = 1;
        }
      };

      _proto.prepareCanvas = function prepareCanvas(ctx, style, resources) {
        Canvas$1.prepareCanvas(ctx, style, resources, this.getPainter().isHitTesting());
      };

      _proto.remove = function remove() {};

      _proto.setZIndex = function setZIndex() {};

      _proto.show = function show() {};

      _proto.hide = function hide() {};

      _proto._defineStyle = function _defineStyle(style) {
        return function () {
          var _this = this;

          var arr = [],
              prop = {};
          return loadFunctionTypes(style, function () {
            var map = _this.getMap();

            return set$1(arr, map.getZoom(), extend({}, _this.geometry.getProperties(), setProp(prop, map.getBearing(), map.getPitch(), map.getZoom())));
          });
        }.bind(this)();
      };

      return CanvasSymbolizer;
    }(Symbolizer);

    function set$1(arr, a0, a1) {
      arr[0] = a0;
      arr[1] = a1;
      return arr;
    }

    function setProp(prop, b, p, z) {
      prop['{bearing}'] = b;
      prop['{pitch}'] = p;
      prop['{zoom}'] = z;
      return prop;
    }

    var TEMP_POINT0$1 = new Point(0, 0);
    var TEMP_POINT1 = new Point(0, 0);
    /**
     * @classdesc
     * Base symbolizer class for all the point type symbol styles.
     * @abstract
     * @class
     * @private
     * @memberOf symbolizer
     * @name PointSymbolizer
     * @extends {symbolizer.CanvasSymbolizer}
     */

    var PointSymbolizer =
    /*#__PURE__*/
    function (_CanvasSymbolizer) {
      _inheritsLoose(PointSymbolizer, _CanvasSymbolizer);

      function PointSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _CanvasSymbolizer.call(this) || this;
        _this.symbol = symbol;
        _this.geometry = geometry;
        _this.painter = painter;
        return _this;
      }

      var _proto = PointSymbolizer.prototype;

      _proto.get2DExtent = function get2DExtent() {
        var map = this.getMap();
        var glZoom = map.getGLZoom();
        var extent = new PointExtent();

        var renderPoints = this._getRenderPoints()[0];

        for (var i = renderPoints.length - 1; i >= 0; i--) {
          if (renderPoints[i]) {
            extent._combine(map._pointToPoint(renderPoints[i], glZoom));
          }
        }

        return extent;
      };

      _proto.isDynamicSize = function isDynamicSize() {
        var symbol = this.symbol;
        return isFunctionDefinition(symbol['markerWidth']) || isFunctionDefinition(symbol['markerHeight']) || isFunctionDefinition(symbol['textSize']);
      };

      _proto._rotateExtent = function _rotateExtent(fixedExtent, angle) {
        return fixedExtent.convertTo(function (p) {
          return p._rotate(angle);
        });
      };

      _proto._getRenderPoints = function _getRenderPoints() {
        var painter = this.getPainter();
        var placement = painter.isSpriting() ? 'center' : this.getPlacement();
        return this.getPainter().getRenderPoints(placement);
      }
      /**
       * Get container points to draw on Canvas
       * @return {Point[]}
       */
      ;

      _proto._getRenderContainerPoints = function _getRenderContainerPoints(ignoreAltitude) {
        var painter = this.getPainter(),
            points = this._getRenderPoints()[0];

        if (painter.isSpriting()) {
          return points;
        }

        var dxdy = this.getDxDy();

        var cpoints = this.painter._pointContainerPoints(points, dxdy.x, dxdy.y, ignoreAltitude, true, this.getPlacement());

        if (!cpoints || !Array.isArray(cpoints[0])) {
          return cpoints;
        }

        var flat = [];

        for (var i = 0, l = cpoints.length; i < l; i++) {
          for (var ii = 0, ll = cpoints[i].length; ii < ll; ii++) {
            flat.push(cpoints[i][ii]);
          }
        }

        return flat;
      };

      _proto._getRotationAt = function _getRotationAt(i) {
        var r = this.getRotation();

        if (!r) {
          r = 0;
        }

        var rotations = this._getRenderPoints()[1];

        if (!rotations || !rotations[i]) {
          return r;
        }

        var map = this.getMap();
        var p0 = rotations[i][0],
            p1 = rotations[i][1];

        if (map.isTransforming()) {
          var maxZoom = map.getGLZoom();
          p0 = map._pointToContainerPoint(rotations[i][0], maxZoom, 0, TEMP_POINT0$1);
          p1 = map._pointToContainerPoint(rotations[i][1], maxZoom, 0, TEMP_POINT1);
          return r + computeDegree(p0.x, p0.y, p1.x, p1.y);
        } else {
          //point的y轴方向与containerPoint是相反的，所以角度取负值
          return r + -computeDegree(p0.x, p0.y, p1.x, p1.y);
        }
      };

      _proto._rotate = function _rotate(ctx, origin, rotation) {
        if (rotation) {
          var dxdy = this.getDxDy();
          var p = origin.sub(dxdy);
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(rotation);
          return this.getDxDy();
        }

        return null;
      };

      return PointSymbolizer;
    }(CanvasSymbolizer);

    var VectorMarkerSymbolizer =
    /*#__PURE__*/
    function (_PointSymbolizer) {
      _inheritsLoose(VectorMarkerSymbolizer, _PointSymbolizer);

      VectorMarkerSymbolizer.test = function test(symbol) {
        if (!symbol) {
          return false;
        }

        if (isNil(symbol['markerFile']) && !isNil(symbol['markerType']) && symbol['markerType'] !== 'path') {
          return true;
        }

        return false;
      };

      function VectorMarkerSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
        _this._dynamic = hasFunctionDefinition(symbol);
        _this.style = _this._defineStyle(_this.translate());
        _this.strokeAndFill = _this._defineStyle(VectorMarkerSymbolizer.translateLineAndFill(_this.style));
        var lineWidth = _this.strokeAndFill['lineWidth'];

        if (lineWidth % 2 === 0) {
          _this.padding = 2;
        } else {
          _this.padding = 1.5;
        }

        return _this;
      }

      var _proto = VectorMarkerSymbolizer.prototype;

      _proto.symbolize = function symbolize(ctx, resources) {
        var style = this.style;

        if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 || style['polygonOpacity'] === 0 && style['lineOpacity'] === 0)) {
          return;
        }

        var cookedPoints = this._getRenderContainerPoints();

        if (!isArrayHasData(cookedPoints)) {
          return;
        }

        this._prepareContext(ctx);

        if (this.getPainter().isSpriting() || this.geometry.getLayer().getMask() === this.geometry || this._dynamic || this.geometry.getLayer().options['cacheVectorOnCanvas'] === false) {
          this._drawMarkers(ctx, cookedPoints, resources);
        } else {
          this._drawMarkersWithCache(ctx, cookedPoints, resources);
        }
      };

      _proto.getDxDy = function getDxDy() {
        var s = this.style;
        var dx = s['markerDx'],
            dy = s['markerDy'];
        return new Point(dx, dy);
      };

      _proto._drawMarkers = function _drawMarkers(ctx, cookedPoints, resources) {
        var strokeAndFill = this.strokeAndFill;
        var gradient = isGradient(strokeAndFill['lineColor']) || isGradient(strokeAndFill['polygonFill']);

        if (!gradient) {
          this.prepareCanvas(ctx, strokeAndFill, resources);
        }

        for (var i = cookedPoints.length - 1; i >= 0; i--) {
          var point = cookedPoints[i];

          var origin = this._rotate(ctx, point, this._getRotationAt(i));

          if (origin) {
            point = origin;
          }

          this._drawVectorMarker(ctx, point, resources);

          if (origin) {
            ctx.restore();
          }
        }
      };

      _proto._drawMarkersWithCache = function _drawMarkersWithCache(ctx, cookedPoints, resources) {
        var stamp = this._stampSymbol();

        var image = resources.getImage(stamp);

        if (!image) {
          image = this._createMarkerImage(ctx, resources);
          resources.addResource([stamp, image.width, image.height], image);
        }

        var anchor = this._getAnchor(image.width, image.height);

        for (var i = cookedPoints.length - 1; i >= 0; i--) {
          var point = cookedPoints[i];

          var origin = this._rotate(ctx, point, this._getRotationAt(i));

          if (origin) {
            point = origin;
          }

          Canvas$1.image(ctx, image, point.x + anchor.x, point.y + anchor.y);

          if (origin) {
            ctx.restore();
          }
        }
      };

      _proto._calMarkerSize = function _calMarkerSize() {
        if (!this._size) {
          var lineWidth = this.strokeAndFill['lineWidth'],
              shadow = 2 * (this.symbol['shadowBlur'] || 0),
              // add some tolerance for shadowOffsetX/Y
          w = Math.round(this.style['markerWidth'] + lineWidth + 2 * shadow + this.padding * 2),
              h = Math.round(this.style['markerHeight'] + lineWidth + 2 * shadow + this.padding * 2);

          if (isFunctionDefinition(this.symbol['markerWidth']) || isFunctionDefinition(this.symbol['markerHeight'])) {
            return [w, h];
          }

          this._size = [w, h];
        }

        return this._size;
      };

      _proto._createMarkerImage = function _createMarkerImage(ctx, resources) {
        var canvasClass = ctx.canvas.constructor,
            size = this._calMarkerSize(),
            canvas = Canvas$1.createCanvas(size[0], size[1], canvasClass),
            point = this._getCacheImageAnchor(size[0], size[1]);

        var context = canvas.getContext('2d');
        var gradient = isGradient(this.strokeAndFill['lineColor']) || isGradient(this.strokeAndFill['polygonFill']);

        if (!gradient) {
          this.prepareCanvas(context, this.strokeAndFill, resources);
        }

        this._drawVectorMarker(context, point, resources);

        return canvas;
      };

      _proto._stampSymbol = function _stampSymbol() {
        if (!this._stamp) {
          this._stamp = [this.style['markerType'], isGradient(this.style['markerFill']) ? getGradientStamp(this.style['markerFill']) : this.style['markerFill'], this.style['markerFillOpacity'], this.style['markerFillPatternFile'], isGradient(this.style['markerLineColor']) ? getGradientStamp(this.style['markerLineColor']) : this.style['markerLineColor'], this.style['markerLineWidth'], this.style['markerLineOpacity'], this.style['markerLineDasharray'] ? this.style['markerLineDasharray'].join(',') : '', this.style['markerLinePatternFile'], this.style['markerWidth'], this.style['markerHeight'], this.style['markerHorizontalAlignment'], this.style['markerVerticalAlignment']].join('_');
        }

        return this._stamp;
      };

      _proto._getAnchor = function _getAnchor(w, h) {
        var shadow = 2 * (this.symbol['shadowBlur'] || 0),
            margin = shadow + this.padding;
        var p = getAlignPoint(new Size(w, h), this.style['markerHorizontalAlignment'], this.style['markerVerticalAlignment']);

        if (p.x !== -w / 2) {
          p.x -= sign(p.x + w / 2) * margin;
        }

        if (p.y !== -h / 2) {
          p.y -= sign(p.y + h / 2) * margin;
        }

        return p;
      };

      _proto._getCacheImageAnchor = function _getCacheImageAnchor(w, h) {
        var shadow = 2 * (this.symbol['shadowBlur'] || 0),
            margin = shadow + this.padding;
        var markerType = this.style['markerType'];

        if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
          return new Point(w / 2, h - margin);
        } else if (markerType === 'rectangle') {
          return new Point(margin, margin);
        } else {
          return new Point(w / 2, h / 2);
        }
      };

      _proto._getGraidentExtent = function _getGraidentExtent(points) {
        var e = new PointExtent(),
            dxdy = this.getDxDy(),
            m = this.getFixedExtent();

        if (Array.isArray(points)) {
          for (var i = points.length - 1; i >= 0; i--) {
            e._combine(points[i]);
          }
        } else {
          e._combine(points);
        }

        e['xmin'] += m['xmin'] - dxdy.x;
        e['ymin'] += m['ymin'] - dxdy.y;
        e['xmax'] += m['xmax'] - dxdy.x;
        e['ymax'] += m['ymax'] - dxdy.y;
        return e;
      };

      _proto._drawVectorMarker = function _drawVectorMarker(ctx, point, resources) {
        var style = this.style,
            strokeAndFill = this.strokeAndFill,
            markerType = style['markerType'].toLowerCase(),
            vectorArray = VectorMarkerSymbolizer._getVectorPoints(markerType, style['markerWidth'], style['markerHeight']),
            lineOpacity = strokeAndFill['lineOpacity'],
            fillOpacity = strokeAndFill['polygonOpacity'];

        var gradient = isGradient(strokeAndFill['lineColor']) || isGradient(strokeAndFill['polygonFill']);

        if (gradient) {
          var gradientExtent;

          if (isGradient(strokeAndFill['lineColor'])) {
            gradientExtent = this._getGraidentExtent(point);
            strokeAndFill['lineGradientExtent'] = gradientExtent.expand(strokeAndFill['lineWidth']);
          }

          if (isGradient(strokeAndFill['polygonFill'])) {
            if (!gradientExtent) {
              gradientExtent = this._getGraidentExtent(point);
            }

            strokeAndFill['polygonGradientExtent'] = gradientExtent;
          }

          this.prepareCanvas(ctx, strokeAndFill, resources);
        }

        var width = style['markerWidth'],
            height = style['markerHeight'],
            hLineWidth = style['markerLineWidth'] / 2;

        if (markerType === 'ellipse') {
          //ellipse default
          Canvas$1.ellipse(ctx, point, width / 2, height / 2, lineOpacity, fillOpacity);
        } else if (markerType === 'cross' || markerType === 'x') {
          for (var j = vectorArray.length - 1; j >= 0; j--) {
            vectorArray[j]._add(point);
          } //线类型


          Canvas$1.path(ctx, vectorArray.slice(0, 2), lineOpacity);
          Canvas$1.path(ctx, vectorArray.slice(2, 4), lineOpacity);
        } else if (markerType === 'diamond' || markerType === 'bar' || markerType === 'square' || markerType === 'rectangle' || markerType === 'triangle') {
          if (markerType === 'bar') {
            point = point.add(0, -hLineWidth);
          } else if (markerType === 'rectangle') {
            point = point.add(hLineWidth, hLineWidth);
          }

          for (var _j = vectorArray.length - 1; _j >= 0; _j--) {
            vectorArray[_j]._add(point);
          } //面类型


          Canvas$1.polygon(ctx, vectorArray, lineOpacity, fillOpacity);
        } else if (markerType === 'pin') {
          point = point.add(0, -hLineWidth);

          for (var _j2 = vectorArray.length - 1; _j2 >= 0; _j2--) {
            vectorArray[_j2]._add(point);
          }

          var lineCap = ctx.lineCap;
          ctx.lineCap = 'round'; //set line cap to round to close the pin bottom

          Canvas$1.bezierCurveAndFill(ctx, vectorArray, lineOpacity, fillOpacity);
          ctx.lineCap = lineCap;
        } else if (markerType === 'pie') {
          point = point.add(0, hLineWidth);
          var angle = Math.atan(width / 2 / height) * 180 / Math.PI;
          var _lineCap = ctx.lineCap;
          ctx.lineCap = 'round';
          Canvas$1.sector(ctx, point, height, [90 - angle, 90 + angle], lineOpacity, fillOpacity);
          ctx.lineCap = _lineCap;
        } else {
          throw new Error('unsupported markerType: ' + markerType);
        }
      };

      _proto.getPlacement = function getPlacement() {
        return this.symbol['markerPlacement'];
      };

      _proto.getRotation = function getRotation() {
        var r = this.style['markerRotation'];

        if (!isNumber(r)) {
          return null;
        } //to radian


        return -r * Math.PI / 180;
      };

      _proto.getFixedExtent = function getFixedExtent() {
        var dxdy = this.getDxDy(),
            padding = this.padding * 2;

        var size = this._calMarkerSize().map(function (d) {
          return d - padding;
        });

        var alignPoint = this._getAnchor(size[0], size[1]);

        var result = new PointExtent(dxdy.add(0, 0), dxdy.add(size[0], size[1]));

        result._add(alignPoint);

        var rotation = this.getRotation();

        if (rotation) {
          result = this._rotateExtent(result, rotation);
        }

        return result;
      };

      _proto.translate = function translate() {
        var s = this.symbol;
        var result = {
          'markerType': getValueOrDefault(s['markerType'], 'ellipse'),
          //<----- ellipse | cross | x | triangle | diamond | square | bar | pin等,默认ellipse
          'markerFill': getValueOrDefault(s['markerFill'], '#00f'),
          //blue as cartoCSS
          'markerFillOpacity': getValueOrDefault(s['markerFillOpacity'], 1),
          'markerFillPatternFile': getValueOrDefault(s['markerFillPatternFile'], null),
          'markerLineColor': getValueOrDefault(s['markerLineColor'], '#000'),
          //black
          'markerLineWidth': getValueOrDefault(s['markerLineWidth'], 1),
          'markerLineOpacity': getValueOrDefault(s['markerLineOpacity'], 1),
          'markerLineDasharray': getValueOrDefault(s['markerLineDasharray'], []),
          'markerLinePatternFile': getValueOrDefault(s['markerLinePatternFile'], null),
          'markerDx': getValueOrDefault(s['markerDx'], 0),
          'markerDy': getValueOrDefault(s['markerDy'], 0),
          'markerWidth': getValueOrDefault(s['markerWidth'], 10),
          'markerHeight': getValueOrDefault(s['markerHeight'], 10),
          'markerRotation': getValueOrDefault(s['markerRotation'], 0)
        };
        var markerType = result['markerType'];
        var ha, va;

        if (markerType === 'bar' || markerType === 'pie' || markerType === 'pin') {
          ha = 'middle';
          va = 'top';
        } else if (markerType === 'rectangle') {
          ha = 'right';
          va = 'bottom';
        } else {
          ha = 'middle';
          va = 'middle';
        }

        result['markerHorizontalAlignment'] = getValueOrDefault(s['markerHorizontalAlignment'], ha); //left | middle | right

        result['markerVerticalAlignment'] = getValueOrDefault(s['markerVerticalAlignment'], va); // top | middle | bottom
        //markerOpacity覆盖fillOpacity和lineOpacity

        if (isNumber(s['markerOpacity'])) {
          if (isNumber(s['markerFillOpacity'])) {
            result['markerFillOpacity'] *= s['markerOpacity'];
          }

          if (isNumber(s['markerLineOpacity'])) {
            result['markerLineOpacity'] *= s['markerOpacity'];
          }
        }

        return result;
      };

      VectorMarkerSymbolizer.translateLineAndFill = function translateLineAndFill(s) {
        var result = {
          'lineColor': s['markerLineColor'],
          'linePatternFile': s['markerLinePatternFile'],
          'lineWidth': s['markerLineWidth'],
          'lineOpacity': s['markerLineOpacity'],
          'lineDasharray': s['markerLineDasharray'],
          'lineCap': 'butt',
          'lineJoin': 'round',
          'polygonFill': s['markerFill'],
          'polygonPatternFile': s['markerFillPatternFile'],
          'polygonOpacity': s['markerFillOpacity']
        };

        if (result['lineWidth'] === 0) {
          result['lineOpacity'] = 0;
        }

        return result;
      };

      VectorMarkerSymbolizer._getVectorPoints = function _getVectorPoints(markerType, width, height) {
        //half height and half width
        var hh = height / 2,
            hw = width / 2;
        var left = 0,
            top = 0;
        var v0, v1, v2, v3;

        if (markerType === 'triangle') {
          v0 = new Point(left, top - hh);
          v1 = new Point(left - hw, top + hh);
          v2 = new Point(left + hw, top + hh);
          return [v0, v1, v2];
        } else if (markerType === 'cross') {
          v0 = new Point(left - hw, top);
          v1 = new Point(left + hw, top);
          v2 = new Point(left, top - hh);
          v3 = new Point(left, top + hh);
          return [v0, v1, v2, v3];
        } else if (markerType === 'diamond') {
          v0 = new Point(left - hw, top);
          v1 = new Point(left, top - hh);
          v2 = new Point(left + hw, top);
          v3 = new Point(left, top + hh);
          return [v0, v1, v2, v3];
        } else if (markerType === 'square') {
          v0 = new Point(left - hw, top + hh);
          v1 = new Point(left + hw, top + hh);
          v2 = new Point(left + hw, top - hh);
          v3 = new Point(left - hw, top - hh);
          return [v0, v1, v2, v3];
        } else if (markerType === 'rectangle') {
          v0 = new Point(left, top);
          v1 = v0.add(width, 0);
          v2 = v0.add(width, height);
          v3 = v0.add(0, height);
          return [v0, v1, v2, v3];
        } else if (markerType === 'x') {
          v0 = new Point(left - hw, top + hh);
          v1 = new Point(left + hw, top - hh);
          v2 = new Point(left + hw, top + hh);
          v3 = new Point(left - hw, top - hh);
          return [v0, v1, v2, v3];
        } else if (markerType === 'bar') {
          v0 = new Point(left - hw, top - height);
          v1 = new Point(left + hw, top - height);
          v2 = new Point(left + hw, top);
          v3 = new Point(left - hw, top);
          return [v0, v1, v2, v3];
        } else if (markerType === 'pin') {
          var extWidth = height * Math.atan(hw / hh);
          v0 = new Point(left, top);
          v1 = new Point(left - extWidth, top - height);
          v2 = new Point(left + extWidth, top - height);
          v3 = new Point(left, top);
          return [v0, v1, v2, v3];
        }

        return [];
      };

      return VectorMarkerSymbolizer;
    }(PointSymbolizer);

    var DebugSymbolizer =
    /*#__PURE__*/
    function (_PointSymbolizer) {
      _inheritsLoose(DebugSymbolizer, _PointSymbolizer);

      function DebugSymbolizer() {
        return _PointSymbolizer.apply(this, arguments) || this;
      }

      var _proto = DebugSymbolizer.prototype;

      _proto.getPlacement = function getPlacement() {
        return 'point';
      };

      _proto.getDxDy = function getDxDy() {
        return new Point(0, 0);
      };

      _proto.symbolize = function symbolize(ctx) {
        var geometry = this.geometry,
            layer = geometry.getLayer();

        if (!geometry.options['debug'] && layer && !layer.options['debug']) {
          return;
        }

        var map = this.getMap();

        if (!map || map.isZooming()) {
          return;
        }

        var color = layer.options['debugOutline'],
            op = 1;
        ctx.strokeStyle = color;
        ctx.fillStyle = color; //outline

        var outline = this.getPainter().getContainerExtent().toArray();
        Canvas$1.polygon(ctx, [outline], op, 0); //center cross and id if have any.

        var points = this._getRenderContainerPoints(),
            id = this.geometry.getId(),
            cross = VectorMarkerSymbolizer._getVectorPoints('cross', 10, 10);

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          if (!isNil(id)) {
            Canvas$1.fillText(ctx, id, p.add(8, -4), color);
          }

          var c = [];

          for (var ii = 0; ii < cross.length; ii++) {
            c.push(cross[ii].add(p));
          }

          Canvas$1.path(ctx, c.slice(0, 2), op);
          Canvas$1.path(ctx, c.slice(2, 4), op);
        }
      };

      return DebugSymbolizer;
    }(PointSymbolizer);

    var ImageMarkerSymbolizer =
    /*#__PURE__*/
    function (_PointSymbolizer) {
      _inheritsLoose(ImageMarkerSymbolizer, _PointSymbolizer);

      ImageMarkerSymbolizer.test = function test(symbol) {
        if (!symbol) {
          return false;
        }

        if (!isNil(symbol['markerFile'])) {
          return true;
        }

        return false;
      };

      function ImageMarkerSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
        _this.style = _this._defineStyle(_this.translate());
        return _this;
      }

      var _proto = ImageMarkerSymbolizer.prototype;

      _proto.symbolize = function symbolize(ctx, resources) {
        var style = this.style;

        if (!this.painter.isHitTesting() && (style['markerWidth'] === 0 || style['markerHeight'] === 0 || style['markerOpacity'] === 0)) {
          return;
        }

        var cookedPoints = this._getRenderContainerPoints();

        if (!isArrayHasData(cookedPoints)) {
          return;
        }

        var img = this._getImage(resources);

        if (!img) {
          if (typeof console !== 'undefined') {
            console.warn('no img found for ' + (this.style['markerFile'] || this._url[0]));
          }

          return;
        }

        this._prepareContext(ctx);

        var width = style['markerWidth'];
        var height = style['markerHeight'];

        if (!isNumber(width) || !isNumber(height)) {
          width = img.width;
          height = img.height;
          style['markerWidth'] = width;
          style['markerHeight'] = height;
          var imgURL = [style['markerFile'], style['markerWidth'], style['markerHeight']];

          if (!resources.isResourceLoaded(imgURL)) {
            resources.addResource(imgURL, img);
          }

          var painter = this.getPainter();

          if (!painter.isSpriting()) {
            painter.removeCache();
          }
        }

        var alpha; // for VectorPathMarkerSymbolizer, opacity is already set into SVG element.

        if (this.symbol['markerType'] !== 'path' && isNumber(style['markerOpacity']) && style['markerOpacity'] < 1) {
          alpha = ctx.globalAlpha;
          ctx.globalAlpha *= style['markerOpacity'];
        }

        var alignPoint = getAlignPoint(new Size(width, height), style['markerHorizontalAlignment'], style['markerVerticalAlignment']);

        for (var i = 0, len = cookedPoints.length; i < len; i++) {
          var p = cookedPoints[i];

          var origin = this._rotate(ctx, p, this._getRotationAt(i));

          if (origin) {
            p = origin;
          }

          Canvas$1.image(ctx, img, p.x + alignPoint.x, p.y + alignPoint.y, width, height);

          if (origin) {
            ctx.restore();
          }
        }

        if (alpha !== undefined) {
          ctx.globalAlpha = alpha;
        }
      };

      _proto._getImage = function _getImage(resources) {
        var img = !resources ? null : resources.getImage([this.style['markerFile'], this.style['markerWidth'], this.style['markerHeight']]);
        return img;
      };

      _proto.getPlacement = function getPlacement() {
        return this.symbol['markerPlacement'];
      };

      _proto.getRotation = function getRotation() {
        var r = this.style['markerRotation'];

        if (!isNumber(r)) {
          return null;
        } //to radian


        return -r * Math.PI / 180;
      };

      _proto.getDxDy = function getDxDy() {
        var s = this.style;
        var dx = s['markerDx'],
            dy = s['markerDy'];
        return new Point(dx, dy);
      };

      _proto.getFixedExtent = function getFixedExtent(resources) {
        var style = this.style;
        var url = style['markerFile'],
            img = resources ? resources.getImage(url) : null;
        var width = style['markerWidth'] || (img ? img.width : 0),
            height = style['markerHeight'] || (img ? img.height : 0);
        var dxdy = this.getDxDy();
        var alignPoint = getAlignPoint(new Size(width, height), style['markerHorizontalAlignment'], style['markerVerticalAlignment']);
        var result = new PointExtent(dxdy.add(0, 0), dxdy.add(width, height));

        result._add(alignPoint);

        var rotation = this.getRotation();

        if (rotation) {
          result = this._rotateExtent(result, rotation);
        }

        return result;
      };

      _proto.translate = function translate() {
        var s = this.symbol;
        return {
          'markerFile': s['markerFile'],
          'markerOpacity': getValueOrDefault(s['markerOpacity'], 1),
          'markerWidth': getValueOrDefault(s['markerWidth'], null),
          'markerHeight': getValueOrDefault(s['markerHeight'], null),
          'markerRotation': getValueOrDefault(s['markerRotation'], 0),
          'markerDx': getValueOrDefault(s['markerDx'], 0),
          'markerDy': getValueOrDefault(s['markerDy'], 0),
          'markerHorizontalAlignment': getValueOrDefault(s['markerHorizontalAlignment'], 'middle'),
          //left | middle | right
          'markerVerticalAlignment': getValueOrDefault(s['markerVerticalAlignment'], 'top') // top | middle | bottom

        };
      };

      return ImageMarkerSymbolizer;
    }(PointSymbolizer);

    var TEMP_COORD0$1 = new Coordinate(0, 0);
    var TEMP_COORD1$1 = new Coordinate(0, 0);

    var StrokeAndFillSymbolizer =
    /*#__PURE__*/
    function (_CanvasSymbolizer) {
      _inheritsLoose(StrokeAndFillSymbolizer, _CanvasSymbolizer);

      StrokeAndFillSymbolizer.test = function test(symbol, geometry) {
        if (!symbol) {
          return false;
        }

        if (geometry && geometry.type === 'Point') {
          return false;
        }

        for (var p in symbol) {
          var f = p.slice(0, 4);

          if (f === 'line' || f === 'poly') {
            return true;
          }
        }

        return false;
      };

      function StrokeAndFillSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _CanvasSymbolizer.call(this) || this;
        _this.symbol = symbol;
        _this.geometry = geometry;
        _this.painter = painter;

        if (geometry.type === 'Point') {
          return _assertThisInitialized(_this);
        }

        _this.style = _this._defineStyle(_this.translate());
        return _this;
      }

      var _proto = StrokeAndFillSymbolizer.prototype;

      _proto.symbolize = function symbolize(ctx, resources) {
        var style = this.style;

        if (style['polygonOpacity'] === 0 && style['lineOpacity'] === 0 && !this.painter.isHitTesting()) {
          return;
        }

        var paintParams = this._getPaintParams();

        if (!paintParams) {
          return;
        }

        this._prepareContext(ctx);

        var isGradient$$1 = isGradient(style['lineColor']),
            isPath = this.geometry.getJSONType() === 'Polygon' || this.geometry.type === 'LineString';

        if (isGradient$$1 && (style['lineColor']['places'] || !isPath)) {
          style['lineGradientExtent'] = this.getPainter().getContainerExtent()._expand(style['lineWidth']);
        }

        if (isGradient(style['polygonFill'])) {
          style['polygonGradientExtent'] = this.getPainter().getContainerExtent();
        }

        var points = paintParams[0],
            isSplitted = this.geometry.getJSONType() === 'Polygon' && points.length > 0 && Array.isArray(points[0][0]) || this.geometry.type === 'LineString' && points.length > 0 && Array.isArray(points[0]);

        if (isSplitted) {
          for (var i = 0; i < points.length; i++) {
            this.prepareCanvas(ctx, style, resources);

            if (isGradient$$1 && isPath && !style['lineColor']['places']) {
              this._createGradient(ctx, points[i], style['lineColor']);
            }

            var params = [ctx, points[i]];

            if (paintParams.length > 1) {
              params.push.apply(params, paintParams.slice(1));
            }

            params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);

            this.geometry._paintOn.apply(this.geometry, params);
          }
        } else {
          this.prepareCanvas(ctx, style, resources);

          if (isGradient$$1 && isPath && !style['lineColor']['places']) {
            this._createGradient(ctx, points, style['lineColor']);
          }

          var _params = [ctx];

          _params.push.apply(_params, paintParams);

          _params.push(style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);

          this.geometry._paintOn.apply(this.geometry, _params);
        }

        if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
          ctx.setLineDash([]);
        }
      };

      _proto.get2DExtent = function get2DExtent() {
        var map = this.getMap();

        var extent = this.geometry._getPrjExtent();

        if (!extent) {
          return null;
        } // this ugly implementation is to improve perf as we can
        // it tries to avoid creating instances to save cpu consumption.


        if (!this._extMin || !this._extMax) {
          this._extMin = new Coordinate(0, 0);
          this._extMax = new Coordinate(0, 0);
        }

        this._extMin.x = extent['xmin'];
        this._extMin.y = extent['ymin'];
        this._extMax.x = extent['xmax'];
        this._extMax.y = extent['ymax'];

        var min = map._prjToPoint(this._extMin, undefined, TEMP_COORD0$1),
            max = map._prjToPoint(this._extMax, undefined, TEMP_COORD1$1);

        if (!this._pxExtent) {
          this._pxExtent = new PointExtent(min, max);
        } else {
          this._pxExtent.set(Math.min(min.x, max.x), Math.min(min.y, max.y), Math.max(min.x, max.x), Math.max(min.y, max.y));
        }

        return this._pxExtent;
      };

      _proto.getFixedExtent = function getFixedExtent() {
        var t = this.style['lineWidth'] / 2;
        return new PointExtent(-t, -t, t, t);
      };

      _proto._getPaintParams = function _getPaintParams() {
        return this.getPainter().getPaintParams(this.style['lineDx'], this.style['lineDy']);
      };

      _proto.translate = function translate() {
        var s = this.symbol;
        var result = {
          'lineColor': getValueOrDefault(s['lineColor'], '#000'),
          'lineWidth': getValueOrDefault(s['lineWidth'], 2),
          'lineOpacity': getValueOrDefault(s['lineOpacity'], 1),
          'lineDasharray': getValueOrDefault(s['lineDasharray'], []),
          'lineCap': getValueOrDefault(s['lineCap'], 'butt'),
          //“butt”, “square”, “round”
          'lineJoin': getValueOrDefault(s['lineJoin'], 'miter'),
          //“bevel”, “round”, “miter”
          'linePatternFile': getValueOrDefault(s['linePatternFile'], null),
          'lineDx': getValueOrDefault(s['lineDx'], 0),
          'lineDy': getValueOrDefault(s['lineDy'], 0),
          'polygonFill': getValueOrDefault(s['polygonFill'], null),
          'polygonOpacity': getValueOrDefault(s['polygonOpacity'], 1),
          'polygonPatternFile': getValueOrDefault(s['polygonPatternFile'], null),
          'polygonPatternDx': getValueOrDefault(s['polygonPatternDx'], 0),
          'polygonPatternDy': getValueOrDefault(s['polygonPatternDy'], 0),
          'linePatternDx': getValueOrDefault(s['linePatternDx'], 0),
          'linePatternDy': getValueOrDefault(s['linePatternDy'], 0)
        };

        if (result['lineWidth'] === 0) {
          result['lineOpacity'] = 0;
        } // fill of arrow


        if (this.geometry.type === 'LineString' && !result['polygonFill']) {
          result['polygonFill'] = result['lineColor'];
        }

        return result;
      };

      _proto._createGradient = function _createGradient(ctx, points, lineColor) {
        if (!Array.isArray(points) || !points.length) {
          return;
        }

        var len = points.length;
        var grad = ctx.createLinearGradient(points[0].x, points[0].y, points[len - 1].x, points[len - 1].y);
        lineColor['colorStops'].forEach(function (stop) {
          grad.addColorStop.apply(grad, stop);
        });
        ctx.strokeStyle = grad;
      };

      return StrokeAndFillSymbolizer;
    }(CanvasSymbolizer);

    var CACHE_KEY = '___text_symbol_cache';

    var TextMarkerSymbolizer =
    /*#__PURE__*/
    function (_PointSymbolizer) {
      _inheritsLoose(TextMarkerSymbolizer, _PointSymbolizer);

      TextMarkerSymbolizer.test = function test(symbol) {
        if (!symbol) {
          return false;
        }

        if (!isNil(symbol['textName'])) {
          return true;
        }

        return false;
      };

      function TextMarkerSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
        _this._dynamic = hasFunctionDefinition(symbol);
        _this.style = _this._defineStyle(_this.translate());

        if (_this.style['textWrapWidth'] === 0) {
          return _assertThisInitialized(_this);
        }

        _this.strokeAndFill = _this._defineStyle(_this.translateLineAndFill(_this.style));
        var textContent = replaceVariable(_this.style['textName'], _this.geometry.getProperties());

        if (!_this._dynamic) {
          // the key to cache text descriptor
          _this._cacheKey = genCacheKey(textContent, _this.style);
        }

        _this._descText(textContent);

        return _this;
      }

      var _proto = TextMarkerSymbolizer.prototype;

      _proto.symbolize = function symbolize(ctx, resources) {
        if (!this.painter.isHitTesting() && (this.style['textSize'] === 0 || !this.style['textOpacity'] && (!this.style['textHaloRadius'] || !this.style['textHaloOpacity']) || this.style['textWrapWidth'] === 0)) {
          return;
        }

        var cookedPoints = this._getRenderContainerPoints();

        if (!isArrayHasData(cookedPoints)) {
          return;
        }

        var style = this.style,
            strokeAndFill = this.strokeAndFill;
        var textContent = replaceVariable(this.style['textName'], this.geometry.getProperties());

        this._descText(textContent);

        this._prepareContext(ctx);

        this.prepareCanvas(ctx, strokeAndFill, resources);
        Canvas$1.prepareCanvasFont(ctx, style);

        for (var i = 0, len = cookedPoints.length; i < len; i++) {
          var p = cookedPoints[i];

          var origin = this._rotate(ctx, p, this._getRotationAt(i));

          if (origin) {
            p = origin;
          }

          Canvas$1.text(ctx, textContent, p, style, this.textDesc);

          if (origin) {
            ctx.restore();
          }
        }
      };

      _proto.getPlacement = function getPlacement() {
        return this.symbol['textPlacement'];
      };

      _proto.getRotation = function getRotation() {
        var r = this.style['textRotation'];

        if (!isNumber(r)) {
          return null;
        } //to radian


        return -r * Math.PI / 180;
      };

      _proto.getDxDy = function getDxDy() {
        var s = this.style;
        return new Point(s['textDx'], s['textDy']);
      };

      _proto.getFixedExtent = function getFixedExtent() {
        var dxdy = this.getDxDy(),
            style = this.style;
        var size = this.textDesc['size'];
        var alignPoint = getAlignPoint(size, style['textHorizontalAlignment'], style['textVerticalAlignment']);
        var alignW = alignPoint.x,
            alignH = alignPoint.y;

        if (style['textHaloRadius']) {
          var r = style['textHaloRadius'];
          size = size.add(r * 2, r * 2);
        }

        var result = new PointExtent(dxdy.add(alignW, alignH), dxdy.add(alignW + size['width'], alignH + size['height']));
        var rotation = this.getRotation();

        if (rotation) {
          result = this._rotateExtent(result, rotation);
        }

        return result;
      };

      _proto.translate = function translate() {
        var s = this.symbol;
        var result = {
          'textName': s['textName'],
          'textFaceName': getValueOrDefault(s['textFaceName'], 'monospace'),
          'textWeight': getValueOrDefault(s['textWeight'], 'normal'),
          //'bold', 'bolder'
          'textStyle': getValueOrDefault(s['textStyle'], 'normal'),
          //'italic', 'oblique'
          'textSize': getValueOrDefault(s['textSize'], DEFAULT_TEXT_SIZE),
          'textFont': getValueOrDefault(s['textFont'], null),
          'textFill': getValueOrDefault(s['textFill'], '#000'),
          'textOpacity': getValueOrDefault(s['textOpacity'], 1),
          'textHaloFill': getValueOrDefault(s['textHaloFill'], '#ffffff'),
          'textHaloRadius': getValueOrDefault(s['textHaloRadius'], 0),
          'textHaloOpacity': getValueOrDefault(s['textHaloOpacity'], 1),
          'textWrapWidth': getValueOrDefault(s['textWrapWidth'], null),
          'textWrapCharacter': getValueOrDefault(s['textWrapCharacter'], '\n'),
          'textLineSpacing': getValueOrDefault(s['textLineSpacing'], 0),
          'textDx': getValueOrDefault(s['textDx'], 0),
          'textDy': getValueOrDefault(s['textDy'], 0),
          'textHorizontalAlignment': getValueOrDefault(s['textHorizontalAlignment'], 'middle'),
          //left | middle | right | auto
          'textVerticalAlignment': getValueOrDefault(s['textVerticalAlignment'], 'middle'),
          // top | middle | bottom | auto
          'textAlign': getValueOrDefault(s['textAlign'], 'center'),
          //left | right | center | auto
          'textRotation': getValueOrDefault(s['textRotation'], 0),
          'textMaxWidth': getValueOrDefault(s['textMaxWidth'], 0),
          'textMaxHeight': getValueOrDefault(s['textMaxHeight'], 0)
        };

        if (result['textMaxWidth'] > 0 && (!result['textWrapWidth'] || result['textWrapWidth'] > result['textMaxWidth'])) {
          if (!result['textWrapWidth']) {
            result['textMaxHeight'] = 1;
          }

          result['textWrapWidth'] = result['textMaxWidth'];
        }

        return result;
      };

      _proto.translateLineAndFill = function translateLineAndFill(s) {
        return {
          'lineColor': s['textHaloRadius'] ? s['textHaloFill'] : s['textFill'],
          'lineWidth': s['textHaloRadius'],
          'lineOpacity': s['textOpacity'],
          'lineDasharray': null,
          'lineCap': 'butt',
          'lineJoin': 'round',
          'polygonFill': s['textFill'],
          'polygonOpacity': s['textOpacity']
        };
      };

      _proto._descText = function _descText(textContent) {
        if (this._dynamic) {
          this.textDesc = this._measureText(textContent);
          return;
        }

        this.textDesc = this._loadFromCache();

        if (!this.textDesc) {
          this.textDesc = this._measureText(textContent);

          this._storeToCache(this.textDesc);
        }
      };

      _proto._measureText = function _measureText(textContent) {
        var maxHeight = this.style['textMaxHeight'];
        var textDesc = splitTextToRow(textContent, this.style);

        if (maxHeight && maxHeight < textDesc.size.height) {
          textDesc.size.height = maxHeight;
        }

        return textDesc;
      };

      _proto._storeToCache = function _storeToCache(textDesc) {
        if (IS_NODE) {
          return;
        }

        if (!this.geometry[CACHE_KEY]) {
          this.geometry[CACHE_KEY] = {};
        }

        this.geometry[CACHE_KEY][this._cacheKey] = {
          'desc': textDesc,
          'active': true
        };
      };

      _proto._loadFromCache = function _loadFromCache() {
        if (!this.geometry[CACHE_KEY]) {
          return null;
        }

        var cache = this.geometry[CACHE_KEY][this._cacheKey];

        if (!cache) {
          return null;
        }

        cache.active = true;
        return cache.desc;
      };

      return TextMarkerSymbolizer;
    }(PointSymbolizer);
    TextMarkerSymbolizer.CACHE_KEY = CACHE_KEY;

    function genCacheKey(textContent, style) {
      var key = [textContent];

      for (var p in style) {
        if (style.hasOwnProperty(p) && p.length > 4 && p.substring(0, 4) === 'text') {
          key.push(p + '=' + style[p]);
        }
      }

      return key.join('-');
    }

    var VectorPathMarkerSymbolizer =
    /*#__PURE__*/
    function (_ImageMarkerSymbolize) {
      _inheritsLoose(VectorPathMarkerSymbolizer, _ImageMarkerSymbolize);

      VectorPathMarkerSymbolizer.test = function test(symbol) {
        if (!symbol) {
          return false;
        }

        if (isNil(symbol['markerFile']) && symbol['markerType'] === 'path') {
          return true;
        }

        return false;
      };

      function VectorPathMarkerSymbolizer(symbol, geometry, painter) {
        var _this;

        //IE must have a valid width and height to draw a svg image
        //otherwise, error will be thrown
        if (isNil(symbol['markerWidth'])) {
          symbol['markerWidth'] = 80;
        }

        if (isNil(symbol['markerHeight'])) {
          symbol['markerHeight'] = 80;
        }

        _this = _ImageMarkerSymbolize.call(this, symbol, geometry, painter) || this;
        symbol = extend(symbol, _this.translate());

        var style = _this.style = _this._defineStyle(symbol);

        if (Browser$1.gecko) {
          // Firefox requires valid width and height attributes in SVG's root element.
          _this._url = [getMarkerPathBase64(style, style['markerWidth'], style['markerHeight']), style['markerWidth'], style['markerHeight']];
        } else {
          _this._url = [getMarkerPathBase64(style), style['markerWidth'], style['markerHeight']];
        }

        return _this;
      }

      var _proto = VectorPathMarkerSymbolizer.prototype;

      _proto._prepareContext = function _prepareContext() {//for VectorPathMarkerSymbolizer, opacity is already added into SVG element.
      };

      _proto._getImage = function _getImage(resources) {
        var _this2 = this;

        if (resources && resources.isResourceLoaded(this._url)) {
          return resources.getImage(this._url);
        }

        var painter = this.painter;
        var image = new Image();

        image.onload = function () {
          var renderer = painter.getLayer() && painter.getLayer().getRenderer();

          if (renderer) {
            renderer.setToRedraw();
          }
        };

        image.onerror = function (err) {
          if (err && typeof console !== 'undefined') {
            console.warn(err);
          }

          resources.markErrorResource(_this2._url);
        };

        image.src = this._url[0];

        if (resources) {
          resources.addResource(this._url, image);
        }

        return image; // return resources ? resources.getImage(this._url) : null;
      };

      return VectorPathMarkerSymbolizer;
    }(ImageMarkerSymbolizer);

    var defaultSymbol = {
      lineWidth: 1,
      polygonFill: '#fff',
      polygonOpacity: 0.5
    };

    var DrawAltitudeSymbolizer =
    /*#__PURE__*/
    function (_PointSymbolizer) {
      _inheritsLoose(DrawAltitudeSymbolizer, _PointSymbolizer);

      DrawAltitudeSymbolizer.test = function test(symbol, geometry) {
        var layer = geometry.getLayer();

        if (!layer) {
          return false;
        }

        var type = geometry.getJSONType(); // shoule be a point or linestring

        return type === 'Marker' || type === 'LineString';
      };

      function DrawAltitudeSymbolizer(symbol, geometry, painter) {
        var _this;

        _this = _PointSymbolizer.call(this, symbol, geometry, painter) || this;
        _this.style = geometry.getLayer().options['drawAltitude'];

        if (!_this.style || !isObject(_this.style)) {
          _this.style = {
            'lineWidth': 2
          };
        }

        if (!_this.style['lineWidth']) {
          // for get2DExtent
          _this.style['lineWidth'] = 0;
        }

        _this.dxdy = _this._defineStyle({
          'dx': symbol['textDx'] || symbol['markerDx'],
          'dy': symbol['textDy'] || symbol['markerDy']
        });
        return _this;
      }

      var _proto = DrawAltitudeSymbolizer.prototype;

      _proto.symbolize = function symbolize(ctx) {
        var layer = this.geometry.getLayer();

        if (!layer.options['drawAltitude']) {
          return;
        }

        var properties = this.geometry.getProperties();

        if (!properties || !properties[layer.options['altitudeProperty']]) {
          return;
        }

        var style = this._getStyle();

        this._prepareContext(ctx);

        if (this.geometry.type === 'LineString') {
          var paintParams = this._getPaintParams(style['lineDx'], style['lineDy']);

          if (!paintParams) {
            return;
          } //container points that ignore altitude


          var groundPoints = this.getPainter().getPaintParams(style['lineDx'], style['lineDy'], true)[0];

          this._drawLineAltitude(ctx, paintParams[0], groundPoints);
        } else {
          var point = this._getRenderContainerPoints(),
              groundPoint = this._getRenderContainerPoints(true);

          if (!point || point.length === 0) {
            return;
          }

          this._drawMarkerAltitude(ctx, point[0], groundPoint[0]);
        }
      };

      _proto.getDxDy = function getDxDy() {
        var s = this.dxdy;
        return new Point(s['dx'] || 0, s['dy'] || 0);
      };

      _proto.get2DExtent = function get2DExtent() {
        if (this.geometry.type === 'LineString') {
          return StrokeAndFillSymbolizer.prototype.get2DExtent.apply(this);
        } else {
          return _PointSymbolizer.prototype.get2DExtent.call(this);
        }
      };

      _proto.getPlacement = function getPlacement() {
        return 'point';
      };

      _proto._getPaintParams = function _getPaintParams(dx, dy) {
        return this.getPainter().getPaintParams(dx || 0, dy || 0);
      };

      _proto._drawMarkerAltitude = function _drawMarkerAltitude(ctx, point, groundPoint) {
        var style = this._getStyle();

        this.prepareCanvas(ctx, style);
        Canvas$1.path(ctx, [point, groundPoint], style['lineOpacity'], null, style['lineDasharray']);
      };

      _proto._drawLineAltitude = function _drawLineAltitude(ctx, points, groundPoints) {
        var style = this._getStyle();

        var isSplitted = points.length > 0 && Array.isArray(points[0]);

        if (isSplitted) {
          for (var i = 0; i < points.length; i++) {
            this._drawLine(ctx, points[i], groundPoints[i]);
          }
        } else {
          this._drawLine(ctx, points, groundPoints);
        }

        if (ctx.setLineDash && Array.isArray(style['lineDasharray'])) {
          ctx.setLineDash([]);
        }
      };

      _proto._drawLine = function _drawLine(ctx, points, groundPoints) {
        var style = this._getStyle();

        this.prepareCanvas(ctx, style);

        for (var i = 0, l = points.length - 1; i < l; i++) {
          Canvas$1.polygon(ctx, [points[i], points[i + 1], groundPoints[i + 1], groundPoints[i]], style['lineOpacity'], style['polygonOpacity'], style['lineDasharray']);
        }
      };

      _proto._getStyle = function _getStyle() {
        // read drawAltitude from layer every time
        var style = this.geometry.getLayer().options['drawAltitude'];

        if (!isObject(style)) {
          style = defaultSymbol;
        }

        if (!style['lineWidth']) {
          // for get2DExtent
          style['lineWidth'] = 0;
          style['lineOpacity'] = 0;
        }

        return style;
      };

      return DrawAltitudeSymbolizer;
    }(PointSymbolizer);



    var index$3 = /*#__PURE__*/Object.freeze({
        Symbolizer: Symbolizer,
        CanvasSymbolizer: CanvasSymbolizer,
        DebugSymbolizer: DebugSymbolizer,
        ImageMarkerSymbolizer: ImageMarkerSymbolizer,
        PointSymbolizer: PointSymbolizer,
        StrokeAndFillSymbolizer: StrokeAndFillSymbolizer,
        TextMarkerSymbolizer: TextMarkerSymbolizer,
        VectorMarkerSymbolizer: VectorMarkerSymbolizer,
        VectorPathMarkerSymbolizer: VectorPathMarkerSymbolizer,
        DrawAltitudeSymbolizer: DrawAltitudeSymbolizer
    });

    //the latter will paint at the last

    var registerSymbolizers = [DrawAltitudeSymbolizer, StrokeAndFillSymbolizer, ImageMarkerSymbolizer, VectorPathMarkerSymbolizer, VectorMarkerSymbolizer, TextMarkerSymbolizer];
    var testCanvas;
    var TEMP_POINT0$2 = new Point(0, 0);
    var TEMP_POINT1$1 = new Point(0, 0);
    var TEMP_POINT2 = new Point(0, 0);
    var TEMP_PAINT_EXTENT = new PointExtent();
    var TEMP_EXTENT$1 = new PointExtent();
    var TEMP_FIXED_EXTENT = new PointExtent();
    var TEMP_CLIP_EXTENT0 = new PointExtent();
    var TEMP_CLIP_EXTENT1 = new PointExtent(); // const TEMP_CONTAINER_EXTENT = new PointExtent();

    /**
     * @classdesc
     * Painter class for all geometry types except the collection types.
     * @class
     * @private
     */

    var Painter =
    /*#__PURE__*/
    function (_Class) {
      _inheritsLoose(Painter, _Class);

      /**
       *  @param {Geometry} geometry - geometry to paint
       */
      function Painter(geometry) {
        var _this;

        _this = _Class.call(this) || this;
        _this.geometry = geometry;
        _this.symbolizers = _this._createSymbolizers();
        _this._altAtGLZoom = _this._getGeometryAltitude();
        return _this;
      }

      var _proto = Painter.prototype;

      _proto.getMap = function getMap() {
        return this.geometry.getMap();
      };

      _proto.getLayer = function getLayer() {
        return this.geometry.getLayer();
      }
      /**
       * create symbolizers
       */
      ;

      _proto._createSymbolizers = function _createSymbolizers() {
        var geoSymbol = this.getSymbol(),
            symbolizers = [],
            regSymbolizers = registerSymbolizers;
        var symbols = geoSymbol;

        if (!Array.isArray(geoSymbol)) {
          symbols = [geoSymbol];
        }

        for (var ii = symbols.length - 1; ii >= 0; ii--) {
          var symbol = symbols[ii];

          for (var i = regSymbolizers.length - 1; i >= 0; i--) {
            if (regSymbolizers[i].test(symbol, this.geometry)) {
              var symbolizer = new regSymbolizers[i](symbol, this.geometry, this);
              symbolizers.push(symbolizer);

              if (symbolizer instanceof PointSymbolizer) {
                this._hasPoint = true;
              }
            }
          }
        }

        if (!symbolizers.length) {
          if (console) {
            var id = this.geometry.getId();
            console.warn('invalid symbol for geometry(' + (this.geometry ? this.geometry.getType() + (id ? ':' + id : '') : '') + ') to draw : ' + JSON.stringify(geoSymbol));
          } // throw new Error('no symbolizers can be created to draw, check the validity of the symbol.');

        }

        this._debugSymbolizer = new DebugSymbolizer(geoSymbol, this.geometry, this);
        return symbolizers;
      };

      _proto.hasPoint = function hasPoint() {
        return !!this._hasPoint;
      }
      /**
       * for point symbolizers
       * @return {Point[]} points to render
       */
      ;

      _proto.getRenderPoints = function getRenderPoints(placement) {
        if (!this._renderPoints) {
          this._renderPoints = {};
        }

        if (!placement) {
          placement = 'center';
        }

        if (!this._renderPoints[placement]) {
          this._renderPoints[placement] = this.geometry._getRenderPoints(placement);
        }

        return this._renderPoints[placement];
      }
      /**
       * for strokeAndFillSymbolizer
       * @return {Object[]} resources to render vector
       */
      ;

      _proto.getPaintParams = function getPaintParams(dx, dy, ignoreAltitude) {
        var map = this.getMap(),
            geometry = this.geometry,
            res = map.getResolution(),
            pitched = map.getPitch() !== 0,
            rotated = map.getBearing() !== 0;
        var params = this._cachedParams;

        var paintAsPath = geometry._paintAsPath && geometry._paintAsPath();

        if (paintAsPath && this._unsimpledParams && res <= this._unsimpledParams._res) {
          //if res is smaller, return unsimplified params directly
          params = this._unsimpledParams;
        } else if (!params || // refresh paint params
        // simplified, but not same zoom
        params._res !== map.getResolution() || // refresh if requested by geometry
        this._pitched !== pitched && geometry._redrawWhenPitch() || this._rotated !== rotated && geometry._redrawWhenRotate()) {
          //render resources geometry returned are based on 2d points.
          params = geometry._getPaintParams();

          if (!params) {
            return null;
          }

          params._res = res;

          if (!geometry._simplified && paintAsPath) {
            if (!this._unsimpledParams) {
              this._unsimpledParams = params;
            }

            if (res > this._unsimpledParams._res) {
              this._unsimpledParams._res = res;
            }
          }

          this._cachedParams = params;
        }

        if (!params) {
          return null;
        }

        this._pitched = pitched;
        this._rotated = rotated;
        var zoomScale = map.getGLScale(),
            // paintParams = this._paintParams,
        tr = [],
            // transformed params
        points = params[0];
        var mapExtent = map.getContainerExtent();

        var cPoints = this._pointContainerPoints(points, dx, dy, ignoreAltitude, this._hitPoint && !mapExtent.contains(this._hitPoint));

        if (!cPoints) {
          return null;
        }

        tr.push(cPoints);

        for (var i = 1, l = params.length; i < l; i++) {
          if (isNumber(params[i]) || params[i] instanceof Size) {
            if (isNumber(params[i])) {
              tr.push(params[i] / zoomScale);
            } else {
              tr.push(params[i].multi(1 / zoomScale));
            }
          } else {
            tr.push(params[i]);
          }
        }

        return tr;
      };

      _proto._pointContainerPoints = function _pointContainerPoints(points, dx, dy, ignoreAltitude, disableClip, pointPlacement) {
        if (this._aboveCamera()) {
          return null;
        }

        var map = this.getMap(),
            glZoom = map.getGLZoom(),
            containerOffset = this.containerOffset;
        var cPoints;

        function pointContainerPoint(point, alt) {
          var p = map._pointToContainerPoint(point, glZoom, alt)._sub(containerOffset);

          if (dx || dy) {
            p._add(dx || 0, dy || 0);
          }

          return p;
        }

        var altitude = this.getAltitude(); //convert 2d points to container points needed by canvas

        if (Array.isArray(points)) {
          var geometry = this.geometry;
          var clipped;

          if (!disableClip && geometry.options['enableClip']) {
            clipped = this._clip(points, altitude);
          } else {
            clipped = {
              points: points,
              altitude: altitude
            };
          }

          var clipPoints = clipped.points;
          altitude = clipped.altitude;

          if (ignoreAltitude) {
            altitude = 0;
          }

          var alt = altitude;
          cPoints = [];

          for (var i = 0, l = clipPoints.length; i < l; i++) {
            var c = clipPoints[i];

            if (Array.isArray(c)) {
              var cring = []; //polygon rings or clipped line string

              for (var ii = 0, ll = c.length; ii < ll; ii++) {
                var cc = c[ii];

                if (Array.isArray(altitude)) {
                  if (altitude[i]) {
                    alt = altitude[i][ii];
                  } else {
                    alt = 0;
                  }
                }

                cring.push(pointContainerPoint(cc, alt));
              }

              cPoints.push(cring);
            } else {
              //line string
              if (Array.isArray(altitude)) {
                // altitude of different placement for point symbolizers
                if (pointPlacement === 'vertex-last') {
                  alt = altitude[altitude.length - 1 - i];
                } else if (pointPlacement === 'line') {
                  alt = (altitude[i] + altitude[i + 1]) / 2;
                } else {
                  //vertex, vertex-first
                  alt = altitude[i];
                }
              }

              cPoints.push(pointContainerPoint(c, alt));
            }
          }
        } else if (points instanceof Point) {
          if (ignoreAltitude) {
            altitude = 0;
          }

          cPoints = map._pointToContainerPoint(points, glZoom, altitude)._sub(containerOffset);

          if (dx || dy) {
            cPoints._add(dx, dy);
          }
        }

        return cPoints;
      };

      _proto._clip = function _clip(points, altitude) {
        var map = this.getMap(),
            geometry = this.geometry;
        var lineWidth = this.getSymbol()['lineWidth'];

        if (!isNumber(lineWidth)) {
          lineWidth = 4;
        }

        var extent2D = map._get2DExtent(undefined, TEMP_CLIP_EXTENT0)._expand(lineWidth);

        if (map.getPitch() > 0 && altitude) {
          var c = map.cameraLookAt;
          var pos = map.cameraPosition; //add [1px, 1px] towards camera's lookAt

          TEMP_POINT0$2.set(pos.x, pos.y);
          extent2D = extent2D._combine(TEMP_POINT0$2._add(sign(c[0] - pos[0]), sign(c[1] - pos[1])));
        }

        var e = this.get2DExtent(null, TEMP_CLIP_EXTENT1);
        var clipPoints = points;

        if (e.within(extent2D)) {
          // if (this.geometry.getJSONType() === 'LineString') {
          //     // clip line with altitude
          //     return this._clipLineByAlt(clipPoints, altitude);
          // }
          return {
            points: clipPoints,
            altitude: altitude
          };
        }

        var glExtent2D = map._get2DExtent(map.getGLZoom(), TEMP_CLIP_EXTENT0)._expand(lineWidth / map._glScale);

        var smoothness = geometry.options['smoothness']; // if (this.geometry instanceof Polygon) {

        if (geometry.getShell && this.geometry.getHoles && !smoothness) {
          // clip the polygon to draw less and improve performance
          if (!Array.isArray(points[0])) {
            clipPoints = clipPolygon(points, glExtent2D);
          } else {
            clipPoints = [];

            for (var i = 0; i < points.length; i++) {
              var part = clipPolygon(points[i], glExtent2D);

              if (part.length) {
                clipPoints.push(part);
              }
            }
          }
        } else if (geometry.getJSONType() === 'LineString' && !smoothness) {
          // clip the line string to draw less and improve performance
          if (!Array.isArray(points[0])) {
            clipPoints = clipLine(points, glExtent2D, false, !!smoothness);
          } else {
            clipPoints = [];

            for (var _i = 0; _i < points.length; _i++) {
              pushIn(clipPoints, clipLine(points[_i], glExtent2D, false, !!smoothness));
            }
          } //interpolate line's segment's altitude if altitude is an array


          return this._interpolateSegAlt(clipPoints, points, altitude); // const segs = this._interpolateSegAlt(clipPoints, points, altitude);
          // return this._clipLineByAlt(segs.points, segs.altitude);
        }

        return {
          points: clipPoints,
          altitude: altitude
        };
      } // _clipLineByAlt(clipSegs, altitude) {
      //     const frustumAlt = this.getMap().getFrustumAltitude();
      //     if (!Array.isArray(altitude) || this.maxAltitude <= frustumAlt) {
      //         return {
      //             points : clipSegs,
      //             altitude : altitude
      //         };
      //     }
      //     return clipByALt(clipSegs, altitude, frustumAlt);
      // }

      /**
       * interpolate clipped line segs's altitude
       * @param {Point[]|Point[][]} clipSegs
       * @param {Point[]|Point[][]} orig
       * @param {Number|Number[]} altitude
       * @private
       */
      ;

      _proto._interpolateSegAlt = function _interpolateSegAlt(clipSegs, orig, altitude) {
        if (!Array.isArray(altitude)) {
          var fn = function fn(cc) {
            return cc.point;
          };

          return {
            points: clipSegs.map(function (c) {
              if (Array.isArray(c)) {
                return c.map(fn);
              }

              return c.point;
            }),
            altitude: altitude
          };
        }

        var segsWithAlt = interpolateAlt(clipSegs, orig, altitude);
        altitude = [];
        var points = segsWithAlt.map(function (p) {
          if (Array.isArray(p)) {
            var alt = [];
            var cp = p.map(function (pp) {
              alt.push(pp.altitude);
              return pp.point;
            });
            altitude.push(alt);
            return cp;
          }

          altitude.push(p.altitude);
          return p.point;
        });
        return {
          points: points,
          altitude: altitude
        };
      };

      _proto.getSymbol = function getSymbol() {
        return this.geometry._getInternalSymbol();
      };

      _proto.paint = function paint(extent, context, offset) {
        if (!this.symbolizers) {
          return;
        }

        var renderer = this.getLayer()._getRenderer();

        if (!renderer || !renderer.context && !context) {
          return;
        } //reduce geos to paint when drawOnInteracting


        if (extent && !extent.intersects(this.get2DExtent(renderer.resources, TEMP_PAINT_EXTENT))) {
          return;
        }

        var map = this.getMap();
        var minAltitude = this.getMinAltitude();
        var frustumAlt = map.getFrustumAltitude();

        if (minAltitude && frustumAlt && frustumAlt < minAltitude) {
          return;
        }

        this.containerOffset = offset || map._pointToContainerPoint(renderer.southWest)._add(0, -map.height);

        this._beforePaint();

        var ctx = context || renderer.context;
        var contexts = [ctx, renderer.resources];

        for (var i = this.symbolizers.length - 1; i >= 0; i--) {
          this._prepareShadow(ctx, this.symbolizers[i].symbol);

          this.symbolizers[i].symbolize.apply(this.symbolizers[i], contexts);
        }

        this._afterPaint();

        this._painted = true;

        this._debugSymbolizer.symbolize.apply(this._debugSymbolizer, contexts);
      };

      _proto.getSprite = function getSprite(resources, canvasClass) {
        if (this.geometry.type !== 'Point') {
          return null;
        }

        this._spriting = true;

        if (!this._sprite && this.symbolizers.length > 0) {
          var extent = new PointExtent();
          this.symbolizers.forEach(function (s) {
            var markerExtent = s.getFixedExtent(resources);

            extent._combine(markerExtent);
          });
          var origin = extent.getMin().multi(-1);
          var clazz = canvasClass || (this.getMap() ? this.getMap().CanvasClass : null);
          var canvas = Canvas$1.createCanvas(extent.getWidth(), extent.getHeight(), clazz);
          var bak;

          if (this._renderPoints) {
            bak = this._renderPoints;
          }

          var ctx = canvas.getContext('2d');
          var contexts = [ctx, resources];

          for (var i = this.symbolizers.length - 1; i >= 0; i--) {
            var dxdy = this.symbolizers[i].getDxDy();
            this._renderPoints = {
              'center': [[origin.add(dxdy)]]
            };

            this._prepareShadow(ctx, this.symbolizers[i].symbol);

            this.symbolizers[i].symbolize.apply(this.symbolizers[i], contexts);
          }

          if (bak) {
            this._renderPoints = bak;
          }

          this._sprite = {
            'canvas': canvas,
            'offset': extent.getCenter()
          };
        }

        this._spriting = false;
        return this._sprite;
      };

      _proto.isSpriting = function isSpriting() {
        return !!this._spriting;
      };

      _proto.hitTest = function hitTest(cp, tolerance) {
        if (!tolerance || tolerance < 0.5) {
          tolerance = 0.5;
        }

        if (!testCanvas) {
          testCanvas = Canvas$1.createCanvas(1, 1);
        }

        Canvas$1.setHitTesting(true);
        testCanvas.width = testCanvas.height = 2 * tolerance;
        var ctx = testCanvas.getContext('2d');
        this._hitPoint = cp.sub(tolerance, tolerance);

        try {
          this.paint(null, ctx, this._hitPoint);
        } catch (e) {
          throw e;
        } finally {
          Canvas$1.setHitTesting(false);
        }

        delete this._hitPoint;
        var imgData = ctx.getImageData(0, 0, testCanvas.width, testCanvas.height).data;

        for (var i = 3, l = imgData.length; i < l; i += 4) {
          if (imgData[i] > 0) {
            return true;
          }
        }

        return false;
      };

      _proto.isHitTesting = function isHitTesting() {
        return !!this._hitPoint;
      };

      _proto._prepareShadow = function _prepareShadow(ctx, symbol) {
        if (symbol['shadowBlur']) {
          //Ignore shadows when hit detection
          ctx.shadowBlur = this.isHitTesting() ? 0 : symbol['shadowBlur'];
          ctx.shadowColor = symbol['shadowColor'] || '#000';
          ctx.shadowOffsetX = symbol['shadowOffsetX'] || 0;
          ctx.shadowOffsetY = symbol['shadowOffsetY'] || 0;
        } else if (ctx.shadowBlur) {
          ctx.shadowBlur = null;
          ctx.shadowColor = null;
          ctx.shadowOffsetX = null;
          ctx.shadowOffsetY = null;
        }
      };

      _proto._eachSymbolizer = function _eachSymbolizer(fn, context) {
        if (!this.symbolizers) {
          return;
        }

        if (!context) {
          context = this;
        }

        for (var i = this.symbolizers.length - 1; i >= 0; i--) {
          fn.apply(context, [this.symbolizers[i]]);
        }
      };

      _proto.get2DExtent = function get2DExtent(resources, out) {
        this._verifyProjection();

        var map = this.getMap();
        resources = resources || this.getLayer()._getRenderer().resources;
        var zoom = map.getZoom();

        var isDynamicSize = this._isDynamicSize();

        if (!this._extent2D || this._extent2D._zoom !== zoom || !this._fixedExtent) {
          if (this._extent2D && this._extent2D._zoom !== zoom) {
            delete this._extent2D;
          }

          if (this.symbolizers) {
            if (!this._extent2D) {
              this._extent2D = this._computeExtent2D(new PointExtent());
              this._extent2D._zoom = zoom;
            }

            if (!this._fixedExtent) {
              this._fixedExtent = this._computeFixedExtent(resources, new PointExtent());
            }
          }
        }

        if (!this._extent2D) {
          if (isDynamicSize) {
            delete this._fixedExtent;
          }

          return null;
        }

        var _this$_fixedExtent = this._fixedExtent,
            xmin = _this$_fixedExtent.xmin,
            ymin = _this$_fixedExtent.ymin,
            xmax = _this$_fixedExtent.xmax,
            ymax = _this$_fixedExtent.ymax;

        if (isDynamicSize) {
          delete this._fixedExtent;
        } //2d 坐标系是opengl规则，y轴方向与containerPoint是反向的


        TEMP_FIXED_EXTENT.set(xmin, -ymax, xmax, -ymin);

        if (out) {
          out.set(this._extent2D['xmin'], this._extent2D['ymin'], this._extent2D['xmax'], this._extent2D['ymax']);

          out._add(TEMP_FIXED_EXTENT);

          return out;
        }

        return this._extent2D.add(TEMP_FIXED_EXTENT);
      };

      _proto._computeExtent2D = function _computeExtent2D(extent) {
        for (var i = this.symbolizers.length - 1; i >= 0; i--) {
          var symbolizer = this.symbolizers[i];

          extent._combine(symbolizer.get2DExtent());
        }

        return extent;
      };

      _proto._computeFixedExtent = function _computeFixedExtent(resources, extent) {
        for (var i = this.symbolizers.length - 1; i >= 0; i--) {
          var symbolizer = this.symbolizers[i];

          if (symbolizer.getFixedExtent) {
            extent._combine(symbolizer.getFixedExtent(resources));
          }
        }

        return extent;
      };

      _proto._isDynamicSize = function _isDynamicSize() {
        for (var i = this.symbolizers.length - 1; i >= 0; i--) {
          var symbolizer = this.symbolizers[i];

          if (symbolizer.isDynamicSize()) {
            return true;
          }
        }

        return false;
      };

      _proto.getContainerExtent = function getContainerExtent(out) {
        if (this._aboveCamera()) {
          return null;
        }

        this._verifyProjection();

        var map = this.getMap();
        var zoom = map.getZoom();
        var glScale = map._glScale;

        if (!this._extent2D || this._extent2D._zoom !== zoom) {
          this.get2DExtent(null, TEMP_EXTENT$1);
        }

        var altitude = this.getMinAltitude();

        var extent = this._extent2D.convertTo(function (c) {
          return map._pointToContainerPoint(c, zoom, altitude / glScale, TEMP_POINT0$2);
        }, out);

        var maxAltitude = this.getMaxAltitude();

        if (maxAltitude !== altitude) {
          var extent2 = this._extent2D.convertTo(function (c) {
            return map._pointToContainerPoint(c, zoom, maxAltitude / glScale, TEMP_POINT0$2);
          }, TEMP_EXTENT$1);

          extent._combine(extent2);
        }

        var layer = this.geometry.getLayer();

        if (this.geometry.type === 'LineString' && maxAltitude && layer.options['drawAltitude']) {
          var groundExtent = this._extent2D.convertTo(function (c) {
            return map._pointToContainerPoint(c, zoom, 0, TEMP_POINT0$2);
          }, TEMP_EXTENT$1);

          extent._combine(groundExtent);
        }

        if (extent) {
          extent._add(this._fixedExtent || this._computeFixedExtent(null, new PointExtent()));
        }

        var smoothness = this.geometry.options['smoothness'];

        if (smoothness) {
          extent._expand(extent.getWidth() * 0.15);
        }

        return extent;
      };

      _proto._aboveCamera = function _aboveCamera() {
        var altitude = this.getMinAltitude();
        var map = this.getMap();
        var frustumAlt = map.getFrustumAltitude();
        return altitude && frustumAlt && frustumAlt < altitude;
      };

      _proto.getFixedExtent = function getFixedExtent() {
        var map = this.getMap();
        var zoom = map.getZoom();

        if (this._isDynamicSize()) {
          return this._computeFixedExtent(null, new PointExtent());
        }

        if (!this._extent2D || this._extent2D._zoom !== zoom) {
          this.get2DExtent(null, TEMP_FIXED_EXTENT);
        }

        return this._fixedExtent;
      };

      _proto.setZIndex = function setZIndex(change) {
        this._eachSymbolizer(function (symbolizer) {
          symbolizer.setZIndex(change);
        });
      };

      _proto.show = function show() {
        if (!this._painted) {
          var layer = this.getLayer();

          if (!layer.isCanvasRender()) {
            this.paint();
          }
        } else {
          this.removeCache();

          this._eachSymbolizer(function (symbolizer) {
            symbolizer.show();
          });
        }
      };

      _proto.hide = function hide() {
        this._eachSymbolizer(function (symbolizer) {
          symbolizer.hide();
        });
      };

      _proto.repaint = function repaint() {
        this._altAtGLZoom = this._getGeometryAltitude();
        this.removeCache();
        var layer = this.getLayer();

        if (!layer) {
          return;
        }

        var renderer = layer.getRenderer();

        if (!renderer || !renderer.setToRedraw()) {
          return;
        }

        renderer.setToRedraw();
      }
      /**
       * refresh symbolizers when symbol changed
       */
      ;

      _proto.refreshSymbol = function refreshSymbol() {
        this.removeCache();

        this._removeSymbolizers();

        this.symbolizers = this._createSymbolizers();
      };

      _proto.remove = function remove() {
        this.removeCache();

        this._removeSymbolizers();
      };

      _proto._removeSymbolizers = function _removeSymbolizers() {
        this._eachSymbolizer(function (symbolizer) {
          delete symbolizer.painter;
          symbolizer.remove();
        });

        delete this.symbolizers;
      }
      /**
       * delete painter's caches
       */
      ;

      _proto.removeCache = function removeCache() {
        delete this._renderPoints;
        delete this._paintParams;
        delete this._sprite;
        delete this._extent2D;
        delete this._fixedExtent;
        delete this._cachedParams;
        delete this._unsimpledParams;

        if (this.geometry) {
          delete this.geometry[TextMarkerSymbolizer.CACHE_KEY];
        }
      };

      _proto.getAltitude = function getAltitude() {
        var propAlt = this._getAltitudeProperty();

        if (propAlt !== this._propAlt) {
          this._altAtGLZoom = this._getGeometryAltitude();
        }

        if (!this._altAtGLZoom) {
          return 0;
        }

        return this._altAtGLZoom;
      };

      _proto.getMinAltitude = function getMinAltitude() {
        if (!this.minAltitude) {
          return 0;
        }

        return this.minAltitude;
      };

      _proto.getMaxAltitude = function getMaxAltitude() {
        if (!this.maxAltitude) {
          return 0;
        }

        return this.maxAltitude;
      };

      _proto._getGeometryAltitude = function _getGeometryAltitude() {
        var _this2 = this;

        var map = this.getMap();

        if (!map) {
          return 0;
        }

        var altitude = this._getAltitudeProperty();

        this._propAlt = altitude;

        if (!altitude) {
          this.minAltitude = this.maxAltitude = 0;
          return 0;
        }

        var center = this.geometry.getCenter();

        if (!center) {
          return 0;
        }

        if (Array.isArray(altitude)) {
          this.minAltitude = Number.MAX_VALUE;
          this.maxAltitude = Number.MIN_VALUE;
          return altitude.map(function (alt) {
            var a = _this2._meterToPoint(center, alt);

            if (a < _this2.minAltitude) {
              _this2.minAltitude = a;
            }

            if (a > _this2.maxAltitude) {
              _this2.maxAltitude = a;
            }

            return a;
          });
        } else {
          this.minAltitude = this.maxAltitude = this._meterToPoint(center, altitude);
          return this.minAltitude;
        }
      };

      _proto._meterToPoint = function _meterToPoint(center, altitude) {
        var map = this.getMap();
        var z = map.getGLZoom();
        var target = map.locate(center, altitude, 0);
        var p0 = map.coordToPoint(center, z, TEMP_POINT1$1),
            p1 = map.coordToPoint(target, z, TEMP_POINT2);
        return Math.abs(p1.x - p0.x) * sign(altitude);
      };

      _proto._getAltitudeProperty = function _getAltitudeProperty() {
        var geometry = this.geometry,
            layerOpts = geometry.getLayer().options,
            properties = geometry.getProperties();
        var altitude = layerOpts['enableAltitude'] ? properties ? properties[layerOpts['altitudeProperty']] : 0 : 0;
        return altitude;
      };

      _proto._verifyProjection = function _verifyProjection() {
        var projection = this.geometry._getProjection();

        if (this._projCode && this._projCode !== projection.code) {
          this.removeCache();
        }

        this._projCode = projection.code;
      };

      _proto._beforePaint = function _beforePaint() {
        var textcache = this.geometry[TextMarkerSymbolizer.CACHE_KEY];

        if (!textcache) {
          return;
        }

        for (var p in textcache) {
          if (hasOwn(textcache, p)) {
            textcache[p].active = false;
          }
        }
      };

      _proto._afterPaint = function _afterPaint() {
        var textcache = this.geometry[TextMarkerSymbolizer.CACHE_KEY];

        if (!textcache) {
          return;
        }

        for (var p in textcache) {
          if (hasOwn(textcache, p)) {
            if (!textcache[p].active) {
              delete textcache[p];
            }
          }
        }
      };

      return Painter;
    }(Class);

    function interpolateAlt(points, orig, altitude) {
      if (!Array.isArray(altitude)) {
        return points;
      }

      var parts = [];

      for (var i = 0, l = points.length; i < l; i++) {
        if (Array.isArray(points[i])) {
          parts.push(interpolateAlt(points[i], orig, altitude));
        } else {
          var p = points[i];

          if (!p.point.equals(orig[p.index])) {
            var w0 = void 0,
                w1 = void 0;

            if (p.index === 0) {
              w0 = p.index;
              w1 = p.index + 1;
            } else {
              w0 = p.index - 1;
              w1 = p.index;
            }

            var t0 = p.point.distanceTo(orig[w1]);
            var t = t0 / (t0 + orig[w0].distanceTo(p.point));
            var alt = interpolate(altitude[w0], altitude[w1], 1 - t);
            p.altitude = alt;
            parts.push(p);
          } else {
            p.altitude = altitude[p.index];
            parts.push(p);
          }
        }
      }

      return parts;
    }

    var TEMP_EXTENT$2 = new PointExtent();
    /**
     * @classdesc
     * Painter for collection type geometries
     * @class
     * @private
     */

    var CollectionPainter =
    /*#__PURE__*/
    function (_Class) {
      _inheritsLoose(CollectionPainter, _Class);

      /**
       * @param {GeometryCollection} geometry - geometry to paint
       */
      function CollectionPainter(geometry) {
        var _this;

        _this = _Class.call(this) || this;
        _this.geometry = geometry;
        return _this;
      }

      var _proto = CollectionPainter.prototype;

      _proto._eachPainter = function _eachPainter(fn) {
        var geometries = this.geometry.getGeometries();
        var painter;

        for (var i = 0, len = geometries.length; i < len; i++) {
          painter = geometries[i]._getPainter();

          if (!painter) {
            continue;
          }

          if (painter) {
            if (fn.call(this, painter) === false) {
              break;
            }
          }
        }
      };

      _proto.paint = function paint(extent) {
        if (!this.geometry) {
          return;
        }

        this._eachPainter(function (painter) {
          painter.paint(extent);
        });
      };

      _proto.get2DExtent = function get2DExtent(resources, out) {
        if (out) {
          out.set(null, null, null, null);
        }

        var extent = out || new PointExtent();

        this._eachPainter(function (painter) {
          extent = extent._combine(painter.get2DExtent(resources, TEMP_EXTENT$2));
        });

        return extent;
      };

      _proto.getContainerExtent = function getContainerExtent() {
        var extent = new PointExtent();

        this._eachPainter(function (painter) {
          extent = extent.combine(painter.getContainerExtent());
        });

        return extent;
      };

      _proto.remove = function remove() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.remove.apply(painter, args);
        });
      };

      _proto.setZIndex = function setZIndex() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.setZIndex.apply(painter, args);
        });
      };

      _proto.show = function show() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.show.apply(painter, args);
        });
      };

      _proto.hide = function hide() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.hide.apply(painter, args);
        });
      };

      _proto.repaint = function repaint() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.repaint.apply(painter, args);
        });
      };

      _proto.refreshSymbol = function refreshSymbol() {
        var args = arguments;

        this._eachPainter(function (painter) {
          painter.refreshSymbol.apply(painter, args);
        });
      };

      _proto.hasPoint = function hasPoint() {
        var result = false;

        this._eachPainter(function (painter) {
          if (painter.hasPoint()) {
            result = true;
            return false;
          }

          return true;
        });

        return result;
      };

      _proto.getMinAltitude = function getMinAltitude() {
        var first = true;
        var result = 0;

        this._eachPainter(function (painter) {
          var alt = painter.getMinAltitude();

          if (first || alt < result) {
            first = false;
            result = alt;
          }
        });

        return result;
      };

      _proto.getMaxAltitude = function getMaxAltitude() {
        var result = 0;

        this._eachPainter(function (painter) {
          var alt = painter.getMaxAltitude();

          if (alt > result) {
            result = alt;
          }
        });

        return result;
      };

      return CollectionPainter;
    }(Class);

    var DefaultSpatialReference = {
      'EPSG:3857': {
        'resolutions': function () {
          var resolutions = [];
          var d = 2 * 6378137 * Math.PI;

          for (var i = 0; i < 21; i++) {
            resolutions[i] = d / (256 * Math.pow(2, i));
          }

          return resolutions;
        }(),
        'fullExtent': {
          'top': 6378137 * Math.PI,
          'left': -6378137 * Math.PI,
          'bottom': -6378137 * Math.PI,
          'right': 6378137 * Math.PI
        }
      },
      'EPSG:4326': {
        'fullExtent': {
          'top': 90,
          'left': -180,
          'bottom': -90,
          'right': 180
        },
        'resolutions': function () {
          var resolutions = [];

          for (var i = 0; i < 20; i++) {
            resolutions[i] = 180 / (Math.pow(2, i) * 128);
          }

          return resolutions;
        }()
      },
      'BAIDU': {
        'resolutions': function () {
          var res = Math.pow(2, 18);
          var resolutions = [];

          for (var i = 0; i < 20; i++) {
            resolutions[i] = res;
            res *= 0.5;
          }

          return resolutions;
        }(),
        'fullExtent': {
          'top': 33554432,
          'left': -33554432,
          'bottom': -33554432,
          'right': 33554432
        }
      },
      'IDENTITY': {
        'resolutions': function () {
          var res = Math.pow(2, 8);
          var resolutions = [];

          for (var i = 0; i < 18; i++) {
            resolutions[i] = res;
            res *= 0.5;
          }

          return resolutions;
        }(),
        'fullExtent': {
          'top': 200000,
          'left': -200000,
          'bottom': -200000,
          'right': 200000
        }
      }
    };
    DefaultSpatialReference['EPSG:4490'] = DefaultSpatialReference['EPSG:4326'];

    var SpatialReference =
    /*#__PURE__*/
    function () {
      function SpatialReference(options) {
        if (options === void 0) {
          options = {};
        }

        this.options = options;

        this._initSpatialRef();
      }

      SpatialReference.getProjectionInstance = function getProjectionInstance(prjName) {
        if (!prjName) {
          return null;
        }

        if (isObject(prjName)) {
          return prjName;
        }

        prjName = (prjName + '').toLowerCase();

        for (var p in projections) {
          if (hasOwn(projections, p)) {
            var code = projections[p]['code'];

            if (code && code.toLowerCase() === prjName) {
              return projections[p];
            }
          }
        }

        return null;
      };

      SpatialReference.equals = function equals(sp1, sp2) {
        if (!sp1 && !sp2) {
          return true;
        } else if (!sp1 || !sp2) {
          return false;
        }

        if (sp1.projection !== sp2.projection) {
          return false;
        }

        var f1 = sp1.fullExtent,
            f2 = sp2.fullExtent;

        if (f1 && !f2 || !f1 && f2) {
          return false;
        }

        if (f1 && f2) {
          if (f1.top !== f2.top || f1.bottom !== f2.bottom || f1.left !== f2.left || f1.right !== f2.right) {
            return false;
          }
        }

        var r1 = sp1.resolutions,
            r2 = sp2.resolutions;

        if (r1 && r2) {
          if (r1.length !== r2.length) {
            return false;
          }

          for (var i = 0; i < r1.length; i++) {
            if (r1[i] !== r2[i]) {
              return false;
            }
          }
        }

        return true;
      };

      var _proto = SpatialReference.prototype;

      _proto._initSpatialRef = function _initSpatialRef() {
        var projection = this.options['projection'];

        if (projection) {
          projection = SpatialReference.getProjectionInstance(projection);
        } else {
          projection = DEFAULT$1;
        }

        if (!projection) {
          throw new Error('must provide a valid projection in map\'s spatial reference.');
        }

        projection = extend({}, Common, projection);

        if (!projection.measureLength) {
          extend(projection, Measurer.DEFAULT);
        }

        this._projection = projection;
        var defaultSpatialRef,
            resolutions = this.options['resolutions'];

        if (!resolutions) {
          if (projection['code']) {
            defaultSpatialRef = DefaultSpatialReference[projection['code']];

            if (defaultSpatialRef) {
              resolutions = defaultSpatialRef['resolutions'];
              this.isEPSG = projection['code'] !== 'IDENTITY';
            }
          }

          if (!resolutions) {
            throw new Error('must provide valid resolutions in map\'s spatial reference.');
          }
        }

        this._resolutions = resolutions;
        var fullExtent = this.options['fullExtent'];

        if (!fullExtent) {
          if (projection['code']) {
            defaultSpatialRef = DefaultSpatialReference[projection['code']];

            if (defaultSpatialRef) {
              fullExtent = defaultSpatialRef['fullExtent'];
            }
          }

          if (!fullExtent) {
            throw new Error('must provide a valid fullExtent in map\'s spatial reference.');
          }
        }

        if (!isNil(fullExtent['left'])) {
          this._fullExtent = new Extent(new Coordinate(fullExtent['left'], fullExtent['top']), new Coordinate(fullExtent['right'], fullExtent['bottom']));
        } else {
          //xmin, ymin, xmax, ymax
          this._fullExtent = new Extent(fullExtent);
          fullExtent['left'] = fullExtent['xmin'];
          fullExtent['right'] = fullExtent['xmax'];
          fullExtent['top'] = fullExtent['ymax'];
          fullExtent['bottom'] = fullExtent['ymin'];
        }

        if (isNil(fullExtent['top']) || isNil(fullExtent['bottom']) || isNil(fullExtent['left']) || isNil(fullExtent['right'])) {
          throw new Error('must provide valid top/bottom/left/right in fullExtent.');
        } //set left, right, top, bottom value


        extend(this._fullExtent, fullExtent);
        this._projection.fullExtent = fullExtent;
        var a = fullExtent['right'] >= fullExtent['left'] ? 1 : -1,
            b = fullExtent['top'] >= fullExtent['bottom'] ? -1 : 1;
        this._transformation = new Transformation([a, b, 0, 0]);
      };

      _proto.getResolutions = function getResolutions() {
        return this._resolutions || [];
      };

      _proto.getResolution = function getResolution(zoom) {
        var z = zoom | 0;

        if (z < 0) {
          z = 0;
        } else if (z > this._resolutions.length - 1) {
          z = this._resolutions.length - 1;
        }

        var res = this._resolutions[z];

        if (z !== zoom && zoom > 0 && z < this._resolutions.length - 1) {
          var next = this._resolutions[z + 1];
          return res + (next - res) * (zoom - z);
        }

        return res;
      };

      _proto.getProjection = function getProjection() {
        return this._projection;
      };

      _proto.getFullExtent = function getFullExtent() {
        return this._fullExtent;
      };

      _proto.getTransformation = function getTransformation() {
        return this._transformation;
      };

      _proto.getMinZoom = function getMinZoom() {
        for (var i = 0; i < this._resolutions.length; i++) {
          if (!isNil(this._resolutions[i])) {
            return i;
          }
        }

        return 0;
      };

      _proto.getMaxZoom = function getMaxZoom() {
        for (var i = this._resolutions.length - 1; i >= 0; i--) {
          if (!isNil(this._resolutions[i])) {
            return i;
          }
        }

        return this._resolutions.length - 1;
      };

      _proto.getZoomDirection = function getZoomDirection() {
        return sign(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()]);
      };

      _proto.toJSON = function toJSON() {
        if (!this.json) {
          this.json = {
            'resolutions': this._resolutions,
            'fullExtent': {
              'top': this._fullExtent.top,
              'left': this._fullExtent.left,
              'bottom': this._fullExtent.bottom,
              'right': this._fullExtent.right
            },
            'projection': this._projection.code
          };
        }

        return this.json;
      };

      return SpatialReference;
    }();

    /**
     * @property {Object} options                       - geometry options
     * @property {Boolean} [options.id=null]            - id of the geometry
     * @property {Boolean} [options.visible=true]       - whether the geometry is visible.
     * @property {Boolean} [options.editable=true]      - whether the geometry can be edited.
     * @property {Boolean} [options.interactive=true]   - whether the geometry can be interactived.
     * @property {String} [options.cursor=null]         - cursor style when mouseover the geometry, same as the definition in CSS.
     * @property {String} [options.measure=EPSG:4326]   - the measure code for the geometry, defines {@tutorial measureGeometry how it can be measured}.
     * @property {Boolean} [options.draggable=false]    - whether the geometry can be dragged.
     * @property {Boolean} [options.dragShadow=true]    - if true, during geometry dragging, a shadow will be dragged before geometry was moved.
     * @property {Boolean} [options.dragOnAxis=null]    - if set, geometry can only be dragged along the specified axis, possible values: x, y
     * @property {Number}  [options.zIndex=undefined]   - geometry's initial zIndex
     * @memberOf Geometry
     * @instance
     */

    var options = {
      'id': null,
      'visible': true,
      'interactive': true,
      'editable': true,
      'cursor': null,
      'defaultProjection': 'EPSG:4326' // BAIDU, IDENTITY

    };
    /**
     * Base class for all the geometries. <br/>
     * It defines common methods that all the geometry classes share. <br>
     * It is abstract and not intended to be instantiated but extended.
     *
     * @category geometry
     * @abstract
     * @extends Class
     * @mixes Eventable
     * @mixes Handlerable
     * @mixes JSONAble
     * @mixes ui.Menuable
     */

    var Geometry =
    /*#__PURE__*/
    function (_JSONAble) {
      _inheritsLoose(Geometry, _JSONAble);

      function Geometry(options) {
        var _this;

        var opts = extend({}, options);
        var symbol = opts['symbol'];
        var properties = opts['properties'];
        var id = opts['id'];
        delete opts['symbol'];
        delete opts['id'];
        delete opts['properties'];
        _this = _JSONAble.call(this, opts) || this;

        if (symbol) {
          _this.setSymbol(symbol);
        }

        if (properties) {
          _this.setProperties(properties);
        }

        if (!isNil(id)) {
          _this.setId(id);
        }

        return _this;
      }
      /**
       * Returns the first coordinate of the geometry.
       *
       * @return {Coordinate} First Coordinate
       */


      var _proto = Geometry.prototype;

      _proto.getFirstCoordinate = function getFirstCoordinate() {
        if (this.type === 'GeometryCollection') {
          var geometries = this.getGeometries();

          if (!geometries.length) {
            return null;
          }

          return geometries[0].getFirstCoordinate();
        }

        var coordinates = this.getCoordinates();

        if (!Array.isArray(coordinates)) {
          return coordinates;
        }

        do {
          coordinates = coordinates[0];
        } while (Array.isArray(coordinates) && coordinates.length > 0);

        return coordinates;
      }
      /**
       * Returns the last coordinate of the geometry.
       *
       * @return {Coordinate} Last Coordinate
       */
      ;

      _proto.getLastCoordinate = function getLastCoordinate() {
        if (this.type === 'GeometryCollection') {
          var geometries = this.getGeometries();

          if (!geometries.length) {
            return null;
          }

          return geometries[geometries.length - 1].getLastCoordinate();
        }

        var coordinates = this.getCoordinates();

        if (!Array.isArray(coordinates)) {
          return coordinates;
        }

        do {
          coordinates = coordinates[coordinates.length - 1];
        } while (Array.isArray(coordinates) && coordinates.length > 0);

        return coordinates;
      }
      /**
       * Adds the geometry to a layer
       * @param {Layer} layer    - layer add to
       * @param {Boolean} [fitview=false] - automatically set the map to a fit center and zoom for the geometry
       * @return {Geometry} this
       * @fires Geometry#add
       */
      ;

      _proto.addTo = function addTo(layer, fitview) {
        layer.addGeometry(this, fitview);
        return this;
      }
      /**
       * Get the layer which this geometry added to.
       * @returns {Layer} - layer added to
       */
      ;

      _proto.getLayer = function getLayer() {
        if (!this._layer) {
          return null;
        }

        return this._layer;
      }
      /**
       * Get the map which this geometry added to
       * @returns {Map} - map added to
       */
      ;

      _proto.getMap = function getMap() {
        if (!this._layer) {
          return null;
        }

        return this._layer.getMap();
      }
      /**
       * Gets geometry's id. Id is set by setId or constructor options.
       * @returns {String|Number} geometry的id
       */
      ;

      _proto.getId = function getId() {
        return this._id;
      }
      /**
       * Set geometry's id.
       * @param {String} id - new id
       * @returns {Geometry} this
       * @fires Geometry#idchange
       */
      ;

      _proto.setId = function setId(id) {
        var oldId = this.getId();
        this._id = id;
        /**
         * idchange event.
         *
         * @event Geometry#idchange
         * @type {Object}
         * @property {String} type - idchange
         * @property {Geometry} target - the geometry fires the event
         * @property {String|Number} old        - value of the old id
         * @property {String|Number} new        - value of the new id
         */

        this._fireEvent('idchange', {
          'old': oldId,
          'new': id
        });

        return this;
      }
      /**
       * Get geometry's properties. Defined by GeoJSON as [feature's properties]{@link http://geojson.org/geojson-spec.html#feature-objects}.
       *
       * @returns {Object} properties
       */
      ;

      _proto.getProperties = function getProperties() {
        if (!this.properties) {
          if (this._getParent()) {
            return this._getParent().getProperties();
          }

          return null;
        }

        return this.properties;
      }
      /**
       * Set a new properties to geometry.
       * @param {Object} properties - new properties
       * @returns {Geometry} this
       * @fires Geometry#propertieschange
       */
      ;

      _proto.setProperties = function setProperties(properties) {
        var old = this.properties;
        this.properties = isObject(properties) ? extend({}, properties) : properties;

        this._repaint();
        /**
         * propertieschange event, thrown when geometry's properties is changed.
         *
         * @event Geometry#propertieschange
         * @type {Object}
         * @property {String} type - propertieschange
         * @property {Geometry} target - the geometry fires the event
         * @property {String|Number} old        - value of the old properties
         * @property {String|Number} new        - value of the new properties
         */


        this._fireEvent('propertieschange', {
          'old': old,
          'new': properties
        });

        return this;
      }
      /**
       * Get type of the geometry, e.g. "Point", "LineString"
       * @returns {String} type of the geometry
       */
      ;

      _proto.getType = function getType() {
        return this.type;
      }
      /**
       * Get symbol of the geometry
       * @returns {Object} geometry's symbol
       */
      ;

      _proto.getSymbol = function getSymbol() {
        var s = this._symbol;

        if (s) {
          if (!Array.isArray(s)) {
            return extend({}, s);
          } else {
            return extendSymbol(s);
          }
        }

        return null;
      }
      /**
       * Set a new symbol to style the geometry.
       * @param {Object} symbol - new symbol
       * @see {@tutorial symbol Style a geometry with symbols}
       * @return {Geometry} this
       * @fires Geometry#symbolchange
       */
      ;

      _proto.setSymbol = function setSymbol(symbol) {
        this._symbol = this._prepareSymbol(symbol);
        this.onSymbolChanged();
        return this;
      }
      /**
       * Update geometry's current symbol.
       *
       * @param  {Object} props - symbol properties to update
       * @return {Geometry} this
       * @fires Geometry#symbolchange
       * @example
       * var marker = new Marker([0, 0], {
       *    symbol : {
       *       markerType : 'ellipse',
       *       markerWidth : 20,
       *       markerHeight : 30
       *    }
       * });
       * // update symbol's markerWidth to 40
       * marker.updateSymbol({
       *     markerWidth : 40
       * });
       */
      ;

      _proto.updateSymbol = function updateSymbol(props) {
        if (!props) {
          return this;
        }

        var s = this._getSymbol();

        if (s) {
          s = extendSymbol(s, props);
        } else {
          s = extendSymbol(this._getInternalSymbol(), props);
        }

        return this.setSymbol(s);
      }
      /**
       * Get the geographical center of the geometry.
       *
       * @returns {Coordinate}
       */
      ;

      _proto.getCenter = function getCenter() {
        return this._computeCenter(this._getMeasurer());
      }
      /**
       * Get the geometry's geographical extent
       *
       * @returns {Extent} geometry's extent
       */
      ;

      _proto.getExtent = function getExtent() {
        var prjExt = this._getPrjExtent();

        if (prjExt) {
          var p = this._getProjection();

          var min = p.unproject(new Coordinate(prjExt['xmin'], prjExt['ymin'])),
              max = p.unproject(new Coordinate(prjExt['xmax'], prjExt['ymax']));
          return new Extent(min, max, this._getProjection());
        } else {
          return this._computeExtent(this._getMeasurer());
        }
      }
      /**
       * Get geometry's screen extent in pixel
       *
       * @returns {PointExtent}
       */
      ;

      _proto.getContainerExtent = function getContainerExtent(out) {
        var painter = this._getPainter();

        return painter ? painter.getContainerExtent(out) : null;
      }
      /**
       * Get pixel size of the geometry, which may vary in different zoom levels.
       *
       * @returns {Size}
       */
      ;

      _proto.getSize = function getSize() {
        var extent = this.getContainerExtent();
        return extent ? extent.getSize() : null;
      }
      /**
       * Whehter the geometry contains the input container point.
       *
       * @param  {Point|Coordinate} point - input container point or coordinate
       * @param  {Number} [t=undefined] - tolerance in pixel
       * @return {Boolean}
       * @example
       * var circle = new Circle([0, 0], 1000)
       *     .addTo(layer);
       * var contains = circle.containsPoint(new maptalks.Point(400, 300));
       */
      ;

      _proto.containsPoint = function containsPoint(containerPoint, t) {
        if (!this.getMap()) {
          throw new Error('The geometry is required to be added on a map to perform "containsPoint".');
        }

        if (containerPoint instanceof Coordinate) {
          containerPoint = this.getMap().coordToContainerPoint(containerPoint);
        }

        return this._containsPoint(containerPoint, t); // return this._containsPoint(this.getMap()._containerPointToPoint(new Point(containerPoint)), t);
      };

      _proto._containsPoint = function _containsPoint(containerPoint, t) {
        var painter = this._getPainter();

        if (!painter) {
          return false;
        }

        if (isNil(t) && this._hitTestTolerance) {
          t = this._hitTestTolerance();
        }

        return painter.hitTest(containerPoint, t);
      }
      /**
       * Show the geometry.
       *
       * @return {Geometry} this
       * @fires Geometry#show
       */
      ;

      _proto.show = function show() {
        this.options['visible'] = true;

        if (this.getMap()) {
          var painter = this._getPainter();

          if (painter) {
            painter.show();
          }
          /**
           * show event
           *
           * @event Geometry#show
           * @type {Object}
           * @property {String} type - show
           * @property {Geometry} target - the geometry fires the event
           */


          this._fireEvent('show');
        }

        return this;
      }
      /**
       * Hide the geometry
       *
       * @return {Geometry} this
       * @fires Geometry#hide
       */
      ;

      _proto.hide = function hide() {
        this.options['visible'] = false;

        if (this.getMap()) {
          this.onHide();

          var painter = this._getPainter();

          if (painter) {
            painter.hide();
          }
          /**
           * hide event
           *
           * @event Geometry#hide
           * @type {Object}
           * @property {String} type - hide
           * @property {Geometry} target - the geometry fires the event
           */


          this._fireEvent('hide');
        }

        return this;
      }
      /**
       * Whether the geometry is visible
       *
       * @returns {Boolean}
       */
      ;

      _proto.isVisible = function isVisible() {
        if (!this.options['visible']) {
          return false;
        }

        var symbol = this._getInternalSymbol();

        if (!symbol) {
          return true;
        }

        if (Array.isArray(symbol)) {
          if (!symbol.length) {
            return true;
          }

          for (var i = 0, l = symbol.length; i < l; i++) {
            if (isNil(symbol[i]['opacity']) || symbol[i]['opacity'] > 0) {
              return true;
            }
          }

          return false;
        } else {
          return isNil(symbol['opacity']) || isNumber(symbol['opacity']) && symbol['opacity'] > 0;
        }
      }
      /**
       * Get zIndex of the geometry, default is 0
       * @return {Number} zIndex
       */
      ;

      _proto.getZIndex = function getZIndex() {
        return this.options['zIndex'] || 0;
      }
      /**
       * Set a new zIndex to Geometry and fire zindexchange event (will cause layer to sort geometries and render)
       * @param {Number} zIndex - new zIndex
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      ;

      _proto.setZIndex = function setZIndex(zIndex) {
        var old = this.options['zIndex'];
        this.options['zIndex'] = zIndex;
        /**
         * zindexchange event, fired when geometry's zIndex is changed.
         *
         * @event Geometry#zindexchange
         * @type {Object}
         * @property {String} type - zindexchange
         * @property {Geometry} target - the geometry fires the event
         * @property {Number} old        - old zIndex
         * @property {Number} new        - new zIndex
         */

        this._fireEvent('zindexchange', {
          'old': old,
          'new': zIndex
        });

        return this;
      }
      /**
       * Only set a new zIndex to Geometry without firing zindexchange event. <br>
       * Can be useful to improve perf when a lot of geometries' zIndex need to be updated. <br>
       * When updated N geometries, You can use setZIndexSilently with (N-1) geometries and use setZIndex with the last geometry for layer to sort and render.
       * @param {Number} zIndex - new zIndex
       * @return {Geometry} this
       */
      ;

      _proto.setZIndexSilently = function setZIndexSilently(zIndex) {
        this.options['zIndex'] = zIndex;
        return this;
      }
      /**
       * Bring the geometry on the top
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      ;

      _proto.bringToFront = function bringToFront() {
        var layer = this.getLayer();

        if (!layer || !layer.getGeoMaxZIndex) {
          return this;
        }

        var topZ = layer.getGeoMaxZIndex();
        this.setZIndex(topZ + 1);
        return this;
      }
      /**
       * Bring the geometry to the back
       * @return {Geometry} this
       * @fires Geometry#zindexchange
       */
      ;

      _proto.bringToBack = function bringToBack() {
        var layer = this.getLayer();

        if (!layer || !layer.getGeoMinZIndex) {
          return this;
        }

        var bottomZ = layer.getGeoMinZIndex();
        this.setZIndex(bottomZ - 1);
        return this;
      }
      /**
       * Translate or move the geometry by the given offset.
       *
       * @param  {Coordinate} offset - translate offset
       * @return {Geometry} this
       * @fires Geometry#positionchange
       * @fires Geometry#shapechange
       */

      /**
       * Translate or move the geometry by the given offset.
       *
       * @param  {Number} x - x offset
       * @param  {Number} y - y offset
       * @return {Geometry} this
       * @fires Geometry#positionchange
       * @fires Geometry#shapechange
       */
      ;

      _proto.translate = function translate(x, y) {
        if (isNil(x)) {
          return this;
        }

        var offset = new Coordinate(x, y);

        if (offset.x === 0 && offset.y === 0) {
          return this;
        }

        var coordinates = this.getCoordinates();

        if (coordinates) {
          if (Array.isArray(coordinates)) {
            var translated = forEachCoord(coordinates, function (coord) {
              return coord.add(offset);
            });
            this.setCoordinates(translated);
          } else {
            this.setCoordinates(coordinates.add(offset));
          }
        }

        return this;
      }
      /**
       * Flash the geometry, show and hide by certain internal for times of count.
       *
       * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)
       * @param {Number} [count=4]          - flash times
       * @param {Function} [cb=null]        - callback function when flash ended
       * @param {*} [context=null]          - callback context
       * @return {Geometry} this
       */
      ;

      _proto.flash = function flash$$1(interval, count, cb, context) {
        return flash.call(this, interval, count, cb, context);
      }
      /**
       * Returns a copy of the geometry without the event listeners.
       * @returns {Geometry} copy
       */
      ;

      _proto.copy = function copy() {
        var json = this.toJSON();
        var ret = Geometry.fromJSON(json); //restore visibility

        ret.options['visible'] = true;
        return ret;
      }
      /**
       * remove itself from the layer if any.
       * @returns {Geometry} this
       * @fires Geometry#removestart
       * @fires Geometry#remove
       */
      ;

      _proto.remove = function remove() {
        var layer = this.getLayer();

        if (!layer) {
          return this;
        }
        /**
         * removestart event.
         *
         * @event Geometry#removestart
         * @type {Object}
         * @property {String} type - removestart
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('removestart');

        this._unbind();
        /**
         * removeend event.
         *
         * @event Geometry#removeend
         * @type {Object}
         * @property {String} type - removeend
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('removeend');
        /**
         * remove event.
         *
         * @event Geometry#remove
         * @type {Object}
         * @property {String} type - remove
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('remove');

        return this;
      }
      /**
       * Exports [geometry]{@link http://geojson.org/geojson-spec.html#feature-objects} out of a GeoJSON feature.
       * @return {Object} GeoJSON Geometry
       */
      ;

      _proto.toGeoJSONGeometry = function toGeoJSONGeometry() {
        var gJson = this._exportGeoJSONGeometry();

        return gJson;
      }
      /**
       * Exports a GeoJSON feature.
       * @param {Object} [opts=null]              - export options
       * @param {Boolean} [opts.geometry=true]    - whether export geometry
       * @param {Boolean} [opts.properties=true]  - whether export properties
       * @returns {Object} GeoJSON Feature
       */
      ;

      _proto.toGeoJSON = function toGeoJSON(opts) {
        if (!opts) {
          opts = {};
        }

        var feature = {
          'type': 'Feature',
          'geometry': null
        };

        if (isNil(opts['geometry']) || opts['geometry']) {
          var geoJSON = this._exportGeoJSONGeometry();

          feature['geometry'] = geoJSON;
        }

        var id = this.getId();

        if (!isNil(id)) {
          feature['id'] = id;
        }

        var properties;

        if (isNil(opts['properties']) || opts['properties']) {
          properties = this._exportProperties();
        }

        feature['properties'] = properties;
        return feature;
      }
      /**
       * Export a profile json out of the geometry. <br>
       * Besides exporting the feature object, a profile json also contains symbol, construct options and infowindow info.<br>
       * The profile json can be stored somewhere else and be used to reproduce the geometry later.<br>
       * Due to the problem of serialization for functions, event listeners and contextmenu are not included in profile json.
       * @example
       *     // an example of a profile json.
       * var profile = {
              "feature": {
                    "type": "Feature",
                    "id" : "point1",
                    "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                    "properties": {"prop0": "value0"}
              },
              //construct options.
              "options":{
                  "draggable" : true
              },
              //symbol
              "symbol":{
                  "markerFile"  : "http://foo.com/icon.png",
                  "markerWidth" : 20,
                  "markerHeight": 20
              },
              //infowindow info
              "infowindow" : {
                  "options" : {
                      "style" : "black"
                  },
                  "title" : "this is a infowindow title",
                  "content" : "this is a infowindow content"
              }
          };
       * @param {Object}  [options=null]          - export options
       * @param {Boolean} [opts.geometry=true]    - whether export feature's geometry
       * @param {Boolean} [opts.properties=true]  - whether export feature's properties
       * @param {Boolean} [opts.options=true]     - whether export construct options
       * @param {Boolean} [opts.symbol=true]      - whether export symbol
       * @param {Boolean} [opts.infoWindow=true]  - whether export infowindow
       * @return {Object} profile json object
       */
      ;

      _proto.toJSON = function toJSON(options) {
        //一个Graphic的profile

        /*
            //因为响应函数无法被序列化, 所以menu, 事件listener等无法被包含在graphic中
        }*/
        if (!options) {
          options = {};
        }

        var json = this._toJSON(options);

        var other = this._exportGraphicOptions(options);

        extend(json, other);
        return json;
      }
      /**
       * Get the geographic length of the geometry.
       * @returns {Number} geographic length, unit is meter
       */
      ;

      _proto.getLength = function getLength() {
        return this._computeGeodesicLength(this._getMeasurer());
      }
      /**
       * Get the geographic area of the geometry.
       * @returns {Number} geographic area, unit is sq.meter
       */
      ;

      _proto.getArea = function getArea() {
        return this._computeGeodesicArea(this._getMeasurer());
      }
      /**
       * Rotate the geometry of given angle around a pivot point
       * @param {Number} angle - angle to rotate in degree
       * @param {Coordinate} [pivot=null]  - optional, will be the geometry's center by default
       * @returns {Geometry} this
       */
      ;

      _proto.rotate = function rotate(angle, pivot) {
        if (this.type === 'GeometryCollection') {
          var geometries = this.getGeometries();
          geometries.forEach(function (g) {
            return g.rotate(angle, pivot);
          });
          return this;
        }

        if (!pivot) {
          pivot = this.getCenter();
        } else {
          pivot = new Coordinate(pivot);
        }

        var measurer = this._getMeasurer();

        var coordinates = this.getCoordinates();

        if (!Array.isArray(coordinates)) {
          if (pivot.x !== coordinates.x || pivot.y !== coordinates.y) {
            var c = measurer._rotate(coordinates, pivot, angle);

            this.setCoordinates(c);
          }

          return this;
        }

        forEachCoord(coordinates, function (c) {
          return measurer._rotate(c, pivot, angle);
        });
        this.setCoordinates(coordinates);
        return this;
      }
      /**
       * Get the connect points for [ConnectorLine]{@link ConnectorLine}
       * @return {Coordinate[]} connect points
       * @private
       */
      ;

      _proto._getConnectPoints = function _getConnectPoints() {
        return [this.getCenter()];
      } //options initializing
      ;

      _proto._initOptions = function _initOptions(options) {
        var opts = extend({}, options);
        var symbol = opts['symbol'];
        var properties = opts['properties'];
        var id = opts['id'];
        delete opts['symbol'];
        delete opts['id'];
        delete opts['properties'];
        this.setOptions(opts);

        if (symbol) {
          this.setSymbol(symbol);
        }

        if (properties) {
          this.setProperties(properties);
        }

        if (!isNil(id)) {
          this.setId(id);
        }
      } //bind the geometry to a layer
      ;

      _proto._bindLayer = function _bindLayer(layer) {
        //check dupliaction
        if (this.getLayer()) {
          throw new Error('Geometry cannot be added to two or more layers at the same time.');
        }

        this._layer = layer;

        this._clearCache();

        this._clearProjection(); // this.callInitHooks();

      };

      _proto._prepareSymbol = function _prepareSymbol(symbol) {
        if (Array.isArray(symbol)) {
          var cookedSymbols = [];

          for (var i = 0; i < symbol.length; i++) {
            cookedSymbols.push(convertResourceUrl(this._checkAndCopySymbol(symbol[i])));
          }

          return cookedSymbols;
        } else if (symbol) {
          symbol = this._checkAndCopySymbol(symbol);
          return convertResourceUrl(symbol);
        }

        return null;
      };

      _proto._checkAndCopySymbol = function _checkAndCopySymbol(symbol) {
        var s = {};

        for (var i in symbol) {
          if (NUMERICAL_PROPERTIES[i] && isString(symbol[i])) {
            s[i] = +symbol[i];
          } else {
            s[i] = symbol[i];
          }
        }

        return s;
      };

      _proto._getSymbol = function _getSymbol() {
        return this._symbol;
      }
      /**
       * Sets a external symbol to the geometry, e.g. style from VectorLayer's setStyle
       * @private
       * @param {Object} symbol - external symbol
       */
      ;

      _proto._setExternSymbol = function _setExternSymbol(symbol) {
        this._externSymbol = this._prepareSymbol(symbol);
        this.onSymbolChanged();
        return this;
      };

      _proto._getInternalSymbol = function _getInternalSymbol() {
        if (this._symbol) {
          return this._symbol;
        } else if (this._externSymbol) {
          return this._externSymbol;
        } else if (this.options['symbol']) {
          return this.options['symbol'];
        }

        return null;
      };

      _proto._getPrjExtent = function _getPrjExtent() {
        var p = this._getProjection();

        this._verifyProjection();

        if (!this._extent && p) {
          this._extent = this._computePrjExtent(p);
        }

        return this._extent;
      };

      _proto._unbind = function _unbind() {
        var layer = this.getLayer();

        if (!layer) {
          return;
        }

        if (this._animPlayer) {
          this._animPlayer.finish();
        }

        this._clearHandlers(); //contextmenu


        this._unbindMenu(); //infowindow


        this._unbindInfoWindow();

        if (this.isEditing()) {
          this.endEdit();
        }

        this._removePainter();

        if (this.onRemove) {
          this.onRemove();
        }

        if (layer.onRemoveGeometry) {
          layer.onRemoveGeometry(this);
        }

        delete this._layer;
        delete this._internalId;
        delete this._extent;
      };

      _proto._getInternalId = function _getInternalId() {
        return this._internalId;
      } //只能被图层调用
      ;

      _proto._setInternalId = function _setInternalId(id) {
        this._internalId = id;
      };

      _proto._getMeasurer = function _getMeasurer() {
        if (this._getProjection()) {
          return this._getProjection();
        }

        return SpatialReference.getProjectionInstance(this.options['defaultProjection']);
      };

      _proto._getProjection = function _getProjection() {
        var map = this.getMap();

        if (map) {
          return map.getProjection();
        }

        return null;
      };

      _proto._verifyProjection = function _verifyProjection() {
        var projection = this._getProjection();

        if (this._projCode && (!projection || this._projCode !== projection.code)) {
          this._clearProjection();
        }

        this._projCode = projection ? projection.code : null;
      } //获取geometry样式中依赖的外部图片资源
      ;

      _proto._getExternalResources = function _getExternalResources() {
        var symbol = this._getInternalSymbol();

        return getExternalResources(symbol);
      };

      _proto._getPainter = function _getPainter() {
        if (!this._painter && this.getMap()) {
          if (GEOMETRY_COLLECTION_TYPES.indexOf(this.type) !== -1) {
            this._painter = new CollectionPainter(this);
          } else {
            this._painter = new Painter(this);
          }
        }

        return this._painter;
      };

      _proto._removePainter = function _removePainter() {
        if (this._painter) {
          this._painter.remove();
        }

        delete this._painter;
      };

      _proto._paint = function _paint(extent) {
        if (this._painter) {
          this._painter.paint(extent);
        }
      };

      _proto._clearCache = function _clearCache() {
        delete this._extent;
      };

      _proto._clearProjection = function _clearProjection() {
        delete this._extent;
      };

      _proto._repaint = function _repaint() {
        if (this._painter) {
          this._painter.repaint();
        }
      };

      _proto.onHide = function onHide() {
        this.closeMenu();
        this.closeInfoWindow();
      };

      _proto.onShapeChanged = function onShapeChanged() {
        this._clearCache();

        this._repaint();
        /**
         * shapechange event.
         *
         * @event Geometry#shapechange
         * @type {Object}
         * @property {String} type - shapechange
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('shapechange');
      };

      _proto.onPositionChanged = function onPositionChanged() {
        this._clearCache();

        this._repaint();
        /**
         * positionchange event.
         *
         * @event Geometry#positionchange
         * @type {Object}
         * @property {String} type - positionchange
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('positionchange');
      };

      _proto.onSymbolChanged = function onSymbolChanged() {
        if (this._painter) {
          this._painter.refreshSymbol();
        }
        /**
         * symbolchange event.
         *
         * @event Geometry#symbolchange
         * @type {Object}
         * @property {String} type - symbolchange
         * @property {Geometry} target - the geometry fires the event
         */


        this._fireEvent('symbolchange');
      };

      _proto.onConfig = function onConfig(conf) {
        var properties;

        if (conf['properties']) {
          properties = conf['properties'];
          delete conf['properties'];
        }

        var needRepaint = false;

        for (var p in conf) {
          if (conf.hasOwnProperty(p)) {
            var prefix = p.slice(0, 5);

            if (prefix === 'arrow' || prefix === 'smoot') {
              needRepaint = true;
              break;
            }
          }
        }

        if (properties) {
          this.setProperties(properties);

          this._repaint();
        } else if (needRepaint) {
          this._repaint();
        }
      }
      /**
       * Set a parent to the geometry, which is usually a MultiPolygon, GeometryCollection, etc
       * @param {GeometryCollection} geometry - parent geometry
       * @private
       */
      ;

      _proto._setParent = function _setParent(geometry) {
        if (geometry) {
          this._parent = geometry;
        }
      };

      _proto._getParent = function _getParent() {
        return this._parent;
      };

      _proto._fireEvent = function _fireEvent(eventName, param) {
        if (this.getLayer() && this.getLayer()._onGeometryEvent) {
          if (!param) {
            param = {};
          }

          param['type'] = eventName;
          param['target'] = this;

          this.getLayer()._onGeometryEvent(param);
        }

        this.fire(eventName, param);
      };

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options)
        };
      };

      _proto._exportGraphicOptions = function _exportGraphicOptions(options) {
        var json = {};

        if (isNil(options['options']) || options['options']) {
          json['options'] = this.config();
        }

        if (isNil(options['symbol']) || options['symbol']) {
          json['symbol'] = this.getSymbol();
        }

        if (isNil(options['infoWindow']) || options['infoWindow']) {
          if (this._infoWinOptions) {
            json['infoWindow'] = this._infoWinOptions;
          }
        }

        return json;
      };

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var points = this.getCoordinates();
        var coordinates = Coordinate.toNumberArrays(points);
        return {
          'type': this.getType(),
          'coordinates': coordinates
        };
      };

      _proto._exportProperties = function _exportProperties() {
        var properties = null;
        var geoProperties = this.getProperties();

        if (!isNil(geoProperties)) {
          if (isObject(geoProperties)) {
            properties = extend({}, geoProperties);
          } else {
            properties = geoProperties;
          }
        }

        return properties;
      };

      return Geometry;
    }(JSONAble(Eventable(Handlerable(Class))));

    Geometry.mergeOptions(options);

    /**
     * @property {Object}  [options=null] - base options of layer.
     * @property {String}  [options.attribution= null] - the attribution of this layer, you can specify company or other information of this layer.
     * @property {Number}  [options.minZoom=-1] - the minimum zoom to display the layer, set to -1 to unlimit it.
     * @property {Number}  [options.maxZoom=-1] - the maximum zoom to display the layer, set to -1 to unlimit it.
     * @property {Boolean} [options.visible=true] - whether to display the layer.
     * @property {Number}  [options.opacity=1] - opacity of the layer, from 0 to 1.
     * @property {Number}  [options.zIndex=undefined] - z index of the layer
     * @property {Boolean} [options.hitDetect=true] - Whether to enable hit detection for layers for cursor styles on this map, disable it to improve performance.
     * @property {String}  [options.renderer=canvas]  - renderer type, "canvas" in default.
     * @property {String}   [options.globalCompositeOperation=null] - (Only for layer rendered with [CanvasRenderer]{@link renderer.CanvasRenderer}) globalCompositeOperation of layer's canvas 2d context.
     * @property {String}   [options.debugOutline='#0f0']  - debug outline's color.
     * @property {String}   [options.cssFilter=null]       - css filter apply to canvas context's filter
     * @property {Boolean}  [options.forceRenderOnMoving=false]    - force to render layer when map is moving
     * @property {Boolean}  [options.forceRenderOnZooming=false]   - force to render layer when map is zooming
     * @property {Boolean}  [options.forceRenderOnRotating=false]  - force to render layer when map is Rotating
     * @memberOf Layer
     * @instance
     */

    var options$1 = {
      'attribution': null,
      'minZoom': null,
      'maxZoom': null,
      'visible': true,
      'opacity': 1,
      // context.globalCompositeOperation, 'source-over' in default
      'globalCompositeOperation': null,
      'renderer': 'canvas',
      'debugOutline': '#0f0',
      'cssFilter': null,
      'forceRenderOnMoving': false,
      'forceRenderOnZooming': false,
      'forceRenderOnRotating': false,
      'hitDetect': function () {
        return !Browser$1.mobile;
      }()
    };
    /**
     * @classdesc
     * Base class for all the layers, defines common methods that all the layer classes share. <br>
     * It is abstract and not intended to be instantiated.
     *
     * @category layer
     * @abstract
     * @extends Class
     * @mixes Eventable
     * @mixes JSONAble
     * @mixes Renderable
     */

    var Layer =
    /*#__PURE__*/
    function (_JSONAble) {
      _inheritsLoose(Layer, _JSONAble);

      function Layer(id, options) {
        var _this;

        var canvas;

        if (options) {
          canvas = options.canvas;
          delete options.canvas;
        }

        _this = _JSONAble.call(this, options) || this;
        _this._canvas = canvas;

        _this.setId(id);

        if (options) {
          _this.setZIndex(options.zIndex);

          if (options.mask) {
            _this.setMask(Geometry.fromJSON(options.mask));
          }
        }

        return _this;
      }
      /**
       * load the tile layer, can't be overrided by sub-classes
       */


      var _proto = Layer.prototype;

      _proto.load = function load() {
        if (!this.getMap()) {
          return this;
        }

        if (this.onLoad()) {
          this._initRenderer();

          var zIndex = this.getZIndex();

          if (!isNil(zIndex)) {
            this._renderer.setZIndex(zIndex);

            if (!this.isCanvasRender()) {
              this._renderer.render();
            }
          }

          this.onLoadEnd();
        }

        return this;
      }
      /**
       * Get the layer id
       * @returns {String} id
       */
      ;

      _proto.getId = function getId() {
        return this._id;
      }
      /**
       * Set a new id to the layer
       * @param {String} id - new layer id
       * @return {Layer} this
       * @fires Layer#idchange
       */
      ;

      _proto.setId = function setId(id) {
        var old = this._id;

        if (!isNil(id)) {
          id = id + '';
        }

        this._id = id;
        /**
         * idchange event.
         *
         * @event Layer#idchange
         * @type {Object}
         * @property {String} type - idchange
         * @property {Layer} target    - the layer fires the event
         * @property {String} old        - value of the old id
         * @property {String} new        - value of the new id
         */

        this.fire('idchange', {
          'old': old,
          'new': id
        });
        return this;
      }
      /**
       * Adds itself to a map.
       * @param {Map} map - map added to
       * @return {Layer} this
       */
      ;

      _proto.addTo = function addTo(map) {
        map.addLayer(this);
        return this;
      }
      /**
       * Set a z-index to the layer
       * @param {Number} zIndex - layer's z-index
       * @return {Layer} this
       */
      ;

      _proto.setZIndex = function setZIndex(zIndex) {
        this._zIndex = zIndex;

        if (isNil(zIndex)) {
          delete this.options['zIndex'];
        } else {
          this.options.zIndex = zIndex;
        }

        if (this.map) {
          this.map._sortLayersByZIndex();
        }

        if (this._renderer) {
          this._renderer.setZIndex(zIndex);
        }

        return this;
      }
      /**
       * Get the layer's z-index
       * @return {Number}
       */
      ;

      _proto.getZIndex = function getZIndex() {
        return this._zIndex || 0;
      }
      /**
       * Get Layer's minZoom to display
       * @return {Number}
       */
      ;

      _proto.getMinZoom = function getMinZoom() {
        var map = this.getMap();
        var minZoom = this.options['minZoom'];
        return map ? Math.max(map.getMinZoom(), minZoom || 0) : minZoom;
      }
      /**
       * Get Layer's maxZoom to display
       * @return {Number}
       */
      ;

      _proto.getMaxZoom = function getMaxZoom() {
        var map = this.getMap();
        var maxZoom = this.options['maxZoom'];
        return map ? Math.min(map.getMaxZoom(), isNil(maxZoom) ? Infinity : maxZoom) : maxZoom;
      }
      /**
       * Get layer's opacity
       * @returns {Number}
       */
      ;

      _proto.getOpacity = function getOpacity() {
        return this.options['opacity'];
      }
      /**
       * Set opacity to the layer
       * @param {Number} opacity - layer's opacity
       * @return {Layer} this
       */
      ;

      _proto.setOpacity = function setOpacity(op) {
        this.config('opacity', op);
        return this;
      }
      /**
       * If the layer is rendered by HTML5 Canvas.
       * @return {Boolean}
       * @protected
       */
      ;

      _proto.isCanvasRender = function isCanvasRender() {
        var renderer = this._getRenderer();

        return renderer && renderer instanceof CanvasRenderer;
      }
      /**
       * Get the map that the layer added to
       * @returns {Map}
       */
      ;

      _proto.getMap = function getMap() {
        if (this.map) {
          return this.map;
        }

        return null;
      }
      /**
       * Get projection of layer's map
       * @returns {Object}
       */
      ;

      _proto.getProjection = function getProjection() {
        var map = this.getMap();
        return map ? map.getProjection() : null;
      }
      /**
       * Brings the layer to the top of all the layers
       * @returns {Layer} this
       */
      ;

      _proto.bringToFront = function bringToFront() {
        var layers = this._getLayerList();

        if (!layers.length) {
          return this;
        }

        var topLayer = layers[layers.length - 1];

        if (layers.length === 1 || topLayer === this) {
          return this;
        }

        var max = topLayer.getZIndex();
        this.setZIndex(max + 1);
        return this;
      }
      /**
       * Brings the layer under the bottom of all the layers
       * @returns {Layer} this
       */
      ;

      _proto.bringToBack = function bringToBack() {
        var layers = this._getLayerList();

        if (!layers.length) {
          return this;
        }

        var bottomLayer = layers[0];

        if (layers.length === 1 || bottomLayer === this) {
          return this;
        }

        var min = bottomLayer.getZIndex();
        this.setZIndex(min - 1);
        return this;
      }
      /**
       * Show the layer
       * @returns {Layer} this
       */
      ;

      _proto.show = function show() {
        var _this2 = this;

        if (!this.options['visible']) {
          this.options['visible'] = true;
          var renderer = this.getRenderer();

          if (renderer) {
            renderer.show();
          }

          var map = this.getMap();

          if (renderer && map) {
            //fire show at renderend to make sure layer is shown
            map.once('renderend', function () {
              _this2.fire('show');
            });
          } else {
            this.fire('show');
          }
        }

        return this;
      }
      /**
       * Hide the layer
       * @returns {Layer} this
       */
      ;

      _proto.hide = function hide() {
        var _this3 = this;

        if (this.options['visible']) {
          this.options['visible'] = false;
          var renderer = this.getRenderer();

          if (renderer) {
            renderer.hide();
          }

          var map = this.getMap();

          if (renderer && map) {
            //fire hide at renderend to make sure layer is hidden
            map.once('renderend', function () {
              _this3.fire('hide');
            });
          } else {
            this.fire('hide');
          }
        } // this.fire('hide');


        return this;
      }
      /**
       * Whether the layer is visible now.
       * @return {Boolean}
       */
      ;

      _proto.isVisible = function isVisible() {
        if (isNumber(this.options['opacity']) && this.options['opacity'] <= 0) {
          return false;
        }

        var map = this.getMap();

        if (map) {
          var zoom = map.getZoom();

          if (!isNil(this.options['maxZoom']) && this.options['maxZoom'] < zoom || !isNil(this.options['minZoom']) && this.options['minZoom'] > zoom) {
            return false;
          }
        }

        if (isNil(this.options['visible'])) {
          this.options['visible'] = true;
        }

        return this.options['visible'];
      }
      /**
       * Remove itself from the map added to.
       * @returns {Layer} this
       */
      ;

      _proto.remove = function remove() {
        if (this.map) {
          this.map.removeLayer(this);
        }

        return this;
      }
      /**
       * Get the mask geometry of the layer
       * @return {Geometry}
       */
      ;

      _proto.getMask = function getMask() {
        return this._mask;
      }
      /**
       * Set a mask geometry on the layer, only the area in the mask will be displayed.
       * @param {Geometry} mask - mask geometry, can only be a Marker with vector symbol, a Polygon or a MultiPolygon
       * @returns {Layer} this
       */
      ;

      _proto.setMask = function setMask(mask) {
        if (!(mask.type === 'Point' && mask._isVectorMarker() || mask.type === 'Polygon' || mask.type === 'MultiPolygon')) {
          throw new Error('Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).');
        }

        if (mask.type === 'Point') {
          mask.updateSymbol({
            'markerLineColor': 'rgba(0, 0, 0, 0)',
            'markerFillOpacity': 0
          });
        } else {
          mask.setSymbol({
            'lineColor': 'rgba(0, 0, 0, 0)',
            'polygonOpacity': 0
          });
        }

        mask._bindLayer(this);

        this._mask = mask;
        this.options.mask = mask.toJSON();

        if (!this.getMap() || this.getMap().isZooming()) {
          return this;
        }

        var renderer = this._getRenderer();

        if (renderer && renderer.setToRedraw) {
          this._getRenderer().setToRedraw();
        }

        return this;
      }
      /**
       * Remove the mask
       * @returns {Layer} this
       */
      ;

      _proto.removeMask = function removeMask() {
        delete this._mask;
        delete this.options.mask;

        if (!this.getMap() || this.getMap().isZooming()) {
          return this;
        }

        var renderer = this._getRenderer();

        if (renderer && renderer.setToRedraw) {
          this._getRenderer().setToRedraw();
        }

        return this;
      }
      /**
       * Prepare Layer's loading, this is a method intended to be overrided by subclasses.
       * @return {Boolean} true to continue loading, false to cease.
       * @protected
       */
      ;

      _proto.onLoad = function onLoad() {
        return true;
      };

      _proto.onLoadEnd = function onLoadEnd() {}
      /**
       * Whether the layer is loaded
       * @return {Boolean}
       */
      ;

      _proto.isLoaded = function isLoaded() {
        return !!this._loaded;
      };

      _proto.getRenderer = function getRenderer() {
        return this._getRenderer();
      };

      _proto.onConfig = function onConfig(conf) {
        if (isNumber(conf['opacity']) || conf['cssFilter']) {
          var renderer = this.getRenderer();

          if (renderer) {
            renderer.setToRedraw();
          }
        }
      };

      _proto.onAdd = function onAdd() {};

      _proto.onRendererCreate = function onRendererCreate() {};

      _proto.onCanvasCreate = function onCanvasCreate() {};

      _proto.onRemove = function onRemove() {};

      _proto._bindMap = function _bindMap(map, zIndex) {
        if (!map) {
          return;
        }

        this.map = map;

        if (!isNil(zIndex)) {
          this.setZIndex(zIndex);
        }

        this._switchEvents('on', this);

        this.onAdd();
        this.fire('add');
      };

      _proto._initRenderer = function _initRenderer() {
        var renderer = this.options['renderer'];

        if (!this.constructor.getRendererClass) {
          return;
        }

        var clazz = this.constructor.getRendererClass(renderer);

        if (!clazz) {
          throw new Error('Invalid renderer for Layer(' + this.getId() + '):' + renderer);
        }

        this._renderer = new clazz(this);
        this._renderer.layer = this;

        this._renderer.setZIndex(this.getZIndex());

        this._switchEvents('on', this._renderer); // some plugin of dom renderer doesn't implement onAdd


        if (this._renderer.onAdd) {
          this._renderer.onAdd();
        }

        this.onRendererCreate();
        /**
         * renderercreate event, fired when renderer is created.
         *
         * @event Layer#renderercreate
         * @type {Object}
         * @property {String} type - renderercreate
         * @property {Layer} target    - the layer fires the event
         * @property {Any} renderer    - renderer of the layer
         */

        this.fire('renderercreate', {
          'renderer': this._renderer
        });
      };

      _proto._doRemove = function _doRemove() {
        this._loaded = false;
        this.onRemove();

        this._switchEvents('off', this);

        if (this._renderer) {
          this._switchEvents('off', this._renderer);

          this._renderer.remove();

          delete this._renderer;
        }

        delete this.map;
      };

      _proto._switchEvents = function _switchEvents(to, emitter) {
        if (emitter && emitter.getEvents) {
          this.getMap()[to](emitter.getEvents(), emitter);
        }
      };

      _proto._getRenderer = function _getRenderer() {
        return this._renderer;
      };

      _proto._getLayerList = function _getLayerList() {
        if (!this.map) {
          return [];
        }

        return this.map._layers;
      };

      _proto._getMask2DExtent = function _getMask2DExtent() {
        if (!this._mask || !this.getMap()) {
          return null;
        }

        var painter = this._mask._getPainter();

        if (!painter) {
          return null;
        }

        return painter.get2DExtent();
      };

      return Layer;
    }(JSONAble(Eventable(Renderable(Class))));

    Layer.mergeOptions(options$1);
    var fire = Layer.prototype.fire;

    Layer.prototype.fire = function (eventType, param) {
      if (eventType === 'layerload') {
        this._loaded = true;
      }

      if (this.map) {
        if (!param) {
          param = {};
        }

        param['type'] = eventType;
        param['target'] = this;

        this.map._onLayerEvent(param);
      }

      return fire.apply(this, arguments);
    };

    /**
     * @property {Object} options                                   - map's options, options must be updated by config method:<br> map.config('zoomAnimation', false);
     * @property {Boolean} [options.centerCross=false]              - Display a red cross in the center of map
     * @property {Boolean} [options.seamlessZoom=false]             - whether to use seamless zooming mode
     * @property {Boolean} [options.zoomInCenter=false]             - whether to fix in the center when zooming
     * @property {Number}  [options.zoomOrigin=null]                - zoom origin in container point, e.g. [400, 300]
     * @property {Boolean} [options.zoomAnimation=true]             - enable zooming animation
     * @property {Number}  [options.zoomAnimationDuration=330]      - zoom animation duration.
     * @property {Boolean} [options.panAnimation=true]              - continue to animate panning when draging or touching ended.
     * @property {Boolean} [options.panAnimationDuration=600]       - duration of pan animation.
     * @property {Boolean} [options.zoomable=true]                  - whether to enable map zooming.
     * @property {Boolean} [options.enableInfoWindow=true]          - whether to enable infowindow on this map.
     * @property {Boolean} [options.hitDetect=true]                 - whether to enable hit detecting of layers for cursor style on this map, disable it to improve performance.
     * @property {Boolean} [options.hitDetectLimit=5]               - the maximum number of layers to perform hit detect.
     * @property {Boolean} [options.fpsOnInteracting=25]            - fps when map is interacting, some slow layers will not be drawn on interacting when fps is low. Set to 0 to disable it.
     * @property {Boolean} [options.layerCanvasLimitOnInteracting=-1]    - limit of layer canvas to draw on map when interacting, set it to improve perf.
     * @property {Number}  [options.maxZoom=null]                   - the maximum zoom the map can be zooming to.
     * @property {Number}  [options.minZoom=null]                   - the minimum zoom the map can be zooming to.
     * @property {Extent}  [options.maxExtent=null]         - when maxExtent is set, map will be restricted to the give max extent and bouncing back when user trying to pan ouside the extent.
     * @property {Boolean} [options.fixCenterOnResize=false]        - whether to fix map center when map is resized
     *
     * @property {Number}  [options.maxPitch=80]                    - max pitch
     * @property {Number}  [options.maxVisualPitch=70]              - the max pitch to be visual
     *
     * @property {Extent}  [options.viewHistory=true]               -  whether to record view history
     * @property {Extent}  [options.viewHistoryCount=10]            -  the count of view history record.
     *
     * @property {Boolean} [options.draggable=true]                         - disable the map dragging if set to false.
     * @property {Boolean} [options.dragPan=true]                           - if true, map can be dragged to pan.
     * @property {Boolean} [options.dragRotate=true]                        - default true. If true, map can be dragged to rotate by right click or ctrl + left click.
     * @property {Boolean} [options.dragPitch=true]                         - default true. If true, map can be dragged to pitch by right click or ctrl + left click.
     * @property {Boolean} [options.dragRotatePitch=true]                  - if true, map is dragged to pitch and rotate at the same time.
     * @property {Boolean} [options.touchGesture=true]                      - whether to allow map to zoom/rotate/tilt by two finger touch gestures.
     * @property {Boolean} [options.touchZoom=true]                         - whether to allow map to zoom by touch pinch.
     * @property {Boolean} [options.touchRotate=true]                       - whether to allow map to rotate by touch pinch.
     * @property {Boolean} [options.touchPitch=true]                        - whether to allow map to pitch by touch pinch.
     * @property {Boolean} [options.touchZoomRotate=false]                  - if true, map is to zoom and rotate at the same time by touch pinch.
     * @property {Boolean} [options.doubleClickZoom=true]                    - whether to allow map to zoom by double click events.
     * @property {Boolean} [options.scrollWheelZoom=true]                   - whether to allow map to zoom by scroll wheel events.
     * @property {Boolean} [options.geometryEvents=true]                    - enable/disable firing geometry events
     *
     * @property {Boolean}        [options.control=true]                    - whether allow map to add controls.
     * @property {Boolean|Object} [options.attribution=true]                - whether to display the attribution control on the map. if true, attribution display maptalks info; if object, you can specify positon or your base content, and both;
     * @property {Boolean|Object} [options.zoomControl=false]               - display the zoom control on the map if set to true or a object as the control construct option.
     * @property {Boolean|Object} [options.scaleControl=false]              - display the scale control on the map if set to true or a object as the control construct option.
     * @property {Boolean|Object} [options.overviewControl=false]           - display the overview control on the map if set to true or a object as the control construct option.
     *
     * @property {Boolean}        [options.fog=true]                        - whether to draw fog in far distance.
     * @property {Number[]}       [options.fogColor=[233, 233, 233]]        - color of fog: [r, g, b]
     *
     * @property {String} [options.renderer=canvas]                 - renderer type. Don't change it if you are not sure about it. About renderer, see [TODO]{@link tutorial.renderer}.
     * @property {Number} [options.devicePixelRatio=null]           - device pixel ratio to override device's default one
     * @memberOf Map
     * @instance
     */

    var options$2 = {
      'maxVisualPitch': 70,
      'maxPitch': 80,
      'centerCross': false,
      'zoomInCenter': false,
      'zoomOrigin': null,
      'zoomAnimation': function () {
        return !IS_NODE;
      }(),
      'zoomAnimationDuration': 330,
      'panAnimation': function () {
        return !IS_NODE;
      }(),
      //default pan animation duration
      'panAnimationDuration': 600,
      'zoomable': true,
      'enableInfoWindow': true,
      'hitDetect': function () {
        return !Browser$1.mobile;
      }(),
      'hitDetectLimit': 5,
      'fpsOnInteracting': 25,
      'layerCanvasLimitOnInteracting': -1,
      'maxZoom': null,
      'minZoom': null,
      'maxExtent': null,
      'fixCenterOnResize': false,
      'checkSize': true,
      'checkSizeInterval': 1000,
      'renderer': 'canvas',
      'cascadePitches': [10, 60]
    };
    /**
     * The central class of the library, to create a map on a container.
     * @category map
     * @extends Class
     *
     * @mixes Eventable
     * @mixes Handlerable
     * @mixes ui.Menuable
     * @mixes Renderable
     *
     * @example
     * var map = new maptalks.Map("map",{
     *      center:     [180,0],
     *      zoom:  4,
     *      baseLayer : new maptalks.TileLayer("base",{
     *          urlTemplate:'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
     *          subdomains:['a','b','c']
     *      }),
     *      layers : [
     *          new maptalks.VectorLayer('v', [new maptalks.Marker([180, 0])])
     *      ]
     * });
     */

    var Map$1 =
    /*#__PURE__*/
    function (_Handlerable) {
      _inheritsLoose(Map, _Handlerable);

      /**
       * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>
       *                                          1. A HTMLElement container.<br/>
       *                                          2. ID of a HTMLElement container.<br/>
       *                                          3. Any canvas compatible container
       * @param {Object} options - construct options
       * @param {(Number[]|Coordinate)} options.center - initial center of the map.
       * @param {Number} options.zoom - initial zoom of the map.
       * @param {Object} [options.spatialReference=null] - map's spatial reference, default is using projection EPSG:3857 with resolutions used by google map/osm.
       * @param {Layer} [options.baseLayer=null] - base layer that will be set to map initially.
       * @param {Layer[]} [options.layers=null] - layers that will be added to map initially.
       * @param {*} options.* - any other option defined in [Map.options]{@link Map#options}      [description]
       */
      function Map(container, options) {
        var _this;

        if (!options) {
          throw new Error('Invalid options when creating map.');
        }

        if (!options['center']) {
          throw new Error('Invalid center when creating map.');
        } // prepare options


        var opts = extend({}, options);
        var zoom = opts['zoom'];
        delete opts['zoom'];
        var center = new Coordinate(opts['center']);
        delete opts['center'];
        var baseLayer = opts['baseLayer'];
        delete opts['baseLayer'];
        var layers = opts['layers'];
        delete opts['layers'];
        _this = _Handlerable.call(this, opts) || this;
        /**
         * @property {String}  - Version of library
         * @constant
         * @static
         */

        _this.VERSION = Map.VERSION;
        Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'id', {
          value: UID(),
          writable: false
        });
        _this._loaded = false;

        _this._initContainer(container);

        _this._panels = {}; //Layers

        _this._baseLayer = null;
        _this._layers = [];
        _this._zoomLevel = zoom;
        _this._center = center;

        _this.setSpatialReference(opts['spatialReference'] || opts['view']);

        _this._mapViewPoint = new Point(0, 0);

        _this._initRenderer();

        _this._updateMapSize(_this._getContainerDomSize());

        if (baseLayer) {
          _this.setBaseLayer(baseLayer);
        }

        if (layers) {
          _this.addLayer(layers);
        }

        _this._Load();

        return _this;
      }
      /**
       * Add hooks for additional codes when map's loading complete, useful for plugin developping.
       * Note that it can only be called before the map is created.
       * @param {Function} fn
       * @returns {Map}
       * @protected
       */


      Map.addOnLoadHook = function addOnLoadHook(fn) {
        // (Function) || (String, args...)
        var args = Array.prototype.slice.call(arguments, 1);
        var onload = typeof fn === 'function' ? fn : function () {
          this[fn].apply(this, args);
        };
        this.prototype._onLoadHooks = this.prototype._onLoadHooks || [];

        this.prototype._onLoadHooks.push(onload);

        return this;
      }
      /**
       * Whether the map is loaded or not.
       * @return {Boolean}
       */
      ;

      var _proto = Map.prototype;

      _proto.isLoaded = function isLoaded() {
        return !!this._loaded;
      }
      /**
       * Get map's container
       * @returns {HTMLElement}
       */
      ;

      _proto.getContainer = function getContainer() {
        return this._containerDOM;
      }
      /**
       * Get the spatial reference of the Map.
       * @return {SpatialReference} map's spatial reference
       */
      ;

      _proto.getSpatialReference = function getSpatialReference() {
        return this._spatialReference;
      }
      /**
       * Change the spatial reference of the map. <br>
       * A SpatialReference is a series of settings to decide the map presentation:<br>
       * 1. the projection.<br>
       * 2. zoom levels and resolutions. <br>
       * 3. full extent.<br>
       * There are some [predefined spatial references]{@link http://www.foo.com}, and surely you can [define a custom one.]{@link http://www.foo.com}.<br>
       * SpatialReference can also be updated by map.config('spatialReference', spatialReference);
       * @param {SpatialReference} spatialReference - spatial reference
       * @returns {Map} this
       * @fires Map#spatialreferencechange
       * @example
       *  map.setSpatialReference({
              projection:'EPSG:4326',
              resolutions: (function() {
                  const resolutions = [];
                  for (let i=0; i < 19; i++) {
                      resolutions[i] = 180/(Math.pow(2, i)*128);
                  }
                  return resolutions;
              })()
       *  });
         @example
       *  map.config('spatialReference', {
              projection:'EPSG:4326',
              resolutions: (function() {
                  const resolutions = [];
                  for (let i=0; i < 19; i++) {
                      resolutions[i] = 180/(Math.pow(2, i)*128);
                  }
                  return resolutions;
              })()
          });
       */
      ;

      _proto.setSpatialReference = function setSpatialReference(ref) {
        var oldRef = this.options['spatialReference'];

        if (this._loaded && SpatialReference.equals(oldRef, ref)) {
          return this;
        }

        this._updateSpatialReference(ref, oldRef);

        return this;
      };

      _proto._updateSpatialReference = function _updateSpatialReference(ref, oldRef) {
        ref = extend({}, ref);
        this._center = this.getCenter();
        this.options['spatialReference'] = ref;
        this._spatialReference = new SpatialReference(ref);

        if (this.options['spatialReference'] && isFunction(this.options['spatialReference']['projection'])) {
          var projection = this._spatialReference.getProjection(); //save projection code for map profiling (toJSON/fromJSON)


          this.options['spatialReference']['projection'] = projection['code'];
        }

        this._resetMapStatus();
        /**
         * spatialreferencechange event, fired when map's spatial reference is updated.
         *
         * @event Map#spatialreferencechange
         * @type {Object}
         * @property {String} type - spatialreferencechange
         * @property {Map} target - map
         * @property {Map} old - the old spatial reference
         * @property {Map} new - the new spatial reference changed to
         */


        this._fireEvent('spatialreferencechange', {
          'old': oldRef,
          'new': extend({}, this.options['spatialReference'])
        });

        return this;
      } // _syncWorld() {
      //     const projection = this.getProjection();
      //     if (!projection) {
      //         return false;
      //     }
      //     const pcenter = this._getPrjCenter();
      //     if (projection.isOutSphere(pcenter)) {
      //         const wrapped = projection.wrapCoord(pcenter);
      //         this._setPrjCenter(wrapped);
      //         this._fireEvent('syncworld', { 'old' : pcenter.toArray(), 'new' : wrapped.toArray() });
      //         return true;
      //     }
      //     return false;
      // }

      /**
       * Callback when any option is updated
       * @private
       * @param  {Object} conf - options to update
       * @return {Map}   this
       */
      ;

      _proto.onConfig = function onConfig(conf) {
        var ref = conf['spatialReference'] || conf['view'];

        if (!isNil(ref)) {
          this._updateSpatialReference(ref, null);
        }

        return this;
      }
      /**
       * Get the projection of the map. <br>
       * Projection is an algorithm for map projection, e.g. well-known [Mercator Projection]{@link https://en.wikipedia.org/wiki/Mercator_projection} <br>
       * A projection must have 2 methods: <br>
       * 1. project(coordinate) - project the input coordinate <br>
       * 2. unproject(coordinate) - unproject the input coordinate <br>
       * Projection also contains measuring method usually extended from a measurer: <br>
       * 1. measureLength(coord1, coord2) - compute length between 2 coordinates.  <br>
       * 2. measureArea(coords[]) - compute area of the input coordinates. <br>
       * 3. locate(coord, distx, disty) - compute the coordinate from the coord with xdist on axis x and ydist on axis y.
       * @return {Object}
       */
      ;

      _proto.getProjection = function getProjection() {
        if (!this._spatialReference) {
          return null;
        }

        return this._spatialReference.getProjection();
      }
      /**
       * Get map's full extent, which is defined in map's spatial reference. <br>
       * eg: {'left': -180, 'right' : 180, 'top' : 90, 'bottom' : -90}
       * @return {Extent}
       */
      ;

      _proto.getFullExtent = function getFullExtent() {
        if (!this._spatialReference) {
          return null;
        }

        return this._spatialReference.getFullExtent();
      }
      /**
       * Set map's cursor style, cursor style is same with CSS.
       * @param {String} cursor - cursor style
       * @returns {Map} this
       * @example
       * map.setCursor('url(cursor.png) 4 12, auto');
       */
      ;

      _proto.setCursor = function setCursor(cursor) {
        delete this._cursor;

        this._trySetCursor(cursor);

        this._cursor = cursor;
        return this;
      }
      /**
       * Reset map's cursor style.
       * @return {Map} this
       * @example
       * map.resetCursor();
       */
      ;

      _proto.resetCursor = function resetCursor() {
        return this.setCursor(null);
      }
      /**
       * Get center of the map.
       * @return {Coordinate}
       */
      ;

      _proto.getCenter = function getCenter() {
        if (!this._loaded || !this._prjCenter) {
          return this._center;
        }

        var projection = this.getProjection();
        return projection.unproject(this._prjCenter);
      }
      /**
       * Set a new center to the map.
       * @param {Coordinate} center
       * @return {Map} this
       */
      ;

      _proto.setCenter = function setCenter(center) {
        if (!center) {
          return this;
        }

        center = new Coordinate(center);
        var projection = this.getProjection();
        var pcenter = projection.project(center);

        if (!this._verifyExtent(pcenter)) {
          return this;
        }

        if (!this._loaded) {
          this._center = center;
          return this;
        }

        this.onMoveStart();

        this._setPrjCenter(pcenter);

        this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
        return this;
      }
      /**
       * Get map's size (width and height) in pixel.
       * @return {Size}
       */
      ;

      _proto.getSize = function getSize() {
        if (isNil(this.width) || isNil(this.height)) {
          return this._getContainerDomSize();
        }

        return new Size(this.width, this.height);
      }
      /**
       * Get container extent of the map
       * @return {PointExtent}
       */
      ;

      _proto.getContainerExtent = function getContainerExtent() {
        var visualHeight = this.height;
        var pitch = this.getPitch(),
            maxVisualPitch = this.options['maxVisualPitch'];

        if (maxVisualPitch && pitch > maxVisualPitch) {
          visualHeight = this._getVisualHeight(maxVisualPitch);
        }

        return new PointExtent(0, this.height - visualHeight, this.width, this.height);
      };

      _proto._getVisualHeight = function _getVisualHeight(visualPitch) {
        // const pitch = this.getPitch();
        // const visualDistance = this.height / 2 * Math.tan(visualPitch * Math.PI / 180);
        // return this.height / 2 + visualDistance *  Math.tan((90 - pitch) * Math.PI / 180);
        var pitch = (90 - this.getPitch()) * Math.PI / 180;
        var fov = this.getFov() * Math.PI / 180;
        visualPitch *= Math.PI / 180;
        var cameraToCenter = this.cameraCenterDistance / this.getGLScale();
        var tanB = Math.tan(fov / 2);
        var tanP = Math.tan(visualPitch);
        var visualDistance = cameraToCenter * tanB / (1 / tanP - tanB) / Math.sin(visualPitch);
        var x = cameraToCenter * (Math.sin(pitch) * visualDistance / (cameraToCenter + Math.cos(pitch) * visualDistance));
        return this.height / 2 + x;
      }
      /**
       * Get the geographical extent of map's current view extent.
       *
       * @return {Extent}
       */
      ;

      _proto.getExtent = function getExtent() {
        return this._pointToExtent(this._get2DExtent());
      }
      /**
       * Get the projected geographical extent of map's current view extent.
       *
       * @return {Extent}
       */
      ;

      _proto.getProjExtent = function getProjExtent() {
        var extent2D = this._get2DExtent();

        return new Extent(this._pointToPrj(extent2D.getMin()), this._pointToPrj(extent2D.getMax()));
      }
      /**
       * Alias for getProjExtent
       *
       * @return {Extent}
       */
      ;

      _proto.getPrjExtent = function getPrjExtent() {
        return this.getProjExtent();
      }
      /**
       * Get the max extent that the map is restricted to.
       * @return {Extent}
       */
      ;

      _proto.getMaxExtent = function getMaxExtent() {
        if (!this.options['maxExtent']) {
          return null;
        }

        return new Extent(this.options['maxExtent'], this.getProjection());
      }
      /**
       * Sets the max extent that the map is restricted to.
       * @param {Extent}
       * @return {Map} this
       * @example
       * map.setMaxExtent(map.getExtent());
       */
      ;

      _proto.setMaxExtent = function setMaxExtent(extent) {
        if (extent) {
          var maxExt = new Extent(extent, this.getProjection());
          this.options['maxExtent'] = maxExt;

          if (!this._verifyExtent(this._getPrjCenter())) {
            this._panTo(this._prjMaxExtent().getCenter());
          }

          var projection = this.getProjection();
          this._prjMaxExtent = maxExt.convertTo(function (c) {
            return projection.project(c);
          });
        } else {
          delete this.options['maxExtent'];
          delete this._prjMaxExtent;
        }

        return this;
      }
      /**
       * Get map's current zoom.
       * @return {Number}
       */
      ;

      _proto.getZoom = function getZoom() {
        return this._zoomLevel;
      }
      /**
       * Caculate the target zoom if scaling from "fromZoom" by "scale"
       * @param  {Number} scale
       * @param  {Number} fromZoom
       * @param  {Boolean} isFraction - can return fractional zoom
       * @return {Number} zoom fit for scale starting from fromZoom
       */
      ;

      _proto.getZoomForScale = function getZoomForScale(scale, fromZoom, isFraction) {
        var zoom = this.getZoom();

        if (isNil(fromZoom)) {
          fromZoom = zoom;
        }

        if (scale === 1 && fromZoom === zoom) {
          return zoom;
        }

        var res = this._getResolution(fromZoom),
            targetRes = res / scale;

        var scaleZoom = this.getZoomFromRes(targetRes);

        if (isFraction) {
          return scaleZoom;
        } else {
          var delta = 1E-6; //avoid precision

          return this.getSpatialReference().getZoomDirection() < 0 ? Math.ceil(scaleZoom - delta) : Math.floor(scaleZoom + delta);
        }
      };

      _proto.getZoomFromRes = function getZoomFromRes(res) {
        var resolutions = this._getResolutions(),
            minRes = this._getResolution(this.getMinZoom()),
            maxRes = this._getResolution(this.getMaxZoom());

        if (minRes <= maxRes) {
          if (res <= minRes) {
            return this.getMinZoom();
          } else if (res >= maxRes) {
            return this.getMaxZoom();
          }
        } else if (res >= minRes) {
          return this.getMinZoom();
        } else if (res <= maxRes) {
          return this.getMaxZoom();
        }

        var l = resolutions.length;

        for (var i = 0; i < l - 1; i++) {
          if (!resolutions[i]) {
            continue;
          }

          var gap = resolutions[i + 1] - resolutions[i];
          var test = res - resolutions[i];

          if (sign(gap) === sign(test) && Math.abs(gap) >= Math.abs(test)) {
            return i + test / gap;
          }
        }

        return l - 1;
      }
      /**
       * Sets zoom of the map
       * @param {Number} zoom
       * @param {Object} [options=null] options
       * @param {Boolean} [options.animation=true] whether zoom is animation, true by default
       * @returns {Map} this
       */
      ;

      _proto.setZoom = function setZoom(zoom, options) {
        if (options === void 0) {
          options = {
            'animation': true
          };
        }

        if (isNaN(zoom) || isNil(zoom)) {
          return this;
        }

        zoom = +zoom;

        if (this._loaded && this.options['zoomAnimation'] && options['animation']) {
          this._zoomAnimation(zoom);
        } else {
          this._zoom(zoom);
        }

        return this;
      }
      /**
       * Get the max zoom that the map can be zoom to.
       * @return {Number}
       */
      ;

      _proto.getMaxZoom = function getMaxZoom() {
        if (!isNil(this.options['maxZoom'])) {
          return this.options['maxZoom'];
        }

        return this.getMaxNativeZoom();
      }
      /**
       * Sets the max zoom that the map can be zoom to.
       * @param {Number} maxZoom
       * @returns {Map} this
       */
      ;

      _proto.setMaxZoom = function setMaxZoom(maxZoom) {
        var viewMaxZoom = this.getMaxNativeZoom();

        if (maxZoom > viewMaxZoom) {
          maxZoom = viewMaxZoom;
        }

        if (maxZoom !== null && maxZoom < this._zoomLevel) {
          this.setZoom(maxZoom);
          maxZoom = +maxZoom;
        }

        this.options['maxZoom'] = maxZoom;
        return this;
      }
      /**
       * Get the min zoom that the map can be zoom to.
       * @return {Number}
       */
      ;

      _proto.getMinZoom = function getMinZoom() {
        if (!isNil(this.options['minZoom'])) {
          return this.options['minZoom'];
        }

        return this._spatialReference.getMinZoom();
      }
      /**
       * Sets the min zoom that the map can be zoom to.
       * @param {Number} minZoom
       * @return {Map} this
       */
      ;

      _proto.setMinZoom = function setMinZoom(minZoom) {
        if (minZoom !== null) {
          minZoom = +minZoom;

          var viewMinZoom = this._spatialReference.getMinZoom();

          if (minZoom < viewMinZoom) {
            minZoom = viewMinZoom;
          }

          if (minZoom > this._zoomLevel) {
            this.setZoom(minZoom);
          }
        }

        this.options['minZoom'] = minZoom;
        return this;
      }
      /**
       * Maximum zoom the map has
       * @return {Number}
       */
      ;

      _proto.getMaxNativeZoom = function getMaxNativeZoom() {
        var ref = this.getSpatialReference();

        if (!ref) {
          return null;
        }

        return ref.getMaxZoom();
      }
      /**
       * Zoom for world point in WebGL context
       * @returns {Number}
       */
      ;

      _proto.getGLZoom = function getGLZoom() {
        return this.getMaxNativeZoom() / 2;
      }
      /**
       * Caculate scale from gl zoom to given zoom (default by current zoom)
       * @param {Number} [zoom=undefined] target zoom, current zoom by default
       * @returns {Number}
       * @examples
       * const point = map.coordToPoint(map.getCenter());
       * // convert to point in gl zoom
       * const glPoint = point.multi(this.getGLScale());
       */
      ;

      _proto.getGLScale = function getGLScale(zoom) {
        if (isNil(zoom)) {
          zoom = this.getZoom();
        }

        return this._getResolution(zoom) / this._getResolution(this.getGLZoom());
      }
      /**
       * zoom in
       * @return {Map} this
       */
      ;

      _proto.zoomIn = function zoomIn() {
        return this.setZoom(this.getZoom() + 1);
      }
      /**
       * zoom out
       * @return {Map} this
       */
      ;

      _proto.zoomOut = function zoomOut() {
        return this.setZoom(this.getZoom() - 1);
      }
      /**
       * Whether the map is zooming
       * @return {Boolean}
       */
      ;

      _proto.isZooming = function isZooming() {
        return !!this._zooming;
      }
      /**
       * Whether the map is being interacted
       * @return {Boolean}
       */
      ;

      _proto.isInteracting = function isInteracting() {
        return this.isZooming() || this.isMoving() || this.isRotating();
      }
      /**
       * Sets the center and zoom at the same time.
       * @param {Coordinate} center
       * @param {Number} zoom
       * @return {Map} this
       */
      ;

      _proto.setCenterAndZoom = function setCenterAndZoom(center, zoom) {
        if (!isNil(zoom) && this._zoomLevel !== zoom) {
          this.setCenter(center);
          this.setZoom(zoom, {
            animation: false
          });
        } else {
          this.setCenter(center);
        }

        return this;
      }
      /**
       * Caculate the zoom level that contains the given extent with the maximum zoom level possible.
       * @param {Extent} extent
       * @param  {Boolean} isFraction - can return fractional zoom
       * @return {Number} zoom fit for scale starting from fromZoom
       */
      ;

      _proto.getFitZoom = function getFitZoom(extent, isFraction) {
        var _this2 = this;

        if (!extent || !(extent instanceof Extent)) {
          return this._zoomLevel;
        } //It's a point


        if (extent['xmin'] === extent['xmax'] && extent['ymin'] === extent['ymax']) {
          return this.getMaxZoom();
        }

        var size = this.getSize();
        var containerExtent = extent.convertTo(function (p) {
          return _this2.coordToContainerPoint(p);
        });
        var w = containerExtent.getWidth(),
            h = containerExtent.getHeight();
        var scaleX = size['width'] / w,
            scaleY = size['height'] / h;
        var scale = this.getSpatialReference().getZoomDirection() < 0 ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);
        var zoom = this.getZoomForScale(scale, null, isFraction);
        return zoom;
      }
      /**
       * Get map's current view (center/zoom/pitch/bearing)
       * @return {Object} { center : *, zoom : *, pitch : *, bearing : * }
       */
      ;

      _proto.getView = function getView() {
        return {
          'center': this.getCenter().toArray(),
          'zoom': this.getZoom(),
          'pitch': this.getPitch(),
          'bearing': this.getBearing()
        };
      }
      /**
       * Set map's center/zoom/pitch/bearing at one time
       * @param {Object} view - a object containing center/zoom/pitch/bearing
       * return {Map} this
       */
      ;

      _proto.setView = function setView(view) {
        if (!view) {
          return this;
        }

        if (view['center']) {
          this.setCenter(view['center']);
        }

        if (view['zoom'] !== null && !isNaN(+view['zoom'])) {
          this.setZoom(+view['zoom'], {
            'animation': false
          });
        }

        if (view['pitch'] !== null && !isNaN(+view['pitch'])) {
          this.setPitch(+view['pitch']);
        }

        if (view['pitch'] !== null && !isNaN(+view['bearing'])) {
          this.setBearing(+view['bearing']);
        }

        return this;
      }
      /**
       * Get map's resolution
       * @param {Number} zoom - zoom or current zoom if not given
       * @return {Number} resolution
       */
      ;

      _proto.getResolution = function getResolution(zoom) {
        return this._getResolution(zoom);
      }
      /**
       * Get scale of resolutions from zoom to max zoom
       * @param {Number} zoom - zoom or current zoom if not given
       * @return {Number} scale
       */
      ;

      _proto.getScale = function getScale(zoom) {
        var z = isNil(zoom) ? this.getZoom() : zoom;

        var max = this._getResolution(this.getMaxNativeZoom()),
            res = this._getResolution(z);

        return res / max;
      }
      /**
       * Set the map to be fit for the given extent with the max zoom level possible.
       * @param  {Extent} extent - extent
       * @param  {Number} zoomOffset - zoom offset
       * @return {Map} - this
       */
      ;

      _proto.fitExtent = function fitExtent(extent, zoomOffset, options, step) {
        if (options === void 0) {
          options = {};
        }

        if (!extent) {
          return this;
        }

        extent = new Extent(extent, this.getProjection());
        var zoom = this.getFitZoom(extent) + (zoomOffset || 0);
        var center = extent.getCenter();
        if (typeof options['animation'] === 'undefined' || options['animation']) return this._animateTo({
          center: center,
          zoom: zoom
        }, {
          'duration': options['duration'] || this.options['zoomAnimationDuration'],
          'easing': options['easing'] || 'out'
        }, step);else return this.setCenterAndZoom(center, zoom);
      }
      /**
       * Get the base layer of the map.
       * @return {Layer}
       */
      ;

      _proto.getBaseLayer = function getBaseLayer() {
        return this._baseLayer;
      }
      /**
       * Sets a new base layer to the map.<br>
       * Some events will be thrown such as baselayerchangestart, baselayerload, baselayerchangeend.
       * @param  {Layer} baseLayer - new base layer
       * @return {Map} this
       * @fires Map#setbaselayer
       * @fires Map#baselayerchangestart
       * @fires Map#baselayerchangeend
       */
      ;

      _proto.setBaseLayer = function setBaseLayer(baseLayer) {
        var isChange = false;

        if (this._baseLayer) {
          isChange = true;
          /**
           * baselayerchangestart event, fired when base layer is changed.
           *
           * @event Map#baselayerchangestart
           * @type {Object}
           * @property {String} type - baselayerchangestart
           * @property {Map} target - map
           */

          this._fireEvent('baselayerchangestart');

          this._baseLayer.remove();
        }

        if (!baseLayer) {
          delete this._baseLayer;
          /**
           * baselayerchangeend event, fired when base layer is changed.
           *
           * @event Map#baselayerchangeend
           * @type {Object}
           * @property {String} type - baselayerchangeend
           * @property {Map} target - map
           */

          this._fireEvent('baselayerchangeend');
          /**
           * setbaselayer event, fired when base layer is set.
           *
           * @event Map#setbaselayer
           * @type {Object}
           * @property {String} type - setbaselayer
           * @property {Map} target - map
           */


          this._fireEvent('setbaselayer');

          return this;
        }

        this._baseLayer = baseLayer;

        baseLayer._bindMap(this, -1);

        function onbaseLayerload() {
          /**
           * baselayerload event, fired when base layer is loaded.
           *
           * @event Map#baselayerload
           * @type {Object}
           * @property {String} type - baselayerload
           * @property {Map} target - map
           */
          this._fireEvent('baselayerload');

          if (isChange) {
            isChange = false;

            this._fireEvent('baselayerchangeend');
          }
        }

        this._baseLayer.on('layerload', onbaseLayerload, this);

        if (this._loaded) {
          this._baseLayer.load();
        }

        this._fireEvent('setbaselayer');

        return this;
      }
      /**
       * Remove the base layer from the map
       * @return {Map} this
       * @fires Map#baselayerremove
       */
      ;

      _proto.removeBaseLayer = function removeBaseLayer() {
        if (this._baseLayer) {
          this._baseLayer.remove();

          delete this._baseLayer;
          /**
           * baselayerremove event, fired when base layer is removed.
           *
           * @event Map#baselayerremove
           * @type {Object}
           * @property {String} type - baselayerremove
           * @property {Map} target - map
           */

          this._fireEvent('baselayerremove');
        }

        return this;
      }
      /**
       * Get the layers of the map, except base layer (which should be by getBaseLayer). <br>
       * A filter function can be given to filter layers, e.g. exclude all the VectorLayers.
       * @param {Function} [filter=undefined] - a filter function of layers, return false to exclude the given layer.
       * @return {Layer[]}
       * @example
       * var vectorLayers = map.getLayers(function (layer) {
       *     return (layer instanceof VectorLayer);
       * });
       */
      ;

      _proto.getLayers = function getLayers(filter) {
        return this._getLayers(function (layer) {
          if (layer === this._baseLayer || layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0) {
            return false;
          }

          if (filter) {
            return filter(layer);
          }

          return true;
        });
      }
      /**
       * Get the layer with the given id.
       * @param  {String} id - layer id
       * @return {Layer}
       */
      ;

      _proto.getLayer = function getLayer(id) {
        if (!id) {
          return null;
        }

        var layer = this._layerCache ? this._layerCache[id] : null;

        if (layer) {
          return layer;
        }

        var baseLayer = this.getBaseLayer();

        if (baseLayer && baseLayer.getId() === id) {
          return baseLayer;
        }

        return null;
      }
      /**
       * Add a new layer on the top of the map.
       * @param  {Layer|Layer[]} layer - one or more layers to add
       * @return {Map} this
       * @fires Map#addlayer
       */
      ;

      _proto.addLayer = function addLayer(layers) {
        if (!layers) {
          return this;
        }

        if (!Array.isArray(layers)) {
          layers = Array.prototype.slice.call(arguments, 0);
          return this.addLayer(layers);
        }

        if (!this._layerCache) {
          this._layerCache = {};
        }

        var mapLayers = this._layers;

        for (var i = 0, len = layers.length; i < len; i++) {
          var layer = layers[i];
          var id = layer.getId();

          if (isNil(id)) {
            throw new Error('Invalid id for the layer: ' + id);
          }

          if (layer.getMap() === this) {
            continue;
          }

          if (this._layerCache[id]) {
            throw new Error('Duplicate layer id in the map: ' + id);
          }

          this._layerCache[id] = layer;

          layer._bindMap(this);

          mapLayers.push(layer);

          if (this._loaded) {
            layer.load();
          }
        }

        this._sortLayersByZIndex();
        /**
         * addlayer event, fired when adding layers.
         *
         * @event Map#addlayer
         * @type {Object}
         * @property {String} type - addlayer
         * @property {Map} target - map
         * @property {Layer[]} layers - layers to add
         */


        this._fireEvent('addlayer', {
          'layers': layers
        });

        return this;
      }
      /**
       * Remove a layer from the map
       * @param  {String|String[]|Layer|Layer[]} layer - one or more layers or layer ids
       * @return {Map} this
       * @fires Map#removelayer
       */
      ;

      _proto.removeLayer = function removeLayer(layers) {
        if (!layers) {
          return this;
        }

        if (!Array.isArray(layers)) {
          return this.removeLayer([layers]);
        }

        var removed = [];

        for (var i = 0, len = layers.length; i < len; i++) {
          var layer = layers[i];

          if (!(layer instanceof Layer)) {
            layer = this.getLayer(layer);
          }

          if (!layer) {
            continue;
          }

          var map = layer.getMap();

          if (!map || map !== this) {
            continue;
          }

          removed.push(layer);

          this._removeLayer(layer, this._layers);

          if (this._loaded) {
            layer._doRemove();
          }

          var id = layer.getId();

          if (this._layerCache) {
            delete this._layerCache[id];
          }
        }

        if (removed.length > 0) {
          var renderer = this.getRenderer();

          if (renderer) {
            renderer.setLayerCanvasUpdated();
          }

          this.once('frameend', function () {
            removed.forEach(function (layer) {
              layer.fire('remove');
            });
          });
        }
        /**
         * removelayer event, fired when removing layers.
         *
         * @event Map#removelayer
         * @type {Object}
         * @property {String} type - removelayer
         * @property {Map} target - map
         * @property {Layer[]} layers - layers to remove
         */


        this._fireEvent('removelayer', {
          'layers': layers
        });

        return this;
      }
      /**
       * Sort layers according to the order provided, the last will be on the top.
       * @param  {string[]|Layer[]} layers - layers or layer ids to sort
       * @return {Map} this
       * @example
       * map.addLayer([layer1, layer2, layer3]);
       * map.sortLayers([layer2, layer3, layer1]);
       * map.sortLayers(['3', '2', '1']); // sort by layer ids.
       */
      ;

      _proto.sortLayers = function sortLayers(layers) {
        if (!layers || !Array.isArray(layers)) {
          return this;
        }

        var layersToOrder = [];
        var minZ = Number.MAX_VALUE;

        for (var i = 0, l = layers.length; i < l; i++) {
          var layer = layers[i];

          if (isString(layers[i])) {
            layer = this.getLayer(layer);
          }

          if (!(layer instanceof Layer) || !layer.getMap() || layer.getMap() !== this) {
            throw new Error('It must be a layer added to this map to order.');
          }

          if (layer.getZIndex() < minZ) {
            minZ = layer.getZIndex();
          }

          layersToOrder.push(layer);
        }

        for (var _i = 0, _l = layersToOrder.length; _i < _l; _i++) {
          layersToOrder[_i].setZIndex(minZ + _i);
        }

        return this;
      }
      /**
       * Exports image from the map's canvas.
       * @param {Object} [options=undefined] - options
       * @param {String} [options.mimeType=image/png] - mime type of the image
       * @param {Boolean} [options.save=false] - whether pop a file save dialog to save the export image.
       * @param {String} [options.fileName=export] - specify the file name, if options.save is true.
       * @return {String} image of base64 format.
       */
      ;

      _proto.toDataURL = function toDataURL(options) {
        if (!options) {
          options = {};
        }

        var mimeType = options['mimeType'];

        if (!mimeType) {
          mimeType = 'image/png';
        }

        var save = options['save'];

        var renderer = this._getRenderer();

        if (renderer && renderer.toDataURL) {
          var file = options['fileName'];

          if (!file) {
            file = 'export';
          }

          var dataURL = renderer.toDataURL(mimeType);

          if (save && dataURL) {
            var imgURL;

            if (typeof Blob !== 'undefined' && typeof atob !== 'undefined') {
              var blob = b64toBlob(dataURL.replace(/^data:image\/(png|jpeg|jpg);base64,/, ''), mimeType);
              imgURL = URL.createObjectURL(blob);
            } else {
              imgURL = dataURL;
            }

            var dlLink = document.createElement('a');
            dlLink.download = file;
            dlLink.href = imgURL;
            document.body.appendChild(dlLink);
            dlLink.click();
            document.body.removeChild(dlLink);
          }

          return dataURL;
        }

        return null;
      }
      /**
       * shorter alias for coordinateToPoint
       */
      ;

      _proto.coordToPoint = function coordToPoint(coordinate, zoom, out) {
        return this.coordinateToPoint(coordinate, zoom, out);
      }
      /**
       * shorter alias for pointToCoordinate
       */
      ;

      _proto.pointToCoord = function pointToCoord(point, zoom, out) {
        return this.pointToCoordinate(point, zoom, out);
      }
      /**
       * shorter alias for coordinateToViewPoint
       */
      ;

      _proto.coordToViewPoint = function coordToViewPoint(coordinate, out) {
        return this.coordinateToViewPoint(coordinate, out);
      }
      /**
       * shorter alias for viewPointToCoordinate
       */
      ;

      _proto.viewPointToCoord = function viewPointToCoord(viewPoint, out) {
        return this.viewPointToCoordinate(viewPoint, out);
      }
      /**
       * shorter alias for coordinateToContainerPoint
       */
      ;

      _proto.coordToContainerPoint = function coordToContainerPoint(coordinate, zoom, out) {
        return this.coordinateToContainerPoint(coordinate, zoom, out);
      }
      /**
       * shorter alias for containerPointToCoordinate
       */
      ;

      _proto.containerPointToCoord = function containerPointToCoord(containerPoint, out) {
        return this.containerPointToCoordinate(containerPoint, out);
      }
      /**
       * Converts a container point to the view point.
       * Usually used in plugin development.
       * @param {Point}
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @returns {Point}
       */
      ;

      _proto.containerPointToViewPoint = function containerPointToViewPoint(containerPoint, out) {
        if (out) {
          out.set(containerPoint.x, containerPoint.y);
        } else {
          out = containerPoint.copy();
        }

        return out._sub(this.getViewPoint());
      }
      /**
       * Converts a view point to the container point.
       * Usually used in plugin development.
       * @param {Point}
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @returns {Point}
       */
      ;

      _proto.viewPointToContainerPoint = function viewPointToContainerPoint(viewPoint, out) {
        if (out) {
          out.set(viewPoint.x, viewPoint.y);
        } else {
          out = viewPoint.copy();
        }

        return out._add(this.getViewPoint());
      }
      /**
       * Checks if the map container size changed and updates the map if so.
       * @return {Map} this
       * @fires Map#resize
       */
      ;

      _proto.checkSize = function checkSize() {
        var justStart = now() - this._initTime < 1500 && this.width === 0 || this.height === 0;

        var watched = this._getContainerDomSize(),
            oldHeight = this.height,
            oldWidth = this.width;

        if (watched['width'] === oldWidth && watched['height'] === oldHeight) {
          return this;
        }

        var center = this.getCenter();

        this._updateMapSize(watched);

        if (!this.options['fixCenterOnResize']) {
          var resizeOffset = new Point((oldWidth - watched.width) / 2, (oldHeight - watched.height) / 2);

          this._offsetCenterByPixel(resizeOffset); // when size changed, center is updated but panel's offset remains.


          this._mapViewCoord = this._getPrjCenter();
        }

        var hided = watched['width'] === 0 || watched['height'] === 0 || oldWidth === 0 || oldHeight === 0;

        if (justStart || hided) {
          this._noEvent = true;
          this.setCenter(center);
          delete this._noEvent;
        }
        /**
         * resize event when map container's size changes
         * @event Map#resize
         * @type {Object}
         * @property {String} type - resize
         * @property {Map} target - map fires the event
         */


        this._fireEvent('resize');

        return this;
      }
      /**
       * Computes the coordinate from the given meter distance.
       * @param  {Coordinate} coordinate - source coordinate
       * @param  {Number} dx           - meter distance on X axis
       * @param  {Number} dy           - meter distance on Y axis
       * @return {Coordinate} Result coordinate
       */
      ;

      _proto.locate = function locate(coordinate, dx, dy) {
        return this.getProjection()._locate(new Coordinate(coordinate), dx, dy);
      }
      /**
       * Return map's main panel
       * @returns {HTMLElement}
       */
      ;

      _proto.getMainPanel = function getMainPanel() {
        return this._getRenderer().getMainPanel();
      }
      /**
       * Returns map panels.
       * @return {Object}
       */
      ;

      _proto.getPanels = function getPanels() {
        return this._panels;
      }
      /**
       * Remove the map
       * @return {Map} this
       */
      ;

      _proto.remove = function remove() {
        if (this.isRemoved()) {
          return this;
        }

        this._fireEvent('removestart');

        this._removeDomEvents();

        this._clearHandlers();

        this.removeBaseLayer();
        var layers = this.getLayers();

        for (var i = 0; i < layers.length; i++) {
          layers[i].remove();
        }

        if (this._getRenderer()) {
          this._getRenderer().remove();
        }

        if (this._containerDOM.innerHTML) {
          this._containerDOM.innerHTML = '';
        }

        delete this._panels;
        delete this._containerDOM;
        delete this.renderer;

        this._fireEvent('removeend');

        this._clearAllListeners();

        return this;
      }
      /**
       * whether the map is removed
       * @return {Boolean}
       */
      ;

      _proto.isRemoved = function isRemoved() {
        return !this._containerDOM;
      }
      /**
       * Whether the map is moving
       * @return {Boolean}
       */
      ;

      _proto.isMoving = function isMoving() {
        return !!this._moving;
      }
      /**
       * The callback function when move started
       * @private
       * @fires Map#movestart
       */
      ;

      _proto.onMoveStart = function onMoveStart(param) {
        this._originCenter = this._getPrjCenter();
        this._moving = true;

        this._trySetCursor('move');
        /**
         * movestart event
         * @event Map#movestart
         * @type {Object}
         * @property {String} type - movestart
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        this._fireEvent('movestart', this._parseEvent(param ? param['domEvent'] : null, 'movestart'));
      };

      _proto.onMoving = function onMoving(param) {
        /**
         * moving event
         * @event Map#moving
         * @type {Object}
         * @property {String} type - moving
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */
        this._fireEvent('moving', this._parseEvent(param ? param['domEvent'] : null, 'moving'));
      };

      _proto.onMoveEnd = function onMoveEnd(param) {
        this._moving = false;

        this._trySetCursor('default');
        /**
         * moveend event
         * @event Map#moveend
         * @type {Object}
         * @property {String} type - moveend
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        this._fireEvent('moveend', param && param['domEvent'] ? this._parseEvent(param['domEvent'], 'moveend') : param);

        if (!this._verifyExtent(this._getPrjCenter())) {
          var moveTo = this._originCenter;

          if (!this._verifyExtent(moveTo)) {
            moveTo = this.getMaxExtent().getCenter();
          }

          this._panTo(moveTo);
        }
      };

      _proto.onDragRotateStart = function onDragRotateStart(param) {
        this._dragRotating = true;
        /**
         * dragrotatestart event
         * @event Map#dragrotatestart
         * @type {Object}
         * @property {String} type - dragrotatestart
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */

        this._fireEvent('dragrotatestart', this._parseEvent(param ? param['domEvent'] : null, 'dragrotatestart'));
      };

      _proto.onDragRotating = function onDragRotating(param) {
        /**
         * dragrotating event
         * @event Map#dragrotating
         * @type {Object}
         * @property {String} type - dragrotating
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */
        this._fireEvent('dragrotating', this._parseEvent(param ? param['domEvent'] : null, 'dragrotating'));
      };

      _proto.onDragRotateEnd = function onDragRotateEnd(param) {
        this._dragRotating = false;
        /**
         * dragrotateend event
         * @event Map#dragrotateend
         * @type {Object}
         * @property {String} type - dragrotateend
         * @property {Map} target - map fires the event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */

        this._fireEvent('dragrotateend', this._parseEvent(param ? param['domEvent'] : null, 'dragrotateend'));
      };

      _proto.isDragRotating = function isDragRotating() {
        return !!this._dragRotating;
      };

      _proto.getRenderer = function getRenderer() {
        return this._getRenderer();
      }
      /**
       * Get device's devicePixelRatio, you can override it by setting devicePixelRatio in options.
       * @returns {Number}
       */
      ;

      _proto.getDevicePixelRatio = function getDevicePixelRatio() {
        return this.options['devicePixelRatio'] || Math.ceil(Browser$1.devicePixelRatio) || 1;
      } //-----------------------------------------------------------
      ;

      _proto._initContainer = function _initContainer(container) {
        if (isString(container)) {
          this._containerDOM = document.getElementById(container);

          if (!this._containerDOM) {
            throw new Error('Invalid container when creating map: \'' + container + '\'');
          }
        } else {
          this._containerDOM = container;

          if (IS_NODE) {
            //Reserve container's constructor in node for canvas creating.
            this.CanvasClass = typeof Canvas !== 'undefined' ? Canvas : this._containerDOM.constructor;
          }
        }

        if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0) {
          if (this._containerDOM.childNodes[0].className === 'maptalks-wrapper') {
            throw new Error('Container is already loaded with another map instance, use map.remove() to clear it.');
          }
        }
      }
      /**
       * try to change cursor when map is not setCursored
       * @private
       * @param  {String} cursor css cursor
       */
      ;

      _proto._trySetCursor = function _trySetCursor(cursor) {
        if (!this._cursor && !this._priorityCursor) {
          if (!cursor) {
            cursor = 'default';
          }

          this._setCursorToPanel(cursor);
        }

        return this;
      };

      _proto._setPriorityCursor = function _setPriorityCursor(cursor) {
        if (!cursor) {
          var hasCursor = false;

          if (this._priorityCursor) {
            hasCursor = true;
          }

          delete this._priorityCursor;

          if (hasCursor) {
            this.setCursor(this._cursor);
          }
        } else {
          this._priorityCursor = cursor;

          this._setCursorToPanel(cursor);
        }

        return this;
      };

      _proto._setCursorToPanel = function _setCursorToPanel(cursor) {
        var panel = this.getMainPanel();

        if (panel && panel.style && panel.style.cursor !== cursor) {
          panel.style.cursor = cursor;
        }
      } //remove a layer from the layerList
      ;

      _proto._removeLayer = function _removeLayer(layer, layerList) {
        if (!layer || !layerList) {
          return;
        }

        var index = layerList.indexOf(layer);

        if (index > -1) {
          layerList.splice(index, 1);
        }
      };

      _proto._sortLayersByZIndex = function _sortLayersByZIndex() {
        if (!this._layers) {
          return;
        }

        for (var i = 0, l = this._layers.length; i < l; i++) {
          this._layers[i]._order = i;
        }

        this._layers.sort(function (a, b) {
          var c = a.getZIndex() - b.getZIndex();

          if (c === 0) {
            return a._order - b._order;
          }

          return c;
        });
      };

      _proto._fireEvent = function _fireEvent(eventName, param) {
        if (this._noEvent) {
          return;
        } //fire internal events at first


        this.fire('_' + eventName, param);
        this.fire(eventName, param);
      };

      _proto._Load = function _Load() {
        this._resetMapStatus();

        if (this.options['pitch']) {
          this.setPitch(this.options['pitch']);
          delete this.options['pitch'];
        }

        if (this.options['bearing']) {
          this.setBearing(this.options['bearing']);
          delete this.options['bearing'];
        }

        this._loadAllLayers();

        this._getRenderer().onLoad();

        this._loaded = true;

        this._callOnLoadHooks();

        this._initTime = now();
      };

      _proto._initRenderer = function _initRenderer() {
        var renderer = this.options['renderer'];
        var clazz = Map.getRendererClass(renderer);
        this._renderer = new clazz(this);

        this._renderer.load();
      };

      _proto._getRenderer = function _getRenderer() {
        return this._renderer;
      };

      _proto._loadAllLayers = function _loadAllLayers() {
        function loadLayer(layer) {
          if (layer) {
            layer.load();
          }
        }

        if (this._baseLayer) {
          this._baseLayer.load();
        }

        this._eachLayer(loadLayer, this.getLayers());
      }
      /**
       * Gets layers that fits for the filter
       * @param  {fn} filter - filter function
       * @return {Layer[]}
       * @private
       */
      ;

      _proto._getLayers = function _getLayers(filter) {
        var layers = this._baseLayer ? [this._baseLayer].concat(this._layers) : this._layers;
        var result = [];

        for (var i = 0; i < layers.length; i++) {
          if (!filter || filter.call(this, layers[i])) {
            result.push(layers[i]);
          }
        }

        return result;
      };

      _proto._eachLayer = function _eachLayer(fn) {
        if (arguments.length < 2) {
          return;
        }

        var layerLists = Array.prototype.slice.call(arguments, 1);

        if (layerLists && !Array.isArray(layerLists)) {
          layerLists = [layerLists];
        }

        var layers = [];

        for (var i = 0, len = layerLists.length; i < len; i++) {
          layers = layers.concat(layerLists[i]);
        }

        for (var j = 0, jlen = layers.length; j < jlen; j++) {
          fn.call(fn, layers[j]);
        }
      };

      _proto._onLayerEvent = function _onLayerEvent(param) {
        if (!param) {
          return;
        }

        if (param['type'] === 'idchange') {
          delete this._layerCache[param['old']];
          this._layerCache[param['new']] = param['target'];
        }
      } //Check and reset map's status when map's spatial reference is changed.
      ;

      _proto._resetMapStatus = function _resetMapStatus() {
        var maxZoom = this.getMaxZoom(),
            minZoom = this.getMinZoom();

        var viewMaxZoom = this._spatialReference.getMaxZoom(),
            viewMinZoom = this._spatialReference.getMinZoom();

        if (isNil(maxZoom) || maxZoom === -1 || maxZoom > viewMaxZoom) {
          this.setMaxZoom(viewMaxZoom);
        }

        if (isNil(minZoom) || minZoom === -1 || minZoom < viewMinZoom) {
          this.setMinZoom(viewMinZoom);
        }

        maxZoom = this.getMaxZoom();
        minZoom = this.getMinZoom();

        if (maxZoom < minZoom) {
          this.setMaxZoom(minZoom);
        }

        if (isNil(this._zoomLevel) || this._zoomLevel > maxZoom) {
          this._zoomLevel = maxZoom;
        }

        if (this._zoomLevel < minZoom) {
          this._zoomLevel = minZoom;
        }

        delete this._prjCenter;
        var projection = this.getProjection();
        this._prjCenter = projection.project(this._center);

        this._calcMatrices();

        var renderer = this._getRenderer();

        if (renderer) {
          renderer.resetContainer();
        }
      };

      _proto._getContainerDomSize = function _getContainerDomSize() {
        if (!this._containerDOM) {
          return null;
        }

        var containerDOM = this._containerDOM;
        var width, height;

        if (!isNil(containerDOM.width) && !isNil(containerDOM.height)) {
          width = containerDOM.width;
          height = containerDOM.height;
          var dpr = this.getDevicePixelRatio();

          if (dpr !== 1 && containerDOM['layer']) {
            //is a canvas tile of CanvasTileLayer
            width /= dpr;
            height /= dpr;
          }
        } else if (!isNil(containerDOM.clientWidth) && !isNil(containerDOM.clientHeight)) {
          width = parseInt(containerDOM.clientWidth, 0);
          height = parseInt(containerDOM.clientHeight, 0);
        } else {
          throw new Error('can not get size of container');
        }

        return new Size(width, height);
      };

      _proto._updateMapSize = function _updateMapSize(mSize) {
        this.width = mSize['width'];
        this.height = mSize['height'];

        this._getRenderer().updateMapSize(mSize);

        this._calcMatrices();

        return this;
      }
      /**
       * Gets projected center of the map
       * @return {Coordinate}
       * @private
       */
      ;

      _proto._getPrjCenter = function _getPrjCenter() {
        return this._prjCenter;
      };

      _proto._setPrjCenter = function _setPrjCenter(pcenter) {
        this._prjCenter = pcenter;

        if (this.isInteracting() && !this.isMoving()) {
          // when map is not moving, map's center is updated but map platform won't
          // mapViewCoord needs to be synced
          this._mapViewCoord = pcenter;
        }

        this._calcMatrices();
      };

      _proto._setPrjCoordAtContainerPoint = function _setPrjCoordAtContainerPoint(coordinate, point) {
        if (point.x === this.width / 2 && point.y === this.height / 2) {
          return this;
        }

        var t = this._containerPointToPoint(point)._sub(this._prjToPoint(this._getPrjCenter()));

        var pcenter = this._pointToPrj(this._prjToPoint(coordinate).sub(t));

        this._setPrjCenter(pcenter);

        return this;
      };

      _proto._verifyExtent = function _verifyExtent(prjCenter) {
        if (!prjCenter) {
          return false;
        }

        var maxExt = this._prjMaxExtent;

        if (!maxExt) {
          return true;
        }

        return maxExt.contains(prjCenter);
      }
      /**
       * Move map's center by pixels.
       * @param  {Point} pixel - pixels to move, the relation between value and direction is as:
       * -1,1 | 1,1
       * ------------
       *-1,-1 | 1,-1
       * @private
       * @returns {Coordinate} the new projected center.
       */
      ;

      _proto._offsetCenterByPixel = function _offsetCenterByPixel(pixel) {
        var pos = new Point(this.width / 2 - pixel.x, this.height / 2 - pixel.y);

        var pCenter = this._containerPointToPrj(pos);

        this._setPrjCenter(pCenter);

        return pCenter;
      }
      /**
       * offset map panels.
       *
       * @param  {Point} offset - offset in pixel to move
       * @return {Map} this
       */

      /**
       * Gets map panel's current view point.
       * @return {Point}
       */
      ;

      _proto.offsetPlatform = function offsetPlatform(offset) {
        if (!offset) {
          return this._mapViewPoint;
        } else {
          this._getRenderer().offsetPlatform(offset);

          this._mapViewCoord = this._getPrjCenter();
          this._mapViewPoint = this._mapViewPoint.add(offset);
          return this;
        }
      }
      /**
       * Get map's view point, adding in frame offset
       * @return {Point} map view point
       */
      ;

      _proto.getViewPoint = function getViewPoint() {
        var offset = this._getViewPointFrameOffset();

        var panelOffset = this.offsetPlatform();

        if (offset) {
          panelOffset = panelOffset.add(offset);
        }

        return panelOffset;
      };

      _proto._resetMapViewPoint = function _resetMapViewPoint() {
        this._mapViewPoint = new Point(0, 0); // mapViewCoord is the proj coordinate of current view point

        this._mapViewCoord = this._getPrjCenter();
      }
      /**
       * Get map's current resolution
       * @return {Number} resolution
       * @private
       */
      ;

      _proto._getResolution = function _getResolution(zoom) {
        if ((zoom === undefined || zoom === this._zoomLevel) && this._mapRes !== undefined) {
          return this._mapRes;
        } else if (zoom === this.getGLZoom() && this._mapGlRes !== undefined) {
          return this._mapGlRes;
        }

        if (isNil(zoom)) {
          zoom = this._zoomLevel;
        }

        return this._spatialReference.getResolution(zoom);
      };

      _proto._getResolutions = function _getResolutions() {
        return this._spatialReference.getResolutions();
      }
      /**
       * Converts the projected coordinate to a 2D point in the specific zoom
       * @param  {Coordinate} pCoord - projected Coordinate
       * @param  {Number} zoom   - point's zoom level
       * @return {Point} 2D point
       * @private
       */
      ;

      _proto._prjToPoint = function _prjToPoint(pCoord, zoom, out) {
        zoom = isNil(zoom) ? this.getZoom() : zoom;
        return this._spatialReference.getTransformation().transform(pCoord, this._getResolution(zoom), out);
      }
      /**
       * Converts the 2D point to projected coordinate
       * @param  {Point} point - 2D point
       * @param  {Number} zoom   - point's zoom level
       * @return {Coordinate} projected coordinate
       * @private
       */
      ;

      _proto._pointToPrj = function _pointToPrj(point, zoom, out) {
        zoom = isNil(zoom) ? this.getZoom() : zoom;
        return this._spatialReference.getTransformation().untransform(point, this._getResolution(zoom), out);
      }
      /**
       * Convert point at zoom to point at current zoom
       * @param  {Point} point point
       * @param  {Number} zoom point's zoom
       * @return {Point} point at current zoom
       * @private
       */
      ;

      _proto._pointToPoint = function _pointToPoint(point, zoom, out) {
        if (out) {
          out.x = point.x;
          out.y = point.y;
        } else {
          out = point.copy();
        }

        if (!isNil(zoom)) {
          return out._multi(this._getResolution(zoom) / this._getResolution());
        }

        return out;
      }
      /**
       * Convert point at current zoom to point at target zoom
       * @param  {Point} point point
       * @param  {Number} zoom target zoom
       * @return {Point} point at current zoom
       * @private
       */
      ;

      _proto._pointToPointAtZoom = function _pointToPointAtZoom(point, zoom, out) {
        if (out) {
          out.x = point.x;
          out.y = point.y;
        } else {
          out = point.copy();
        }

        if (!isNil(zoom)) {
          return out._multi(this._getResolution() / this._getResolution(zoom));
        }

        return out;
      }
      /**
       * transform container point to geographical projected coordinate
       *
       * @param  {Point} containerPoint
       * @return {Coordinate}
       * @private
       */
      ;

      _proto._containerPointToPrj = function _containerPointToPrj(containerPoint, out) {
        return this._pointToPrj(this._containerPointToPoint(containerPoint, undefined, out), undefined, out);
      }
      /* eslint no-extend-native: 0 */
      ;

      _proto._callOnLoadHooks = function _callOnLoadHooks() {
        var proto = Map.prototype;

        if (!proto._onLoadHooks) {
          return;
        }

        for (var i = 0, l = proto._onLoadHooks.length; i < l; i++) {
          proto._onLoadHooks[i].call(this);
        }
      };

      return Map;
    }(Handlerable(Eventable(Renderable(Class))));

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Converts a coordinate to the 2D point in current zoom or in the specific zoom. <br>
       * The 2D point's coordinate system's origin is the same with map's origin.
       * Usually used in plugin development.
       * @param  {Coordinate} coordinate - coordinate
       * @param  {Number} [zoom=undefined]  - zoom level
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @return {Point}  2D point
       * @function
       * @example
       * var point = map.coordinateToPoint(new Coordinate(121.3, 29.1));
       */
      coordinateToPoint: function () {
        var COORD = new Coordinate(0, 0);
        return function (coordinate, zoom, out) {
          var prjCoord = this.getProjection().project(coordinate, COORD);
          return this._prjToPoint(prjCoord, zoom, out);
        };
      }(),

      /**
       * Converts a 2D point in current zoom or a specific zoom to a coordinate.
       * Usually used in plugin development.
       * @param  {Point} point - 2D point
       * @param  {Number} zoom  - point's zoom level
       * @param  {Coordinate} [out=undefined]    - optional coordinate to receive result
       * @return {Coordinate} coordinate
       * @function
       * @example
       * var coord = map.pointToCoordinate(new Point(4E6, 3E4));
       */
      pointToCoordinate: function () {
        var COORD = new Coordinate(0, 0);
        return function (point, zoom, out) {
          var prjCoord = this._pointToPrj(point, zoom, COORD);

          return this.getProjection().unproject(prjCoord, out);
        };
      }(),

      /**
       * Converts a geographical coordinate to view point.<br>
       * A view point is a point relative to map's mapPlatform panel's position. <br>
       * Usually used in plugin development.
       * @param {Coordinate} coordinate
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @return {Point}
       * @function
       */
      coordinateToViewPoint: function () {
        var COORD = new Coordinate(0, 0);
        return function (coordinate, out) {
          return this._prjToViewPoint(this.getProjection().project(coordinate, COORD), out);
        };
      }(),

      /**
       * Converts a view point to the geographical coordinate.
       * Usually used in plugin development.
       * @param {Point} viewPoint
       * @param  {Coordinate} [out=undefined]    - optional coordinate to receive result
       * @return {Coordinate}
       * @function
       */
      viewPointToCoordinate: function () {
        var COORD = new Coordinate(0, 0);
        return function (viewPoint, out) {
          return this.getProjection().unproject(this._viewPointToPrj(viewPoint, COORD), out);
        };
      }(),

      /**
       * Convert a geographical coordinate to the container point. <br>
       *  A container point is a point relative to map container's top-left corner. <br>
       * @param {Coordinate}                - coordinate
       * @param  {Number} [zoom=undefined]  - zoom level
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @return {Point}
       * @function
       */
      coordinateToContainerPoint: function () {
        var COORD = new Coordinate(0, 0);
        return function (coordinate, zoom, out) {
          var pCoordinate = this.getProjection().project(coordinate, COORD);
          return this._prjToContainerPoint(pCoordinate, zoom, out);
        };
      }(),

      /**
       * Converts a container point to geographical coordinate.
       * @param {Point}
       * @param  {Coordinate} [out=undefined]    - optional coordinate to receive result
       * @return {Coordinate}
       * @function
       */
      containerPointToCoordinate: function () {
        var COORD = new Coordinate(0, 0);
        return function (containerPoint, out) {
          var pCoordinate = this._containerPointToPrj(containerPoint, COORD);

          return this.getProjection().unproject(pCoordinate, out);
        };
      }(),

      /**
       * Converts a container point extent to the geographic extent.
       * @param  {PointExtent} containerExtent - containeproints extent
       * @return {Extent}  geographic extent
       * @function
       */
      containerToExtent: function () {
        var POINT0 = new Point(0, 0);
        var POINT1 = new Point(0, 0);
        return function (containerExtent) {
          var extent2D = new PointExtent(this._containerPointToPoint(containerExtent.getMin(POINT0), undefined, POINT0), this._containerPointToPoint(containerExtent.getMax(POINT1), undefined, POINT1));
          return this._pointToExtent(extent2D);
        };
      }(),

      /**
       * Converts geographical distances to the pixel length.<br>
       * The value varis with difference zoom level.
       *
       * @param  {Number} xDist - distance on X axis.
       * @param  {Number} yDist - distance on Y axis.
       * @return {Size} result.width: pixel length on X axis; result.height: pixel length on Y axis
       * @function
       */
      distanceToPixel: function () {
        var POINT0 = new Point(0, 0);
        var POINT1 = new Point(0, 0);
        return function (xDist, yDist, zoom) {
          var projection = this.getProjection();

          if (!projection) {
            return null;
          }

          var scale = this.getScale() / this.getScale(zoom);
          var center = this.getCenter(),
              target = projection.locate(center, xDist, yDist);
          var p0 = this.coordToContainerPoint(center, undefined, POINT0),
              p1 = this.coordToContainerPoint(target, undefined, POINT1);

          p1._sub(p0)._multi(scale)._abs();

          return new Size(p1.x, p1.y);
        };
      }(),

      /**
       * Converts geographical distances to the 2d point length.<br>
       * The value varis with difference zoom level.
       *
       * @param  {Number} xDist - distance on X axis.
       * @param  {Number} yDist - distance on Y axis.
       * @param  {Number} zoom - point's zoom
       * @return {Point}
       * @function
       */
      distanceToPoint: function () {
        var POINT = new Point(0, 0);
        return function (xDist, yDist, zoom) {
          var projection = this.getProjection();

          if (!projection) {
            return null;
          }

          var center = this.getCenter(),
              target = projection.locate(center, xDist, yDist);
          var p0 = this.coordToPoint(center, zoom, POINT),
              p1 = this.coordToPoint(target, zoom);

          p1._sub(p0)._abs();

          return p1;
        };
      }(),

      /**
       * Converts pixel size to geographical distance.
       *
       * @param  {Number} width - pixel width
       * @param  {Number} height - pixel height
       * @return {Number}  distance - Geographical distance
       * @function
       */
      pixelToDistance: function () {
        var COORD0 = new Coordinate(0, 0);
        var COORD1 = new Coordinate(0, 0);
        return function (width, height) {
          var projection = this.getProjection();

          if (!projection) {
            return null;
          }

          var fullExt = this.getFullExtent();
          var d = fullExt['top'] > fullExt['bottom'] ? -1 : 1;
          var target = COORD0.set(this.width / 2 + width, this.height / 2 + d * height);
          var coord = this.containerPointToCoord(target, COORD1);
          return projection.measureLength(this.getCenter(), coord);
        };
      }(),

      /**
       * Converts 2d point distances to geographic length.<br>
       *
       * @param  {Number} dx - distance on X axis.
       * @param  {Number} dy - distance on Y axis.
       * @param  {Number} zoom - point's zoom
       * @return {Number} distance
       * @function
       */
      pointToDistance: function () {
        var POINT = new Point(0, 0);
        var COORD = new Coordinate(0, 0);
        return function (dx, dy, zoom) {
          var projection = this.getProjection();

          if (!projection) {
            return null;
          }

          var c = this._prjToPoint(this._getPrjCenter(), zoom, POINT);

          c._add(dx, dy);

          var target = this.pointToCoord(c, zoom, COORD);
          return projection.measureLength(this.getCenter(), target);
        };
      }(),

      /**
       * Computes the coordinate from the given pixel distance.
       * @param  {Coordinate} coordinate - source coordinate
       * @param  {Number} px           - pixel distance on X axis
       * @param  {Number} py           - pixel distance on Y axis
       * @return {Coordinate} Result coordinate
       * @function
       */
      locateByPoint: function () {
        var POINT = new Point(0, 0);
        return function (coordinate, px, py) {
          var point = this.coordToContainerPoint(coordinate, undefined, POINT);
          return this.containerPointToCoord(point._add(px, py));
        };
      }(),

      /**
       * Get map's extent in view points.
       * @param {Number} zoom - zoom
       * @return {PointExtent}
       * @private
       * @function
       */
      _get2DExtent: function () {
        var POINT = new Point(0, 0);
        return function (zoom, out) {
          var _this3 = this;

          var cached;

          if ((zoom === undefined || zoom === this._zoomLevel) && this._mapExtent2D) {
            cached = this._mapExtent2D;
          } else if (zoom === this.getGLZoom() && this._mapGlExtent2D) {
            cached = this._mapGlExtent2D;
          }

          if (cached) {
            if (out) {
              out.set(cached['xmin'], cached['ymin'], cached['xmax'], cached['ymax']);
              return out;
            }

            return cached.copy();
          }

          var cExtent = this.getContainerExtent();
          return cExtent.convertTo(function (c) {
            return _this3._containerPointToPoint(c, zoom, POINT);
          }, out);
        };
      }(),

      /**
       * Converts a view point extent to the geographic extent.
       * @param  {PointExtent} extent2D - view points extent
       * @return {Extent}  geographic extent
       * @protected
       * @function
       */
      _pointToExtent: function () {
        var COORD0 = new Coordinate(0, 0);
        var COORD1 = new Coordinate(0, 0);
        return function (extent2D) {
          var min2d = extent2D.getMin(),
              max2d = extent2D.getMax();
          var fullExtent = this.getFullExtent();

          var _ref = !fullExtent || fullExtent.left <= fullExtent.right ? [min2d.x, max2d.x] : [max2d.x, min2d.x],
              minx = _ref[0],
              maxx = _ref[1];

          var _ref2 = !fullExtent || fullExtent.top > fullExtent.bottom ? [max2d.y, min2d.y] : [min2d.y, max2d.y],
              miny = _ref2[0],
              maxy = _ref2[1];

          var min = min2d.set(minx, maxy);
          var max = max2d.set(maxx, miny);
          return new Extent(this.pointToCoord(min, undefined, COORD0), this.pointToCoord(max, undefined, COORD1), this.getProjection());
        };
      }(),

      /**
       * When moving map, map's center is updated in real time, but platform will be moved in the next frame to keep syncing with other layers
       * Get the offset in current frame and the next frame
       * @return {Point} view point offset
       * @private
       * @function
       */
      _getViewPointFrameOffset: function () {
        var POINT = new Point(0, 0);
        return function () {
          // when zooming, view point is not updated, and container is being transformed with matrix.
          // so ignore the frame offset
          if (this.isZooming()) {
            return null;
          }

          var pcenter = this._getPrjCenter();

          if (this._mapViewCoord && !this._mapViewCoord.equals(pcenter)) {
            return this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(pcenter, undefined, POINT));
          }

          return null;
        };
      }(),

      /**
       * transform view point to geographical projected coordinate
       * @param  {Point} viewPoint
       * @param  {Coordinate} [out=undefined]  - optional coordinate to receive result
       * @return {Coordinate}
       * @private
       * @function
       */
      _viewPointToPrj: function () {
        var POINT = new Point(0, 0);
        return function (viewPoint, out) {
          return this._containerPointToPrj(this.viewPointToContainerPoint(viewPoint, POINT), out);
        };
      }(),

      /**
       * transform geographical projected coordinate to container point
       * @param  {Coordinate} pCoordinate
       * @param  {Number} zoom target zoom
       * @param  {Point} [out=undefined]    - optional point to receive result
       * @return {Point}
       * @private
       * @function
       */
      _prjToContainerPoint: function () {
        var POINT = new Point(0, 0);
        return function (pCoordinate, zoom, out) {
          return this._pointToContainerPoint(this._prjToPoint(pCoordinate, zoom, POINT), zoom, 0, out);
        };
      }(),

      /**
       * transform geographical projected coordinate to view point
       * @param  {Coordinate} pCoordinate
       * @return {Point}
       * @private
       * @function
       */
      _prjToViewPoint: function () {
        var POINT = new Point(0, 0);
        return function (pCoordinate, out) {
          var containerPoint = this._prjToContainerPoint(pCoordinate, undefined, POINT);

          return this.containerPointToViewPoint(containerPoint, out);
        };
      }(),
      _viewPointToPoint: function () {
        var POINT = new Point(0, 0);
        return function (viewPoint, zoom, out) {
          return this._containerPointToPoint(this.viewPointToContainerPoint(viewPoint, POINT), zoom, out);
        };
      }(),
      _pointToViewPoint: function () {
        var COORD = new Coordinate(0, 0);
        return function (point, zoom, out) {
          return this._prjToViewPoint(this._pointToPrj(point, zoom, COORD), out);
        };
      }()
    });
    Map$1.mergeOptions(options$2);

    var MapDoubleClickZoomHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapDoubleClickZoomHandler, _Handler);

      function MapDoubleClickZoomHandler() {
        return _Handler.apply(this, arguments) || this;
      }

      var _proto = MapDoubleClickZoomHandler.prototype;

      _proto.addHooks = function addHooks() {
        if (!this.target) {
          return;
        }

        this.target.on('_dblclick', this._onDoubleClick, this);
      };

      _proto.removeHooks = function removeHooks() {
        if (!this.target) {
          return;
        }

        this.target.off('_dblclick', this._onDoubleClick, this);
      };

      _proto._onDoubleClick = function _onDoubleClick(param) {
        var map = this.target;

        if (map.options['doubleClickZoom']) {
          var oldZoom = map.getZoom(),
              zoom = param['domEvent']['shiftKey'] ? Math.ceil(oldZoom) - 1 : Math.floor(oldZoom) + 1;

          map._zoomAnimation(zoom, param['containerPoint']);
        }
      };

      return MapDoubleClickZoomHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'doubleClickZoom': true
    });
    Map$1.addOnLoadHook('addHandler', 'doubleClickZoom', MapDoubleClickZoomHandler);

    var MapDragHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapDragHandler, _Handler);

      function MapDragHandler() {
        return _Handler.apply(this, arguments) || this;
      }

      var _proto = MapDragHandler.prototype;

      _proto.addHooks = function addHooks() {
        var map = this.target;

        if (!map) {
          return;
        }

        var dom = map._panels.mapWrapper || map._containerDOM;
        this._dragHandler = new DragHandler(dom, {
          'cancelOn': this._cancelOn.bind(this),
          'rightclick': true
        });

        this._dragHandler.on('mousedown', this._onMouseDown, this).on('dragstart', this._onDragStart, this).on('dragging', this._onDragging, this).on('dragend', this._onDragEnd, this).enable();
      };

      _proto.removeHooks = function removeHooks() {
        this._dragHandler.off('mousedown', this._onMouseDown, this).off('dragstart', this._onDragStart, this).off('dragging', this._onDragging, this).off('dragend', this._onDragEnd, this);

        this._dragHandler.remove();

        delete this._dragHandler;
      };

      _proto._cancelOn = function _cancelOn(domEvent) {
        if (this.target.isZooming() || this._ignore(domEvent)) {
          return true;
        }

        return false;
      };

      _proto._ignore = function _ignore(param) {
        if (!param) {
          return false;
        }

        if (param.domEvent) {
          param = param.domEvent;
        }

        return this.target._ignoreEvent(param);
      };

      _proto._onMouseDown = function _onMouseDown(param) {
        delete this.startDragTime;
        delete this._mode;

        if (param.domEvent.button === 2 || param.domEvent.ctrlKey) {
          if (this.target.options['dragRotate'] || this.target.options['dragPitch']) {
            this._mode = 'rotatePitch';
          }
        } else if (this.target.options['dragPan']) {
          this._mode = 'move';
        }

        this.target._stopAnim(this.target._mapAnimPlayer);

        preventDefault(param['domEvent']);
      };

      _proto._onDragStart = function _onDragStart(param) {
        this.startDragTime = now();

        if (this._mode === 'move') {
          this._moveStart(param);
        } else if (this._mode === 'rotatePitch') {
          this._rotateStart(param);
        }
      };

      _proto._onDragging = function _onDragging(param) {
        var map = this.target;

        if (map._isEventOutMap(param['domEvent'])) {
          return;
        }

        if (this._mode === 'move') {
          this._moving(param);
        } else if (this._mode === 'rotatePitch') {
          this._rotating(param);
        }
      };

      _proto._onDragEnd = function _onDragEnd(param) {
        if (this._mode === 'move') {
          this._moveEnd(param);
        } else if (this._mode === 'rotatePitch') {
          this._rotateEnd(param);
        }

        delete this.startDragTime;
        delete this.startBearing;
      };

      _proto._start = function _start(param) {
        this.preX = param['mousePos'].x;
        this.preY = param['mousePos'].y;
        this.startX = this.preX;
        this.startY = this.preY;
      };

      _proto._moveStart = function _moveStart(param) {
        this._start(param);

        var map = this.target;
        map.onMoveStart(param);
        var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());
        this.startPrjCoord = map._containerPointToPrj(p);
      };

      _proto._moving = function _moving(param) {
        if (!this.startDragTime) {
          return;
        }

        var map = this.target;
        var p = getEventContainerPoint(map._getActualEvent(param.domEvent), map.getContainer());

        map._setPrjCoordAtContainerPoint(this.startPrjCoord, p);

        map.onMoving(param);
      };

      _proto._moveEnd = function _moveEnd(param) {
        if (!this.startDragTime) {
          return;
        }

        var map = this.target;
        var t = now() - this.startDragTime;
        var mx = param['mousePos'].x,
            my = param['mousePos'].y;
        var dx = mx - this.startX;
        var dy = my - this.startY;

        this._clear();

        if (map.options['panAnimation'] && !param.interupted && map._verifyExtent(map._getPrjCenter()) && t < 280 && Math.abs(dy) + Math.abs(dx) > 5) {
          t = 5 * t * (Math.abs(dx) + Math.abs(dy)) / 500;
          map.panBy(new Point(dx, dy), {
            'duration': t
          });
        } else {
          map.onMoveEnd(param);
        }
      };

      _proto._rotateStart = function _rotateStart(param) {
        this._start(param);

        delete this._rotateMode;
        this.startBearing = this.target.getBearing();
        this.target.onDragRotateStart(param);
        this._db = 0;
      };

      _proto._rotating = function _rotating(param) {
        var map = this.target;
        var mx = param['mousePos'].x,
            my = param['mousePos'].y;
        var prePitch = map.getPitch(),
            preBearing = map.getBearing();
        var dx = Math.abs(mx - this.preX),
            dy = Math.abs(my - this.preY);

        if (!this._rotateMode) {
          if (map.options['dragRotatePitch']) {
            this._rotateMode = 'rotate_pitch';
          } else if (dx > dy) {
            this._rotateMode = 'rotate';
          } else if (dx < dy) {
            this._rotateMode = 'pitch';
          } else {
            this._rotateMode = 'rotate';
          }
        }

        if (this._rotateMode === 'pitch' && prePitch === 0 && dy < 10) {
          return;
        }

        if (this._rotateMode.indexOf('rotate') >= 0 && map.options['dragRotate']) {
          var db = 0;

          if (map.options['dragPitch'] || dx > dy) {
            db = -0.6 * (this.preX - mx);
          } else if (mx > map.width / 2) {
            db = 0.6 * (this.preY - my);
          } else {
            db = -0.6 * (this.preY - my);
          }

          var bearing = map.getBearing() + db;
          this._db = this._db || 0;
          this._db += db;
          map.setBearing(bearing);
        }

        if (this._rotateMode.indexOf('pitch') >= 0 && map.options['dragPitch']) {
          map.setPitch(map.getPitch() + (this.preY - my) * 0.4);
        }

        this.preX = mx;
        this.preY = my;

        if (map.getBearing() !== preBearing || map.getPitch() !== prePitch) {
          map.onDragRotating(param);
        }
      };

      _proto._rotateEnd = function _rotateEnd(param) {
        var map = this.target;
        var bearing = map.getBearing();

        this._clear();

        var t = now() - this.startDragTime;
        map.onDragRotateEnd(param);

        if (Math.abs(bearing - this.startBearing) > 20 && (this._rotateMode === 'rotate' || this._rotateMode === 'rotate_pitch') && !param.interupted && t < 400) {
          var _bearing = map.getBearing();

          map._animateTo({
            'bearing': _bearing + this._db / 2
          }, {
            'easing': 'out',
            'duration': 800
          });
        }
      };

      _proto._clear = function _clear() {
        delete this.startPrjCoord;
        delete this.preX;
        delete this.preY;
        delete this.startX;
        delete this.startY;
      };

      return MapDragHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'draggable': true,
      'dragPan': true,
      'dragRotatePitch': true,
      'dragRotate': true,
      'dragPitch': true
    });
    Map$1.addOnLoadHook('addHandler', 'draggable', MapDragHandler);

    var EVENTS =
    /**
     * mousedown event
     * @event Geometry#mousedown
     * @type {Object}
     * @property {String} type                    - mousedown
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousedown ' +
    /**
     * mouseup event
     * @event Geometry#mouseup
     * @type {Object}
     * @property {String} type                    - mouseup
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseup ' +
    /**
     * mousemove event
     * @event Geometry#mousemove
     * @type {Object}
     * @property {String} type                    - mousemove
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousemove ' +
    /**
     * click event
     * @event Geometry#click
     * @type {Object}
     * @property {String} type                    - click
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'click ' +
    /**
     * dblclick event
     * @event Geometry#dblclick
     * @type {Object}
     * @property {String} type                    - dblclick
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'dblclick ' +
    /**
     * contextmenu event
     * @event Geometry#contextmenu
     * @type {Object}
     * @property {String} type                    - contextmenu
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'contextmenu ' +
    /**
     * touchstart event
     * @event Geometry#touchstart
     * @type {Object}
     * @property {String} type                    - touchstart
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchstart ' +
    /**
     * touchmove event
     * @event Geometry#touchmove
     * @type {Object}
     * @property {String} type                    - touchmove
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchmove ' +
    /**
     * touchend event
     * @event Geometry#touchend
     * @type {Object}
     * @property {String} type                    - touchend
     * @property {Geometry} target            - the Geometry fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchend';
    /**
     * mouseenter event for geometry
     * @event Geometry#mouseenter
     * @type {Object}
     * @property {String} type                    - mouseenter
     * @property {Geometry} target       - the geometry fires mouseenter
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */

    /**
     * mouseover event for geometry
     * @event Geometry#mouseover
     * @type {Object}
     * @property {String} type                    - mouseover
     * @property {Geometry} target       - the geometry fires mouseover
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */

    /**
     * mouseout event for geometry
     * @event Geometry#mouseout
     * @type {Object}
     * @property {String} type                    - mouseout
     * @property {Geometry} target       - the geometry fires mouseout
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */

    var MapGeometryEventsHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapGeometryEventsHandler, _Handler);

      function MapGeometryEventsHandler() {
        return _Handler.apply(this, arguments) || this;
      }

      var _proto = MapGeometryEventsHandler.prototype;

      _proto.addHooks = function addHooks() {
        var map = this.target;
        var dom = map._panels.allLayers || map._containerDOM;
        on(dom, EVENTS, this._identifyGeometryEvents, this);
      };

      _proto.removeHooks = function removeHooks() {
        var map = this.target;
        var dom = map._panels.allLayers || map._containerDOM;
        off(dom, EVENTS, this._identifyGeometryEvents, this);
      };

      _proto._identifyGeometryEvents = function _identifyGeometryEvents(domEvent, type) {
        var map = this.target;

        if (map.isInteracting() || map._ignoreEvent(domEvent)) {
          return;
        }

        var layers = map._getLayers(function (layer) {
          if (layer.identify && layer.options['geometryEvents']) {
            return true;
          }

          return false;
        });

        if (!layers.length) {
          return;
        }

        var oneMoreEvent = null;
        var eventType = type || domEvent.type; // ignore click lasted for more than 300ms.

        if (eventType === 'mousedown' || eventType === 'touchstart' && domEvent.touches.length === 1) {
          this._mouseDownTime = now();
        } else if ((eventType === 'click' || eventType === 'touchend') && this._mouseDownTime) {
          var downTime = this._mouseDownTime;
          delete this._mouseDownTime;
          var time = now();

          if (time - downTime > 300) {
            if (eventType === 'click') {
              return;
            }
          } else if (eventType === 'touchend') {
            oneMoreEvent = 'click';
          }
        }

        var actual = domEvent.touches && domEvent.touches.length > 0 ? domEvent.touches[0] : domEvent.changedTouches && domEvent.changedTouches.length > 0 ? domEvent.changedTouches[0] : domEvent;

        if (!actual) {
          return;
        }

        var containerPoint = getEventContainerPoint(actual, map._containerDOM),
            coordinate = map.containerPointToCoordinate(containerPoint);

        if (eventType === 'touchstart') {
          preventDefault(domEvent);
        }

        var geometryCursorStyle = null;
        var identifyOptions = {
          'includeInternals': true,
          //return only one geometry on top,
          'filter': function filter(geometry) {
            if (!(geometry instanceof Geometry)) {
              return false;
            }

            var eventToFire = geometry._getEventTypeToFire(domEvent);

            if (eventType === 'mousemove') {
              if (!geometryCursorStyle && geometry.options['cursor']) {
                geometryCursorStyle = geometry.options['cursor'];
              }

              if (!geometry.listens('mousemove') && !geometry.listens('mouseover') && !geometry.listens('mouseenter')) {
                return false;
              }
            } else if (!geometry.listens(eventToFire) && !geometry.listens(oneMoreEvent)) {
              return false;
            }

            return true;
          },
          'count': 1,
          'coordinate': coordinate,
          'onlyVisible': map.options['onlyVisibleGeometryEvents'],
          'layers': layers
        };
        var callback = fireGeometryEvent.bind(this);

        if (eventType === 'mousemove' || eventType === 'touchmove') {
          this._queryIdentifyTimeout = map.getRenderer().callInNextFrame(function () {
            if (map.isInteracting()) {
              return;
            }

            map.identify(identifyOptions, callback);
          });
        } else {
          map.identify(identifyOptions, callback);
        }

        function fireGeometryEvent(geometries) {
          var propagation = true;

          if (eventType === 'mousemove') {
            var geoMap = {};

            if (geometries.length > 0) {
              for (var i = geometries.length - 1; i >= 0; i--) {
                var geo = geometries[i];

                if (!(geo instanceof Geometry)) {
                  continue;
                }

                var iid = geo._getInternalId();

                geoMap[iid] = geo;

                geo._onEvent(domEvent);

                if (!this._prevOverGeos || !this._prevOverGeos.geomap[iid]) {
                  geo._onEvent(domEvent, 'mouseenter');
                }

                propagation = geo._onEvent(domEvent, 'mouseover');
              }
            }

            map._setPriorityCursor(geometryCursorStyle);

            var oldTargets = this._prevOverGeos && this._prevOverGeos.geos;
            this._prevOverGeos = {
              'geos': geometries,
              'geomap': geoMap
            };

            if (oldTargets && oldTargets.length > 0) {
              for (var _i = oldTargets.length - 1; _i >= 0; _i--) {
                var oldTarget = oldTargets[_i];

                if (!(oldTarget instanceof Geometry)) {
                  continue;
                }

                var oldTargetId = oldTargets[_i]._getInternalId();
                /**
                 * 鼠标经过的新位置中不包含老的目标geometry
                 */


                if (!geoMap[oldTargetId]) {
                  propagation = oldTarget._onEvent(domEvent, 'mouseout');
                }
              }
            }
          } else {
            if (!geometries || !geometries.length) {
              return;
            }

            for (var _i2 = geometries.length - 1; _i2 >= 0; _i2--) {
              if (!(geometries[_i2] instanceof Geometry)) {
                continue;
              }

              propagation = geometries[_i2]._onEvent(domEvent);

              if (oneMoreEvent) {
                geometries[_i2]._onEvent(domEvent, oneMoreEvent);
              }

              break;
            }
          }

          if (propagation === false) {
            stopPropagation(domEvent);
          }
        }
      };

      return MapGeometryEventsHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'geometryEvents': true,
      'onlyVisibleGeometryEvents': true
    });
    Map$1.addOnLoadHook('addHandler', 'geometryEvents', MapGeometryEventsHandler);

    /*!
     * Contains code from mapbox-gl-js
     * http://github.com/mapbox/mapbox-gl-js
     * License BSD-3-Clause
     */

    var wheelZoomDelta = 4.000244140625;
    var defaultZoomRate = 1 / 100;
    var wheelZoomRate = 1 / 450;
    var maxScalePerFrame = 2;

    var MapScrollWheelZoomHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapScrollWheelZoomHandler, _Handler);

      function MapScrollWheelZoomHandler(target) {
        var _this;

        _this = _Handler.call(this, target) || this;
        _this._thisScrollZoom = _this._scrollZoom.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this._wheelZoomRate = wheelZoomRate;
        _this._defaultZoomRate = defaultZoomRate;
        _this._delta = 0;
        return _this;
      }

      var _proto = MapScrollWheelZoomHandler.prototype;

      _proto.addHooks = function addHooks() {
        addDomEvent(this.target._containerDOM, 'mousewheel', this._onWheelScroll, this);
      };

      _proto.removeHooks = function removeHooks() {
        removeDomEvent(this.target._containerDOM, 'mousewheel', this._onWheelScroll);
      };

      _proto._onWheelScroll = function _onWheelScroll(evt) {
        preventDefault(evt);
        stopPropagation(evt);
        var map = this.target;

        if (map._ignoreEvent(evt) || !map.options['zoomable']) {
          return false;
        }

        var container = map._containerDOM;

        var origin = map._checkZoomOrigin(getEventContainerPoint(evt, container));

        if (map.options['seamlessZoom']) {
          if (!this._zooming) {
            this._trackPadSuspect = 0;
            this._ensureTrackpad = false;
          }

          return this._seamless(evt, origin);
        } else {
          return this._interval(evt, origin);
        }
      };

      _proto._seamless = function _seamless(evt, origin) {
        var value = evt.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? evt.deltaY * 60 : evt.deltaY;

        if (value % wheelZoomDelta !== 0) {
          //according to https://archive.fo/ZV8gz
          //value % wheelDelta === 0 means it must be  mouse on Mac OS X
          if (!this._ensureTrackpad) {
            if (Math.abs(value) < 60) {
              this._trackPadSuspect++;
            } else {
              this._trackPadSuspect = 0;
            } //repeated very small delta value ensure it's a trackpad


            if (this._trackPadSuspect >= 2) {
              this._ensureTrackpad = true;
            }
          }

          if (this._ensureTrackpad) {
            value *= 14;
          }
        }

        if (evt.shiftKey && value) value = value / 4;
        this._lastWheelEvent = evt;
        this._delta -= value;

        if (!this._zooming && this._delta) {
          var map = this.target;
          this._zoomOrigin = origin;
          map.onZoomStart(null, origin);
        }

        this._start();
      };

      _proto._start = function _start() {
        if (!this._delta) return;
        this._zooming = true;
        var map = this.target;

        if (!this._active) {
          map.getRenderer().callInNextFrame(this._thisScrollZoom);
          this._active = true;
        }
      };

      _proto._scrollZoom = function _scrollZoom() {
        var _this2 = this;

        this._active = false;

        if (!this._delta) {
          return;
        }

        var zoomRate = Math.abs(this._delta) > wheelZoomDelta ? this._wheelZoomRate : this._defaultZoomRate;
        var scale = maxScalePerFrame / (1 + Math.exp(-Math.abs(this._delta * zoomRate)));

        if (this._delta < 0 && scale !== 0) {
          scale = 1 / scale;
        }

        var map = this.target;
        var zoom = map.getZoom();
        var targetZoom = map.getZoomForScale(scale, zoom, true);
        this._delta = 0;
        map.onZooming(targetZoom, this._zoomOrigin);

        if (this._timeout) {
          clearTimeout(this._timeout);
        }

        this._timeout = setTimeout(function () {
          _this2._zooming = false;
          delete _this2._timeout;
          map.onZoomEnd(map.getZoom(), _this2._zoomOrigin);
        }, 320);
      };

      _proto._interval = function _interval(evt, origin) {
        var _this3 = this;

        var map = this.target;

        if (this._zooming) {
          this._requesting++;
          return false;
        }

        this._requesting = 0;
        var levelValue = (evt.wheelDelta ? evt.wheelDelta : evt.detail) > 0 ? 1 : -1;

        if (evt.detail) {
          levelValue *= -1;
        }

        var zoom = map.getZoom();
        var nextZoom = zoom + levelValue;
        nextZoom = map._checkZoom(levelValue > 0 ? Math.ceil(nextZoom) : Math.floor(nextZoom));

        if (nextZoom === zoom) {
          return false;
        }

        this._zooming = true;

        if (!this._delta) {
          map.onZoomStart(null, origin);
          this._origin = origin;
          this._delta = levelValue;
          this._startZoom = map.getZoom();
        }

        var duration = 90;

        map._animateTo({
          'zoom': nextZoom - this._delta * 1 / 2,
          'around': this._origin
        }, {
          'continueOnViewChanged': true,
          'easing': 'linear',
          'duration': duration,
          'wheelZoom': true
        }, function (frame) {
          if (frame.state.playState !== 'finished') {
            return;
          }

          if (_this3._requesting < 1 || Math.abs(nextZoom - _this3._startZoom) > 2 || //finish zooming if target zoom hits min/max
          nextZoom === map.getMaxZoom() || nextZoom === map.getMinZoom()) {
            map._animateTo({
              'zoom': nextZoom,
              'around': _this3._origin
            }, {
              'continueOnViewChanged': true,
              'duration': 100
            }, function (frame) {
              if (frame.state.playState === 'finished') {
                setTimeout(function () {
                  delete _this3._zooming;
                  delete _this3._requesting;
                }, 200);
              }
            });

            delete _this3._startZoom;
            delete _this3._origin;
            delete _this3._delta;
            _this3._requesting = 0;
          } else if (!isNil(_this3._requesting)) {
            delete _this3._zooming;

            _this3._onWheelScroll(evt);
          }
        });

        return false;
      };

      return MapScrollWheelZoomHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'scrollWheelZoom': true,
      'seamlessZoom': false
    });
    Map$1.addOnLoadHook('addHandler', 'scrollWheelZoom', MapScrollWheelZoomHandler);

    var MapTouchZoomHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapTouchZoomHandler, _Handler);

      function MapTouchZoomHandler() {
        return _Handler.apply(this, arguments) || this;
      }

      var _proto = MapTouchZoomHandler.prototype;

      _proto.addHooks = function addHooks() {
        addDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart, this);
      };

      _proto.removeHooks = function removeHooks() {
        removeDomEvent(this.target.getContainer(), 'touchstart', this._onTouchStart);
      };

      _proto._onTouchStart = function _onTouchStart(event) {
        var map = this.target;

        if (!event.touches || event.touches.length !== 2 || map.isInteracting()) {
          return;
        }

        var container = map.getContainer();
        var p1 = getEventContainerPoint(event.touches[0], container),
            p2 = getEventContainerPoint(event.touches[1], container);
        this.preY = p1.y;
        this._startP1 = p1;
        this._startP2 = p2;
        this._startDist = p1.distanceTo(p2);
        this._startVector = p1.sub(p2);
        this._startZoom = map.getZoom();
        this._startBearing = map.getBearing();
        addDomEvent(document, 'touchmove', this._onTouchMove, this);
        addDomEvent(document, 'touchend', this._onTouchEnd, this);
        preventDefault(event);
        /**
          * touchactstart event
          * @event Map#touchactstart
          * @type {Object}
          * @property {String} type                    - touchactstart
          * @property {Map} target                     - the map fires event
          */

        map._fireEvent('touchactstart');
      };

      _proto._onTouchMove = function _onTouchMove(event) {
        var map = this.target;

        if (!event.touches || event.touches.length !== 2) {
          return;
        }

        var container = map.getContainer(),
            p1 = getEventContainerPoint(event.touches[0], container),
            p2 = getEventContainerPoint(event.touches[1], container),
            d1 = p1.sub(this._startP1),
            d2 = p2.sub(this._startP2),
            vector = p1.sub(p2),
            scale = p1.distanceTo(p2) / this._startDist,
            bearing = vector.angleWith(this._startVector) * 180 / Math.PI,
            preY = this.preY || p1.y,
            pitch = (preY - p1.y) * 0.4; // console.log(preY, p1.y);


        this.preY = p1.y;
        var param = {
          'domEvent': event,
          'mousePos': [p1, p2]
        };

        if (!this.mode) {
          if (map.options['touchRotate'] && Math.abs(bearing) > 8) {
            this.mode = map.options['touchZoomRotate'] ? 'rotate_zoom' : 'rotate';
          } else if (map.options['touchPitch'] && d1.y * d2.y > 0 && Math.abs(d1.y) > 10 && Math.abs(d2.y) > 10) {
            this.mode = 'pitch';
          } else if (map.options['zoomable'] && map.options['touchZoom'] && Math.abs(1 - scale) > 0.15) {
            this.mode = map.options['touchZoomRotate'] && map.options['touchRotate'] ? 'rotate_zoom' : 'zoom';
          }

          this._startTouching(param);
        }

        if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
          this._scale = scale;
          var res = map._getResolution(this._startZoom) / scale;
          var zoom = map.getZoomFromRes(res);
          map.onZooming(zoom, this._Origin);
        }

        if (this.mode === 'rotate' || this.mode === 'rotate_zoom') {
          map.setBearing(this._startBearing + bearing);
          map.onDragRotating(param);
        } else if (this.mode === 'pitch') {
          map.setPitch(map.getPitch() + pitch);
          map.onDragRotating(param);
        }
        /**
          * touchacting event
          * @event Map#touchacting
          * @type {Object}
          * @property {String} type                    - touchacting
          * @property {Map} target                     - the map fires event
          */


        map._fireEvent('touchactinging');
      };

      _proto._startTouching = function _startTouching(param) {
        var map = this.target;

        if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
          var size = map.getSize();
          this._Origin = new Point(size['width'] / 2, size['height'] / 2);
          map.onZoomStart(null, this._Origin);
        }

        if (this.mode === 'rotate' || this.mode === 'pitch' || this.mode === 'rotate_zoom') {
          map.onDragRotateStart(param);
        }
      };

      _proto._onTouchEnd = function _onTouchEnd(event) {
        delete this.preY;
        var map = this.target;
        off(document, 'touchmove', this._onTouchMove, this);
        off(document, 'touchend', this._onTouchEnd, this);

        if (this.mode === 'zoom' || this.mode === 'rotate_zoom') {
          var scale = this._scale;
          var res = map._getResolution(this._startZoom) / scale;
          var zoom = map.getZoomFromRes(res);
          map.onZoomEnd(zoom, this._Origin);
        }

        if (this.mode === 'pitch' || this.mode === 'rotate' || this.mode === 'rotate_zoom') {
          map.onDragRotateEnd({
            'domEvent': event
          });
        }

        delete this.mode;
        /**
          * touchactend event
          * @event Map#touchactend
          * @type {Object}
          * @property {String} type                    - touchactend
          * @property {Map} target                     - the map fires event
          */

        map._fireEvent('touchactend');
      };

      return MapTouchZoomHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'touchGesture': true,
      'touchZoom': true,
      'touchPitch': true,
      'touchRotate': true,
      'touchZoomRotate': false
    });
    Map$1.addOnLoadHook('addHandler', 'touchGesture', MapTouchZoomHandler);

    /**
     * @classdesc
     * Easing functions for anmation, from openlayers 3
     * @class
     * @category animation
     * @memberof animation
     * @protected
     */

    var Easing = {
      /**
       * Start slow and speed up.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      in: function _in(t) {
        return Math.pow(t, 2);
      },

      /**
       * Start fast and slow down.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      out: function out(t) {
        return 1 - Easing.in(1 - t);
      },

      /**
       * Start slow, speed up, and then slow down again.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      inAndOut: function inAndOut(t) {
        return 3 * t * t - 2 * t * t * t;
      },

      /**
       * Maintain a constant speed over time.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      linear: function linear(t) {
        return t;
      },

      /**
       * Start slow, speed up, and at the very end slow down again.  This has the
       * same general behavior as {@link inAndOut}, but the final slowdown
       * is delayed.
       * @param {number} t Input between 0 and 1.
       * @return {number} Output between 0 and 1.
       */
      upAndDown: function upAndDown(t) {
        if (t < 0.5) {
          return Easing.inAndOut(2 * t);
        } else {
          return 1 - Easing.inAndOut(2 * (t - 0.5));
        }
      }
    };
    /**
     * Animation Frame used internally in animation player.
     * @category animation
     * @memberof animation
     * @protected
     */

    var Frame =
    /**
     * Create an animation frame.
     * @param {Object} state  - animation state
     * @param {Object} styles - styles to animate
     */
    function Frame(state, styles) {
      this.state = state;
      this.styles = styles;
    };
    /**
     * An [Web Animation API]{@link https://developer.mozilla.org/zh-CN/docs/Web/API/Animation} style animation player
     * @category animation
     * @memberof animation
     */


    var Player =
    /**
     * Create an animation player
     * @param {Function} animation - animation [framing]{@link framing} function
     * @param {Object} options     - animation options
     * @param {Function} onFrame  - callback function for animation steps
     */
    function Player(animation, options, onFrame) {
      this._animation = animation;
      this.options = options;
      this._onFrame = onFrame;
      this.playState = 'idle';
      this.ready = true;
      this.finished = false;
    };
    /**
     * @classdesc
     * Utilities for animation
     * @class
     * @category animation
     * @memberof animation
     */


    var Animation = {
      /**
       * @property {Object} speed         - predefined animation speed
       * @property {Number} speed.slow    - 2000ms
       * @property {Number} speed.normal  - 1000ms
       * @property {Number} speed.fast    - 500ms
       */
      speed: {
        'slow': 2000,
        'normal': 1000,
        'fast': 500
      },

      /**
       * resolve styles for animation, get a style group of start style, styles to animate and end styles.
       * @param  {Object} styles - styles to resolve
       * @return {Object[]}  styles resolved
       * @private
       */
      _resolveStyles: function _resolveStyles(styles) {
        if (!styles) {
          return null;
        } //resolve a child styles.


        function resolveChild(child) {
          if (!Array.isArray(child)) {
            return Animation._resolveStyles(child);
          }

          var start = [],
              d = [],
              dest = [];

          for (var i = 0; i < child.length; i++) {
            var _styles = Animation._resolveStyles(child[i]);

            if (_styles) {
              start.push(_styles[0]);
              d.push(_styles[1]);
              dest.push(_styles[2]);
            }
          }

          if (!start.length) {
            return null;
          } else {
            return [start, d, dest];
          }
        } // resolve a style value.


        function resolveVal(val) {
          var values = val;
          var clazz; //val is just a destination value, so we set start value to 0 or a 0-point or a 0-coordinate.

          if (!Array.isArray(val)) {
            if (isNumber(val)) {
              values = [0, val];
            } else if (val instanceof Point || val instanceof Coordinate) {
              clazz = val.constructor;
              values = [new clazz(0, 0), val];
            } else {
              values = [val, val];
            }
          } //val is an array and val[0] is the start value and val[1] is the destination value.


          var v1 = values[0],
              v2 = values[1];

          if (isNumber(v1) && isNumber(v2)) {
            if (v1 === v2) {
              return null;
            }

            return [v1, v2 - v1, v2];
          } else if (Array.isArray(v1) || v1 instanceof Coordinate || v1 instanceof Point) {
            // is a coordinate (array or a coordinate) or a point
            if (Array.isArray(v1)) {
              v1 = new Coordinate(v1);
              v2 = new Coordinate(v2);
            } else {
              clazz = v1.constructor;
              v1 = new clazz(v1);
              v2 = new clazz(v2);
            }

            if (v1.equals(v2)) {
              //a Coordinate or a Point to be eql with each other
              return null;
            }

            return [v1, v2.sub(v1), v2];
          } else {
            return [v1, 0, v2];
          }
        }

        function isChild(val) {
          if (!Array.isArray(val) && val.constructor === Object) {
            return true;
          } else if (Array.isArray(val) && val[0].constructor === Object) {
            return true;
          }

          return false;
        }

        var d = {},
            start = {},
            dest = {};

        for (var p in styles) {
          if (styles.hasOwnProperty(p)) {
            var values = styles[p]; // ignore null values

            if (!values) {
              continue;
            } else if (Array.isArray(values)) {
              if (isNil(values[0]) || isNil(values[1])) {
                continue;
              }
            }

            var childStyles = void 0;

            if (isChild(values)) {
              childStyles = resolveChild(values);
            } else {
              childStyles = resolveVal(values);
            }

            if (childStyles) {
              start[p] = childStyles[0];
              d[p] = childStyles[1];
              dest[p] = childStyles[2];
            }
          }
        }

        return [start, d, dest];
      },

      /**
       * Generate a framing function
       * @param  {Object[]} styles        - animation style group
       * @param  {Object} [options=null]  - options
       * @param  {Object} [options.easing=null]  - animation easing
       * @return {Function} framing function helps to generate animation frames.
       */
      framing: function framing(styles, options) {
        if (!options) {
          options = {};
        }

        var easing = options['easing'] ? Easing[options['easing']] : Easing.linear;

        if (!easing) {
          easing = Easing.linear;
        }

        var dStyles, startStyles, destStyles;
        styles = Animation._resolveStyles(styles);

        if (styles) {
          startStyles = styles[0];
          dStyles = styles[1];
          destStyles = styles[2];
        }

        var deltaStyles = function deltaStyles(delta, _startStyles, _dStyles) {
          if (!_startStyles || !_dStyles) {
            return null;
          }

          var result = {};

          for (var p in _dStyles) {
            if (_dStyles.hasOwnProperty(p)) {
              if (_startStyles[p] === destStyles[p]) {
                result[p] = _startStyles[p];
                continue;
              }

              var s = _startStyles[p],
                  d = _dStyles[p];

              if (isNumber(d)) {
                //e.g. radius, width, height
                result[p] = s + delta * d;
              } else if (Array.isArray(d)) {
                //e.g. a composite symbol, element in array can only be a object.
                var children = [];

                for (var i = 0; i < d.length; i++) {
                  children.push(deltaStyles(delta, s[i], d[i]));
                }

                result[p] = children;
              } else {
                //e.g. translate or a child
                var clazz = d.constructor;

                if (clazz === Object) {
                  result[p] = deltaStyles(delta, s, d);
                } else if (s instanceof Point || s instanceof Coordinate) {
                  result[p] = s.add(d.multi(delta));
                }
              }
            }
          }

          return result;
        };

        return function (elapsed, duration) {
          var state, d;

          if (elapsed < 0) {
            state = {
              'playState': 'idle',
              'delta': 0
            };
            d = startStyles;
          } else if (elapsed < duration) {
            var delta = easing(elapsed / duration);
            state = {
              'playState': 'running',
              'delta': delta
            };
            d = deltaStyles(delta, startStyles, dStyles);
          } else {
            state = {
              'playState': 'finished',
              'delta': 1
            };
            d = destStyles;
          }

          state['startStyles'] = startStyles;
          state['destStyles'] = destStyles;
          state['progress'] = elapsed;
          state['remainingMs'] = duration - elapsed;
          return new Frame(state, d);
        };
      },
      _requestAnimFrame: function _requestAnimFrame(fn) {
        if (!this._frameQueue) {
          this._frameQueue = [];
        }

        this._frameQueue.push(fn);

        this._a();
      },
      _a: function _a() {
        if (!this._animationFrameId) {
          this._animationFrameId = requestAnimFrame(Animation._frameFn);
        }
      },
      _run: function _run() {
        if (this._frameQueue.length) {
          var running = this._frameQueue;
          this._frameQueue = [];

          for (var i = 0, len = running.length; i < len; i++) {
            running[i]();
          }

          if (this._frameQueue.length) {
            this._animationFrameId = requestAnimFrame(Animation._frameFn);
          } else {
            delete this._animationFrameId;
          }
        }
      },

      /**
       * Create an animation player
       * @param  {Object} styles  - styles to animate
       * @param  {Object} options - animation options
       * @param  {Function} step  - callback function for animation steps
       * @return {Player} player
       */
      animate: function animate(styles, options, step) {
        if (!options) {
          options = {};
        }

        var animation = Animation.framing(styles, options);
        return new Player(animation, options, step);
      }
    };
    Animation._frameFn = Animation._run.bind(Animation);
    extend(Player.prototype,
    /** @lends animation.Player.prototype */
    {
      _prepare: function _prepare() {
        var options = this.options;
        var duration = options['speed'] || options['duration'];

        if (isString(duration)) {
          duration = Animation.speed[duration];

          if (!duration) {
            duration = +duration;
          }
        }

        if (!duration) {
          duration = Animation.speed['normal'];
        }

        this.duration = duration;
        this._framer = options['framer'] || Animation._requestAnimFrame.bind(Animation);
      },

      /**
       * Start or resume the animation
       * @return {Player} this
       */
      play: function play() {
        if (this.playState !== 'idle' && this.playState !== 'paused') {
          return this;
        }

        if (this.playState === 'idle') {
          this.currentTime = 0;

          this._prepare();
        }

        var t = now();

        if (!this.startTime) {
          var options = this.options;
          this.startTime = options['startTime'] ? options['startTime'] : t;
        }

        this._playStartTime = Math.max(t, this.startTime);

        if (this.playState === 'paused') {
          this._playStartTime -= this.currentTime;
        }

        this.playState = 'running';

        this._run();

        return this;
      },

      /**
       * Pause the animation
       * @return {Player} this
       */
      pause: function pause() {
        if (this.playState === 'paused') {
          return this;
        }

        this.playState = 'paused';

        this._run(); //this.duration = this.duration - this.currentTime;


        return this;
      },

      /**
       * Cancel the animation play and ready to play again
       * @return {Player} this
       */
      cancel: function cancel() {
        if (this.playState === 'idle') {
          return this;
        }

        this.playState = 'idle';
        this.finished = false;

        this._run();

        return this;
      },

      /**
       * Finish the animation play, and can't be played any more.
       * @return {Player} this
       */
      finish: function finish() {
        if (this.playState === 'finished') {
          return this;
        }

        this.playState = 'finished';
        this.finished = true;

        this._run();

        return this;
      },
      reverse: function reverse() {},
      _run: function _run() {
        var _this = this;

        var onFrame = this._onFrame;
        var t = now();
        var elapsed = t - this._playStartTime;

        if (this.options['repeat'] && elapsed >= this.duration) {
          this._playStartTime = t;
          elapsed = 0;
        }

        if (this.playState !== 'running') {
          if (onFrame) {
            if (this.playState === 'finished') {
              elapsed = this.duration;
            } else if (this.playState === 'idle') {
              elapsed = 0;
            }

            var _frame = this._animation(elapsed, this.duration);

            _frame.state.playState = this.playState;
            onFrame(_frame);
          }

          return;
        } //elapsed, duration


        var frame = this._animation(elapsed, this.duration);

        this.playState = frame.state['playState'];

        if (this.playState === 'idle') {
          if (this.startTime > t) {
            setTimeout(this._run.bind(this), this.startTime - t);
          }
        } else if (this.playState === 'running') {
          this._framer(function () {
            if (_this.playState !== 'running') {
              // this._run();
              return;
            }

            _this.currentTime = elapsed;

            if (onFrame) {
              onFrame(frame);
            }

            _this._run();
          });
        } else if (this.playState === 'finished') {
          this.finished = true; //finished

          if (onFrame) {
            onFrame(frame);
          }
        }
      }
    });

    var Animation$1 = /*#__PURE__*/Object.freeze({
        Animation: Animation,
        Easing: Easing,
        Player: Player,
        Frame: Frame
    });

    /*
     (c) 2017, Vladimir Agafonkin
     Simplify.js, a high-performance JS polyline simplification library
     mourner.github.io/simplify-js
    */
    // to suit your point format, run search/replace for '.x' and '.y';
    // for 3D version, see 3d branch (configurability would draw significant performance overhead)
    // square distance between 2 points
    function getSqDist(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return dx * dx + dy * dy;
    } // square distance from a point to a segment


    function getSqSegDist(p, p1, p2) {
      var x = p1.x,
          y = p1.y,
          dx = p2.x - x,
          dy = p2.y - y;

      if (dx !== 0 || dy !== 0) {
        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p.x - x;
      dy = p.y - y;
      return dx * dx + dy * dy;
    } // rest of the code doesn't care about point format
    // basic distance-based simplification


    function simplifyRadialDist(points, sqTolerance) {
      var prevPoint = points[0],
          newPoints = [prevPoint],
          point;

      for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
          newPoints.push(point);
          prevPoint = point;
        }
      }

      if (prevPoint !== point) newPoints.push(point);
      return newPoints;
    }

    function simplifyDPStep(points, first, last, sqTolerance, simplified) {
      var maxSqDist = sqTolerance,
          index;

      for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
      }
    } // simplification using Ramer-Douglas-Peucker algorithm


    function simplifyDouglasPeucker(points, sqTolerance) {
      var last = points.length - 1;
      var simplified = [points[0]];
      simplifyDPStep(points, 0, last, sqTolerance, simplified);
      simplified.push(points[last]);
      return simplified;
    } // both algorithms combined for awesome performance


    function simplify(points, tolerance, highestQuality) {
      if (points.length <= 2) return points;
      var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
      points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
      points = simplifyDouglasPeucker(points, sqTolerance);
      return points;
    }

    /**
     * @property {Object} options - configuration options
     * @property {Number} [options.smoothness=0]      - line smoothing by quad bezier interporating, 0 by default
     * @property {Boolean} [options.enableSimplify=true] - whether to simplify path before rendering
     * @property {Number}  [options.simplifyTolerance=2] - tolerance to simplify path, the higher the simplify is more intense
     * @property {Boolean} [options.enableClip=true] - whether to clip path with map's current extent
     * @property {Object} options.symbol - Path's default symbol
     * @memberOf Path
     * @instance
     */

    var options$3 = {
      'smoothness': 0,
      'enableClip': true,
      'enableSimplify': true,
      'simplifyTolerance': 2,
      'symbol': {
        'lineColor': '#000',
        'lineWidth': 2,
        'lineOpacity': 1,
        'polygonFill': '#fff',
        //default color in cartoCSS
        'polygonOpacity': 1,
        'opacity': 1
      }
    };
    /**
     * An abstract class Path containing common methods for Path geometry classes, e.g. LineString, Polygon
     * @abstract
     * @category geometry
     * @extends Geometry
     */

    var Path =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Path, _Geometry);

      function Path() {
        return _Geometry.apply(this, arguments) || this;
      }

      var _proto = Path.prototype;

      _proto.getOutline = function getOutline() {
        var painter = this._getPainter();

        if (!painter) {
          return null;
        }

        var map = this.getMap();
        var extent = painter.getContainerExtent().convertTo(function (c) {
          return map.containerPointToCoord(c);
        });
        return new Polygon(extent.toArray(), {
          symbol: {
            'lineWidth': 1,
            'lineColor': '6b707b'
          }
        });
      }
      /**
       * Show the linestring with animation
       * @param  {Object} [options=null] animation options
       * @param  {Number} [options.duration=1000] duration
       * @param  {String} [options.easing=out] animation easing
       * @param  {Function} [cb=null] callback function in animation, function parameters: frame, currentCoord
       * @example
       *  line.animateShow({
       *    duration : 2000,
       *    easing : 'linear'
       *  }, function (frame, currentCoord) {
       *    //frame is the animation frame
       *    //currentCoord is current coordinate of animation
       *  });
       * @return {LineString}         this
       */
      ;

      _proto.animateShow = function animateShow(options, cb) {
        var _this = this;

        if (options === void 0) {
          options = {};
        }

        if (this._showPlayer) {
          this._showPlayer.finish();
        }

        if (isFunction(options)) {
          options = {};
          cb = options;
        }

        var coordinates = this.getCoordinates();

        if (coordinates.length === 0) {
          return this;
        }

        this._animIdx = 0;
        this._animLenSoFar = 0;
        this.show();
        var isPolygon = !!this.getShell;
        var animCoords = isPolygon ? this.getShell().concat(this.getShell()[0]) : this.getCoordinates();

        var projection = this._getProjection();

        this._aniShowCenter = projection.unproject(this._getPrjExtent().getCenter());
        var duration = options['duration'] || 1000,
            length = this.getLength(),
            easing = options['easing'] || 'out';
        this.setCoordinates([]);
        var player = this._showPlayer = Animation.animate({
          't': duration
        }, {
          'duration': duration,
          'easing': easing
        }, function (frame) {
          if (!_this.getMap()) {
            if (player.playState !== 'finished') {
              player.finish();

              if (cb) {
                var _coordinates = _this.getCoordinates();

                cb(frame, _coordinates[_coordinates.length - 1]);
              }
            }

            return;
          }

          var currentCoord = _this._drawAnimShowFrame(frame.styles.t, duration, length, animCoords);

          if (frame.state.playState === 'finished') {
            delete _this._showPlayer;
            delete _this._aniShowCenter;
            delete _this._animIdx;
            delete _this._animLenSoFar;
            delete _this._animTailRatio;

            _this.setCoordinates(coordinates);
          }

          if (cb) {
            cb(frame, currentCoord);
          }
        });
        player.play();
        return player;
      };

      _proto._drawAnimShowFrame = function _drawAnimShowFrame(t, duration, length, coordinates) {
        if (t === 0) {
          return coordinates[0];
        }

        var map = this.getMap();
        var targetLength = t / duration * length;
        var segLen = 0;
        var i, l;

        for (i = this._animIdx, l = coordinates.length; i < l - 1; i++) {
          segLen = map.computeLength(coordinates[i], coordinates[i + 1]);

          if (this._animLenSoFar + segLen > targetLength) {
            break;
          }

          this._animLenSoFar += segLen;
        }

        this._animIdx = i;

        if (this._animIdx >= l - 1) {
          this.setCoordinates(coordinates);
          return coordinates[coordinates.length - 1];
        }

        var idx = this._animIdx;
        var p1 = coordinates[idx],
            p2 = coordinates[idx + 1],
            span = targetLength - this._animLenSoFar,
            r = span / segLen;
        this._animTailRatio = r;
        var x = p1.x + (p2.x - p1.x) * r,
            y = p1.y + (p2.y - p1.y) * r,
            targetCoord = new Coordinate(x, y);
        var isPolygon = !!this.getShell;

        if (!isPolygon && this.options['smoothness'] > 0) {
          //smooth line needs to set current coordinates plus 2 more to caculate correct control points
          var animCoords = coordinates.slice(0, this._animIdx + 3);
          this.setCoordinates(animCoords);
        } else {
          var _animCoords = coordinates.slice(0, this._animIdx + 1);

          _animCoords.push(targetCoord);

          if (isPolygon) {
            this.setCoordinates([this._aniShowCenter].concat(_animCoords));
          } else {
            this.setCoordinates(_animCoords);
          }
        }

        return targetCoord;
      };

      _proto._getCenterInExtent = function _getCenterInExtent(extent, coordinates, clipFn) {
        var meExtent = this.getExtent();

        if (!extent.intersects(meExtent)) {
          return null;
        }

        var clipped = clipFn(coordinates, extent);

        if (clipped.length === 0) {
          return null;
        }

        var sumx = 0,
            sumy = 0,
            counter = 0;
        clipped.forEach(function (part) {
          if (Array.isArray(part)) {
            part.forEach(function (c) {
              if (c.point) {
                c = c.point;
              }

              sumx += c.x;
              sumy += c.y;
              counter++;
            });
          } else {
            if (part.point) {
              part = part.point;
            }

            sumx += part.x;
            sumy += part.y;
            counter++;
          }
        });

        var c = new Coordinate(sumx, sumy)._multi(1 / counter);

        c.count = counter;
        return c;
      }
      /**
       * Transform projected coordinates to view points
       * @param  {Coordinate[]} prjCoords           - projected coordinates
       * @param  {Boolean} disableSimplify          - whether to disable simplify\
       * @param  {Number} zoom                      - 2d points' zoom level
       * @returns {Point[]}
       * @private
       */
      ;

      _proto._getPath2DPoints = function _getPath2DPoints(prjCoords, disableSimplify, zoom) {
        if (!isArrayHasData(prjCoords)) {
          return [];
        }

        var map = this.getMap(),
            isSimplify = !disableSimplify && this._shouldSimplify(),
            tolerance = this.options['simplifyTolerance'] * map._getResolution(),
            isMulti = Array.isArray(prjCoords[0]);

        delete this._simplified;

        if (isSimplify && !isMulti) {
          var count = prjCoords.length;
          prjCoords = simplify(prjCoords, tolerance, false);
          this._simplified = prjCoords.length < count;
        }

        if (isNil(zoom)) {
          zoom = map.getZoom();
        }

        return forEachCoord(prjCoords, function (c) {
          return map._prjToPoint(c, zoom);
        });
      };

      _proto._shouldSimplify = function _shouldSimplify() {
        var layer = this.getLayer(),
            properties = this.getProperties();
        var hasAltitude = properties && layer.options['enableAltitude'] && !isNil(properties[layer.options['altitudeProperty']]);
        return layer && layer.options['enableSimplify'] && !hasAltitude && this.options['enableSimplify'] && !this._showPlayer
        /* && !this.options['smoothness'] */
        ;
      };

      _proto._setPrjCoordinates = function _setPrjCoordinates(prjPoints) {
        this._prjCoords = prjPoints;
        this.onShapeChanged();
      };

      _proto._getPrjCoordinates = function _getPrjCoordinates() {
        var projection = this._getProjection();

        if (!projection) {
          return null;
        }

        this._verifyProjection();

        if (!this._prjCoords) {
          this._prjCoords = this._projectCoords(this._coordinates);
        }

        return this._prjCoords;
      } //update cached variables if geometry is updated.
      ;

      _proto._updateCache = function _updateCache() {
        this._clearCache();

        var projection = this._getProjection();

        if (!projection) {
          return;
        }

        if (this._prjCoords) {
          this._coordinates = this._unprojectCoords(this._getPrjCoordinates());
        }
      };

      _proto._clearProjection = function _clearProjection() {
        this._prjCoords = null;

        _Geometry.prototype._clearProjection.call(this);
      };

      _proto._projectCoords = function _projectCoords(points) {
        var projection = this._getProjection();

        if (projection) {
          return projection.projectCoords(points);
        }

        return [];
      };

      _proto._unprojectCoords = function _unprojectCoords(prjPoints) {
        var projection = this._getProjection();

        if (projection) {
          return projection.unprojectCoords(prjPoints);
        }

        return [];
      };

      _proto._computeCenter = function _computeCenter() {
        var ring = this._coordinates;

        if (!isArrayHasData(ring)) {
          return null;
        }

        var sumx = 0,
            sumy = 0,
            counter = 0;
        var size = ring.length;

        for (var i = 0; i < size; i++) {
          if (ring[i]) {
            if (isNumber(ring[i].x) && isNumber(ring[i].y)) {
              sumx += ring[i].x;
              sumy += ring[i].y;
              counter++;
            }
          }
        }

        return new Coordinate(sumx / counter, sumy / counter);
      };

      _proto._computeExtent = function _computeExtent() {
        var shell = this._coordinates;

        if (!isArrayHasData(shell)) {
          return null;
        }

        var rings = [shell];

        if (this.hasHoles && this.hasHoles()) {
          rings.push.apply(rings, this.getHoles());
        }

        return this._coords2Extent(rings, this._getProjection());
      };

      _proto._computePrjExtent = function _computePrjExtent() {
        var coords = [this._getPrjCoordinates()];

        if (this.hasHoles && this.hasHoles()) {
          coords.push.apply(coords, this._getPrjHoles());
        }

        return this._coords2Extent(coords);
      };

      _proto._get2DLength = function _get2DLength() {
        var vertexes = this._getPath2DPoints(this._getPrjCoordinates(), true);

        var len = 0;

        for (var i = 1, l = vertexes.length; i < l; i++) {
          len += vertexes[i].distanceTo(vertexes[i - 1]);
        }

        return len;
      };

      _proto._hitTestTolerance = function _hitTestTolerance() {
        var symbol = this._getInternalSymbol();

        var w;

        if (Array.isArray(symbol)) {
          w = 0;

          for (var i = 0; i < symbol.length; i++) {
            if (isNumber(symbol[i]['lineWidth'])) {
              if (symbol[i]['lineWidth'] > w) {
                w = symbol[i]['lineWidth'];
              }
            }
          }
        } else {
          w = symbol['lineWidth'];
        }

        return isNumber(w) ? w / 2 : 1.5;
      };

      _proto._coords2Extent = function _coords2Extent(coords, proj) {
        var result = new Extent(proj);

        for (var i = 0, l = coords.length; i < l; i++) {
          for (var j = 0, ll = coords[i].length; j < ll; j++) {
            result._combine(coords[i][j]);
          }
        }

        return result;
      };

      return Path;
    }(Geometry);

    Path.mergeOptions(options$3);

    var JSON_TYPE = 'Polygon';
    /**
     * @classdesc
     * Geometry class for polygon type
     * @category geometry
     * @extends Path
     * @example
     * var polygon = new Polygon(
     *      [
     *          [
     *              [121.48053653961283, 31.24244899384889],
     *              [121.48049362426856, 31.238559229494186],
     *              [121.49032123809872, 31.236210614999653],
     *              [121.49366863494917, 31.242926029397037],
     *              [121.48577221160967, 31.243880093267567],
     *              [121.48053653961283, 31.24244899384889]
     *          ]
     *      ]
     *  ).addTo(layer);
     */

    var Polygon =
    /*#__PURE__*/
    function (_Path) {
      _inheritsLoose(Polygon, _Path);

      /**
       * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - coordinates, shell coordinates or all the rings.
       * @param {Object} [options=null] - construct options defined in [Polygon]{@link Polygon#options}
       */
      function Polygon(coordinates, opts) {
        var _this;

        _this = _Path.call(this, opts) || this;
        _this.type = 'Polygon';

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        return _this;
      }
      /**
       * Set coordinates to the polygon
       *
       * @param {Number[][]|Number[][][]|Coordinate[]|Coordinate[][]} coordinates - new coordinates
       * @return {Polygon} this
       * @fires Polygon#shapechange
       */


      var _proto = Polygon.prototype;

      _proto.setCoordinates = function setCoordinates(coordinates) {
        if (!coordinates) {
          this._coordinates = null;
          this._holes = null;

          this._projectRings();

          return this;
        }

        var rings = Coordinate.toCoordinates(coordinates);
        var len = rings.length;

        if (!Array.isArray(rings[0])) {
          this._coordinates = this._trimRing(rings);
        } else {
          this._coordinates = this._trimRing(rings[0]);

          if (len > 1) {
            var holes = [];

            for (var i = 1; i < len; i++) {
              if (!rings[i]) {
                continue;
              }

              holes.push(this._trimRing(rings[i]));
            }

            this._holes = holes;
          }
        }

        this._projectRings();

        return this;
      }
      /**
       * Gets polygons's coordinates
       *
       * @returns {Coordinate[][]}
       */
      ;

      _proto.getCoordinates = function getCoordinates() {
        if (!this._coordinates) {
          return [];
        }

        var holes = this.getHoles();
        var rings = [this._copyAndCloseRing(this._coordinates)];

        for (var i = 0, l = holes.length; i < l; i++) {
          rings.push(this._copyAndCloseRing(holes[i]));
        }

        return rings;
      }
      /**
       * Get center of linestring's intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = line.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      ;

      _proto.getCenterInExtent = function getCenterInExtent(extent) {
        return this._getCenterInExtent(extent, this.getShell(), clipPolygon);
      }
      /**
       * Gets shell's coordinates of the polygon
       *
       * @returns {Coordinate[]}
       */
      ;

      _proto.getShell = function getShell() {
        return this._coordinates || [];
      }
      /**
       * Gets holes' coordinates of the polygon if it has.
       * @returns {Coordinate[][]}
       */
      ;

      _proto.getHoles = function getHoles() {
        return this._holes || [];
      }
      /**
       * Whether the polygon has any holes inside.
       *
       * @returns {Boolean}
       */
      ;

      _proto.hasHoles = function hasHoles() {
        return this.getHoles().length > 0;
      };

      _proto._projectRings = function _projectRings() {
        if (!this.getMap()) {
          this.onShapeChanged();
          return;
        }

        this._prjCoords = this._projectCoords(this._coordinates);
        this._prjHoles = this._projectCoords(this._holes);
        this.onShapeChanged();
      };

      _proto._cleanRing = function _cleanRing(ring) {
        for (var i = ring.length - 1; i >= 0; i--) {
          if (!ring[i]) {
            ring.splice(i, 1);
          }
        }
      }
      /**
       * Check if ring is valid
       * @param  {*} ring ring to check
       * @return {Boolean} is ring a closed one
       * @private
       */
      ;

      _proto._checkRing = function _checkRing(ring) {
        this._cleanRing(ring);

        if (!ring || !isArrayHasData(ring)) {
          return false;
        }

        var lastPoint = ring[ring.length - 1];
        var isClose = true;

        if (ring[0].x !== lastPoint.x || ring[0].y !== lastPoint.y) {
          isClose = false;
        }

        return isClose;
      }
      /**
       * If the first coordinate is equal with the last one, then remove the last coordinates.
       * @private
       */
      ;

      _proto._trimRing = function _trimRing(ring) {
        var isClose = this._checkRing(ring);

        if (isArrayHasData(ring) && isClose) {
          ring.splice(ring.length - 1, 1);
        }

        return ring;
      }
      /**
       * If the first coordinate is different with the last one, then copy the first coordinates and add to the ring.
       * @private
       */
      ;

      _proto._copyAndCloseRing = function _copyAndCloseRing(ring) {
        ring = ring.slice(0);

        var isClose = this._checkRing(ring);

        if (isArrayHasData(ring) && !isClose) {
          ring.push(ring[0].copy());
          return ring;
        } else {
          return ring;
        }
      };

      _proto._getPrjShell = function _getPrjShell() {
        if (this.getJSONType() === JSON_TYPE) {
          return this._getPrjCoordinates();
        }

        var projection = this._getProjection();

        if (!projection) {
          return null;
        }

        this._verifyProjection();

        if (!this._prjShell) {
          this._prjShell = this._projectCoords(this.getShell());
        }

        return this._prjShell;
      };

      _proto._getPrjHoles = function _getPrjHoles() {
        var projection = this._getProjection();

        if (!projection) {
          return null;
        }

        this._verifyProjection();

        if (!this._prjHoles) {
          this._prjHoles = this._projectCoords(this.getHoles());
        }

        return this._prjHoles;
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength(measurer) {
        var rings = this.getCoordinates();

        if (!isArrayHasData(rings)) {
          return 0;
        }

        var result = 0;

        for (var i = 0, len = rings.length; i < len; i++) {
          result += measurer.measureLength(rings[i]);
        }

        return result;
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea(measurer) {
        var rings = this.getCoordinates();

        if (!isArrayHasData(rings)) {
          return 0;
        }

        var result = measurer.measureArea(rings[0]); //holes

        for (var i = 1, len = rings.length; i < len; i++) {
          result -= measurer.measureArea(rings[i]);
        }

        return result;
      };

      _proto._updateCache = function _updateCache() {
        _Path.prototype._updateCache.call(this);

        if (this._prjHoles) {
          this._holes = this._unprojectCoords(this._getPrjHoles());
        }
      };

      _proto._clearCache = function _clearCache() {
        delete this._prjShell;
        return _Path.prototype._clearCache.call(this);
      };

      _proto._clearProjection = function _clearProjection() {
        if (this._prjHoles) {
          this._prjHoles = null;
        }

        if (this._prjShell) {
          this._prjShell = null;
        }

        _Path.prototype._clearProjection.call(this);
      };

      return Polygon;
    }(Path);

    Polygon.registerJSONType(JSON_TYPE);

    /**
     * Common methods for geometry classes that base on a center, e.g. Marker, Circle, Ellipse , etc
     * @mixin CenterMixin
     */

    function CenterMixin (Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          var _proto = _class.prototype;

          /**
           * Get geometry's center
           * @return {Coordinate} - center of the geometry
           * @function CenterMixin.getCoordinates
           */
          _proto.getCoordinates = function getCoordinates() {
            return this._coordinates;
          }
          /**
           * Set a new center to the geometry
           * @param {Coordinate|Number[]} coordinates - new center
           * @return {Geometry} this
           * @fires Geometry#positionchange
           * @function CenterMixin.setCoordinates
           */
          ;

          _proto.setCoordinates = function setCoordinates(coordinates) {
            var center = coordinates instanceof Coordinate ? coordinates : new Coordinate(coordinates);

            if (center.equals(this._coordinates)) {
              return this;
            }

            this._coordinates = center;

            if (!this.getMap()) {
              this.onPositionChanged();
              return this;
            }

            var projection = this._getProjection();

            this._setPrjCoordinates(projection.project(this._coordinates));

            return this;
          } //Gets view point of the geometry's center
          ;

          _proto._getCenter2DPoint = function _getCenter2DPoint(zoom) {
            var map = this.getMap();

            if (!map) {
              return null;
            }

            var z = isNil(zoom) ? map.getZoom() : map.getGLZoom();

            var pcenter = this._getPrjCoordinates();

            if (!pcenter) {
              return null;
            }

            return map._prjToPoint(pcenter, z);
          };

          _proto._getPrjCoordinates = function _getPrjCoordinates() {
            var projection = this._getProjection();

            if (!projection) {
              return null;
            }

            this._verifyProjection();

            if (!this._pcenter) {
              if (this._coordinates) {
                this._pcenter = projection.project(this._coordinates);
              }
            }

            return this._pcenter;
          } //Set center by projected coordinates
          ;

          _proto._setPrjCoordinates = function _setPrjCoordinates(pcenter) {
            this._pcenter = pcenter;
            this.onPositionChanged();
          } //update cached const iables if geometry is updated.
          ;

          _proto._updateCache = function _updateCache() {
            this._clearCache();

            var projection = this._getProjection();

            if (this._pcenter && projection) {
              this._coordinates = projection.unproject(this._pcenter);
            }
          };

          _proto._clearProjection = function _clearProjection() {
            this._pcenter = null;

            _Base.prototype._clearProjection.call(this);
          };

          _proto._computeCenter = function _computeCenter() {
            return this._coordinates ? this._coordinates.copy() : null;
          };

          return _class;
        }(Base)
      );
    }

    /**
     * @property {String} [options.hitTestForEvent=false] - use hit testing for events, be careful, it may fail due to tainted canvas.
     * @memberOf Marker
     * @instance
     */

    var options$4 = {
      'symbol': {
        'markerType': 'path',
        'markerPath': [{
          'path': 'M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z',
          'fill': '#DE3333'
        }],
        'markerPathWidth': 16,
        'markerPathHeight': 23,
        'markerWidth': 24,
        'markerHeight': 34
      },
      'hitTestForEvent': false
    };
    /**
     * @classdesc
     * Represents a Point type Geometry.
     * @category geometry
     * @extends Geometry
     * @mixes CenterMixin
     * @example
     * var marker = new Marker([100, 0], {
     *     'id' : 'marker0',
     *     'symbol' : {
     *         'markerFile'  : 'foo.png',
     *         'markerWidth' : 20,
     *         'markerHeight': 20,
     *     },
     *     'properties' : {
     *         'foo' : 'value'
     *     }
     * });
     */

    var Marker =
    /*#__PURE__*/
    function (_CenterMixin) {
      _inheritsLoose(Marker, _CenterMixin);

      /**
       * @param {Coordinate} coordinates      - coordinates of the marker
       * @param {Object} [options=null]       - construct options defined in [Marker]{@link Marker#options}
       */
      function Marker(coordinates, opts) {
        var _this;

        _this = _CenterMixin.call(this, opts) || this;
        _this.type = 'Point';

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        return _this;
      }

      var _proto = Marker.prototype;

      _proto.getOutline = function getOutline() {
        var painter = this._getPainter();

        if (!painter) {
          return null;
        }

        var coord = this.getCoordinates();
        var extent = painter.getContainerExtent();
        var anchor = this.getMap().coordToContainerPoint(coord);
        return new Marker(coord, {
          'symbol': {
            'markerType': 'square',
            'markerWidth': extent.getWidth(),
            'markerHeight': extent.getHeight(),
            'markerLineWidth': 1,
            'markerLineColor': '6b707b',
            'markerFill': 'rgba(0, 0, 0, 0)',
            'markerDx': extent.xmin - (anchor.x - extent.getWidth() / 2),
            'markerDy': extent.ymin - (anchor.y - extent.getHeight() / 2)
          }
        });
      };

      _proto._isVectorMarker = function _isVectorMarker() {
        var symbol = this._getInternalSymbol();

        if (Array.isArray(symbol)) {
          return false;
        }

        return VectorMarkerSymbolizer.test(symbol);
      }
      /**
       * Can be edited, only marker with a vector symbol, vector path symbol or a image symbol can be edited.
       * @return {Boolean}
       * @private
       */
      ;

      _proto._canEdit = function _canEdit() {
        var symbol = this._getInternalSymbol();

        if (Array.isArray(symbol)) {
          return false;
        }

        return VectorMarkerSymbolizer.test(symbol) || VectorPathMarkerSymbolizer.test(symbol) || ImageMarkerSymbolizer.test(symbol);
      };

      _proto._containsPoint = function _containsPoint(point, t) {
        var extent = this.getContainerExtent();

        if (t) {
          extent = extent.expand(t);
        }

        if (extent.contains(point)) {
          if (this.options['hitTestForEvent']) {
            return _CenterMixin.prototype._containsPoint.call(this, point, t);
          } else {
            return true;
          }
        } else {
          return false;
        }
      };

      _proto._computeExtent = function _computeExtent() {
        return computeExtent.call(this, 'getCenter');
      };

      _proto._computePrjExtent = function _computePrjExtent() {
        return computeExtent.call(this, '_getPrjCoordinates');
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength() {
        return 0;
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        return 0;
      };

      _proto._getSprite = function _getSprite(resources, canvasClass) {
        if (this._getPainter()) {
          return this._getPainter().getSprite(resources, canvasClass);
        }

        return new Painter(this).getSprite(resources, canvasClass);
      };

      return Marker;
    }(CenterMixin(Geometry));

    Marker.mergeOptions(options$4);
    Marker.registerJSONType('Marker');

    function computeExtent(fn) {
      var coordinates = this[fn]();

      if (!coordinates) {
        return null;
      }

      return new Extent(coordinates, coordinates, this._getProjection());
    }

    /**
     * @property {Object} [options=null]
     * @property {String|Number[]} [options.arrowStyle=null]        - style of arrow, can be a pre-defined value or an array [arrow-width, arrow-height] (value in the array is times of linewidth), possible predefined values: classic ([3, 4])
     * @property {String} [options.arrowPlacement=vertex-last]      - arrow's placement: vertex-first, vertex-last, vertex-firstlast, point
     * @memberOf LineString
     * @instance
     */

    var options$5 = {
      'arrowStyle': null,
      'arrowPlacement': 'vertex-last' //vertex-first, vertex-last, vertex-firstlast, point

    };
    /**
     * Represents a LineString type Geometry.
     * @category geometry
     * @extends Path
     * @example
     * var line = new LineString(
     *     [
     *         [121.45942, 31.24123],
     *         [121.46371, 31.24226],
     *         [121.46727, 31.23870],
     *         [121.47019, 31.24145]
     *     ]
     * ).addTo(layer);
     */

    var LineString =
    /*#__PURE__*/
    function (_Path) {
      _inheritsLoose(LineString, _Path);

      /**
       * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string
       * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}
       */
      function LineString(coordinates, options) {
        var _this;

        _this = _Path.call(this, options) || this;
        _this.type = 'LineString';

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        return _this;
      }
      /**
       * Set new coordinates to the line string
       * @param {Coordinate[]|Number[][]} coordinates - new coordinates
       * @fires LineString#shapechange
       * @return {LineString} this
       */


      var _proto = LineString.prototype;

      _proto.setCoordinates = function setCoordinates(coordinates) {
        if (!coordinates) {
          this._coordinates = null;

          this._setPrjCoordinates(null);

          return this;
        }

        this._coordinates = Coordinate.toCoordinates(coordinates);

        if (this.getMap()) {
          this._setPrjCoordinates(this._projectCoords(this._coordinates));
        } else {
          this.onShapeChanged();
        }

        return this;
      }
      /**
       * Get coordinates of the line string
       * @return {Coordinate[]|Number[][]} coordinates
       */
      ;

      _proto.getCoordinates = function getCoordinates() {
        return this._coordinates || [];
      }
      /**
       * Get center of linestring's intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = line.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      ;

      _proto.getCenterInExtent = function getCenterInExtent(extent) {
        return this._getCenterInExtent(extent, this.getCoordinates(), clipLine);
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength(measurer) {
        return measurer.measureLength(this.getCoordinates());
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        return 0;
      };

      return LineString;
    }(Path);

    LineString.mergeOptions(options$5);
    LineString.registerJSONType('LineString');

    /**
     * @classdesc
     * Represents a GeometryCollection.
     * @category geometry
     * @extends Geometry
     * @example
     * var marker = new Marker([0, 0]),
     *     line = new LineString([[0, 0], [0, 1]]),
     *     polygon = new Polygon([[0, 0], [0, 1], [1, 3]]);
     * var collection = new GeometryCollection([marker, line, polygon])
     *     .addTo(layer);
     */

    var GeometryCollection =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(GeometryCollection, _Geometry);

      /**
       * @param {Geometry[]} geometries - GeometryCollection's geometries
       * @param {Object} [options=null] - options defined in [nGeometryCollection]{@link GeometryCollection#options}
       */
      function GeometryCollection(geometries, opts) {
        var _this;

        _this = _Geometry.call(this, opts) || this;
        _this.type = 'GeometryCollection';

        _this.setGeometries(geometries);

        return _this;
      }
      /**
       * Set new geometries to the geometry collection
       * @param {Geometry[]} geometries
       * @return {GeometryCollection} this
       * @fires GeometryCollection#shapechange
       */


      var _proto = GeometryCollection.prototype;

      _proto.setGeometries = function setGeometries(_geometries) {
        var geometries = this._checkGeometries(_geometries || []);

        var symbol = this._getSymbol();

        var options = this.config(); //Set the collection as child geometries' parent.

        for (var i = geometries.length - 1; i >= 0; i--) {
          geometries[i]._initOptions(options);

          geometries[i]._setParent(this);

          geometries[i]._setEventParent(this);

          if (symbol) {
            geometries[i].setSymbol(symbol);
          }
        }

        this._geometries = geometries;

        if (this.getLayer()) {
          this._bindGeometriesToLayer();

          this.onShapeChanged();
        }

        return this;
      }
      /**
       * Get geometries of the geometry collection
       * @return {Geometry[]} geometries
       */
      ;

      _proto.getGeometries = function getGeometries() {
        return this._geometries || [];
      }
      /**
       * Executes the provided callback once for each geometry present in the collection in order.
       * @param  {Function} fn             - a callback function
       * @param  {*} [context=undefined]   - callback's context
       * @return {GeometryCollection} this
       */
      ;

      _proto.forEach = function forEach(fn, context) {
        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          if (!context) {
            fn(geometries[i], i);
          } else {
            fn.call(context, geometries[i], i);
          }
        }

        return this;
      }
      /**
       * Creates a GeometryCollection with all elements that pass the test implemented by the provided function.
       * @param  {Function} fn      - Function to test each geometry
       * @param  {*} [context=undefined]    - Function's context
       * @return {GeometryCollection} A GeometryCollection with all elements that pass the test
       * @example
       * var filtered = collection.filter(['==', 'foo', 'bar]);
       * @example
       * var filtered = collection.filter(geometry => geometry.getProperties().foo === 'bar');
       */
      ;

      _proto.filter = function filter(fn, context) {
        if (!fn) {
          return new GeometryCollection();
        }

        var selected = [];
        var isFn = isFunction(fn);
        var filter = isFn ? fn : createFilter(fn);
        this.forEach(function (geometry) {
          var g = isFn ? geometry : getFilterFeature(geometry);

          if (context ? filter.call(context, g) : filter(g)) {
            selected.push(geometry);
          }
        }, this);
        return new GeometryCollection(selected);
      }
      /**
       * Translate or move the geometry collection by the given offset.
       * @param  {Coordinate} offset - translate offset
       * @return {GeometryCollection} this
       */
      ;

      _proto.translate = function translate(offset) {
        if (!offset) {
          return this;
        }

        if (this.isEmpty()) {
          return this;
        }

        var args = arguments;
        this.forEach(function (geometry) {
          if (geometry && geometry.translate) {
            geometry.translate.apply(geometry, args);
          }
        });
        return this;
      }
      /**
       * Whether the geometry collection is empty
       * @return {Boolean}
       */
      ;

      _proto.isEmpty = function isEmpty$$1() {
        return !isArrayHasData(this.getGeometries());
      }
      /**
       * remove itself from the layer if any.
       * @returns {Geometry} this
       * @fires GeometryCollection#removestart
       * @fires GeometryCollection#remove
       * @fires GeometryCollection#removeend
       */
      ;

      _proto.remove = function remove() {
        this.forEach(function (geometry) {
          geometry._unbind();
        });
        return Geometry.prototype.remove.apply(this, arguments);
      }
      /**
       * Show the geometry collection.
       * @return {GeometryCollection} this
       * @fires GeometryCollection#show
       */
      ;

      _proto.show = function show() {
        this.options['visible'] = true;
        this.forEach(function (geometry) {
          geometry.show();
        });
        return this;
      }
      /**
       * Hide the geometry collection.
       * @return {GeometryCollection} this
       * @fires GeometryCollection#hide
       */
      ;

      _proto.hide = function hide() {
        this.options['visible'] = false;
        this.forEach(function (geometry) {
          geometry.hide();
        });
        return this;
      };

      _proto.onConfig = function onConfig(config) {
        this.forEach(function (geometry) {
          geometry.config(config);
        });
      };

      _proto.getSymbol = function getSymbol() {
        var s = _Geometry.prototype.getSymbol.call(this);

        if (!s) {
          var symbols = [];
          var is = false;
          this.forEach(function (g) {
            var symbol = g.getSymbol();

            if (symbol && !is) {
              is = true;
            }

            symbols.push(g.getSymbol());
          });

          if (is) {
            s = {
              'children': symbols
            };
          }
        }

        return s;
      };

      _proto.setSymbol = function setSymbol(s) {
        if (s && s['children']) {
          this._symbol = null;
          this.forEach(function (g, i) {
            g.setSymbol(s['children'][i]);
          });
        } else {
          var symbol = this._prepareSymbol(s);

          this._symbol = symbol;
          this.forEach(function (g) {
            g.setSymbol(symbol);
          });
        }

        this.onSymbolChanged();
        return this;
      };

      _proto._setExternSymbol = function _setExternSymbol(symbol) {
        symbol = this._prepareSymbol(symbol);
        this._externSymbol = symbol;
        this.forEach(function (geometry) {
          geometry._setExternSymbol(symbol);
        });
        this.onSymbolChanged();
        return this;
      }
      /**
       * bind this geometry collection to a layer
       * @param  {Layer} layer
       * @private
       */
      ;

      _proto._bindLayer = function _bindLayer() {
        _Geometry.prototype._bindLayer.apply(this, arguments);

        this._bindGeometriesToLayer();
      };

      _proto._bindGeometriesToLayer = function _bindGeometriesToLayer() {
        var layer = this.getLayer();
        this.forEach(function (geometry) {
          geometry._bindLayer(layer);
        });
      }
      /**
       * Check whether the type of geometries is valid
       * @param  {Geometry[]} geometries - geometries to check
       * @private
       */
      ;

      _proto._checkGeometries = function _checkGeometries(geometries) {
        var invalidGeoError = 'The geometry added to collection is invalid.';

        if (geometries && !Array.isArray(geometries)) {
          if (geometries instanceof Geometry) {
            return [geometries];
          } else {
            throw new Error(invalidGeoError);
          }
        } else {
          for (var i = 0, l = geometries.length; i < l; i++) {
            if (!this._checkGeo(geometries[i])) {
              throw new Error(invalidGeoError + ' Index: ' + i);
            }
          }

          return geometries;
        }
      };

      _proto._checkGeo = function _checkGeo(geo) {
        return geo instanceof Geometry;
      };

      _proto._updateCache = function _updateCache() {
        this._clearCache();

        if (this.isEmpty()) {
          return;
        }

        this.forEach(function (geometry) {
          if (geometry && geometry._updateCache) {
            geometry._updateCache();
          }
        });
      };

      _proto._removePainter = function _removePainter() {
        if (this._painter) {
          this._painter.remove();
        }

        delete this._painter;
        this.forEach(function (geometry) {
          geometry._removePainter();
        });
      };

      _proto._computeCenter = function _computeCenter(projection) {
        if (!projection || this.isEmpty()) {
          return null;
        }

        var sumX = 0,
            sumY = 0,
            counter = 0;
        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          var center = geometries[i]._computeCenter(projection);

          if (center) {
            sumX += center.x;
            sumY += center.y;
            counter++;
          }
        }

        if (counter === 0) {
          return null;
        }

        return new Coordinate(sumX / counter, sumY / counter);
      };

      _proto._containsPoint = function _containsPoint(point, t) {
        if (this.isEmpty()) {
          return false;
        }

        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (geometries[i]._containsPoint(point, t)) {
            return true;
          }
        }

        return false;
      };

      _proto._computeExtent = function _computeExtent(projection) {
        return computeExtent$1.call(this, projection, '_computeExtent');
      };

      _proto._computePrjExtent = function _computePrjExtent(projection) {
        return computeExtent$1.call(this, projection, '_computePrjExtent');
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength(projection) {
        if (!projection || this.isEmpty()) {
          return 0;
        }

        var geometries = this.getGeometries();
        var result = 0;

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          result += geometries[i]._computeGeodesicLength(projection);
        }

        return result;
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea(projection) {
        if (!projection || this.isEmpty()) {
          return 0;
        }

        var geometries = this.getGeometries();
        var result = 0;

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          result += geometries[i]._computeGeodesicArea(projection);
        }

        return result;
      };

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var children = [];

        if (!this.isEmpty()) {
          var geometries = this.getGeometries();

          for (var i = 0, l = geometries.length; i < l; i++) {
            if (!geometries[i]) {
              continue;
            }

            children.push(geometries[i]._exportGeoJSONGeometry());
          }
        }

        return {
          'type': 'GeometryCollection',
          'geometries': children
        };
      };

      _proto._clearProjection = function _clearProjection() {
        if (this.isEmpty()) {
          return;
        }

        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          geometries[i]._clearProjection();
        }
      }
      /**
       * Get connect points if being connected by [ConnectorLine]{@link ConnectorLine}
       * @private
       * @return {Coordinate[]}
       */
      ;

      _proto._getConnectPoints = function _getConnectPoints() {
        var extent = this.getExtent();
        var anchors = [new Coordinate(extent.xmin, extent.ymax), new Coordinate(extent.xmax, extent.ymin), new Coordinate(extent.xmin, extent.ymin), new Coordinate(extent.xmax, extent.ymax)];
        return anchors;
      };

      _proto._getExternalResources = function _getExternalResources() {
        if (this.isEmpty()) {
          return [];
        }

        var geometries = this.getGeometries(),
            resources = [];
        var cache = {};
        var symbol, res, key;

        for (var i = 0, l = geometries.length; i < l; i++) {
          if (!geometries[i]) {
            continue;
          }

          symbol = geometries[i]._getInternalSymbol();
          res = getExternalResources(symbol);

          for (var ii = 0, ll = res.length; ii < ll; ii++) {
            key = res[ii].join();

            if (!cache[key]) {
              resources.push(res[ii]);
              cache[key] = 1;
            }
          }
        }

        return resources;
      } //----------Overrides editor methods in Geometry-----------------
      ;

      _proto.startEdit = function startEdit(opts) {
        var _this2 = this;

        if (this.isEmpty()) {
          return this;
        }

        if (!opts) {
          opts = {};
        }

        if (opts['symbol']) {
          this._originalSymbol = this.getSymbol();
          this.setSymbol(opts['symbol']);
        }

        this._draggbleBeforeEdit = this.options['draggable'];
        this.config('draggable', false);
        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          geometries[i].startEdit(opts);
        }

        this._editing = true;
        this.hide();
        setTimeout(function () {
          _this2.fire('editstart');
        }, 1);
        return this;
      };

      _proto.endEdit = function endEdit() {
        if (this.isEmpty()) {
          return this;
        }

        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          geometries[i].endEdit();
        }

        if (this._originalSymbol) {
          this.setSymbol(this._originalSymbol);
          delete this._originalSymbol;
        }

        this._editing = false;
        this.show();
        this.config('draggable', this._draggbleBeforeEdit);
        this.fire('editend');
        return this;
      };

      _proto.isEditing = function isEditing() {
        if (!this._editing) {
          return false;
        }

        return true;
      };

      return GeometryCollection;
    }(Geometry);

    GeometryCollection.registerJSONType('GeometryCollection');

    function computeExtent$1(projection, fn) {
      if (this.isEmpty()) {
        return null;
      }

      var geometries = this.getGeometries();
      var result = null;

      for (var i = 0, l = geometries.length; i < l; i++) {
        var geo = geometries[i];

        if (!geo) {
          continue;
        }

        var geoExtent = geo[fn](projection);

        if (geoExtent) {
          result = geoExtent.combine(result);
        }
      }

      return result;
    }

    /**
     * The parent class for MultiPoint, MultiLineString and MultiPolygon
     * @category geometry
     * @abstract
     * @extends {GeometryCollection}
     */

    var MultiGeometry =
    /*#__PURE__*/
    function (_GeometryCollection) {
      _inheritsLoose(MultiGeometry, _GeometryCollection);

      /**
       * @param  {Class} geoType      Type of the geometry
       * @param  {String} type        type in String, e.g. "MultiPoint", "MultiLineString"
       * @param  {Geometry[]} data    data
       * @param  {Object} [options=null] configuration options
       */
      function MultiGeometry(geoType, type, data, options) {
        var _this;

        _this = _GeometryCollection.call(this, null, options) || this;
        _this.GeometryType = geoType;
        _this.type = type;

        _this._initData(data);

        return _this;
      }
      /**
       * Get coordinates of the collection
       * @return {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates
       */


      var _proto = MultiGeometry.prototype;

      _proto.getCoordinates = function getCoordinates() {
        var coordinates = [];
        var geometries = this.getGeometries();

        for (var i = 0, l = geometries.length; i < l; i++) {
          var child = geometries[i];
          coordinates.push(child.getShell && child.getJSONType() !== 'Polygon' ? [child.getShell()] : child.getCoordinates());
        }

        return coordinates;
      }
      /**
       * Set new coordinates to the collection
       * @param {Coordinate[]|Coordinate[][]|Coordinate[][][]} coordinates
       * @returns {Geometry} this
       * @fires maptalk.Geometry#shapechange
       */
      ;

      _proto.setCoordinates = function setCoordinates(coordinates) {
        coordinates = coordinates || [];
        var geometries = [];

        for (var i = 0, l = coordinates.length; i < l; i++) {
          var g = new this.GeometryType(coordinates[i], this.config());
          geometries.push(g);
        }

        this.setGeometries(geometries);
        return this;
      };

      _proto._initData = function _initData(data) {
        data = data || [];

        if (data.length) {
          if (data[0] instanceof this.GeometryType) {
            this.setGeometries(data);
          } else {
            this.setCoordinates(data);
          }
        }
      };

      _proto._checkGeo = function _checkGeo(geo) {
        return geo instanceof this.GeometryType;
      } //override _exportGeoJSONGeometry in GeometryCollection
      ;

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var points = this.getCoordinates();
        var coordinates = Coordinate.toNumberArrays(points);
        return {
          'type': this.getType(),
          'coordinates': coordinates
        };
      };

      return MultiGeometry;
    }(GeometryCollection);

    /**
     * @classdesc
     * Represents a Geometry type of MultiPoint.
     * @category geometry
     * @extends MultiGeometry
     * @example
     * var multiPoint = new MultiPoint(
     *     [
     *         [121.5080881906138, 31.241128104458117],
     *         [121.50804527526954, 31.237238340103413],
     *         [121.5103728890997, 31.23888972560888]
     *     ]
     * ).addTo(layer);
     */

    var MultiPoint =
    /*#__PURE__*/
    function (_MultiGeometry) {
      _inheritsLoose(MultiPoint, _MultiGeometry);

      /**
       * @param {Number[][]|Coordinate[]|Marker[]} data - construct data, coordinates or an array of markers
       * @param {Object} [options=null] - options defined in [nMultiPoint]{@link MultiPoint#options}
       */
      function MultiPoint(data, opts) {
        return _MultiGeometry.call(this, Marker, 'MultiPoint', data, opts) || this;
      }
      /**
       * Find the closet point to the give coordinate
       * @param {Coordinate} coordinate coordinate
       * @returns {Coordinate} coordinate
       */


      var _proto = MultiPoint.prototype;

      _proto.findClosest = function findClosest(coordinate) {
        if (!coordinate) {
          return null;
        }

        var coords = this.getCoordinates();
        var hit = null;
        var max = Infinity;
        coords.forEach(function (c) {
          var dist = distanceTo(c, coordinate);

          if (dist < max) {
            hit = c;
            max = dist;
          }
        });
        return hit;
      };

      return MultiPoint;
    }(MultiGeometry);

    MultiPoint.registerJSONType('MultiPoint');

    function distanceTo(p0, p1) {
      var x = p1.x - p0.x,
          y = p1.y - p0.y;
      return Math.sqrt(x * x + y * y);
    }

    /**
     * @classdesc
     * An abstract class for MultiPolygon and MultiLineString
     * @category geometry
     * @extends MultiGeometry
     */

    var MultiPath =
    /*#__PURE__*/
    function (_MultiGeometry) {
      _inheritsLoose(MultiPath, _MultiGeometry);

      function MultiPath() {
        return _MultiGeometry.apply(this, arguments) || this;
      }

      var _proto = MultiPath.prototype;

      /**
       * Get center of (MultiLineString or MultiPolygon)'s intersection with give extent
       * @example
       *  const extent = map.getExtent();
       *  const center = geometry.getCenterInExtent(extent);
       * @param {Extent} extent
       * @return {Coordinate} center, null if line doesn't intersect with extent
       */
      _proto.getCenterInExtent = function getCenterInExtent(extent) {
        var children = this.getGeometries();
        var sumx = 0,
            sumy = 0,
            counter = 0;
        children.forEach(function (l) {
          var c = l.getCenterInExtent(extent);

          if (c) {
            sumx += c.x * c.count;
            sumy += c.y * c.count;
            counter += c.count;
          }
        });

        if (counter === 0) {
          return null;
        }

        return new Coordinate(sumx, sumy)._multi(1 / counter);
      };

      return MultiPath;
    }(MultiGeometry);

    /**
     * @classdesc
     * Represents a Geometry type of MultiLineString
     * @category geometry
     * @extends MultiGeometry
     * @example
     * var multiLineString = new MultiLineString(
     *      [
     *          [
     *              [121.5289450479131, 31.2420083925986],
     *              [121.52860172515919, 31.238926401171824]
     *          ],
     *          [
     *              [121.53091915374796, 31.241898323208233],
     *              [121.53104789978069, 31.23859618183896]
     *          ],
     *          [
     *               [121.5324641061405, 31.241898323208233],
     *               [121.53242119079626, 31.239146546752256]
     *           ]
     *       ],
     *       {
     *           symbol:{
     *               'lineColor' : '#000000',
     *               'lineWidth' : 5,
     *               'lineOpacity' : 1
     *           },
     *          draggable:true
     *      }
     * ).addTo(layer);
     */

    var MultiLineString =
    /*#__PURE__*/
    function (_MultiPath) {
      _inheritsLoose(MultiLineString, _MultiPath);

      /**
       * @param {Number[][][]|Coordinate[][]|LineString[]} data - construct data, coordinates or an array of linestrings
       * @param {Object} [options=null]           - options defined in [MultiLineString]{@link MultiLineString#options}
       */
      function MultiLineString(data, options) {
        return _MultiPath.call(this, LineString, 'MultiLineString', data, options) || this;
      }

      return MultiLineString;
    }(MultiPath);

    MultiLineString.registerJSONType('MultiLineString');

    /**
     * @classdesc
     * Represents a Geometry type of MultiPolygon
     * @category geometry
     * @extends MultiGeometry
     * @example
     * var multiPolygon = new MultiPolygon(
     *       [
     *           [
     *               [
     *                   [121.55074604278596, 31.242008515751614],
     *                   [121.55074604278596, 31.23914637638951],
     *                   [121.55349262481711, 31.23914637638951],
     *                   [121.55349262481711, 31.24134802974913],
     *                   [121.5518618417361, 31.241384723537074],
     *                   [121.55074604278596, 31.242008515751614]
     *               ]
     *           ],
     *           [
     *               [
     *                   [121.5543080163576, 31.241054478932387],
     *                   [121.5543938470461, 31.240100432478293],
     *                   [121.55555256134048, 31.240173821009137],
     *                   [121.55542381530773, 31.240981091085693],
     *                   [121.5543080163576, 31.241054478932387]
     *               ]
     *           ]
     *
     *       ],
     *       {
     *           symbol:{
     *               'lineColor' : '#000000',
     *               'lineWidth' : 2,
     *               'lineDasharray' : null,//线形
     *               'lineOpacity' : 1,
     *               'polygonFill' : 'rgb(255, 0, 0)',
     *               'polygonOpacity' : 0.8
     *           },
     *           draggable:true
     * }).addTo(layer);
     */

    var MultiPolygon =
    /*#__PURE__*/
    function (_MultiPath) {
      _inheritsLoose(MultiPolygon, _MultiPath);

      /**
       * @param {Number[][][][]|Coordinate[][][]|Polygon[]} data - construct data, coordinates or an array of polygons
       * @param {Object} [options=null]           - options defined in [MultiPolygon]{@link MultiPolygon#options}
       */
      function MultiPolygon(data, opts) {
        return _MultiPath.call(this, Polygon, 'MultiPolygon', data, opts) || this;
      }

      return MultiPolygon;
    }(MultiPath);

    MultiPolygon.registerJSONType('MultiPolygon');

    var types$1 = {
      'Marker': Marker,
      'LineString': LineString,
      'Polygon': Polygon,
      'MultiPoint': MultiPoint,
      'MultiLineString': MultiLineString,
      'MultiPolygon': MultiPolygon
    };
    /**
     * GeoJSON utilities
     * @class
     * @category geometry
     * @name GeoJSON
     */

    var GeoJSON = {
      /**
       * Convert one or more GeoJSON objects to geometry
       * @param  {String|Object|Object[]} geoJSON - GeoJSON objects or GeoJSON string
       * @param  {Function} [foreachFn=undefined] - callback function for each geometry
       * @return {Geometry|Geometry[]} a geometry array when input is a FeatureCollection
       * @example
       * var collection = {
       *      "type": "FeatureCollection",
       *      "features": [
       *          { "type": "Feature",
       *            "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
       *            "properties": {"prop0": "value0"}
       *           },
       *           { "type": "Feature",
       *             "geometry": {
       *                 "type": "LineString",
       *                 "coordinates": [
       *                     [102.0, 0.0], [103.0, 1.0], [104.0, 0.0], [105.0, 1.0]
       *                 ]
       *             },
       *             "properties": {
       *                 "prop0": "value0",
       *                 "prop1": 0.0
       *             }
       *           },
       *           { "type": "Feature",
       *             "geometry": {
       *                 "type": "Polygon",
       *                 "coordinates": [
       *                     [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
       *                       [100.0, 1.0], [100.0, 0.0] ]
       *                 ]
       *             },
       *             "properties": {
       *                 "prop0": "value0",
       *                 "prop1": {"this": "that"}
       *             }
       *          }
       *      ]
       *  }
       *  // A geometry array.
       *  const geometries = GeoJSON.toGeometry(collection, geometry => { geometry.config('draggable', true); });
       */
      toGeometry: function toGeometry(geoJSON, foreachFn) {
        if (isString(geoJSON)) {
          geoJSON = parseJSON(geoJSON);
        }

        if (Array.isArray(geoJSON)) {
          var resultGeos = [];

          for (var i = 0, len = geoJSON.length; i < len; i++) {
            var geo = GeoJSON._convert(geoJSON[i], foreachFn);

            if (Array.isArray(geo)) {
              pushIn(resultGeos, geo);
            } else {
              resultGeos.push(geo);
            }
          }

          return resultGeos;
        } else {
          var resultGeo = GeoJSON._convert(geoJSON, foreachFn);

          return resultGeo;
        }
      },

      /**
       * Convert single GeoJSON object
       * @param  {Object} geoJSONObj - a GeoJSON object
       * @return {Geometry}
       * @private
       */
      _convert: function _convert(json, foreachFn) {
        if (!json || isNil(json['type'])) {
          return null;
        }

        var type = json['type'];

        if (type === 'Feature') {
          var g = json['geometry'];

          var geometry = GeoJSON._convert(g, foreachFn);

          if (!geometry) {
            return null;
          }

          geometry.setId(json['id']);
          geometry.setProperties(json['properties']);
          return geometry;
        } else if (type === 'FeatureCollection') {
          var features = json['features'];

          if (!features) {
            return null;
          }

          return GeoJSON.toGeometry(features, foreachFn);
        } else if (['Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon'].indexOf(type) >= 0) {
          var clazz = type === 'Point' ? 'Marker' : type;
          var result = new types$1[clazz](json['coordinates']);

          if (foreachFn) {
            foreachFn(result);
          }

          return result;
        } else if (type === 'GeometryCollection') {
          var geometries = json['geometries'];

          if (!isArrayHasData(geometries)) {
            var _result2 = new GeometryCollection();

            if (foreachFn) {
              foreachFn(_result2);
            }

            return _result2;
          }

          var mGeos = [];
          var size = geometries.length;

          for (var i = 0; i < size; i++) {
            mGeos.push(GeoJSON._convert(geometries[i]));
          }

          var _result = new GeometryCollection(mGeos);

          if (foreachFn) {
            foreachFn(_result);
          }

          return _result;
        }

        return null;
      }
    };

    /**
     * @property {Object} options
     * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when converting the circle to a polygon.
     * @memberOf Circle
     * @instance
     */

    var options$6 = {
      'numberOfShellPoints': 60
    };
    /**
     * @classdesc
     * Represents a Circle Geometry. <br>
     * @category geometry
     * @extends Polygon
     * @mixes Geometry.Center
     * @example
     * var circle = new Circle([100, 0], 1000, {
     *     id : 'circle0',
     *     properties : {
     *         foo : 'bar'
     *     }
     * });
     * @mixes CenterMixin
     */

    var Circle =
    /*#__PURE__*/
    function (_CenterMixin) {
      _inheritsLoose(Circle, _CenterMixin);

      Circle.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var circle = new Circle(json['coordinates'], json['radius'], json['options']);
        circle.setProperties(feature['properties']);
        return circle;
      }
      /**
       * @param {Coordinate} center - center of the circle
       * @param {Number} radius           - radius of the circle, in meter
       * @param {Object} [options=null]   - construct options defined in [Circle]{@link Circle#options}
       */
      ;

      function Circle(coordinates, radius, opts) {
        var _this;

        _this = _CenterMixin.call(this, null, opts) || this;

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        _this._radius = radius;
        return _this;
      }
      /**
       * Get radius of the circle
       * @return {Number}
       */


      var _proto = Circle.prototype;

      _proto.getRadius = function getRadius() {
        return this._radius;
      }
      /**
       * Set a new radius to the circle
       * @param {Number} radius - new radius
       * @return {Circle} this
       * @fires Circle#shapechange
       */
      ;

      _proto.setRadius = function setRadius(radius) {
        this._radius = radius;
        this.onShapeChanged();
        return this;
      }
      /**
       * Gets the shell of the circle as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}
       * @return {Coordinate[]} - shell coordinates
       */
      ;

      _proto.getShell = function getShell() {
        var measurer = this._getMeasurer(),
            center = this.getCoordinates(),
            numberOfPoints = this.options['numberOfShellPoints'],
            radius = this.getRadius();

        var shell = [];
        var rad, dx, dy;

        for (var i = 0, len = numberOfPoints - 1; i < len; i++) {
          rad = 360 * i / len * Math.PI / 180;
          dx = radius * Math.cos(rad);
          dy = radius * Math.sin(rad);
          var vertex = measurer.locate(center, dx, dy);
          shell.push(vertex);
        }

        shell.push(shell[0]);
        return shell;
      }
      /**
       * Circle won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      ;

      _proto.getHoles = function getHoles() {
        return [];
      };

      _proto.animateShow = function animateShow() {
        return this.show();
      };

      _proto._containsPoint = function _containsPoint(point, tolerance) {
        var map = this.getMap();

        if (map.getPitch()) {
          return _CenterMixin.prototype._containsPoint.call(this, point, tolerance);
        }

        var center = map._pointToContainerPoint(this._getCenter2DPoint()),
            size = this.getSize(),
            t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
            se = center.add(size.width / 2, size.height / 2);

        return withInEllipse(point, center, se, t);
      };

      _proto._computePrjExtent = function _computePrjExtent(projection) {
        var minmax = this._getMinMax(projection);

        if (!minmax) {
          return null;
        }

        var pcenter = this._getPrjCoordinates();

        var pminmax = minmax.map(function (c) {
          return projection.project(c);
        });
        var dx = Math.min(Math.abs(pminmax[0].x - pcenter.x), Math.abs(pminmax[1].x - pcenter.x)),
            dy = Math.min(Math.abs(pminmax[2].y - pcenter.y), Math.abs(pminmax[3].y - pcenter.y));
        return new Extent(pcenter.sub(dx, dy), pcenter.add(dx, dy));
      };

      _proto._computeExtent = function _computeExtent(measurer) {
        var minmax = this._getMinMax(measurer);

        if (!minmax) {
          return null;
        }

        return new Extent(minmax[0].x, minmax[2].y, minmax[1].x, minmax[3].y, this._getProjection());
      };

      _proto._getMinMax = function _getMinMax(measurer) {
        if (!measurer || !this._coordinates || isNil(this._radius)) {
          return null;
        }

        var radius = this._radius;
        var p1 = measurer.locate(this._coordinates, -radius, 0),
            p2 = measurer.locate(this._coordinates, radius, 0),
            p3 = measurer.locate(this._coordinates, 0, radius),
            p4 = measurer.locate(this._coordinates, 0, -radius);
        return [p1, p2, p3, p4];
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength() {
        if (isNil(this._radius)) {
          return 0;
        }

        return Math.PI * 2 * this._radius;
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        if (isNil(this._radius)) {
          return 0;
        }

        return Math.PI * Math.pow(this._radius, 2);
      };

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var coordinates = Coordinate.toNumberArrays([this.getShell()]);
        return {
          'type': 'Polygon',
          'coordinates': coordinates
        };
      };

      _proto._toJSON = function _toJSON(options) {
        var center = this.getCenter();
        var opts = extend({}, options);
        opts.geometry = false;
        var feature = this.toGeoJSON(opts);
        feature['geometry'] = {
          'type': 'Polygon'
        };
        return {
          'feature': feature,
          'subType': 'Circle',
          'coordinates': [center.x, center.y],
          'radius': this.getRadius()
        };
      };

      return Circle;
    }(CenterMixin(Polygon));

    Circle.mergeOptions(options$6);
    Circle.registerJSONType('Circle');

    /**
     * @property {Object} [options=null]
     * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when exporting the ellipse's shell coordinates as a polygon.
     * @memberOf Ellipse
     * @instance
     */

    var options$7 = {
      'numberOfShellPoints': 80
    };
    /**
     * Represents a Ellipse Geometry. <br>
     * @category geometry
     * @extends Polygon
     * @mixes CenterMixin
     * @example
     * var ellipse = new Ellipse([100, 0], 1000, 500, {
     *     id : 'ellipse0'
     * });
     */

    var Ellipse =
    /*#__PURE__*/
    function (_CenterMixin) {
      _inheritsLoose(Ellipse, _CenterMixin);

      Ellipse.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var ellipse = new Ellipse(json['coordinates'], json['width'], json['height'], json['options']);
        ellipse.setProperties(feature['properties']);
        return ellipse;
      }
      /**
       * @param {Coordinate} center  - center of the ellipse
       * @param {Number} width  - width of the ellipse, in meter
       * @param {Number} height - height of the ellipse, in meter
       * @param {Object}  [options=null] - construct options defined in [Ellipse]{@link Ellipse#options}
       */
      ;

      function Ellipse(coordinates, width, height, opts) {
        var _this;

        _this = _CenterMixin.call(this, null, opts) || this;

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        _this.width = width;
        _this.height = height;
        return _this;
      }
      /**
       * Get ellipse's width
       * @return {Number}
       */


      var _proto = Ellipse.prototype;

      _proto.getWidth = function getWidth() {
        return this.width;
      }
      /**
       * Set new width to ellipse
       * @param {Number} width - new width
       * @fires Ellipse#shapechange
       * @return {Ellipse} this
       */
      ;

      _proto.setWidth = function setWidth(width) {
        this.width = width;
        this.onShapeChanged();
        return this;
      }
      /**
       * Get ellipse's height
       * @return {Number}
       */
      ;

      _proto.getHeight = function getHeight() {
        return this.height;
      }
      /**
       * Set new height to ellipse
       * @param {Number} height - new height
       * @fires Ellipse#shapechange
       * @return {Ellipse} this
       */
      ;

      _proto.setHeight = function setHeight(height) {
        this.height = height;
        this.onShapeChanged();
        return this;
      }
      /**
       * Gets the shell of the ellipse as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Circle#options}
       * @return {Coordinate[]} - shell coordinates
       */
      ;

      _proto.getShell = function getShell() {
        var measurer = this._getMeasurer(),
            center = this.getCoordinates(),
            numberOfPoints = this.options['numberOfShellPoints'],
            width = this.getWidth(),
            height = this.getHeight();

        var shell = [];
        var s = Math.pow(width / 2, 2) * Math.pow(height / 2, 2),
            sx = Math.pow(width / 2, 2),
            sy = Math.pow(height / 2, 2);
        var deg, rad, dx, dy;

        for (var i = 0; i < numberOfPoints; i++) {
          deg = 360 * i / numberOfPoints;
          rad = deg * Math.PI / 180;
          dx = Math.sqrt(s / (sx * Math.pow(Math.tan(rad), 2) + sy));
          dy = Math.sqrt(s / (sy * Math.pow(1 / Math.tan(rad), 2) + sx));

          if (deg > 90 && deg < 270) {
            dx *= -1;
          }

          if (deg > 180 && deg < 360) {
            dy *= -1;
          }

          var vertex = measurer.locate(center, dx, dy);
          shell.push(vertex);
        }

        return shell;
      }
      /**
       * Ellipse won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      ;

      _proto.getHoles = function getHoles() {
        return [];
      };

      _proto.animateShow = function animateShow() {
        return this.show();
      };

      _proto._containsPoint = function _containsPoint(point, tolerance) {
        var map = this.getMap();

        if (map.isTransforming()) {
          return _CenterMixin.prototype._containsPoint.call(this, point, tolerance);
        }

        var projection = map.getProjection();

        var t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
            pps = projection.projectCoords([this._coordinates, map.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2)]),
            p0 = map._prjToContainerPoint(pps[0]),
            p1 = map._prjToContainerPoint(pps[1]);

        return withInEllipse(point, p0, p1, t);
      };

      _proto._computePrjExtent = function _computePrjExtent() {
        return Circle.prototype._computePrjExtent.apply(this, arguments);
      };

      _proto._computeExtent = function _computeExtent() {
        return Circle.prototype._computeExtent.apply(this, arguments);
      };

      _proto._getMinMax = function _getMinMax(measurer) {
        if (!measurer || !this._coordinates || isNil(this.width) || isNil(this.height)) {
          return null;
        }

        var width = this.getWidth(),
            height = this.getHeight();
        var p1 = measurer.locate(this._coordinates, -width / 2, 0),
            p2 = measurer.locate(this._coordinates, width / 2, 0),
            p3 = measurer.locate(this._coordinates, 0, -height / 2),
            p4 = measurer.locate(this._coordinates, 0, height / 2);
        return [p1, p2, p3, p4];
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength() {
        if (isNil(this.width) || isNil(this.height)) {
          return 0;
        } //L=2πb+4(a-b)
        //近似值


        var longer = this.width > this.height ? this.width : this.height;
        return 2 * Math.PI * longer / 2 - 4 * Math.abs(this.width - this.height);
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        if (isNil(this.width) || isNil(this.height)) {
          return 0;
        }

        return Math.PI * this.width * this.height / 4;
      };

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var coordinates = Coordinate.toNumberArrays([this.getShell()]);
        return {
          'type': 'Polygon',
          'coordinates': coordinates
        };
      };

      _proto._toJSON = function _toJSON(options) {
        var opts = extend({}, options);
        var center = this.getCenter();
        opts.geometry = false;
        var feature = this.toGeoJSON(opts);
        feature['geometry'] = {
          'type': 'Polygon'
        };
        return {
          'feature': feature,
          'subType': 'Ellipse',
          'coordinates': [center.x, center.y],
          'width': this.getWidth(),
          'height': this.getHeight()
        };
      };

      return Ellipse;
    }(CenterMixin(Polygon));

    Ellipse.mergeOptions(options$7);
    Ellipse.registerJSONType('Ellipse');

    /**
     * @classdesc
     * Represents a Rectangle geometry.
     * @category geometry
     * @extends Polygon
     * @example
     * var rectangle = new Rectangle([100, 0], 1000, 500, {
     *     id : 'rectangle0'
     * });
     */

    var Rectangle =
    /*#__PURE__*/
    function (_Polygon) {
      _inheritsLoose(Rectangle, _Polygon);

      Rectangle.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var rect = new Rectangle(json['coordinates'], json['width'], json['height'], json['options']);
        rect.setProperties(feature['properties']);
        return rect;
      }
      /**
       * @param {Coordinate} coordinates  - northwest of the rectangle
       * @param {Number} width                     - width of the rectangle, in meter
       * @param {Number} height                    - height of the rectangle, in meter
       * @param {Object} [options=null]            - options defined in [Rectangle]{@link Rectangle#options}
       */
      ;

      function Rectangle(coordinates, width, height, opts) {
        var _this;

        _this = _Polygon.call(this, null, opts) || this;

        if (coordinates) {
          _this.setCoordinates(coordinates);
        }

        _this._width = width;
        _this._height = height;
        return _this;
      }
      /**
       * Get coordinates of rectangle's northwest
       * @return {Coordinate}
       */


      var _proto = Rectangle.prototype;

      _proto.getCoordinates = function getCoordinates() {
        return this._coordinates;
      }
      /**
       * Set a new coordinate for northwest of the rectangle
       * @param {Coordinate} nw - coordinates of new northwest
       * @return {Rectangle} this
       * @fires Rectangle#positionchange
       */
      ;

      _proto.setCoordinates = function setCoordinates(nw) {
        this._coordinates = nw instanceof Coordinate ? nw : new Coordinate(nw);

        if (!this._coordinates || !this.getMap()) {
          this.onPositionChanged();
          return this;
        }

        var projection = this._getProjection();

        this._setPrjCoordinates(projection.project(this._coordinates));

        return this;
      }
      /**
       * Get rectangle's width
       * @return {Number}
       */
      ;

      _proto.getWidth = function getWidth() {
        return this._width;
      }
      /**
       * Set new width to the rectangle
       * @param {Number} width - new width
       * @fires Rectangle#shapechange
       * @return {Rectangle} this
       */
      ;

      _proto.setWidth = function setWidth(width) {
        this._width = width;
        this.onShapeChanged();
        return this;
      }
      /**
       * Get rectangle's height
       * @return {Number}
       */
      ;

      _proto.getHeight = function getHeight() {
        return this._height;
      }
      /**
       * Set new height to rectangle
       * @param {Number} height - new height
       * @fires Rectangle#shapechange
       * @return {Rectangle} this
       */
      ;

      _proto.setHeight = function setHeight(height) {
        this._height = height;
        this.onShapeChanged();
        return this;
      }
      /**
       * Gets the shell of the rectangle as a polygon
       * @return {Coordinate[]} - shell coordinates
       */
      ;

      _proto.getShell = function getShell() {
        var measurer = this._getMeasurer();

        var nw = this._coordinates;
        var map = this.getMap();
        var sx = 1,
            sy = -1;

        if (map) {
          var fExt = map.getFullExtent();

          if (fExt['left'] > fExt['right']) {
            sx = -1;
          }

          if (fExt['bottom'] > fExt['top']) {
            sy = 1;
          }
        }

        var points = [];
        points.push(nw);
        points.push(measurer.locate(nw, sx * this._width, 0));
        points.push(measurer.locate(nw, sx * this._width, sy * this._height));
        points.push(measurer.locate(nw, 0, sy * this._height));
        points.push(nw);
        return points;
      }
      /**
       * Rectangle won't have any holes, always returns null
       * @return {Object[]} an empty array
       */
      ;

      _proto.getHoles = function getHoles() {
        return [];
      };

      _proto.animateShow = function animateShow() {
        return this.show();
      };

      _proto._getPrjCoordinates = function _getPrjCoordinates() {
        var projection = this._getProjection();

        if (!projection) {
          return null;
        }

        this._verifyProjection();

        if (!this._pnw) {
          if (this._coordinates) {
            this._pnw = projection.project(this._coordinates);
          }
        }

        return this._pnw;
      };

      _proto._setPrjCoordinates = function _setPrjCoordinates(pnw) {
        this._pnw = pnw;
        this.onPositionChanged();
      };

      _proto._getPrjShell = function _getPrjShell() {
        var shell = _Polygon.prototype._getPrjShell.call(this);

        var projection = this._getProjection();

        if (!projection.isSphere()) {
          return shell;
        }

        var sphereExtent = projection.getSphereExtent(),
            sx = sphereExtent.sx,
            sy = sphereExtent.sy;

        var circum = this._getProjection().getCircum();

        var nw = shell[0];

        for (var i = 1, l = shell.length; i < l; i++) {
          var p = shell[i];
          var dx = 0,
              dy = 0;

          if (sx * (nw.x - p.x) > 0) {
            dx = circum.x * sx;
          }

          if (sy * (nw.y - p.y) < 0) {
            dy = circum.y * sy;
          }

          shell[i]._add(dx, dy);
        }

        return shell;
      } //update cached variables if geometry is updated.
      ;

      _proto._updateCache = function _updateCache() {
        this._clearCache();

        var projection = this._getProjection();

        if (this._pnw && projection) {
          this._coordinates = projection.unproject(this._pnw);
        }
      };

      _proto._clearProjection = function _clearProjection() {
        this._pnw = null;

        _Polygon.prototype._clearProjection.call(this);
      };

      _proto._computeCenter = function _computeCenter(measurer) {
        return measurer.locate(this._coordinates, this._width / 2, -this._height / 2);
      };

      _proto._containsPoint = function _containsPoint(point, tolerance) {
        var map = this.getMap();

        if (map.isTransforming()) {
          return _Polygon.prototype._containsPoint.call(this, point, tolerance);
        }

        var t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
            r = map._getResolution() * t;

        var extent = this._getPrjExtent().expand(r);

        var p = map._containerPointToPrj(point);

        return extent.contains(p);
      };

      _proto._computePrjExtent = function _computePrjExtent(projection) {
        var se = this._getSouthEast(projection);

        if (!se) {
          return null;
        }

        var prjs = projection.projectCoords([new Coordinate(this._coordinates.x, se.y), new Coordinate(se.x, this._coordinates.y)]);
        return new Extent(prjs[0], prjs[1]);
      };

      _proto._computeExtent = function _computeExtent(measurer) {
        var se = this._getSouthEast(measurer);

        if (!se) {
          return null;
        }

        return new Extent(this._coordinates, se, this._getProjection());
      };

      _proto._getSouthEast = function _getSouthEast(measurer) {
        if (!measurer || !this._coordinates || isNil(this._width) || isNil(this._height)) {
          return null;
        }

        var width = this.getWidth(),
            height = this.getHeight();
        var w = width,
            h = -height;

        if (measurer.fullExtent) {
          var fullExtent = measurer.fullExtent,
              sx = fullExtent.right > fullExtent.left ? 1 : -1,
              sy = fullExtent.top > fullExtent.bottom ? 1 : -1;
          w *= sx;
          h *= sy;
        }

        var se = measurer.locate(this._coordinates, w, h);
        return se;
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength() {
        if (isNil(this._width) || isNil(this._height)) {
          return 0;
        }

        return 2 * (this._width + this._height);
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        if (isNil(this._width) || isNil(this._height)) {
          return 0;
        }

        return this._width * this._height;
      };

      _proto._exportGeoJSONGeometry = function _exportGeoJSONGeometry() {
        var coordinates = Coordinate.toNumberArrays([this.getShell()]);
        return {
          'type': 'Polygon',
          'coordinates': coordinates
        };
      };

      _proto._toJSON = function _toJSON(options) {
        var opts = extend({}, options);
        var nw = this.getCoordinates();
        opts.geometry = false;
        var feature = this.toGeoJSON(opts);
        feature['geometry'] = {
          'type': 'Polygon'
        };
        return {
          'feature': feature,
          'subType': 'Rectangle',
          'coordinates': [nw.x, nw.y],
          'width': this.getWidth(),
          'height': this.getHeight()
        };
      };

      return Rectangle;
    }(Polygon);

    Rectangle.registerJSONType('Rectangle');

    /**
     * @property {Object} options -
     * @property {Number} [options.numberOfShellPoints=60]   - number of shell points when converting the sector to a polygon.
     * @memberOf Sector
     * @instance
     */

    var options$8 = {
      'numberOfShellPoints': 60
    };
    /**
     * @classdesc
     * Represents a sector Geometry.
     * @category geometry
     * @extends Circle
     * @example
     * var sector = new Sector([100, 0], 1000, 30, 120, {
     *     id : 'sector0'
     * });
     */

    var Sector =
    /*#__PURE__*/
    function (_Circle) {
      _inheritsLoose(Sector, _Circle);

      Sector.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var sector = new Sector(json['coordinates'], json['radius'], json['startAngle'], json['endAngle'], json['options']);
        sector.setProperties(feature['properties']);
        return sector;
      }
      /**
       * @param {Coordinate} center - center of the sector
       * @param {Number} radius           - radius of the sector, in meter
       * @param {Number} startAngle       - start angle of the sector, in degree
       * @param {Number} endAngle         - end angle of the sector, in degree
       * @param {Object} [options=null]   - construct options defined in [Sector]{@link Sector#options}
       */
      ;

      function Sector(coordinates, radius, startAngle, endAngle, opts) {
        var _this;

        _this = _Circle.call(this, coordinates, radius, opts) || this;
        _this.startAngle = startAngle;
        _this.endAngle = endAngle;
        return _this;
      }
      /**
       * Get the sector's start angle
       * @return {Number}
       */


      var _proto = Sector.prototype;

      _proto.getStartAngle = function getStartAngle() {
        return this.startAngle;
      }
      /**
       * Set a new start angle to the sector
       * @param {Number} startAngle
       * @return {Sector} this
       * @fires Sector#shapechange
       */
      ;

      _proto.setStartAngle = function setStartAngle(startAngle) {
        this.startAngle = startAngle;
        this.onShapeChanged();
        return this;
      }
      /**
       * Get the sector's end angle
       * @return {Number}
       */
      ;

      _proto.getEndAngle = function getEndAngle() {
        return this.endAngle;
      }
      /**
       * Set a new end angle to the sector
       * @param {Number} endAngle
       * @return {Sector} this
       * @fires Sector#shapechange
       */
      ;

      _proto.setEndAngle = function setEndAngle(endAngle) {
        this.endAngle = endAngle;
        this.onShapeChanged();
        return this;
      }
      /**
       * Gets the shell of the sector as a polygon, number of the shell points is decided by [options.numberOfShellPoints]{@link Sector#options}
       * @return {Coordinate[]} - shell coordinates
       */
      ;

      _proto.getShell = function getShell() {
        var measurer = this._getMeasurer(),
            center = this.getCoordinates(),
            numberOfPoints = this.options['numberOfShellPoints'] - 2,
            radius = this.getRadius(),
            shell = [center.copy()],
            startAngle = this.getStartAngle(),
            angle = this.getEndAngle() - startAngle;

        var rad, dx, dy;

        for (var i = 0; i < numberOfPoints; i++) {
          rad = (angle * i / (numberOfPoints - 1) + startAngle) * Math.PI / 180;
          dx = radius * Math.cos(rad);
          dy = radius * Math.sin(rad);
          var vertex = measurer.locate(center, dx, dy);
          shell.push(vertex);
        }

        shell.push(center.copy());
        return shell;
      };

      _proto._containsPoint = function _containsPoint(point, tolerance) {
        var map = this.getMap();

        if (map.isTransforming()) {
          return _Circle.prototype._containsPoint.call(this, point, tolerance);
        }

        var center = map._pointToContainerPoint(this._getCenter2DPoint()),
            t = isNil(tolerance) ? this._hitTestTolerance() : tolerance,
            size = this.getSize(),
            pc = center,
            pp = point,
            x = pp.x - pc.x,
            y = pc.y - pp.y,
            atan2 = Math.atan2(y, x),
            // [0.0, 360.0)
        angle = atan2 < 0 ? (atan2 + 2 * Math.PI) * 360 / (2 * Math.PI) : atan2 * 360 / (2 * Math.PI);

        var sAngle = this.startAngle % 360,
            eAngle = this.endAngle % 360;
        var between = false;

        if (sAngle > eAngle) {
          between = !(angle > eAngle && angle < sAngle);
        } else {
          between = angle >= sAngle && angle <= eAngle;
        }

        return pp.distanceTo(pc) <= size.width / 2 + t && between;
      };

      _proto._computeGeodesicLength = function _computeGeodesicLength() {
        if (isNil(this._radius)) {
          return 0;
        }

        return Math.PI * 2 * this._radius * Math.abs(this.startAngle - this.endAngle) / 360 + 2 * this._radius;
      };

      _proto._computeGeodesicArea = function _computeGeodesicArea() {
        if (isNil(this._radius)) {
          return 0;
        }

        return Math.PI * Math.pow(this._radius, 2) * Math.abs(this.startAngle - this.endAngle) / 360;
      };

      _proto._toJSON = function _toJSON(options) {
        var opts = extend({}, options);
        var center = this.getCenter();
        opts.geometry = false;
        var feature = this.toGeoJSON(opts);
        feature['geometry'] = {
          'type': 'Polygon'
        };
        return {
          'feature': feature,
          'subType': 'Sector',
          'coordinates': [center.x, center.y],
          'radius': this.getRadius(),
          'startAngle': this.getStartAngle(),
          'endAngle': this.getEndAngle()
        };
      };

      return Sector;
    }(Circle);

    Sector.mergeOptions(options$8);
    Sector.registerJSONType('Sector');

    var options$9 = {
      'enableSimplify': false,
      'enableClip': false
    };
    /**
     * Curve style LineString, an abstract parent class for all the curves.
     * @category geometry
     * @abstract
     * @extends LineString
     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the line string
     * @param {Object} [options=null] - construct options defined in [LineString]{@link LineString#options}
     * @property {Boolean} [options.enableSimplify=false] - whether to simplify path before rendering
     * @property {Boolean} [options.enableClip=false] - whether to clip curve with map's current extent
     */

    var Curve =
    /*#__PURE__*/
    function (_LineString) {
      _inheritsLoose(Curve, _LineString);

      function Curve() {
        return _LineString.apply(this, arguments) || this;
      }

      var _proto = Curve.prototype;

      _proto._arc = function _arc(ctx, points, lineOpacity) {
        var degree = this.options['arcDegree'] * Math.PI / 180;

        for (var i = 1, l = points.length; i < l; i++) {
          var c = Canvas$1._arcBetween(ctx, points[i - 1], points[i], degree); //add control points to caculate normal of arrow


          var ctrlPoint = [points[i - 1].x + points[i].x - c[0], points[i - 1].y + points[i].y - c[1]];
          points[i - 1].nextCtrlPoint = ctrlPoint;
          points[i].prevCtrlPoint = ctrlPoint;

          Canvas$1._stroke(ctx, lineOpacity);
        }
      };

      _proto._quadraticCurve = function _quadraticCurve(ctx, points) {
        if (points.length <= 2) {
          Canvas$1._path(ctx, points);

          return;
        }

        var i, l;

        for (i = 2, l = points.length; i < l; i += 2) {
          ctx.quadraticCurveTo(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
        }

        i -= 1;

        if (i < l) {
          for (; i < l; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
        }
      };

      _proto._bezierCurve = function _bezierCurve(ctx, points) {
        if (points.length <= 3) {
          Canvas$1._path(ctx, points);

          return;
        }

        var i, l;

        for (i = 1, l = points.length; i + 2 < l; i += 3) {
          ctx.bezierCurveTo(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y);
        }

        if (i < l) {
          for (; i < l; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }
        }
      };

      _proto._getCurveArrowPoints = function _getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, step) {
        var l = segments.length;
        var i;

        for (i = step; i < l; i += step) {
          var arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);

          if (arrow) {
            arrows.push(arrow);
          }
        }

        i -= step;

        if (i < l - 1) {
          for (i += 1; i < l; i++) {
            var _arrow = this._getArrowShape(segments[i - 1], segments[i], lineWidth, arrowStyle, tolerance);

            if (_arrow) {
              arrows.push(_arrow);
            }
          }
        }
      };

      return Curve;
    }(LineString);

    Curve.mergeOptions(options$9);

    /**
     * @property {Object} options
     * @property {Number} [options.arcDegree=90]           - circle arc's degree.
     * @memberOf ArcCurve
     * @instance
     */

    var options$a = {
      'arcDegree': 90
    };
    /**
     * @classdesc
     * Circle Arc Curve
     * @category geometry
     * @extends Curve
     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
     * @param {Object} [options=null]   - construct options defined in [ArcCurve]{@link ArcCurve#options}
     * @example
     * var curve = new ArcCurve(
     *     [
     *         [121.47083767181408,31.214448123476995],
     *         [121.4751292062378,31.215475523000404],
     *         [121.47869117980943,31.211916269810335]
     *     ],
     *     {
     *         arcDegree : 120,
     *         symbol : {
     *             'lineWidth' : 5
     *         }
     *     }
     * ).addTo(layer);
     */

    var ArcCurve =
    /*#__PURE__*/
    function (_Curve) {
      _inheritsLoose(ArcCurve, _Curve);

      function ArcCurve() {
        return _Curve.apply(this, arguments) || this;
      }

      var _proto = ArcCurve.prototype;

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options),
          'subType': 'ArcCurve'
        };
      } // paint method on canvas
      ;

      _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
        ctx.beginPath();

        this._arc(ctx, points, lineOpacity);

        Canvas$1._stroke(ctx, lineOpacity);

        this._paintArrow(ctx, points, lineOpacity);
      };

      ArcCurve.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var arc = new ArcCurve(feature['geometry']['coordinates'], json['options']);
        arc.setProperties(feature['properties']);
        return arc;
      };

      return ArcCurve;
    }(Curve);

    ArcCurve.registerJSONType('ArcCurve');
    ArcCurve.mergeOptions(options$a);

    /**
     * Cubic Bezier Curve
     * @category geometry
     * @extends Curve
     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
     * @param {Object} [options=null]   - construct options defined in [CubicBezierCurve]{@link CubicBezierCurve#options}
     * @example
     * var curve = new CubicBezierCurve(
     *     [
     *         [121.47083767181408,31.214448123476995],
     *         [121.4751292062378,31.215475523000404],
     *         [121.47869117980943,31.211916269810335]
     *     ],
     *     {
     *         symbol : {
     *             'lineWidth' : 5
     *         }
     *     }
     * ).addTo(layer);
     */

    var CubicBezierCurve =
    /*#__PURE__*/
    function (_Curve) {
      _inheritsLoose(CubicBezierCurve, _Curve);

      function CubicBezierCurve() {
        return _Curve.apply(this, arguments) || this;
      }

      CubicBezierCurve.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var curve = new CubicBezierCurve(feature['geometry']['coordinates'], json['options']);
        curve.setProperties(feature['properties']);
        return curve;
      };

      var _proto = CubicBezierCurve.prototype;

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options),
          'subType': 'CubicBezierCurve'
        };
      } // paint method on canvas
      ;

      _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        this._bezierCurve(ctx, points);

        Canvas$1._stroke(ctx, lineOpacity);

        this._paintArrow(ctx, points, lineOpacity);
      };

      _proto._getArrowPoints = function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
        return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 3);
      };

      return CubicBezierCurve;
    }(Curve);

    CubicBezierCurve.registerJSONType('CubicBezierCurve');

    /**
     * @classdesc
     * Quadratic Bezier Curve
     * @category geometry
     * @extends Curve
     * @param {Coordinate[]|Number[][]} coordinates - coordinates of the curve
     * @example
     * var curve = new QuadBezierCurve(
     *     [
     *         [121.47083767181408,31.214448123476995],
     *         [121.4751292062378,31.215475523000404],
     *         [121.47869117980943,31.211916269810335]
     *     ],
     *     {
     *         symbol : {
     *             'lineWidth' : 5
     *         }
     *     }
     * ).addTo(layer);
     */

    var QuadBezierCurve =
    /*#__PURE__*/
    function (_Curve) {
      _inheritsLoose(QuadBezierCurve, _Curve);

      function QuadBezierCurve() {
        return _Curve.apply(this, arguments) || this;
      }

      QuadBezierCurve.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var curve = new QuadBezierCurve(feature['geometry']['coordinates'], json['options']);
        curve.setProperties(feature['properties']);
        return curve;
      };

      var _proto = QuadBezierCurve.prototype;

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options),
          'subType': 'QuadBezierCurve'
        };
      } // paint method on canvas
      ;

      _proto._paintOn = function _paintOn(ctx, points, lineOpacity) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        this._quadraticCurve(ctx, points, lineOpacity);

        Canvas$1._stroke(ctx, lineOpacity);

        this._paintArrow(ctx, points, lineOpacity);
      };

      _proto._getArrowPoints = function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
        return this._getCurveArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance, 2);
      };

      return QuadBezierCurve;
    }(Curve);

    QuadBezierCurve.registerJSONType('QuadBezierCurve');

    var defaultSymbol$1 = {
      'textFaceName': 'monospace',
      'textSize': 12,
      'textLineSpacing': 8,
      'textWrapCharacter': '\n',
      'textHorizontalAlignment': 'middle',
      //left middle right
      'textVerticalAlignment': 'middle' //top middle bottom

    };
    var defaultBoxSymbol = {
      'markerType': 'square',
      'markerLineColor': '#000',
      'markerLineWidth': 2,
      'markerLineOpacity': 1,
      'markerFill': '#fff',
      'markerOpacity': 1
    };
    /**
     * @classdesc
     * Base class for  the Text marker classes, a marker which has text and background box. <br>
     * It is abstract and not intended to be instantiated.
     * @category geometry
     * @abstract
     * @extends Marker
     */

    var TextMarker =
    /*#__PURE__*/
    function (_Marker) {
      _inheritsLoose(TextMarker, _Marker);

      function TextMarker() {
        return _Marker.apply(this, arguments) || this;
      }

      var _proto = TextMarker.prototype;

      /**
       * Get text content of the label
       * @returns {String}
       */
      _proto.getContent = function getContent() {
        return this._content;
      }
      /**
       * Set a new text content to the label
       * @return {Label} this
       * @fires Label#contentchange
       */
      ;

      _proto.setContent = function setContent(content) {
        var old = this._content;
        this._content = escapeSpecialChars(content);

        this._refresh();
        /**
         * an event when changing label's text content
         * @event Label#contentchange
         * @type {Object}
         * @property {String} type - contentchange
         * @property {Label} target - label fires the event
         * @property {String} old - old content
         * @property {String} new - new content
         */


        this._fireEvent('contentchange', {
          'old': old,
          'new': content
        });

        return this;
      };

      _proto.onAdd = function onAdd() {
        this._refresh();
      };

      _proto.toJSON = function toJSON() {
        var json = _Marker.prototype.toJSON.call(this);

        delete json['symbol'];
        return json;
      };

      _proto.setSymbol = function setSymbol(symbol) {
        if (this._refreshing || !symbol) {
          return _Marker.prototype.setSymbol.call(this, symbol);
        }

        var s = this._parseSymbol(symbol);

        if (this.setTextStyle) {
          var style = this.getTextStyle() || {};
          style.symbol = s[0];
          this.setTextStyle(style);
        } else if (this.setTextSymbol) {
          this.setTextSymbol(s[0]);
        }

        if (this.setBoxStyle) {
          var _style = this.getBoxStyle() || {};

          _style.symbol = s[1];
          this.setBoxStyle(_style);
        } else if (this.setBoxSymbol) {
          this.setBoxSymbol(s[1]);
        }

        return this;
      };

      _proto._parseSymbol = function _parseSymbol(symbol) {
        var t = {};
        var b = {};

        for (var p in symbol) {
          if (hasOwn(symbol, p)) {
            if (p.indexOf('text') === 0) {
              t[p] = symbol[p];
            } else {
              b[p] = symbol[p];
            }
          }
        }

        return [t, b];
      };

      _proto._getTextSize = function _getTextSize(symbol) {
        return splitTextToRow(this._content, symbol)['size'];
      };

      _proto._getInternalSymbol = function _getInternalSymbol() {
        return this._symbol;
      };

      _proto._getDefaultTextSymbol = function _getDefaultTextSymbol() {
        return extend({}, defaultSymbol$1);
      };

      _proto._getDefaultBoxSymbol = function _getDefaultBoxSymbol() {
        return extend({}, defaultBoxSymbol);
      };

      _proto._getDefaultPadding = function _getDefaultPadding() {
        return [12, 8];
      };

      return TextMarker;
    }(Marker);

    /**
     * @property {Object} [options=null]                   - textbox's options, also including options of [Marker]{@link Marker#options}
     * @property {Boolean} [options.textStyle]             - the default text style of text
     * @property {Boolean} [options.textStyle.wrap=true]             - whether to autowrap text in the textbox
     * @property {Boolean} [options.textStyle.padding=[12, 8]]       - text padding in the box
     * @property {Boolean} [options.textStyle.verticalAlignment=middle]  - text's vertical alignment
     * @property {Boolean} [options.textStyle.horizontalAlignment=true]  - text's horizontal alignment
     * @property {Boolean} [options.boxSymbol=null]        - box symbol of textbox
     * @memberOf TextBox
     * @instance
     */

    var options$b = {
      'textStyle': {
        'wrap': true,
        'padding': [12, 8],
        'verticalAlignment': 'middle',
        'horizontalAlignment': 'middle'
      },
      'boxSymbol': null
    };
    /**
     * @classdesc
     * Represents point type geometry for text boxes.<br>
     * A TextBox is used to draw a box with text inside on a particular coordinate.
     * @category geometry
     * @extends TextMarker
     * @mixes TextEditable
     * @example
     * var textbox = new maptalks.TextBox('This is a textbox',
        [0, 0], 200, 90,
        {
          'draggable' : true,
          'textStyle' : {
            'wrap' : true,
            'padding' : [12, 8],
            'verticalAlignment' : 'top',
            'horizontalAlignment' : 'right',
            'symbol' : {
              'textFaceName' : 'monospace',
              'textFill' : '#34495e',
              'textHaloFill' : '#fff',
              'textHaloRadius' : 4,
              'textSize' : 18,
              'textWeight' : 'bold'
            }
          },
          'boxSymbol': {
            // box's symbol
            'markerType' : 'square',
            'markerFill' : 'rgb(135,196,240)',
            'markerFillOpacity' : 0.9,
            'markerLineColor' : '#34495e',
            'markerLineWidth' : 1
          }
        });
     */

    var TextBox =
    /*#__PURE__*/
    function (_TextMarker) {
      _inheritsLoose(TextBox, _TextMarker);

      /**
       * @param {String} content                 - TextBox's text content
       * @param {Coordinate} coordinates         - coordinates
       * @param {Number} width                   - width in pixel
       * @param {Number} height                  - height in pixel
       * @param {Object} [options=null]          - construct options defined in [TextBox]{@link TextBox#options}
       */
      function TextBox(content, coordinates, width, height, options) {
        var _this;

        if (options === void 0) {
          options = {};
        }

        _this = _TextMarker.call(this, coordinates, options) || this;
        _this._content = escapeSpecialChars(content);
        _this._width = isNil(width) ? 100 : width;
        _this._height = isNil(height) ? 40 : height;

        if (options.boxSymbol) {
          _this.setBoxSymbol(options.boxSymbol);
        }

        if (options.textStyle) {
          _this.setTextStyle(options.textStyle);
        }

        _this._refresh();

        return _this;
      }
      /**
       * Get textbox's width
       * @return {Number}
       */


      var _proto = TextBox.prototype;

      _proto.getWidth = function getWidth() {
        return this._width;
      }
      /**
       * Set new width to textbox
       * @param {Number} width
       * returns {TextBox} this
       */
      ;

      _proto.setWidth = function setWidth(width) {
        this._width = width;

        this._refresh();

        return this;
      }
      /**
       * Get textbox's height
       * @return {Number}
       */
      ;

      _proto.getHeight = function getHeight() {
        return this._height;
      }
      /**
       * Set new height to textbox
       * @param {Number} height
       * returns {TextBox} this
       */
      ;

      _proto.setHeight = function setHeight(height) {
        this._height = height;

        this._refresh();

        return this;
      }
      /**
       * Get textbox's boxSymbol
       * @return {Object} boxsymbol
       */
      ;

      _proto.getBoxSymbol = function getBoxSymbol() {
        return extend({}, this.options.boxSymbol);
      }
      /**
       * Set a new box symbol to textbox
       * @param {Object} symbol
       * returns {TextBox} this
       */
      ;

      _proto.setBoxSymbol = function setBoxSymbol(symbol) {
        this.options.boxSymbol = symbol ? extend({}, symbol) : symbol;

        if (this.getSymbol()) {
          this._refresh();
        }

        return this;
      }
      /**
       * Get textbox's text style
       * @return {Object}
       */
      ;

      _proto.getTextStyle = function getTextStyle() {
        if (!this.options.textStyle) {
          return null;
        }

        return extend({}, this.options.textStyle);
      }
      /**
       * Set a new text style to the textbox
       * @param {Object} style new text style
       * returns {TextBox} this
       */
      ;

      _proto.setTextStyle = function setTextStyle(style) {
        this.options.textStyle = style ? extend({}, style) : style;

        if (this.getSymbol()) {
          this._refresh();
        }

        return this;
      };

      TextBox.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var textBox = new TextBox(json['content'], feature['geometry']['coordinates'], json['width'], json['height'], json['options']);
        textBox.setProperties(feature['properties']);
        textBox.setId(feature['id']);

        if (json['symbol']) {
          textBox.setSymbol(json['symbol']);
        }

        return textBox;
      };

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options),
          'width': this.getWidth(),
          'height': this.getHeight(),
          'subType': 'TextBox',
          'content': this._content
        };
      };

      _proto._refresh = function _refresh() {
        var textStyle = this.getTextStyle() || {},
            padding = textStyle['padding'] || [12, 8],
            maxWidth = this._width - 2 * padding[0],
            maxHeight = this._height - 2 * padding[1];
        var symbol = extend({}, textStyle.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
          'textName': this._content,
          'markerWidth': this._width,
          'markerHeight': this._height,
          'textHorizontalAlignment': 'middle',
          'textVerticalAlignment': 'middle',
          'textMaxWidth': maxWidth,
          'textMaxHeight': maxHeight
        });

        if (textStyle['wrap'] && !symbol['textWrapWidth']) {
          symbol['textWrapWidth'] = maxWidth;
        }

        var hAlign = textStyle['horizontalAlignment'];
        symbol['textDx'] = symbol['markerDx'] || 0;
        var offsetX = symbol['markerWidth'] / 2 - padding[0];

        if (hAlign === 'left') {
          symbol['textHorizontalAlignment'] = 'right';
          symbol['textDx'] = symbol['textDx'] - offsetX;
        } else if (hAlign === 'right') {
          symbol['textHorizontalAlignment'] = 'left';
          symbol['textDx'] = symbol['textDx'] + offsetX;
        }

        var vAlign = textStyle['verticalAlignment'];
        symbol['textDy'] = symbol['markerDy'] || 0;
        var offsetY = symbol['markerHeight'] / 2 - padding[1];

        if (vAlign === 'top') {
          symbol['textVerticalAlignment'] = 'bottom';
          symbol['textDy'] -= offsetY;
        } else if (vAlign === 'bottom') {
          symbol['textVerticalAlignment'] = 'top';
          symbol['textDy'] += offsetY;
        }

        this._refreshing = true;
        this.updateSymbol(symbol);
        delete this._refreshing;
      };

      return TextBox;
    }(TextMarker);

    TextBox.mergeOptions(options$b);
    TextBox.registerJSONType('TextBox');

    /**
     * @property {Object} [options=null]                   - textbox's options, also including options of [Marker]{@link Marker#options}
     * @property {Boolean} [options.boxStyle=null]             - the default box style of text
     * @property {Boolean} [options.boxStyle.padding=[12, 8]]           - text padding in the box
     * @property {Boolean} [options.boxStyle.verticalAlignment=middle]  - text's vertical alignment
     * @property {Boolean} [options.boxStyle.horizontalAlignment=true]  - text's horizontal alignment
     * @property {Number} [options.boxStyle.minWidth=0]                 - label box's minWidth
     * @property {Number} [options.boxStyle.minHeight=0]                - label box's minHeight
     * @property {Boolean} [options.textSymbol=null]        - text symbol of label
     * @memberOf Label
     * @instance
     */

    var options$c = {
      'boxStyle': null,

      /*{
      'padding' : [12, 8],
      'verticalAlignment' : 'middle',
      'horizontalAlignment' : 'middle',
      'minWidth' : 0,
      'minHeight' : 0,
      'symbol' : null
      }*/
      textSymbol: null
    };
    /**
     * @classdesc
     * Represents point type geometry for text labels.<br>
     * A label is used to draw text (with a box background if specified) on a particular coordinate.
     * @category geometry
     * @extends TextMarker
     * @mixes TextEditable
     * @example
     * var label = new maptalks.Label('label with a box',
        [0, 0],
        {
          'draggable' : true,
          'boxStyle' : {
            'padding' : [12, 8],
            'verticalAlignment' : 'top',
            'horizontalAlignment' : 'right',
            'minWidth' : 300,
            'minHeight' : 200,
            'symbol' : {
              'markerType' : 'square',
              'markerFill' : 'rgb(135,196,240)',
              'markerFillOpacity' : 0.9,
              'markerLineColor' : '#34495e',
              'markerLineWidth' : 1
            }
          },
          'textSymbol': {
            'textFaceName' : 'monospace',
            'textFill' : '#34495e',
            'textHaloFill' : '#fff',
            'textHaloRadius' : 4,
            'textSize' : 18,
            'textWeight' : 'bold',
            'textVerticalAlignment' : 'top'
          }
        });
     */

    var Label =
    /*#__PURE__*/
    function (_TextMarker) {
      _inheritsLoose(Label, _TextMarker);

      /**
       * @param {String} content                 - Label's text content
       * @param {Coordinate} coordinates         - coordinates
       * @param {Object} [options=null]          - construct options defined in [Label]{@link Label#options}
       */
      function Label(content, coordinates, options) {
        var _this;

        if (options === void 0) {
          options = {};
        }

        _this = _TextMarker.call(this, coordinates, options) || this;

        if (options.textSymbol) {
          _this.setTextSymbol(options.textSymbol);
        }

        if (options.boxStyle) {
          _this.setBoxStyle(options.boxStyle);
        }

        _this._content = escapeSpecialChars(content);

        _this._refresh();

        return _this;
      }
      /**
       * Get label's box style
       * @return {Object}
       */


      var _proto = Label.prototype;

      _proto.getBoxStyle = function getBoxStyle() {
        if (!this.options.boxStyle) {
          return null;
        }

        return extend({}, this.options.boxStyle);
      }
      /**
       * Set a new box style to the label
       * @param {Object}
       * @returns {Label} this
       */
      ;

      _proto.setBoxStyle = function setBoxStyle(style) {
        this.options.boxStyle = style ? extend({}, style) : style;

        this._refresh();

        return this;
      }
      /**
       * Get label's text symbol
       * @return {Object}
       */
      ;

      _proto.getTextSymbol = function getTextSymbol() {
        return extend({}, this._getDefaultTextSymbol(), this.options.textSymbol);
      }
      /**
       * Set a new text symbol to the label
       * @param {Object} symbol
       * @returns {Label} this
       */
      ;

      _proto.setTextSymbol = function setTextSymbol(symbol) {
        this.options.textSymbol = symbol ? extend({}, symbol) : symbol;

        this._refresh();

        return this;
      };

      Label.fromJSON = function fromJSON(json) {
        var feature = json['feature'];
        var label = new Label(json['content'], feature['geometry']['coordinates'], json['options']);
        label.setProperties(feature['properties']);
        label.setId(feature['id']);

        if (json['symbol']) {
          label.setSymbol(json['symbol']);
        }

        return label;
      };

      _proto._canEdit = function _canEdit() {
        return false;
      };

      _proto._toJSON = function _toJSON(options) {
        return {
          'feature': this.toGeoJSON(options),
          'subType': 'Label',
          'content': this._content
        };
      };

      _proto._refresh = function _refresh() {
        var symbol = extend({}, this.getTextSymbol(), {
          'textName': this._content
        });
        var boxStyle = this.getBoxStyle();

        if (boxStyle) {
          extend(symbol, boxStyle.symbol);

          var sizes = this._getBoxSize(symbol),
              textSize = sizes[1],
              padding = boxStyle['padding'] || this._getDefaultPadding();

          var boxSize = sizes[0]; //if no boxSize then use text's size in default

          symbol['markerWidth'] = boxSize['width'];
          symbol['markerHeight'] = boxSize['height'];

          var dx = symbol['textDx'] || 0,
              dy = symbol['textDy'] || 0,
              textAlignPoint = getAlignPoint(textSize, symbol['textHorizontalAlignment'], symbol['textVerticalAlignment'])._add(dx, dy);

          var hAlign = boxStyle['horizontalAlignment'] || 'middle';
          symbol['markerDx'] = textAlignPoint.x;

          if (hAlign === 'left') {
            symbol['markerDx'] += symbol['markerWidth'] / 2 - padding[0];
          } else if (hAlign === 'right') {
            symbol['markerDx'] -= symbol['markerWidth'] / 2 - textSize['width'] - padding[0];
          } else {
            symbol['markerDx'] += textSize['width'] / 2;
          }

          var vAlign = boxStyle['verticalAlignment'] || 'middle';
          symbol['markerDy'] = textAlignPoint.y;

          if (vAlign === 'top') {
            symbol['markerDy'] += symbol['markerHeight'] / 2 - padding[1];
          } else if (vAlign === 'bottom') {
            symbol['markerDy'] -= symbol['markerHeight'] / 2 - textSize['height'] - padding[1];
          } else {
            symbol['markerDy'] += textSize['height'] / 2;
          }
        }

        this._refreshing = true;
        this.updateSymbol(symbol);
        delete this._refreshing;
      };

      _proto._getBoxSize = function _getBoxSize(symbol) {
        if (!symbol['markerType']) {
          symbol['markerType'] = 'square';
        }

        var boxStyle = this.getBoxStyle();

        var size = this._getTextSize(symbol);

        var width, height;

        var padding = boxStyle['padding'] || this._getDefaultPadding();

        width = size['width'] + padding[0] * 2;
        height = size['height'] + padding[1] * 2;

        if (boxStyle['minWidth']) {
          if (!width || width < boxStyle['minWidth']) {
            width = boxStyle['minWidth'];
          }
        }

        if (boxStyle['minHeight']) {
          if (!height || height < boxStyle['minHeight']) {
            height = boxStyle['minHeight'];
          }
        }

        return [new Size(width, height), size];
      };

      return Label;
    }(TextMarker);

    Label.mergeOptions(options$c);
    Label.registerJSONType('Label');

    /**
     * Mixin of connector line methods.
     * @mixin Connectable
     * @private
     */

    var Connectable = function Connectable(Base) {
      return (
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(_class, _Base);

          function _class() {
            return _Base.apply(this, arguments) || this;
          }

          _class._hasConnectors = function _hasConnectors(geometry) {
            return !isNil(geometry.__connectors) && geometry.__connectors.length > 0;
          };

          _class._getConnectors = function _getConnectors(geometry) {
            return geometry.__connectors;
          }
          /**
           * Gets the source of the connector line.
           * @return {Geometry|control.Control|UIComponent}
           * @function Connectable.getConnectSource
           */
          ;

          var _proto = _class.prototype;

          _proto.getConnectSource = function getConnectSource() {
            return this._connSource;
          }
          /**
           * Sets the source to the connector line.
           * @param {Geometry|control.Control|UIComponent} src
           * @return {ConnectorLine} this
           * @function Connectable.setConnectSource
           */
          ;

          _proto.setConnectSource = function setConnectSource(src) {
            var target = this._connTarget;
            this.onRemove();
            this._connSource = src;
            this._connTarget = target;
            this.onAdd();
            return this;
          }
          /**
           * Gets the target of the connector line.
           * @return {Geometry|control.Control|UIComponent}
           * @function Connectable.getConnectTarget
           */
          ;

          _proto.getConnectTarget = function getConnectTarget() {
            return this._connTarget;
          }
          /**
           * Sets the target to the connector line.
           * @param {Geometry|control.Control|UIComponent} target
           * @return {ConnectorLine} this
           * @function Connectable.setConnectTarget
           */
          ;

          _proto.setConnectTarget = function setConnectTarget(target) {
            var src = this._connSource;
            this.onRemove();
            this._connSource = src;
            this._connTarget = target;

            this._updateCoordinates();

            this._registerEvents();

            return this;
          };

          _proto._updateCoordinates = function _updateCoordinates() {
            var map = this.getMap();

            if (!map && this._connSource) {
              map = this._connSource.getMap();
            }

            if (!map && this._connTarget) {
              map = this._connTarget.getMap();
            }

            if (!map) {
              return;
            }

            if (!this._connSource || !this._connTarget) {
              return;
            }

            var srcPoints = this._connSource._getConnectPoints();

            var targetPoints = this._connTarget._getConnectPoints();

            var minDist = 0;
            var oldCoordinates = this.getCoordinates();
            var c1, c2;

            for (var i = 0, len = srcPoints.length; i < len; i++) {
              var p1 = srcPoints[i];

              for (var j = 0, length = targetPoints.length; j < length; j++) {
                var p2 = targetPoints[j];
                var dist = map.computeLength(p1, p2);

                if (i === 0 && j === 0) {
                  c1 = p1;
                  c2 = p2;
                  minDist = dist;
                } else if (dist < minDist) {
                  c1 = p1;
                  c2 = p2;
                }
              }
            }

            if (!isArrayHasData(oldCoordinates) || !oldCoordinates[0].equals(c1) || !oldCoordinates[1].equals(c2)) {
              this.setCoordinates([c1, c2]);
            }
          };

          _proto.onAdd = function onAdd() {
            this._registerEvents();

            this._updateCoordinates();
          };

          _proto.onRemove = function onRemove() {
            if (this._connSource) {
              if (this._connSource.__connectors) {
                removeFromArray(this, this._connSource.__connectors);
              }

              this._connSource.off('dragging positionchange', this._updateCoordinates, this).off('remove', this.onRemove, this);

              this._connSource.off('dragstart mousedown mouseover', this._showConnect, this);

              this._connSource.off('dragend mouseup mouseout', this.hide, this);

              this._connSource.off('show', this._showConnect, this).off('hide', this.hide, this);

              delete this._connSource;
            }

            if (this._connTarget) {
              removeFromArray(this, this._connTarget.__connectors);

              this._connTarget.off('dragging positionchange', this._updateCoordinates, this).off('remove', this.onRemove, this);

              this._connTarget.off('show', this._showConnect, this).off('hide', this.hide, this);

              delete this._connTarget;
            } //not a geometry


            if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
              var map = this.getMap();

              if (map) {
                map.off('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
              }
            }
          };

          _proto._showConnect = function _showConnect() {
            if (!this._connSource || !this._connTarget) {
              return;
            }

            if (this._connSource.isVisible() && this._connTarget.isVisible()) {
              this._updateCoordinates();

              this.show();
            }
          };

          _proto._registerEvents = function _registerEvents() {
            if (!this._connSource || !this._connTarget) {
              return;
            }

            if (!this._connSource.__connectors) {
              this._connSource.__connectors = [];
            }

            if (!this._connTarget.__connectors) {
              this._connTarget.__connectors = [];
            }

            this._connSource.__connectors.push(this);

            this._connTarget.__connectors.push(this);

            this._connSource.on('dragging positionchange', this._updateCoordinates, this).on('remove', this.remove, this);

            this._connTarget.on('dragging positionchange', this._updateCoordinates, this).on('remove', this.remove, this);

            this._connSource.on('show', this._showConnect, this).on('hide', this.hide, this);

            this._connTarget.on('show', this._showConnect, this).on('hide', this.hide, this);

            var trigger = this.options['showOn'];
            this.hide();

            if (trigger === 'moving') {
              this._connSource.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);

              this._connTarget.on('dragstart', this._showConnect, this).on('dragend', this.hide, this);
            } else if (trigger === 'click') {
              this._connSource.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);

              this._connTarget.on('mousedown', this._showConnect, this).on('mouseup', this.hide, this);
            } else if (trigger === 'mouseover') {
              this._connSource.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);

              this._connTarget.on('mouseover', this._showConnect, this).on('mouseout', this.hide, this);
            } else {
              this._showConnect();
            } //not a geometry


            if (!(this._connSource instanceof Geometry) || !(this._connTarget instanceof Geometry)) {
              var map = this.getMap();

              if (map) {
                map.on('movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange', this._updateCoordinates, this);
              }
            }
          };

          return _class;
        }(Base)
      );
    };
    /**
     * @property {Object} options - ConnectorLine's options
     * @property {String} [options.showOn=always]  - when to show the connector line, possible values: 'moving', 'click', 'mouseover', 'always'
     * @memberOf ConnectorLine
     * @instance
     */

    /**
     * @property {Object} options - ConnectorLine's options
     * @property {String} [options.showOn=always]  - when to show the connector line, possible values: 'moving', 'click', 'mouseover', 'always'
     * @memberOf ArcConnectorLine
     * @instance
     */


    var options$d = {
      showOn: 'always'
    };
    /**
     * A straight connector line geometry can connect geometries or ui components with each other. <br>
     *
     * @category geometry
     * @extends LineString
     * @example
     * var src = new Marker([0,0]).addTo(layer),
     *     dst = new Marker([1,0]).addTo(layer),
     *     line = new ConnectorLine(src, dst, {
     *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'
     *         arrowStyle : 'classic',
     *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point
     *         symbol: {
     *           lineColor: '#34495e',
     *           lineWidth: 2
     *        }
     *     }).addTo(layer);
     * @mixes connectorLineMixin
     */

    var ConnectorLine =
    /*#__PURE__*/
    function (_Connectable) {
      _inheritsLoose(ConnectorLine, _Connectable);

      /**
       * @param {Geometry|control.Control|UIComponent} src     - source to connect
       * @param {Geometry|control.Control|UIComponent} target  - target to connect
       * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}
       */
      function ConnectorLine(src, target, options) {
        var _this;

        _this = _Connectable.call(this, null, options) || this;

        if (arguments.length === 1) {
          options = src;
          src = null;
          target = null;
        }

        _this._connSource = src;
        _this._connTarget = target;
        return _this;
      }

      return ConnectorLine;
    }(Connectable(LineString));

    ConnectorLine.mergeOptions(options$d);
    ConnectorLine.registerJSONType('ConnectorLine');
    /**
     * An arc curve connector line geometry can connect geometries or ui components with each other. <br>
     *
     * @category geometry
     * @extends ArcCurve
     * @example
     * var src = new Marker([0,0]).addTo(layer),
     *     dst = new Marker([1,0]).addTo(layer),
     *     line = new ArcConnectorLine(src, dst, {
     *         arcDegree : 120,
     *         showOn : 'always', //'moving', 'click', 'mouseover', 'always'
     *         arrowStyle : 'classic',
     *         arrowPlacement : 'vertex-last', //vertex-first, vertex-last, vertex-firstlast, point
     *         symbol: {
     *           lineColor: '#34495e',
     *           lineWidth: 2
     *        }
     *     }).addTo(layer);
     * @mixes connectorLineMixin
     */

    var ArcConnectorLine =
    /*#__PURE__*/
    function (_Connectable2) {
      _inheritsLoose(ArcConnectorLine, _Connectable2);

      /**
       * @param {Geometry|control.Control|UIComponent} src     - source to connect
       * @param {Geometry|control.Control|UIComponent} target  - target to connect
       * @param {Object} [options=null]  - construct options defined in [ConnectorLine]{@link ConnectorLine#options}
       */
      function ArcConnectorLine(src, target, options) {
        var _this2;

        _this2 = _Connectable2.call(this, null, options) || this;

        if (arguments.length === 1) {
          options = src;
          src = null;
          target = null;
        }

        _this2._connSource = src;
        _this2._connTarget = target;
        return _this2;
      }

      return ArcConnectorLine;
    }(Connectable(ArcCurve));

    ArcConnectorLine.mergeOptions(options$d);
    ArcConnectorLine.registerJSONType('ArcConnectorLine');

    /**
     * @property {Boolean}  [options.drawImmediate=false] - (Only for layer rendered with [CanvasRenderer]{@link renderer.CanvasRenderer}) <br>
     *                                                    In default, for performance reason, layer will be drawn in a frame requested by RAF(RequestAnimationFrame).<br>
     *                                                    Set drawImmediate to true to draw immediately.<br>
     *                                                    This is necessary when layer's drawing is wrapped with another frame requested by RAF.
     * @memberOf OverlayLayer
     * @instance
     */

    var options$e = {
      'drawImmediate': false
    };
    var TEMP_EXTENT$3 = new PointExtent();
    /**
     * @classdesc
     * Base class of all the layers that can add/remove geometries. <br>
     * It is abstract and not intended to be instantiated.
     * @category layer
     * @abstract
     * @extends Layer
     */

    var OverlayLayer =
    /*#__PURE__*/
    function (_Layer) {
      _inheritsLoose(OverlayLayer, _Layer);

      function OverlayLayer(id, geometries, options) {
        var _this;

        if (geometries && !(geometries instanceof Geometry) && !Array.isArray(geometries) && GEOJSON_TYPES.indexOf(geometries.type) < 0) {
          options = geometries;
          geometries = null;
        }

        _this = _Layer.call(this, id, options) || this;
        _this._maxZIndex = 0;
        _this._minZIndex = 0;

        _this._initCache();

        if (geometries) {
          _this.addGeometry(geometries);
        }

        return _this;
      }
      /**
       * Get a geometry by its id
       * @param  {String|Number} id   - id of the geometry
       * @return {Geometry}
       */


      var _proto = OverlayLayer.prototype;

      _proto.getGeometryById = function getGeometryById(id) {
        if (isNil(id) || id === '') {
          return null;
        }

        if (!this._geoMap[id]) {
          return null;
        }

        return this._geoMap[id];
      }
      /**
       * Get all the geometries or the ones filtered if a filter function is provided.
       * @param {Function} [filter=undefined]  - a function to filter the geometries
       * @param {Object} [context=undefined]   - context of the filter function, value to use as this when executing filter.
       * @return {Geometry[]}
       */
      ;

      _proto.getGeometries = function getGeometries(filter, context) {
        if (!filter) {
          return this._geoList.slice(0);
        }

        var result = [];
        var geometry, filtered;

        for (var i = 0, l = this._geoList.length; i < l; i++) {
          geometry = this._geoList[i];

          if (context) {
            filtered = filter.call(context, geometry);
          } else {
            filtered = filter(geometry);
          }

          if (filtered) {
            result.push(geometry);
          }
        }

        return result;
      }
      /**
       * Get the first geometry, the geometry at the bottom.
       * @return {Geometry} first geometry
       */
      ;

      _proto.getFirstGeometry = function getFirstGeometry() {
        if (!this._geoList.length) {
          return null;
        }

        return this._geoList[0];
      }
      /**
       * Get the last geometry, the geometry on the top
       * @return {Geometry} last geometry
       */
      ;

      _proto.getLastGeometry = function getLastGeometry() {
        var len = this._geoList.length;

        if (len === 0) {
          return null;
        }

        return this._geoList[len - 1];
      }
      /**
       * Get count of the geometries
       * @return {Number} count
       */
      ;

      _proto.getCount = function getCount() {
        return this._geoList.length;
      }
      /**
       * Get extent of all the geometries in the layer, return null if the layer is empty.
       * @return {Extent} - extent of the layer
       */
      ;

      _proto.getExtent = function getExtent() {
        if (this.getCount() === 0) {
          return null;
        }

        var extent = new Extent(this.getProjection());
        this.forEach(function (g) {
          extent._combine(g.getExtent());
        });
        return extent;
      }
      /**
       * Executes the provided callback once for each geometry present in the layer in order.
       * @param  {Function} fn - a callback function
       * @param  {*} [context=undefined]   - callback's context, value to use as this when executing callback.
       * @return {OverlayLayer} this
       */
      ;

      _proto.forEach = function forEach(fn, context) {
        var copyOnWrite = this._geoList.slice(0);

        for (var i = 0, l = copyOnWrite.length; i < l; i++) {
          if (!context) {
            fn(copyOnWrite[i], i);
          } else {
            fn.call(context, copyOnWrite[i], i);
          }
        }

        return this;
      }
      /**
       * Creates a GeometryCollection with all the geometries that pass the test implemented by the provided function.
       * @param  {Function} fn      - Function to test each geometry
       * @param  {*} [context=undefined]  - Function's context, value to use as this when executing function.
       * @return {GeometryCollection} A GeometryCollection with all the geometries that pass the test
       */
      ;

      _proto.filter = function filter(fn, context) {
        var selected = [];
        var isFn = isFunction(fn);
        var filter = isFn ? fn : createFilter(fn);
        this.forEach(function (geometry) {
          var g = isFn ? geometry : getFilterFeature(geometry);

          if (context ? filter.call(context, g) : filter(g)) {
            selected.push(geometry);
          }
        }, this);
        return selected;
      }
      /**
       * Whether the layer is empty.
       * @return {Boolean}
       */
      ;

      _proto.isEmpty = function isEmpty$$1() {
        return !this._geoList.length;
      }
      /**
       * Adds one or more geometries to the layer
       * @param {Geometry|Geometry[]} geometries - one or more geometries
       * @param {Boolean|Object} [fitView=false]  - automatically set the map to a fit center and zoom for the geometries
       * @param {String} [fitView.easing=out]  - default animation type
       * @param {Number} [fitView.duration=map.options.zoomAnimationDuration]  - default animation time
       * @param {Function} [fitView.step=null]  - step function during animation, animation frame as the parameter
       * @return {OverlayLayer} this
       */
      ;

      _proto.addGeometry = function addGeometry(geometries, fitView) {
        if (!geometries) {
          return this;
        }

        if (geometries.type === 'FeatureCollection') {
          return this.addGeometry(GeoJSON.toGeometry(geometries), fitView);
        } else if (!Array.isArray(geometries)) {
          var count = arguments.length;
          var last = arguments[count - 1];
          geometries = Array.prototype.slice.call(arguments, 0, count - 1);
          fitView = last;

          if (last && isObject(last) && ('type' in last || last instanceof Geometry)) {
            geometries.push(last);
            fitView = false;
          }

          return this.addGeometry(geometries, fitView);
        } else if (geometries.length === 0) {
          return this;
        }

        this._initCache();

        var extent;

        if (fitView) {
          extent = new Extent();
        }

        this._toSort = this._maxZIndex > 0;
        var geos = [];

        for (var i = 0, l = geometries.length; i < l; i++) {
          var geo = geometries[i];

          if (!geo) {
            throw new Error('Invalid geometry to add to layer(' + this.getId() + ') at index:' + i);
          }

          if (!(geo instanceof Geometry)) {
            geo = Geometry.fromJSON(geo);

            if (Array.isArray(geo)) {
              for (var ii = 0, ll = geo.length; ii < ll; ii++) {
                this._add(geo[ii], extent, i);

                geos.push(geo[ii]);
              }
            }
          }

          if (!Array.isArray(geo)) {
            this._add(geo, extent, i);

            geos.push(geo);
          }
        }

        var map = this.getMap();

        if (map) {
          this._getRenderer().onGeometryAdd(geos);

          if (extent && !isNil(extent.xmin)) {
            var center = extent.getCenter();
            var z = map.getFitZoom(extent);

            if (isObject(fitView)) {
              var step = isFunction(fitView.step) ? fitView.step : function () {
                return undefined;
              };
              map.animateTo({
                center: center,
                zoom: z
              }, extend({
                duration: map.options.zoomAnimationDuration,
                easing: 'out'
              }, fitView), step);
            } else if (fitView === true) {
              map.setCenterAndZoom(center, z);
            }
          }
        }
        /**
         * addgeo event.
         *
         * @event OverlayLayer#addgeo
         * @type {Object}
         * @property {String} type - addgeo
         * @property {OverlayLayer} target - layer
         * @property {Geometry[]} geometries - the geometries to add
         */


        this.fire('addgeo', {
          'geometries': geometries
        });
        return this;
      }
      /**
       * Get minimum zindex of geometries
       */
      ;

      _proto.getGeoMinZIndex = function getGeoMinZIndex() {
        return this._minZIndex;
      }
      /**
       * Get maximum zindex of geometries
       */
      ;

      _proto.getGeoMaxZIndex = function getGeoMaxZIndex() {
        return this._maxZIndex;
      };

      _proto._add = function _add(geo, extent, i) {
        if (!this._toSort) {
          this._toSort = geo.getZIndex() !== 0;
        }

        this._updateZIndex(geo.getZIndex());

        var geoId = geo.getId();

        if (!isNil(geoId)) {
          if (!isNil(this._geoMap[geoId])) {
            throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + geoId + ', at index:' + i);
          }

          this._geoMap[geoId] = geo;
        }

        var internalId = UID();

        geo._setInternalId(internalId);

        this._geoList.push(geo);

        if (this.onAddGeometry) {
          this.onAddGeometry(geo);
        }

        geo._bindLayer(this);

        if (geo.onAdd) {
          geo.onAdd();
        }

        if (extent) {
          extent._combine(geo.getExtent());
        }
        /**
         * add event.
         *
         * @event Geometry#add
         * @type {Object}
         * @property {String} type - add
         * @property {Geometry} target - geometry
         * @property {Layer} layer - the layer added to.
         */


        geo._fireEvent('add', {
          'layer': this
        });
      }
      /**
       * Removes one or more geometries from the layer
       * @param  {String|String[]|Geometry|Geometry[]} geometries - geometry ids or geometries to remove
       * @returns {OverlayLayer} this
       */
      ;

      _proto.removeGeometry = function removeGeometry(geometries) {
        if (!Array.isArray(geometries)) {
          return this.removeGeometry([geometries]);
        }

        for (var i = geometries.length - 1; i >= 0; i--) {
          if (!(geometries[i] instanceof Geometry)) {
            geometries[i] = this.getGeometryById(geometries[i]);
          }

          if (!geometries[i] || this !== geometries[i].getLayer()) continue;
          geometries[i].remove();
        }
        /**
         * removegeo event.
         *
         * @event OverlayLayer#removegeo
         * @type {Object}
         * @property {String} type - removegeo
         * @property {OverlayLayer} target - layer
         * @property {Geometry[]} geometries - the geometries to remove
         */


        this.fire('removegeo', {
          'geometries': geometries
        });
        return this;
      }
      /**
       * Clear all geometries in this layer
       * @returns {OverlayLayer} this
       */
      ;

      _proto.clear = function clear() {
        this._clearing = true;
        this.forEach(function (geo) {
          geo.remove();
        });
        this._geoMap = {};
        var old = this._geoList;
        this._geoList = [];

        if (this._getRenderer()) {
          this._getRenderer().onGeometryRemove(old);
        }

        this._clearing = false;
        /**
         * clear event.
         *
         * @event OverlayLayer#clear
         * @type {Object}
         * @property {String} type - clear
         * @property {OverlayLayer} target - layer
         */

        this.fire('clear');
        return this;
      }
      /**
       * Called when geometry is being removed to clear the context concerned.
       * @param  {Geometry} geometry - the geometry instance to remove
       * @protected
       */
      ;

      _proto.onRemoveGeometry = function onRemoveGeometry(geometry) {
        if (!geometry || this._clearing) {
          return;
        } //考察geometry是否属于该图层


        if (this !== geometry.getLayer()) {
          return;
        }

        var internalId = geometry._getInternalId();

        if (isNil(internalId)) {
          return;
        }

        var geoId = geometry.getId();

        if (!isNil(geoId)) {
          delete this._geoMap[geoId];
        }

        var idx = this._findInList(geometry);

        if (idx >= 0) {
          this._geoList.splice(idx, 1);
        }

        if (this._getRenderer()) {
          this._getRenderer().onGeometryRemove([geometry]);
        }
      };

      _proto.hide = function hide() {
        for (var i = 0, l = this._geoList.length; i < l; i++) {
          this._geoList[i].onHide();
        }

        return Layer.prototype.hide.call(this);
      }
      /**
       * Identify the geometries on the given coordinate
       * @param  {maptalks.Coordinate} coordinate   - coordinate to identify
       * @param  {Object} [options=null]  - options
       * @param  {Object} [options.tolerance=0] - identify tolerance in pixel
       * @param  {Object} [options.count=null]  - result count
       * @return {Geometry[]} geometries identified
       */
      ;

      _proto.identify = function identify(coordinate, options) {
        if (options === void 0) {
          options = {};
        }

        return this._hitGeos(this._geoList, coordinate, options);
      };

      _proto._hitGeos = function _hitGeos(geometries, coordinate, options) {
        if (options === void 0) {
          options = {};
        }

        var filter = options['filter'],
            tolerance = options['tolerance'],
            hits = [];
        var map = this.getMap();
        var point = map.coordToPoint(coordinate);

        var cp = map._pointToContainerPoint(point, undefined, 0, point);

        for (var i = geometries.length - 1; i >= 0; i--) {
          var geo = geometries[i];

          if (!geo || !geo.isVisible() || !geo._getPainter() || !geo.options['interactive']) {
            continue;
          }

          if (!(geo instanceof LineString) || !geo._getArrowStyle() && !(geo instanceof Curve)) {
            // Except for LineString with arrows or curves
            var extent = geo.getContainerExtent(TEMP_EXTENT$3);

            if (tolerance) {
              extent = extent._expand(tolerance);
            }

            if (!extent || !extent.contains(cp)) {
              continue;
            }
          }

          if (geo._containsPoint(cp, tolerance) && (!filter || filter(geo))) {
            hits.push(geo);

            if (options['count']) {
              if (hits.length >= options['count']) {
                break;
              }
            }
          }
        }

        return hits;
      };

      _proto._initCache = function _initCache() {
        if (!this._geoList) {
          this._geoList = [];
          this._geoMap = {};
        }
      };

      _proto._updateZIndex = function _updateZIndex() {
        for (var _len = arguments.length, zIndex = new Array(_len), _key = 0; _key < _len; _key++) {
          zIndex[_key] = arguments[_key];
        }

        this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, zIndex));
        this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, zIndex));
      };

      _proto._sortGeometries = function _sortGeometries() {
        var _this2 = this;

        if (!this._toSort) {
          return;
        }

        this._maxZIndex = 0;
        this._minZIndex = 0;

        this._geoList.sort(function (a, b) {
          _this2._updateZIndex(a.getZIndex(), b.getZIndex());

          return _this2._compare(a, b);
        });

        this._toSort = false;
      };

      _proto._compare = function _compare(a, b) {
        if (a.getZIndex() === b.getZIndex()) {
          return a._getInternalId() - b._getInternalId();
        }

        return a.getZIndex() - b.getZIndex();
      } //binarySearch
      ;

      _proto._findInList = function _findInList(geo) {
        var len = this._geoList.length;

        if (len === 0) {
          return -1;
        }

        var low = 0,
            high = len - 1,
            middle;

        while (low <= high) {
          middle = Math.floor((low + high) / 2);

          if (this._geoList[middle] === geo) {
            return middle;
          } else if (this._compare(this._geoList[middle], geo) > 0) {
            high = middle - 1;
          } else {
            low = middle + 1;
          }
        }

        return -1;
      };

      _proto._onGeometryEvent = function _onGeometryEvent(param) {
        if (!param || !param['target']) {
          return;
        }

        var type = param['type'];

        if (type === 'idchange') {
          this._onGeometryIdChange(param);
        } else if (type === 'zindexchange') {
          this._onGeometryZIndexChange(param);
        } else if (type === 'positionchange') {
          this._onGeometryPositionChange(param);
        } else if (type === 'shapechange') {
          this._onGeometryShapeChange(param);
        } else if (type === 'symbolchange') {
          this._onGeometrySymbolChange(param);
        } else if (type === 'show') {
          this._onGeometryShow(param);
        } else if (type === 'hide') {
          this._onGeometryHide(param);
        } else if (type === 'propertieschange') {
          this._onGeometryPropertiesChange(param);
        }
      };

      _proto._onGeometryIdChange = function _onGeometryIdChange(param) {
        if (param['new'] === param['old']) {
          if (this._geoMap[param['old']] && this._geoMap[param['old']] === param['target']) {
            return;
          }
        }

        if (!isNil(param['new'])) {
          if (this._geoMap[param['new']]) {
            throw new Error('Duplicate geometry id in layer(' + this.getId() + '):' + param['new']);
          }

          this._geoMap[param['new']] = param['target'];
        }

        if (!isNil(param['old']) && param['new'] !== param['old']) {
          delete this._geoMap[param['old']];
        }
      };

      _proto._onGeometryZIndexChange = function _onGeometryZIndexChange(param) {
        if (param['old'] !== param['new']) {
          this._updateZIndex(param['new']);

          this._toSort = true;

          if (this._getRenderer()) {
            this._getRenderer().onGeometryZIndexChange(param);
          }
        }
      };

      _proto._onGeometryPositionChange = function _onGeometryPositionChange(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometryPositionChange(param);
        }
      };

      _proto._onGeometryShapeChange = function _onGeometryShapeChange(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometryShapeChange(param);
        }
      };

      _proto._onGeometrySymbolChange = function _onGeometrySymbolChange(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometrySymbolChange(param);
        }
      };

      _proto._onGeometryShow = function _onGeometryShow(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometryShow(param);
        }
      };

      _proto._onGeometryHide = function _onGeometryHide(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometryHide(param);
        }
      };

      _proto._onGeometryPropertiesChange = function _onGeometryPropertiesChange(param) {
        if (this._getRenderer()) {
          this._getRenderer().onGeometryPropertiesChange(param);
        }
      };

      return OverlayLayer;
    }(Layer);

    OverlayLayer.mergeOptions(options$e);

    /**
     * @property {Object}  options - VectorLayer's options
     * @property {Boolean} options.debug=false           - whether the geometries on the layer is in debug mode.
     * @property {Boolean} options.enableSimplify=true   - whether to simplify geometries before rendering.
     * @property {String}  options.cursor=default        - the cursor style of the layer
     * @property {Boolean} options.geometryEvents=true   - enable/disable firing geometry events, disable it to improve performance.
     * @property {Boolean} options.defaultIconSize=[20,20] - default size of a marker's icon
     * @property {Boolean} [options.enableAltitude=false]  - whether to enable render geometry with altitude, false by default
     * @property {Boolean} [options.altitudeProperty=altitude] - geometry's altitude property name, if enableAltitude is true, "altitude" by default
     * @property {Boolean} [options.drawAltitude=false]  - whether to draw altitude: a vertical line for marker, a vertical polygon for line
     * @property {Boolean} [options.debug=false]         - whether the geometries on the layer is in debug mode.
     * @memberOf VectorLayer
     * @instance
     */

    var options$f = {
      'debug': false,
      'enableSimplify': true,
      'geometryEvents': true,
      'defaultIconSize': [20, 20],
      'cacheVectorOnCanvas': true,
      'cacheSvgOnCanvas': Browser$1.gecko,
      'enableAltitude': false,
      'altitudeProperty': 'altitude',
      'drawAltitude': false
    };
    /**
     * @classdesc
     * A layer for managing and rendering geometries.
     * @category layer
     * @extends OverlayLayer
     */

    var VectorLayer =
    /*#__PURE__*/
    function (_OverlayLayer) {
      _inheritsLoose(VectorLayer, _OverlayLayer);

      /**
       * @param {String|Number} id - layer's id
       * @param {Geometry|Geometry[]} [geometries=null] - geometries to add
       * @param {Object}  [options=null]          - construct options
       * @param {Object}  [options.style=null]    - vectorlayer's style
       * @param {*}  [options.*=null]             - options defined in [VectorLayer]{@link VectorLayer#options}
       */
      function VectorLayer(id, geometries, options) {
        var _this;

        _this = _OverlayLayer.call(this, id, geometries, options) || this;
        var style = _this.options['style'];
        delete _this.options['style'];

        if (style) {
          _this.setStyle(style);
        }

        return _this;
      }
      /**
       * Gets layer's style.
       * @return {Object|Object[]} layer's style
       */


      var _proto = VectorLayer.prototype;

      _proto.getStyle = function getStyle() {
        if (!this._style) {
          return null;
        }

        return this._style;
      }
      /**
       * Sets style to the layer, styling the geometries satisfying the condition with style's symbol. <br>
       * Based on filter type in [mapbox-gl-js's style specification]{https://www.mapbox.com/mapbox-gl-js/style-spec/#types-filter}.
       * @param {Object|Object[]} style - layer's style
       * @returns {VectorLayer} this
       * @fires VectorLayer#setstyle
       * @example
       * layer.setStyle([
          {
            'filter': ['==', 'count', 100],
            'symbol': {'markerFile' : 'foo1.png'}
          },
          {
            'filter': ['==', 'count', 200],
            'symbol': {'markerFile' : 'foo2.png'}
          }
        ]);
       */
      ;

      _proto.setStyle = function setStyle(style) {
        this._style = style;
        this._cookedStyles = compileStyle(style);
        this.forEach(function (geometry) {
          this._styleGeometry(geometry);
        }, this);
        /**
         * setstyle event.
         *
         * @event VectorLayer#setstyle
         * @type {Object}
         * @property {String} type - setstyle
         * @property {VectorLayer} target - layer
         * @property {Object|Object[]}       style - style to set
         */

        this.fire('setstyle', {
          'style': style
        });
        return this;
      }
      /**
       * Removes layers' style
       * @returns {VectorLayer} this
       * @fires VectorLayer#removestyle
       */
      ;

      _proto.removeStyle = function removeStyle() {
        if (!this._style) {
          return this;
        }

        delete this._style;
        delete this._cookedStyles;
        this.forEach(function (geometry) {
          geometry._setExternSymbol(null);
        }, this);
        /**
         * removestyle event.
         *
         * @event VectorLayer#removestyle
         * @type {Object}
         * @property {String} type - removestyle
         * @property {VectorLayer} target - layer
         */

        this.fire('removestyle');
        return this;
      };

      _proto.onAddGeometry = function onAddGeometry(geo) {
        var style = this.getStyle();

        if (style) {
          this._styleGeometry(geo);
        }
      };

      _proto.onConfig = function onConfig(conf) {
        _OverlayLayer.prototype.onConfig.call(this, conf);

        if (conf['enableAltitude'] || conf['drawAltitude'] || conf['altitudeProperty']) {
          var renderer = this.getRenderer();

          if (renderer && renderer.setToRedraw) {
            renderer.setToRedraw();
          }
        }
      };

      _proto._styleGeometry = function _styleGeometry(geometry) {
        if (!this._cookedStyles) {
          return false;
        }

        var g = getFilterFeature(geometry);

        for (var i = 0, len = this._cookedStyles.length; i < len; i++) {
          if (this._cookedStyles[i]['filter'](g) === true) {
            geometry._setExternSymbol(this._cookedStyles[i]['symbol']);

            return true;
          }
        }

        return false;
      };

      _proto.identify = function identify(coordinate, options) {
        if (options === void 0) {
          options = {};
        }

        var renderer = this.getRenderer(); // only iterate drawn geometries when onlyVisible is true.

        if (options['onlyVisible'] && renderer && renderer.identify) {
          return renderer.identify(coordinate, options);
        }

        return _OverlayLayer.prototype.identify.call(this, coordinate, options);
      }
      /**
       * Export the VectorLayer's JSON. <br>
       * @param  {Object} [options=null] - export options
       * @param  {Object} [options.geometries=null] - If not null and the layer is a [OverlayerLayer]{@link OverlayLayer},
       *                                            the layer's geometries will be exported with the given "options.geometries" as a parameter of geometry's toJSON.
       * @param  {Extent} [options.clipExtent=null] - if set, only the geometries intersectes with the extent will be exported.
       * @return {Object} layer's JSON
       */
      ;

      _proto.toJSON = function toJSON(options) {
        if (!options) {
          options = {};
        }

        var profile = {
          'type': this.getJSONType(),
          'id': this.getId(),
          'options': this.config()
        };

        if ((isNil(options['style']) || options['style']) && this.getStyle()) {
          profile['style'] = this.getStyle();
        }

        if (isNil(options['geometries']) || options['geometries']) {
          var clipExtent;

          if (options['clipExtent']) {
            var map = this.getMap();
            var projection = map ? map.getProjection() : null;
            clipExtent = new Extent(options['clipExtent'], projection);
          }

          var geoJSONs = [];
          var geometries = this.getGeometries();

          for (var i = 0, len = geometries.length; i < len; i++) {
            var geo = geometries[i];
            var geoExt = geo.getExtent();

            if (!geoExt || clipExtent && !clipExtent.intersects(geoExt)) {
              continue;
            }

            var json = geo.toJSON(options['geometries']);
            geoJSONs.push(json);
          }

          profile['geometries'] = geoJSONs;
        }

        return profile;
      }
      /**
       * Reproduce a VectorLayer from layer's JSON.
       * @param  {Object} layerJSON - layer's JSON
       * @return {VectorLayer}
       * @static
       * @private
       * @function
       */
      ;

      VectorLayer.fromJSON = function fromJSON(json) {
        if (!json || json['type'] !== 'VectorLayer') {
          return null;
        }

        var layer = new VectorLayer(json['id'], json['options']);
        var geoJSONs = json['geometries'];
        var geometries = [];

        for (var i = 0; i < geoJSONs.length; i++) {
          var geo = Geometry.fromJSON(geoJSONs[i]);

          if (geo) {
            geometries.push(geo);
          }
        }

        layer.addGeometry(geometries);

        if (json['style']) {
          layer.setStyle(json['style']);
        }

        return layer;
      };

      return VectorLayer;
    }(OverlayLayer);

    VectorLayer.mergeOptions(options$f);
    VectorLayer.registerJSONType('VectorLayer');

    var key = '_map_tool';
    /**
     * @classdesc
     * <pre>
     * The parent class for all the map tools.
     * It is abstract and not intended to be instantiated.
     * Some interface methods to implement:
     * 1. onAdd: optional, a callback method to do some prepares before enabled when the map tool is added to a map
     * 2. onEnable: optional, called when the map tool is enabled, used to setup the context such as adding more event listeners other than the map, disabling map's default handlers (draggable, scrollWheelZoom, etc) and creating temporary layers.
     * 3. getEvents: required, provide an event map to register event listeners on the map.
     * 4. onDisable: optional, called when the map tool is disabled, used to cleanup such as unregistering event listeners, enable map's original handlers and remove temporary layers.
     * </pre>
     * @abstract
     * @category maptool
     * @extends Class
     * @mixes Eventable
     */

    var MapTool =
    /*#__PURE__*/
    function (_Eventable) {
      _inheritsLoose(MapTool, _Eventable);

      function MapTool() {
        return _Eventable.apply(this, arguments) || this;
      }

      var _proto = MapTool.prototype;

      /**
       * Adds the map tool to a map.
       * @param {Map} map
       * @return {MapTool} this
       * @fires MapTool#add
       */
      _proto.addTo = function addTo(map) {
        if (!map) {
          return this;
        }

        this._map = map; // map tool is unique on one map

        if (map[key]) {
          map[key].disable();
        }

        if (this.onAdd) {
          this.onAdd();
        }

        this.enable();
        map[key] = this;
        /**
         * add event.
         *
         * @event MapTool#add
         * @type {Object}
         * @property {String} type - add
         * @property {MapTool} target - map tool
         */

        this._fireEvent('add');

        return this;
      }
      /**
       * Gets the map it added to.
       * @return {Map} map
       */
      ;

      _proto.getMap = function getMap() {
        return this._map;
      }
      /**
       * Enable the map tool.
       * @return {MapTool} this
       * @fires MapTool#enable
       */
      ;

      _proto.enable = function enable() {
        var map = this._map;

        if (!map || this._enabled) {
          return this;
        }

        this._enabled = true;

        this._switchEvents('off');

        this._registerEvents();

        if (this.onEnable) {
          this.onEnable();
        }
        /**
         * enable event.
         *
         * @event MapTool#enable
         * @type {Object}
         * @property {String} type - enable
         * @property {MapTool} target - map tool
         */


        this._fireEvent('enable');

        return this;
      }
      /**
       * Disable the map tool
       * @return {MapTool} this
       * @fires MapTool#disable
       */
      ;

      _proto.disable = function disable() {
        if (!this._enabled || !this._map) {
          return this;
        }

        this._enabled = false;

        this._switchEvents('off');

        if (this.onDisable) {
          this.onDisable();
        }
        /**
         * disable event.
         *
         * @event MapTool#disable
         * @type {Object}
         * @property {String} type - disable
         * @property {MapTool} target - map tool
         */


        this._fireEvent('disable');

        return this;
      }
      /**
       * Returns whether the tool is enabled
       * @return {Boolean} true | false
       */
      ;

      _proto.isEnabled = function isEnabled() {
        if (!this._enabled) {
          return false;
        }

        return true;
      };

      _proto.remove = function remove() {
        if (!this._map) {
          return this;
        }

        this.disable();

        if (this._map) {
          delete this._map[key];
          delete this._map;
        }
        /**
         * remove event.
         *
         * @event MapTool#remove
         * @type {Object}
         * @property {String} type - remove
         * @property {MapTool} target - map tool
         */


        this._fireEvent('remove');

        return this;
      };

      _proto._registerEvents = function _registerEvents() {
        this._switchEvents('on');
      };

      _proto._switchEvents = function _switchEvents(to) {
        var events = this.getEvents();

        if (events) {
          this._map[to](events, this);
        }
      };

      _proto._fireEvent = function _fireEvent(eventName, param) {
        if (!param) {
          param = {};
        }

        this.fire(eventName, param);
      };

      return MapTool;
    }(Eventable(Class));

    /**
     * @property {Object} [options=null] - construct options
     * @property {String} [options.mode=null]   - mode of the draw tool
     * @property {Object} [options.symbol=null] - symbol of the geometries drawn
     * @property {Boolean} [options.once=null]  - whether disable immediately once drawn a geometry.
     * @property {Boolean} [options.autoPanAtEdge=false]  - Whether to make edge judgement or not.
     * @memberOf DrawTool
     * @instance
     */

    var options$g = {
      'symbol': {
        'lineColor': '#000',
        'lineWidth': 2,
        'lineOpacity': 1,
        'polygonFill': '#fff',
        'polygonOpacity': 0.3
      },
      'doubleClickZoom': false,
      'mode': null,
      'once': false,
      'autoPanAtEdge': false,
      'ignoreMouseleave': true
    };
    var registeredMode = {};
    /**
     * A map tool to help draw geometries.
     * @category maptool
     * @extends MapTool
     * @example
     * var drawTool = new DrawTool({
     *     mode : 'Polygon',
     *     symbol : {
     *         'lineColor' : '#000',
     *         'lineWidth' : 5
     *     },
     *     once : true
     * }).addTo(map);
     */

    var DrawTool =
    /*#__PURE__*/
    function (_MapTool) {
      _inheritsLoose(DrawTool, _MapTool);

      /**
       * Register a new mode for DrawTool
       * @param  {String} name       mode name
       * @param  {Object} modeAction modeActions
       * @param  {Object} modeAction.action the action of DrawTool: click, mousedown, clickDblclick
       * @param  {Object} modeAction.create the create method of drawn geometry
       * @param  {Object} modeAction.update the update method of drawn geometry
       * @param  {Object} modeAction.generate the method to generate geometry at the end of drawing.
       * @example
       * //Register "CubicBezierCurve" mode to draw Cubic Bezier Curves.
       * DrawTool.registerMode('CubicBezierCurve', {
          'action': 'clickDblclick',
          'create': path => new CubicBezierCurve(path),
          'update': (path, geometry) => {
              geometry.setCoordinates(path);
          },
          'generate': geometry => geometry
         }
       });
       */
      DrawTool.registerMode = function registerMode(name, modeAction) {
        registeredMode[name.toLowerCase()] = modeAction;
      }
      /**
       * Get mode actions by mode name
       * @param  {String} name DrawTool mode name
       * @return {Object}      mode actions
       */
      ;

      DrawTool.getRegisterMode = function getRegisterMode(name) {
        return registeredMode[name.toLowerCase()];
      }
      /**
       * In default, DrawTool supports the following modes: <br>
       * [Point, LineString, Polygon, Circle, Ellipse, Rectangle, ArcCurve, QuadBezierCurve, CubicBezierCurve] <br>
       * You can easily add new mode to DrawTool by calling [registerMode]{@link DrawTool.registerMode}
       * @param {Object} [options=null] - construct options
       * @param {String} [options.mode=null]   - mode of the draw tool
       * @param {Object} [options.symbol=null] - symbol of the geometries drawn
       * @param {Boolean} [options.once=null]  - whether disable immediately once drawn a geometry.
       * @param {Boolean} [options.autoPanAtEdge=false]  - Whether to make edge judgement or not.
       */
      ;

      function DrawTool(options) {
        var _this;

        _this = _MapTool.call(this, options) || this;

        _this._checkMode();
        /**
         * events
         * @type {{click: DrawTool._firstClickHandler, mousemove: DrawTool._mouseMoveHandler, dblclick: DrawTool._doubleClickHandler, mousedown: DrawTool._mouseDownHandler, mouseup: DrawTool._mouseUpHandler}}
         * @private
         */


        _this._events = {
          'click': _this._firstClickHandler,
          'mousemove': _this._mouseMoveHandler,
          'dblclick': _this._doubleClickHandler,
          'mousedown': _this._mouseDownHandler,
          'mouseup': _this._mouseUpHandler
        };
        return _this;
      }
      /**
       * Get current mode of draw tool
       * @return {String} mode
       */


      var _proto = DrawTool.prototype;

      _proto.getMode = function getMode() {
        if (this.options['mode']) {
          return this.options['mode'].toLowerCase();
        }

        return null;
      }
      /**
       * Set mode of the draw tool
       * @param {String} mode - mode of the draw tool
       * @expose
       */
      ;

      _proto.setMode = function setMode(mode) {
        if (this._geometry) {
          this._geometry.remove();

          delete this._geometry;
        }

        this._clearStage();

        this._switchEvents('off');

        this.options['mode'] = mode;

        this._checkMode();

        if (this.isEnabled()) {
          this._switchEvents('on');

          this._restoreMapCfg();

          this._saveMapCfg();
        }

        return this;
      }
      /**
       * Get symbol of the draw tool
       * @return {Object} symbol
       */
      ;

      _proto.getSymbol = function getSymbol() {
        var symbol = this.options['symbol'];

        if (symbol) {
          return extendSymbol(symbol);
        } else {
          return extendSymbol(this.options['symbol']);
        }
      }
      /**
       * Set draw tool's symbol
       * @param {Object} symbol - symbol set
       * @returns {DrawTool} this
       */
      ;

      _proto.setSymbol = function setSymbol(symbol) {
        if (!symbol) {
          return this;
        }

        this.options['symbol'] = symbol;

        if (this._geometry) {
          this._geometry.setSymbol(symbol);
        }

        return this;
      }
      /**
       * Get geometry is currently drawing
       * @return {Geometry} geometry currently drawing
       */
      ;

      _proto.getCurrentGeometry = function getCurrentGeometry() {
        return this._geometry;
      };

      _proto.onAdd = function onAdd() {
        this._checkMode();
      };

      _proto.onEnable = function onEnable() {
        this._saveMapCfg();

        this._drawToolLayer = this._getDrawLayer();

        this._clearStage();

        this._loadResources();

        if (this.options['autoPanAtEdge']) {
          var map = this.getMap();
          this._mapAutoPanAtEdge = map.options['autoPanAtEdge'];

          if (!this._mapAutoPanAtEdge) {
            map.config({
              autoPanAtEdge: true
            });
          }
        }

        return this;
      };

      _proto.onDisable = function onDisable() {
        var map = this.getMap();

        this._restoreMapCfg();

        this.endDraw();

        if (this._map) {
          map.removeLayer(this._getDrawLayer());

          if (this.options['autoPanAtEdge']) {
            if (!this._mapAutoPanAtEdge) {
              map.config({
                autoPanAtEdge: false
              });
            }
          }
        }

        return this;
      }
      /**
       * Undo drawing, only applicable for click/dblclick mode
       * @return {DrawTool} this
       */
      ;

      _proto.undo = function undo() {
        var registerMode = this._getRegisterMode();

        var action = registerMode.action;

        if (!this._shouldRecordHistory(action) || !this._historyPointer) {
          return this;
        }

        var coords = this._clickCoords.slice(0, --this._historyPointer);

        registerMode.update(coords, this._geometry);
        return this;
      }
      /**
       * Redo drawing, only applicable for click/dblclick mode
       * @return {DrawTool} this
       */
      ;

      _proto.redo = function redo() {
        var registerMode = this._getRegisterMode();

        var action = registerMode.action;

        if (!this._shouldRecordHistory(action) || isNil(this._historyPointer) || this._historyPointer === this._clickCoords.length) {
          return this;
        }

        var coords = this._clickCoords.slice(0, ++this._historyPointer);

        registerMode.update(coords, this._geometry);
        return this;
      }
      /**
       * check should recor history
       * @param actions
       * @returns {boolean}
       * @private
       */
      ;

      _proto._shouldRecordHistory = function _shouldRecordHistory(actions) {
        return Array.isArray(actions) && actions[0] === 'click' && actions[1] === 'mousemove' && actions[2] === 'dblclick';
      };

      _proto._checkMode = function _checkMode() {
        this._getRegisterMode();
      };

      _proto._saveMapCfg = function _saveMapCfg() {
        var map = this.getMap();
        this._mapDoubleClickZoom = map.options['doubleClickZoom'];
        map.config({
          'doubleClickZoom': this.options['doubleClickZoom']
        });

        var actions = this._getRegisterMode()['action'];

        if (actions.indexOf('mousedown') > -1) {
          var _map = this.getMap();

          this._mapDraggable = _map.options['draggable'];

          _map.config({
            'draggable': false
          });
        }
      };

      _proto._restoreMapCfg = function _restoreMapCfg() {
        var map = this.getMap();
        map.config({
          'doubleClickZoom': this._mapDoubleClickZoom
        });

        if (!isNil(this._mapDraggable)) {
          map.config('draggable', this._mapDraggable);
        }

        delete this._mapDraggable;
        delete this._mapDoubleClickZoom;
      };

      _proto._loadResources = function _loadResources() {
        var symbol = this.getSymbol();
        var resources = getExternalResources(symbol);

        if (resources.length > 0) {
          //load external resources at first
          this._drawToolLayer._getRenderer().loadResources(resources);
        }
      };

      _proto._getProjection = function _getProjection() {
        return this._map.getProjection();
      };

      _proto._getRegisterMode = function _getRegisterMode() {
        var mode = this.getMode();
        var registerMode = DrawTool.getRegisterMode(mode);

        if (!registerMode) {
          throw new Error(mode + ' is not a valid mode of DrawTool.');
        }

        return registerMode;
      };

      _proto.getEvents = function getEvents() {
        var action = this._getRegisterMode()['action'];

        var _events = {};

        if (Array.isArray(action)) {
          for (var i = 0; i < action.length; i++) {
            _events[action[i]] = this._events[action[i]];
          }

          return _events;
        }

        return null;
      }
      /**
       * mouse down start draw
       * @param event
       * @private
       */
      ;

      _proto._mouseDownHandler = function _mouseDownHandler(event) {
        this._createGeometry(event);
      }
      /**
       * handle mouse up event
       * @param event
       * @private
       */
      ;

      _proto._mouseUpHandler = function _mouseUpHandler(event) {
        this.endDraw(event);
      }
      /**
       * handle mouse first click handle
       * @param event
       * @private
       */
      ;

      _proto._firstClickHandler = function _firstClickHandler(event) {
        var registerMode = this._getRegisterMode();

        var coordinate = event['coordinate'];

        if (!this._geometry) {
          this._createGeometry(event);
        } else {
          if (!isNil(this._historyPointer)) {
            this._clickCoords = this._clickCoords.slice(0, this._historyPointer);
          }

          this._clickCoords.push(coordinate);

          this._historyPointer = this._clickCoords.length;
          event.drawTool = this;

          if (registerMode['clickLimit'] && registerMode['clickLimit'] === this._historyPointer) {
            registerMode['update']([coordinate], this._geometry, event);
            this.endDraw(event);
          } else {
            registerMode['update'](this._clickCoords, this._geometry, event);
          }
          /**
           * drawvertex event.
           *
           * @event DrawTool#drawvertex
           * @type {Object}
           * @property {String} type - drawvertex
           * @property {DrawTool} target - draw tool
           * @property {Geometry} geometry - geometry drawn
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */


          this._fireEvent('drawvertex', event);
        }
      }
      /**
       * 第一次事件创建相关geometry
       * @param event
       * @private
       */
      ;

      _proto._createGeometry = function _createGeometry(event) {
        var mode = this.getMode();

        var registerMode = this._getRegisterMode();

        var coordinate = event['coordinate'];
        var symbol = this.getSymbol();

        if (!this._geometry) {
          this._clickCoords = [coordinate];
          event.drawTool = this;
          this._geometry = registerMode['create'](this._clickCoords, event);

          if (symbol && mode !== 'point') {
            this._geometry.setSymbol(symbol);
          } else if (this.options.hasOwnProperty('symbol')) {
            this._geometry.setSymbol(this.options['symbol']);
          }

          this._addGeometryToStage(this._geometry);
          /**
           * drawstart event.
           *
           * @event DrawTool#drawstart
           * @type {Object}
           * @property {String} type - drawstart
           * @property {DrawTool} target - draw tool
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */


          this._fireEvent('drawstart', event);
        }

        if (mode === 'point') {
          this.endDraw(event);
        }
      }
      /**
       * handle mouse move event
       * @param event
       * @private
       */
      ;

      _proto._mouseMoveHandler = function _mouseMoveHandler(event) {
        var map = this.getMap();
        var coordinate = event['coordinate'];

        if (!this._geometry || !map || map.isInteracting()) {
          return;
        }

        var containerPoint = this._getMouseContainerPoint(event);

        if (!this._isValidContainerPoint(containerPoint)) {
          return;
        }

        event.drawTool = this;

        var registerMode = this._getRegisterMode();

        if (this._shouldRecordHistory(registerMode.action)) {
          var path = this._clickCoords.slice(0, this._historyPointer);

          if (path && path.length > 0 && coordinate.equals(path[path.length - 1])) {
            return;
          }

          registerMode['update'](path.concat([coordinate]), this._geometry, event);
        } else {
          registerMode['update']([coordinate], this._geometry, event);
        }
        /**
         * mousemove event.
         *
         * @event DrawTool#mousemove
         * @type {Object}
         * @property {String} type - mousemove
         * @property {DrawTool} target - draw tool
         * @property {Geometry} geometry - geometry drawn
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        this._fireEvent('mousemove', event);
      }
      /**
       * handle mouse double click event
       * @param event
       * @private
       */
      ;

      _proto._doubleClickHandler = function _doubleClickHandler(event) {
        if (!this._geometry) {
          return;
        }

        var containerPoint = this._getMouseContainerPoint(event);

        if (!this._isValidContainerPoint(containerPoint)) {
          return;
        }

        var registerMode = this._getRegisterMode();

        var clickCoords = this._clickCoords;

        if (clickCoords.length < 2) {
          return;
        } //remove duplicate vertexes


        var path = [clickCoords[0]];

        for (var i = 1, len = clickCoords.length; i < len; i++) {
          if (clickCoords[i].x !== clickCoords[i - 1].x || clickCoords[i].y !== clickCoords[i - 1].y) {
            path.push(clickCoords[i]);
          }
        }

        if (path.length < 2 || this._geometry && this._geometry instanceof Polygon && path.length < 3) {
          return;
        }

        event.drawTool = this;
        registerMode['update'](path, this._geometry, event);
        this.endDraw(event);
      };

      _proto._addGeometryToStage = function _addGeometryToStage(geometry) {
        var drawLayer = this._getDrawLayer();

        drawLayer.addGeometry(geometry);
      }
      /**
       * End current draw
       * @param {Object} [param=null] params of drawend event
       * @returns {DrawTool} this
       */
      ;

      _proto.endDraw = function endDraw(param) {
        if (!this._geometry || this._ending) {
          return this;
        }

        this._ending = true;
        var geometry = this._geometry;

        this._clearStage();

        param = param || {};
        this._geometry = geometry;
        /**
         * drawend event.
         *
         * @event DrawTool#drawend
         * @type {Object}
         * @property {String} type - drawend
         * @property {DrawTool} target - draw tool
         * @property {Geometry} geometry - geometry drawn
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */

        this._fireEvent('drawend', param);

        delete this._geometry;

        if (this.options['once']) {
          this.disable();
        }

        delete this._ending;
        return this;
      };

      _proto._clearStage = function _clearStage() {
        this._getDrawLayer().clear();

        delete this._geometry;
        delete this._clickCoords;
      }
      /**
       * Get container point of the mouse event
       * @param  {Event} event -  mouse event
       * @return {Point}
       * @private
       */
      ;

      _proto._getMouseContainerPoint = function _getMouseContainerPoint(event) {
        var action = this._getRegisterMode()['action'];

        if (action === 'mousedown') {
          stopPropagation(event['domEvent']);
        }

        return event['containerPoint'];
      };

      _proto._isValidContainerPoint = function _isValidContainerPoint(containerPoint) {
        var mapSize = this._map.getSize();

        var w = mapSize['width'],
            h = mapSize['height'];

        if (containerPoint.x < 0 || containerPoint.y < 0) {
          return false;
        } else if (containerPoint.x > w || containerPoint.y > h) {
          return false;
        }

        return true;
      };

      _proto._getDrawLayer = function _getDrawLayer() {
        var drawLayerId = INTERNAL_LAYER_PREFIX + 'drawtool';

        var drawToolLayer = this._map.getLayer(drawLayerId);

        if (!drawToolLayer) {
          drawToolLayer = new VectorLayer(drawLayerId, {
            'enableSimplify': false
          });

          this._map.addLayer(drawToolLayer);
        }

        return drawToolLayer;
      };

      _proto._fireEvent = function _fireEvent(eventName, param) {
        if (!param) {
          param = {};
        }

        if (this._geometry) {
          param['geometry'] = this._getRegisterMode()['generate'](this._geometry, {
            drawTool: this
          }).copy();
        }

        MapTool.prototype._fireEvent.call(this, eventName, param);
      };

      return DrawTool;
    }(MapTool);

    DrawTool.mergeOptions(options$g);

    var MapBoxZoomHander =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapBoxZoomHander, _Handler);

      function MapBoxZoomHander(target) {
        var _this;

        _this = _Handler.call(this, target) || this;
        _this.drawTool = new DrawTool({
          'mode': 'boxZoom',
          'ignoreMouseleave': false
        });
        return _this;
      }

      var _proto = MapBoxZoomHander.prototype;

      _proto.addHooks = function addHooks() {
        this.target.on('_mousedown', this._onMouseDown, this);
      };

      _proto.removeHooks = function removeHooks() {
        this.target.off('_mousedown', this._onMouseDown, this);

        if (this.drawTool.isEnabled()) {
          this.drawTool.remove();
        }
      };

      _proto._onMouseDown = function _onMouseDown(param) {
        if (!this.target.options['boxZoom']) {
          return;
        }

        if (param.domEvent.shiftKey) {
          this.drawTool.setSymbol(this.target.options['boxZoomSymbol']).on('drawend', this._boxZoom, this).addTo(this.target);
        }
      };

      _proto._boxZoom = function _boxZoom(param) {
        var map = this.target;
        this.drawTool.remove();
        var geometry = param.geometry,
            center = geometry.getCenter(),
            symbol = geometry.getSymbol(),
            w = symbol.markerWidth,
            h = symbol.markerHeight;
        var extent = new Extent(center, map.locateByPoint(center, w, h), map.getProjection());
        var zoom = map.getFitZoom(extent);

        map._animateTo({
          center: extent.getCenter(),
          zoom: zoom
        });
      };

      return MapBoxZoomHander;
    }(Handler$1);

    Map$1.mergeOptions({
      'boxZoom': true,
      'boxZoomSymbol': {
        'markerType': 'rectangle',
        'markerLineWidth': 3,
        'markerLineColor': '#1bbc9b',
        'markerLineDasharray': [10, 5],
        'markerFillOpacity': 0.1,
        'markerFill': '#1bbc9b',
        'markerWidth': 1,
        'markerHeight': 1
      }
    });
    Map$1.addOnLoadHook('addHandler', 'boxZoom', MapBoxZoomHander);

    var PANOFFSET = 30;

    var MapAutoPanAtEdgeHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(MapAutoPanAtEdgeHandler, _Handler);

      function MapAutoPanAtEdgeHandler() {
        return _Handler.apply(this, arguments) || this;
      }

      var _proto = MapAutoPanAtEdgeHandler.prototype;

      _proto.addHooks = function addHooks() {
        if (!this.target) {
          return;
        }

        this.target.on('_mousemove', this._onMouseMove, this);
      };

      _proto.removeHooks = function removeHooks() {
        if (!this.target) {
          return;
        }

        this.target.off('_mousemove', this._onMouseMove, this);
      };

      _proto._onMouseMove = function _onMouseMove(event) {
        var map = this.target;

        if (map.options['autoPanAtEdge']) {
          var containerPoint = event.containerPoint;
          var containerExtent = map.getContainerExtent();

          if (containerExtent) {
            var x = containerPoint.x,
                y = containerPoint.y;
            var xmax = containerExtent.xmax,
                ymax = containerExtent.ymax;
            var p;

            if (x < PANOFFSET) {
              p = [Math.abs(x - PANOFFSET), 0];
            }

            if (y < PANOFFSET) {
              p = [0, Math.abs(y - PANOFFSET)];
            }

            if (x + PANOFFSET > xmax) {
              p = [-Math.abs(x + PANOFFSET - xmax), 0];
            }

            if (y + PANOFFSET > ymax) {
              p = [0, -Math.abs(y + PANOFFSET - ymax)];
            }

            if (p) {
              map.panBy(p, {
                duration: 1
              });
            }
          }
        }
      };

      return MapAutoPanAtEdgeHandler;
    }(Handler$1);

    Map$1.mergeOptions({
      'autoPanAtEdge': false
    });
    Map$1.addOnLoadHook('addHandler', 'autoPanAtEdge', MapAutoPanAtEdgeHandler);

    //     for (const p in view1) {
    //         if (hasOwn(view1, p)) {
    //             if (p === 'center') {
    //                 if (view1[p][0] !== view2[p][0] || view1[p][1] !== view2[p][1]) {
    //                     return false;
    //                 }
    //             } else if (view1[p] !== view2[p]) {
    //                 return false;
    //             }
    //         }
    //     }
    //     return true;
    // }

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Update map's view with animation.
       * @example
       * map.animateTo({
       *     zoom : 13,
       *     center : [0, 0],
       *     pitch : 30,
       *     bearing : 60
       * }, {
       *     duration : 6000,
       *     easing : 'out'
       * }, function(frame) {
       *     if (frame.state.playState === 'finished') {
       *         console.log('animation finished');
       *     }
       * });
       * @param  {Object} view    view object
       * @param  {Object} [options=null]
       * @param  {String} [options.easing=out]
       * @param  {Number} [options.duration=map.options.zoomAnimationDuration]
       * @param  {Function} [step=null]  - step function during animation, animation frame as the parameter
       * @return {Map}         this
       */
      animateTo: function animateTo(view, options, step) {
        var _this = this;

        if (options === void 0) {
          options = {};
        }

        // this._stopAnim(this._animPlayer);
        if (isFunction(options)) {
          step = options;
          options = {};
        }

        var projection = this.getProjection(),
            currView = this.getView(),
            props = {};
        var empty = true;

        for (var p in view) {
          if (hasOwn(view, p) && (p === 'prjCenter' || !isNil(currView[p]))) {
            empty = false;

            if (p === 'center') {
              var from = new Coordinate(currView[p]).toFixed(7),
                  to = new Coordinate(view[p]).toFixed(7);

              if (!from.equals(to)) {
                props['center'] = [from, to];
              }
            } else if (p === 'prjCenter') {
              var _from = new Coordinate(this._getPrjCenter());

              var _to = new Coordinate(view[p]);

              if (!_from.equals(_to)) {
                props['prjCenter'] = [_from, _to];
              }
            } else if (currView[p] !== view[p] && p !== 'around') {
              props[p] = [currView[p], view[p]];
            }
          }
        }

        if (empty) {
          return null;
        }

        if (this._animPlayer) {
          if (this._isInternalAnimation) {
            this._animPlayer.pause();

            this._prevAnimPlayer = this._animPlayer;
          } else {
            delete this._prevAnimPlayer;

            this._stopAnim(this._animPlayer);
          }
        }

        var zoomOrigin = view['around'] || new Point(this.width / 2, this.height / 2); // let preView = this.getView();

        var renderer = this._getRenderer(),
            framer = function framer(fn) {
          renderer.callInNextFrame(fn);
        };

        var player = this._animPlayer = Animation.animate(props, {
          'easing': options['easing'] || 'out',
          'duration': options['duration'] || this.options['zoomAnimationDuration'],
          'framer': framer
        }, function (frame) {
          if (_this.isRemoved()) {
            player.finish();
            return;
          }

          if (player.playState === 'running') {
            // const view = this.getView();
            // if (!options['continueOnViewChanged'] && !equalView(view, preView)) {
            //     // map's view is updated by another operation, animation should stop
            //     this._stopAnim(player);
            //     return;
            // }
            if (frame.styles['center']) {
              var center = frame.styles['center'];

              _this._setPrjCenter(projection.project(center));

              _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
            } else if (frame.styles['prjCenter']) {
              var _center = frame.styles['prjCenter'];

              _this._setPrjCenter(_center);

              _this.onMoving(_this._parseEventFromCoord(_this.getCenter()));
            }

            if (!isNil(frame.styles['zoom'])) {
              _this.onZooming(frame.styles['zoom'], zoomOrigin);
            }

            if (!isNil(frame.styles['pitch'])) {
              _this.setPitch(frame.styles['pitch']);
            }

            if (!isNil(frame.styles['bearing'])) {
              _this.setBearing(frame.styles['bearing']);
            } // preView = this.getView();

            /**
             * fired when map is animating.  (panning, zooming, rotating)
             *
             * @event Map#animating
             * @type {Object}
             * @property {String} type - animating
             * @property {Map} target - the map fires the event
             */


            _this._fireEvent('animating');
          } else if (player.playState === 'finished') {
            if (!player._interupted) {
              if (props['center']) {
                _this._setPrjCenter(projection.project(props['center'][1]));
              } else if (props['prjCenter']) {
                _this._setPrjCenter(props['prjCenter'][1]);
              }

              if (!isNil(props['pitch'])) {
                _this.setPitch(props['pitch'][1]);
              }

              if (!isNil(props['bearing'])) {
                _this.setBearing(props['bearing'][1]);
              }
            }

            _this._endAnim(player, props, zoomOrigin, options); // preView = this.getView();

          }

          if (step) {
            step(frame);
          }
        });

        this._startAnim(props, zoomOrigin);

        return player;
      },
      _animateTo: function _animateTo(view, options, step) {
        if (options === void 0) {
          options = {};
        }

        if (this._mapAnimPlayer) {
          this._stopAnim(this._mapAnimPlayer);
        }

        this._isInternalAnimation = true;
        this._mapAnimPlayer = this.animateTo(view, options, step);
        delete this._isInternalAnimation;
        return this._mapAnimPlayer;
      },

      /**
       * Whether the map is animating with .animateTo
       * @return {Boolean}
       */
      isAnimating: function isAnimating() {
        return !!this._animPlayer;
      },
      isRotating: function isRotating() {
        return this.isDragRotating() || !!this._animRotating;
      },
      _endAnim: function _endAnim(player, props, zoomOrigin, options) {
        delete this._animRotating;
        /**
         * fired when map's animation is interrupted by mouse event or else.
         *
         * @event Map#animateinterrupted
         * @type {Object}
         * @property {String} type - animateinterrupted
         * @property {Map} target - the map fires the event
         */

        /**
         * fired when map's animation ended (panning, zooming, rotating).
         *
         * @event Map#animateend
         * @type {Object}
         * @property {String} type - animateend
         * @property {Map} target - the map fires the event
         */

        var evtType = player._interupted ? 'animateinterrupted' : 'animateend';

        if (player === this._animPlayer) {
          delete this._animPlayer;
        }

        if (player === this._mapAnimPlayer) {
          delete this._mapAnimPlayer;
        }

        if (props['center']) {
          var endCoord;

          if (player._interupted) {
            endCoord = this.getCenter();
          } else {
            endCoord = props['center'][1];
          }

          this.onMoveEnd(this._parseEventFromCoord(endCoord));
        } else if (props['prjCenter']) {
          var _endCoord;

          if (player._interupted) {
            _endCoord = this._getPrjCenter();
          } else {
            _endCoord = props['prjCenter'][1];
          }

          var event = this._parseEventFromCoord(this.getProjection().unproject(_endCoord));

          event['point2d'] = this._prjToPoint(_endCoord);
          this.onMoveEnd(event);
        }

        if (!isNil(props['zoom'])) {
          if (player._interupted) {
            this.onZoomEnd(this.getZoom(), zoomOrigin);
          } else if (!options['wheelZoom']) {
            this.onZoomEnd(props['zoom'][1], zoomOrigin);
          } else {
            this.onZooming(props['zoom'][1], zoomOrigin);
          }
        }

        if (evtType) {
          this._fireEvent(evtType);
        }

        if (!isNil(props['pitch']) && !this.getPitch()) {
          //https://github.com/maptalks/maptalks.js/issues/732
          //fix blank map when pitch changes to 0
          this.getRenderer().setToRedraw();
        }

        if (this._prevAnimPlayer) {
          this._animPlayer = this._prevAnimPlayer;

          this._prevAnimPlayer.play();
        }
      },
      _startAnim: function _startAnim(props, zoomOrigin) {
        if (!this._animPlayer) {
          return;
        }

        if (props['center']) {
          this.onMoveStart();
        }

        if (props['zoom'] && !this.isZooming()) {
          this.onZoomStart(props['zoom'][1], zoomOrigin);
        }

        if (props['pitch'] || props['bearing']) {
          this._animRotating = true;
        }
        /**
         * fired when map starts to animate (panning, zooming, rotating).
         *
         * @event Map#animatestart
         * @type {Object}
         * @property {String} type - animatestart
         * @property {Map} target - the map fires the event
         */


        this._fireEvent('animatestart');

        this._animPlayer.play();
      },
      _stopAnim: function _stopAnim(player) {
        if (!player) {
          return;
        }

        if (player.playState !== 'finished') {
          player._interupted = true;
          player.cancel();
        }

        if (player === this._animPlayer && this._prevAnimPlayer) {
          this._animPlayer = this._prevAnimPlayer;

          this._prevAnimPlayer.play();
        }

        if (player === this._animPlayer) {
          delete this._animPlayer;
        }

        if (player === this._mapAnimPlayer) {
          delete this._mapAnimPlayer;
        }
      }
    });

    var events =
    /**
     * mousedown event
     * @event Map#mousedown
     * @type {Object}
     * @property {String} type                    - mousedown
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousedown ' +
    /**
     * mouseup event
     * @event Map#mouseup
     * @type {Object}
     * @property {String} type                    - mouseup
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseup ' +
    /**
     * mouseover event
     * @event Map#mouseover
     * @type {Object}
     * @property {String} type                    - mouseover
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseover ' +
    /**
     * mouseout event
     * @event Map#mouseout
     * @type {Object}
     * @property {String} type                    - mouseout
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseout ' +
    /**
     * mouseenter event
     * @event Map#mouseenter
     * @type {Object}
     * @property {String} type                    - mouseenter
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseenter ' +
    /**
     * mouseleave event
     * @event Map#mouseleave
     * @type {Object}
     * @property {String} type                    - mouseleave
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseleave ' +
    /**
     * mousemove event
     * @event Map#mousemove
     * @type {Object}
     * @property {String} type                    - mousemove
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousemove ' +
    /**
     * click event
     * @event Map#click
     * @type {Object}
     * @property {String} type                    - click
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'click ' +
    /**
     * dblclick event
     * @event Map#dblclick
     * @type {Object}
     * @property {String} type                    - dblclick
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'dblclick ' +
    /**
     * contextmenu event
     * @event Map#contextmenu
     * @type {Object}
     * @property {String} type                    - contextmenu
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'contextmenu ' +
    /**
     * keypress event
     * @event Map#keypress
     * @type {Object}
     * @property {String} type                    - keypress
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'keypress ' +
    /**
     * touchstart event
     * @event Map#touchstart
     * @type {Object}
     * @property {String} type                    - touchstart
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchstart ' +
    /**
     * touchmove event
     * @event Map#touchmove
     * @type {Object}
     * @property {String} type                    - touchmove
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchmove ' +
    /**
     * touchend event
     * @event Map#touchend
     * @type {Object}
     * @property {String} type                    - touchend
     * @property {Map} target            - the map fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchend ';
    Map$1.include(
    /** @lends Map.prototype */
    {
      _registerDomEvents: function _registerDomEvents() {
        var dom = this._panels.mapWrapper || this._containerDOM;
        addDomEvent(dom, events, this._handleDOMEvent, this);
      },
      _removeDomEvents: function _removeDomEvents() {
        var dom = this._panels.mapWrapper || this._containerDOM;
        removeDomEvent(dom, events, this._handleDOMEvent, this);
      },
      _handleDOMEvent: function _handleDOMEvent(e) {
        var type = e.type; // prevent default contextmenu

        if (type === 'contextmenu') {
          preventDefault(e);
        }

        if (this._ignoreEvent(e)) {
          return;
        }

        var mimicClick = false; // ignore click lasted for more than 300ms.

        if (type === 'mousedown' || type === 'touchstart' && e.touches.length === 1) {
          this._mouseDownTime = now();
        } else if (type === 'click' || type === 'touchend' || type === 'contextmenu') {
          if (!this._mouseDownTime) {
            //mousedown | touchstart propogation is stopped
            //ignore the click/touchend/contextmenu
            return;
          } else {
            var downTime = this._mouseDownTime;
            delete this._mouseDownTime;
            var time = now();

            if (time - downTime > 300) {
              if (type === 'click' || type === 'contextmenu') {
                return;
              }
            } else if (type === 'touchend') {
              mimicClick = true;
            }
          }
        }

        this._fireDOMEvent(this, e, type);

        if (mimicClick) {
          if (this._clickTime && now() - this._clickTime <= 300) {
            delete this._clickTime;

            this._fireDOMEvent(this, e, 'dblclick');
          } else {
            this._clickTime = now();

            this._fireDOMEvent(this, e, 'click');
          }
        }
      },
      _ignoreEvent: function _ignoreEvent(domEvent) {
        //ignore events originated from control and ui doms.
        if (!domEvent || !this._panels.control) {
          return false;
        }

        if (this._isEventOutMap(domEvent)) {
          return true;
        }

        var target = domEvent.srcElement || domEvent.target;
        var preTarget;

        if (target) {
          while (target && target !== this._containerDOM) {
            if (target.className && target.className.indexOf && (target.className.indexOf('maptalks-control') >= 0 || target.className.indexOf('maptalks-ui') >= 0 && !preTarget['eventsPropagation'])) {
              return true;
            }

            preTarget = target;
            target = target.parentNode;
          }
        }

        return false;
      },
      _isEventOutMap: function _isEventOutMap(domEvent) {
        if (this.getPitch() > this.options['maxVisualPitch']) {
          var actualEvent = this._getActualEvent(domEvent);

          var eventPos = getEventContainerPoint(actualEvent, this._containerDOM);

          if (!this.getContainerExtent().contains(eventPos)) {
            return true;
          }
        }

        return false;
      },
      _parseEvent: function _parseEvent(e, type) {
        if (!e) {
          return null;
        }

        var eventParam = {
          'domEvent': e
        };

        if (type !== 'keypress') {
          var actual = this._getActualEvent(e);

          if (actual) {
            var containerPoint = getEventContainerPoint(actual, this._containerDOM);
            eventParam = extend(eventParam, {
              'coordinate': this.containerPointToCoord(containerPoint),
              'containerPoint': containerPoint,
              'viewPoint': this.containerPointToViewPoint(containerPoint),
              'point2d': this._containerPointToPoint(containerPoint)
            });
          }
        }

        return eventParam;
      },
      _parseEventFromCoord: function _parseEventFromCoord(coord) {
        var containerPoint = this.coordToContainerPoint(coord),
            viewPoint = this.containerPointToViewPoint(containerPoint);
        var e = {
          'coordinate': coord,
          'containerPoint': containerPoint,
          'viewPoint': viewPoint,
          'point2d': this.coordToPoint(coord)
        };
        return e;
      },
      _getActualEvent: function _getActualEvent(e) {
        return e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;
      },
      _fireDOMEvent: function _fireDOMEvent(target, e, type) {
        if (this.isRemoved()) {
          return;
        }

        var eventParam = this._parseEvent(e, type);

        this._fireEvent(type, eventParam);
      } // _onKeyPress(e) {
      //     if (!this.isRemoved() && e.keyCode === 48 && e.ctrlKey) {
      //         this.setBearing(0);
      //     }
      // }

    });
    Map$1.addOnLoadHook('_registerDomEvents');

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * @return {Boolean} Element is currently in fullscreen.
       */
      isFullScreen: function isFullScreen() {
        return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
      },

      /**
       * Request for the full screen
       * @property {Object} dom -containerDOM to requestFullScreen
       * @return {Map} this
       * @fires Map#fullscreenstart
       * @fires Map#fullscreenend
       */
      requestFullScreen: function requestFullScreen(dom) {
        /**
         * fullscreenstart event
         * @event Map#fullscreenstart
         * @type {Object}
         * @property {String} type                    - fullscreenstart
         * @property {Map} target            - the map fires event
         */
        this._fireEvent('fullscreenstart');

        this._requestFullScreen(dom || this._containerDOM);
        /**
         * fullscreenend event
         * @event Map#fullscreenend
         * @type {Object}
         * @property {String} type                    - fullscreenend
         * @property {Map} target            - the map fires event
         */


        this._fireEvent('fullscreenend');

        return this;
      },

      /**
       * Cancel full screen
       * @return {Map} this
       * @fires Map#cancelfullscreen
       */
      cancelFullScreen: function cancelFullScreen() {
        this._cancelFullScreen();
        /**
         * cancelfullscreen event
         * @event Map#cancelfullscreen
         * @type {Object}
         * @property {String} type                    - cancelfullscreen
         * @property {Map} target            - the map fires event
         */


        this._fireEvent('cancelfullscreen');

        return this;
      },
      _requestFullScreen: function _requestFullScreen(dom) {
        if (dom.requestFullScreen) {
          dom.requestFullScreen();
        } else if (dom.mozRequestFullScreen) {
          dom.mozRequestFullScreen();
        } else if (dom.webkitRequestFullScreen) {
          dom.webkitRequestFullScreen();
        } else if (dom.msRequestFullScreen) {
          dom.msRequestFullScreen();
        } else {
          var features = 'fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,' + 'titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,' + 'width=' + (screen.availWidth - 8) + ',height=' + (screen.availHeight - 45);
          var newWin = window.open(location.href, '_blank', features);

          if (newWin !== null) {
            window.opener = null; //close parent window

            window.close();
          }
        }
      },
      _cancelFullScreen: function _cancelFullScreen() {
        if (document.cancelFullScreen) {
          document.cancelFullScreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.webkitCancelFullScreen) {
          document.webkitCancelFullScreen();
        } else {
          var features = 'fullscreen=no,status=yes,resizable=yes,scrollbars=no,' + 'titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes';
          var newWin = window.open(location.href, '_blank', features);

          if (newWin !== null) {
            window.opener = null; //close parent window

            window.close();
          }
        }
      }
    });

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Pan to the given coordinate
       * @param {Coordinate} coordinate - coordinate to pan to
       * @param {Object} [options=null] - pan options
       * @param {Boolean} [options.animation=null] - whether pan with animation
       * @param {Boolean} [options.duration=600] - pan animation duration
       * @return {Map} this
       */
      panTo: function panTo(coordinate, options, step) {
        if (options === void 0) {
          options = {};
        }

        if (!coordinate) {
          return this;
        }

        if (isFunction(options)) {
          step = options;
          options = {};
        }

        coordinate = new Coordinate(coordinate);

        if (typeof options['animation'] === 'undefined' || options['animation']) {
          var prjCoord = this.getProjection().project(coordinate);
          return this._panAnimation(prjCoord, options['duration'], step);
        } else {
          this.setCenter(coordinate);
        }

        return this;
      },
      _panTo: function _panTo(prjCoord, options) {
        if (options === void 0) {
          options = {};
        }

        if (typeof options['animation'] === 'undefined' || options['animation']) {
          return this._panAnimation(prjCoord, options['duration']);
        } else {
          this.onMoveStart();

          this._setPrjCenter(prjCoord);

          this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
          return this;
        }
      },

      /**
       * Pan the map by the give point
       * @param  {Point} point - distance to pan, in pixel
       * @param {Object} [options=null] - pan options
       * @param {Boolean} [options.animation=null] - whether pan with animation
       * @param {Boolean} [options.duration=600] - pan animation duration
       * @return {Map} this
       */
      panBy: function panBy(offset, options, step) {
        if (options === void 0) {
          options = {};
        }

        if (!offset) {
          return this;
        }

        if (isFunction(options)) {
          step = options;
          options = {};
        }

        offset = new Point(offset);
        this.onMoveStart();

        if (typeof options['animation'] === 'undefined' || options['animation']) {
          offset = offset.multi(-1); // const point0 = this._prjToPoint(this._getPrjCenter());
          // const point1 =
          // point._add(offset.x, offset.y);
          // const target = this._pointToPrj(point);

          var target = this._containerPointToPrj(new Point(this.width / 2 + offset.x, this.height / 2 + offset.y)); // const target = this.locateByPoint(this.getCenter(), offset.x, offset.y);


          this._panAnimation(target, options['duration'], step);
        } else {
          this._offsetCenterByPixel(offset);

          this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
        }

        return this;
      },
      _panAnimation: function _panAnimation(target, t, cb) {
        return this._animateTo({
          'prjCenter': target
        }, {
          'duration': t || this.options['panAnimationDuration']
        }, cb);
      }
    });

    /** Profile **/
    /**
     * Produce a geometry from one or more [JSON]{@link Geometry#toJSON} or GeoJSON.
     * @param  {Object} json - a geometry's JSON or a geojson
     * @return {Geometry} geometry
     * @example
     * var profile = {
            "feature": {
                  "type": "Feature",
                  "id" : "point1",
                  "geometry": {"type": "Point", "coordinates": [102.0, 0.5]},
                  "properties": {"prop0": "value0"}
            },
            //construct options.
            "options":{
                "draggable" : true
            },
            //symbol
            "symbol":{
                "markerFile"  : "http://foo.com/icon.png",
                "markerWidth" : 20,
                "markerHeight": 20
            }
        };
        const marker = Geometry.fromJSON(profile);
     */

    Geometry.fromJSON = function (json) {
      if (Array.isArray(json)) {
        var result = [];

        for (var i = 0, len = json.length; i < len; i++) {
          var c = Geometry.fromJSON(json[i]);

          if (Array.isArray(json)) {
            result = result.concat(c);
          } else {
            result.push(c);
          }
        }

        return result;
      }

      if (json && !json['feature']) {
        return GeoJSON.toGeometry(json);
      }

      var geometry;

      if (json['subType']) {
        geometry = Geometry.getJSONClass(json['subType']).fromJSON(json);

        if (!isNil(json['feature']['id'])) {
          geometry.setId(json['feature']['id']);
        }
      } else {
        geometry = GeoJSON.toGeometry(json['feature']);

        if (json['options']) {
          geometry.config(json['options']);
        }
      }

      if (json['symbol']) {
        geometry.setSymbol(json['symbol']);
      }

      if (json['infoWindow']) {
        geometry.setInfoWindow(json['infoWindow']);
      }

      return geometry;
    };
    /**
     * Reproduce a Layer from layer's JSON.
     * @param  {Object} layerJSON - layer's JSON
     * @return {Layer}
     */


    Layer.fromJSON = function (layerJSON) {
      if (!layerJSON) {
        return null;
      }

      var layerType = layerJSON['type'];
      var clazz = Layer.getJSONClass(layerType);

      if (!clazz || !clazz.fromJSON) {
        throw new Error('unsupported layer type:' + layerType);
      }

      return clazz.fromJSON(layerJSON);
    };

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * @property {String}  - Version of the [JSON]{@link Map#toJSON} schema.
       * @constant
       * @static
       */
      'JSON_VERSION': '1.0',

      /**
       * Export the map's json, a snapshot of the map in JSON format.<br>
       * It can be used to reproduce the instance by [fromJSON]{@link Map#fromJSON} method
       * @param  {Object} [options=null] - export options
       * @param  {Boolean|Object} [options.baseLayer=null] - whether to export base layer's JSON, if yes, it will be used as layer's toJSON options.
       * @param  {Boolean|Extent} [options.clipExtent=null] - if set with an extent instance, only the geometries intersectes with the extent will be exported.
       *                                                             If set to true, map's current extent will be used.
       * @param  {Boolean|Object|Object[]} [options.layers=null] - whether to export other layers' JSON, if yes, it will be used as layer's toJSON options.
       *                                                        It can also be an array of layer export options with a "id" attribute to filter the layers to export.
       * @return {Object} layer's JSON
       */
      toJSON: function toJSON(options) {
        if (!options) {
          options = {};
        }

        var json = {
          'jsonVersion': this['JSON_VERSION'],
          'version': this.VERSION,
          'extent': this.getExtent().toJSON()
        };
        json['options'] = this.config();
        json['options']['center'] = this.getCenter();
        json['options']['zoom'] = this.getZoom();
        var baseLayer = this.getBaseLayer();

        if ((isNil(options['baseLayer']) || options['baseLayer']) && baseLayer) {
          json['baseLayer'] = baseLayer.toJSON(options['baseLayer']);
        }

        var extraLayerOptions = {};

        if (options['clipExtent']) {
          //if clipExtent is set, only geometries intersecting with extent will be exported.
          //clipExtent's value can be an extent or true (map's current extent)
          if (options['clipExtent'] === true) {
            extraLayerOptions['clipExtent'] = this.getExtent();
          } else {
            extraLayerOptions['clipExtent'] = options['clipExtent'];
          }
        }

        var layersJSON = [];

        if (isNil(options['layers']) || options['layers'] && !Array.isArray(options['layers'])) {
          var layers = this.getLayers();

          for (var i = 0, len = layers.length; i < len; i++) {
            if (!layers[i].toJSON) {
              continue;
            }

            var opts = extend({}, isObject(options['layers']) ? options['layers'] : {}, extraLayerOptions);
            layersJSON.push(layers[i].toJSON(opts));
          }

          json['layers'] = layersJSON;
        } else if (isArrayHasData(options['layers'])) {
          var _layers = options['layers'];

          for (var _i = 0; _i < _layers.length; _i++) {
            var exportOption = _layers[_i];
            var layer = this.getLayer(exportOption['id']);

            if (!layer.toJSON) {
              continue;
            }

            var _opts = extend({}, exportOption['options'], extraLayerOptions);

            layersJSON.push(layer.toJSON(_opts));
          }

          json['layers'] = layersJSON;
        } else {
          json['layers'] = [];
        }

        return json;
      }
    });
    /**
     * Reproduce a map from map's profile JSON.
     * @param {(string|HTMLElement|object)} container - The container to create the map on, can be:<br>
     *                                          1. A HTMLElement container.<br/>
     *                                          2. ID of a HTMLElement container.<br/>
     *                                          3. A canvas compatible container in node,
     *                                          e.g. [node-canvas]{@link https://github.com/Automattic/node-canvas},
     *                                              [canvas2svg]{@link https://github.com/gliffy/canvas2svg}
     * @param  {Object} mapJSON - map's profile JSON
     * @param  {Object} [options=null] - options
     * @param  {Object} [options.baseLayer=null] - whether to import the baseLayer
     * @param  {Object} [options.layers=null]    - whether to import the layers
     * @return {Map}
     * @static
     * @function
     * @example
     * var map = Map.fromJSON('map', mapProfile);
     */

    Map$1.fromJSON = function (container, profile, options) {
      if (!container || !profile) {
        return null;
      }

      if (!options) {
        options = {};
      }

      var map = new Map$1(container, profile['options']);

      if (isNil(options['baseLayer']) || options['baseLayer']) {
        var baseLayer = Layer.fromJSON(profile['baseLayer']);

        if (baseLayer) {
          map.setBaseLayer(baseLayer);
        }
      }

      if (isNil(options['layers']) || options['layers']) {
        var layers = [];
        var layerJSONs = profile['layers'];

        for (var i = 0; i < layerJSONs.length; i++) {
          var layer = Layer.fromJSON(layerJSONs[i]);
          layers.push(layer);
        }

        map.addLayer(layers);
      }

      return map;
    };

    /**
     * Methods of topo computations
     */

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Caculate distance of two coordinates.
       * @param {Number[]|Coordinate} coord1 - coordinate 1
       * @param {Number[]|Coordinate} coord2 - coordinate 2
       * @return {Number} distance, unit is meter
       * @example
       * var distance = map.computeLength([0, 0], [0, 20]);
       */
      computeLength: function computeLength(coord1, coord2) {
        if (!this.getProjection()) {
          return null;
        }

        var p1 = new Coordinate(coord1),
            p2 = new Coordinate(coord2);

        if (p1.equals(p2)) {
          return 0;
        }

        return this.getProjection().measureLength(p1, p2);
      },

      /**
       * Caculate a geometry's length.
       * @param {Geometry} geometry - geometry to caculate
       * @return {Number} length, unit is meter
       */
      computeGeometryLength: function computeGeometryLength(geometry) {
        return geometry._computeGeodesicLength(this.getProjection());
      },

      /**
       * Caculate a geometry's area.
       * @param  {Geometry} geometry - geometry to caculate
       * @return {Number} area, unit is sq.meter
       */
      computeGeometryArea: function computeGeometryArea(geometry) {
        return geometry._computeGeodesicArea(this.getProjection());
      },

      /**
       * Identify the geometries on the given coordinate.
       * @param {Object} opts - the identify options
       * @param {Coordinate} opts.coordinate - coordinate to identify
       * @param {Object}   opts.layers        - the layers to perform identify on.
       * @param {Function} [opts.filter=null] - filter function of the result geometries, return false to exclude.
       * @param {Number}   [opts.count=null]  - limit of the result count.
       * @param {Number}   [opts.tolerance=0] - identify tolerance in pixel.
       * @param {Boolean}  [opts.includeInternals=false] - whether to identify internal layers.
       * @param {Boolean}  [opts.includeInvisible=false] - whether to identify invisible layers.
       * @param {Function} callback           - the callback function using the result geometries as the parameter.
       * @return {Map} this
       * @example
       * map.identify({
       *      coordinate: [0, 0],
       *      layers: [layer]
       *  },
       *  geos => {
       *      console.log(geos);
       *  });
       */
      identify: function identify(opts, callback) {
        if (!opts) {
          return this;
        }

        var reqLayers = opts['layers'];

        if (!isArrayHasData(reqLayers)) {
          return this;
        }

        var layers = [];

        for (var i = 0, len = reqLayers.length; i < len; i++) {
          if (isString(reqLayers[i])) {
            layers.push(this.getLayer(reqLayers[i]));
          } else {
            layers.push(reqLayers[i]);
          }
        }

        var coordinate = new Coordinate(opts['coordinate']);
        var options = extend({}, opts);
        var hits = [];

        for (var _i = layers.length - 1; _i >= 0; _i--) {
          if (opts['count'] && hits.length >= opts['count']) {
            break;
          }

          var layer = layers[_i];

          if (!layer || !layer.getMap() || !opts['includeInvisible'] && !layer.isVisible() || !opts['includeInternals'] && layer.getId().indexOf(INTERNAL_LAYER_PREFIX) >= 0) {
            continue;
          }

          var layerHits = layer.identify(coordinate, options);

          if (layerHits) {
            if (Array.isArray(layerHits)) {
              pushIn(hits, layerHits);
            } else {
              hits.push(layerHits);
            }
          }
        }

        callback.call(this, hits);
        return this;
      }
    });

    Map$1.include(
    /** @lends Map.prototype */
    {
      _zoom: function _zoom(nextZoom, origin) {
        if (!this.options['zoomable'] || this.isZooming()) {
          return;
        }

        origin = this._checkZoomOrigin(origin);
        nextZoom = this._checkZoom(nextZoom);
        this.onZoomStart(nextZoom, origin);
        this._frameZoom = this.getZoom();
        this.onZoomEnd(nextZoom, origin);
      },
      _zoomAnimation: function _zoomAnimation(nextZoom, origin, startScale) {
        if (!this.options['zoomable'] || this.isZooming()) {
          return;
        }

        nextZoom = this._checkZoom(nextZoom);

        if (this.getZoom() === nextZoom) {
          return;
        }

        origin = this._checkZoomOrigin(origin);

        this._startZoomAnim(nextZoom, origin, startScale);
      },
      _checkZoomOrigin: function _checkZoomOrigin(origin) {
        if (!origin || this.options['zoomInCenter']) {
          origin = new Point(this.width / 2, this.height / 2);
        }

        if (this.options['zoomOrigin']) {
          origin = new Point(this.options['zoomOrigin']);
        }

        return origin;
      },
      _startZoomAnim: function _startZoomAnim(nextZoom, origin, startScale) {
        if (isNil(startScale)) {
          startScale = 1;
        }

        var endScale = this._getResolution(this._startZoomVal) / this._getResolution(nextZoom);

        var duration = this.options['zoomAnimationDuration'] * Math.abs(endScale - startScale) / Math.abs(endScale - 1);
        this._frameZoom = this._startZoomVal;

        this._animateTo({
          'zoom': nextZoom,
          'around': origin
        }, {
          'continueOnViewChanged': true,
          'duration': duration
        });
      },
      onZoomStart: function onZoomStart(nextZoom, origin) {
        if (!this.options['zoomable'] || this.isZooming()) {
          return;
        }

        if (this._mapAnimPlayer) {
          this._stopAnim(this._mapAnimPlayer);
        }

        this._zooming = true;
        this._startZoomVal = this.getZoom();
        this._startZoomCoord = this._containerPointToPrj(origin);
        /**
          * zoomstart event
          * @event Map#zoomstart
          * @type {Object}
          * @property {String} type                    - zoomstart
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - zoom level zooming from
          * @property {Number} to                      - zoom level zooming to
          */

        this._fireEvent('zoomstart', {
          'from': this._startZoomVal,
          'to': nextZoom
        });
      },
      onZooming: function onZooming(nextZoom, origin, startScale) {
        if (!this.options['zoomable']) {
          return;
        }

        var frameZoom = this._frameZoom;

        if (frameZoom === nextZoom) {
          return;
        }

        if (isNil(startScale)) {
          startScale = 1;
        }

        this._zoomTo(nextZoom, origin);

        var res = this.getResolution(nextZoom),
            fromRes = this.getResolution(this._startZoomVal),
            scale = fromRes / res / startScale,
            startPoint = this._prjToContainerPoint(this._startZoomCoord, this._startZoomVal);

        var offset = this.getViewPoint();

        if (!this.isRotating() && !startPoint.equals(origin) && scale !== 1) {
          var pitch = this.getPitch(); // coordinate at origin changed, usually by map.setCenter
          // add origin offset

          var originOffset = startPoint._sub(origin)._multi(1 / (1 - scale));

          if (pitch) {
            //FIXME Math.cos(pitch * Math.PI / 180) is just a magic num, works when tilting but may have problem when rotating
            originOffset.y /= Math.cos(pitch * Math.PI / 180);
          }

          origin = origin.add(originOffset);
        }

        var matrix = {
          'view': [scale, 0, 0, scale, (origin.x - offset.x) * (1 - scale), (origin.y - offset.y) * (1 - scale)]
        };
        var dpr = this.getDevicePixelRatio();

        if (dpr !== 1) {
          origin = origin.multi(dpr);
        }

        matrix['container'] = [scale, 0, 0, scale, origin.x * (1 - scale), origin.y * (1 - scale)];
        /**
          * zooming event
          * @event Map#zooming
          * @type {Object}
          * @property {String} type                    - zooming
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - zoom level zooming from
          * @property {Number} to                      - zoom level zooming to
          */

        this._fireEvent('zooming', {
          'from': this._startZoomVal,
          'to': nextZoom,
          'origin': origin,
          'matrix': matrix
        });

        this._frameZoom = nextZoom;
      },
      onZoomEnd: function onZoomEnd(nextZoom, origin) {
        if (!this.options['zoomable']) {
          return;
        }

        var startZoomVal = this._startZoomVal;

        this._zoomTo(nextZoom, origin);

        this._zooming = false;

        this._getRenderer().onZoomEnd();
        /**
          * zoomend event
          * @event Map#zoomend
          * @type {Object}
          * @property {String} type                    - zoomend
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - zoom level zooming from
          * @property {Number} to                      - zoom level zooming to
          */


        this._fireEvent('zoomend', {
          'from': startZoomVal,
          'to': nextZoom
        });

        if (!this._verifyExtent(this._getPrjCenter())) {
          this._panTo(this._prjMaxExtent.getCenter());
        }
      },
      _zoomTo: function _zoomTo(nextZoom, origin) {
        this._zoomLevel = nextZoom;

        this._calcMatrices();

        if (origin) {
          this._setPrjCoordAtContainerPoint(this._startZoomCoord, origin);
        }
      },
      _checkZoom: function _checkZoom(nextZoom) {
        var maxZoom = this.getMaxZoom(),
            minZoom = this.getMinZoom();

        if (nextZoom < minZoom) {
          nextZoom = minZoom;
        }

        if (nextZoom > maxZoom) {
          nextZoom = maxZoom;
        }

        return nextZoom;
      }
    });

    /*eslint-disable no-var*/
    // Contains code from glmatrix.js
    function perspective(out, fovy, aspect, near, far) {
      var f = 1.0 / Math.tan(fovy / 2),
          nf = 1 / (near - far);
      out[0] = f / aspect;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = f;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = (far + near) * nf;
      out[11] = -1;
      out[12] = 0;
      out[13] = 0;
      out[14] = 2 * far * near * nf;
      out[15] = 0;
      return out;
    }
    function translate(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2],
          a00,
          a01,
          a02,
          a03,
          a10,
          a11,
          a12,
          a13,
          a20,
          a21,
          a22,
          a23;

      if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
      } else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
      }

      return out;
    }
    function scale(out, a, v) {
      var x = v[0],
          y = v[1],
          z = v[2];
      out[0] = a[0] * x;
      out[1] = a[1] * x;
      out[2] = a[2] * x;
      out[3] = a[3] * x;
      out[4] = a[4] * y;
      out[5] = a[5] * y;
      out[6] = a[6] * y;
      out[7] = a[7] * y;
      out[8] = a[8] * z;
      out[9] = a[9] * z;
      out[10] = a[10] * z;
      out[11] = a[11] * z;
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
    function rotateX(out, a, rad) {
      var s = Math.sin(rad),
          c = Math.cos(rad),
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11];

      if (a !== out) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }

      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
    }
    function rotateZ(out, a, rad) {
      var s = Math.sin(rad),
          c = Math.cos(rad),
          a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7];

      if (a !== out) {
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
      }

      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
    }
    /* export function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
    } */

    function multiply(out, a, b) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15]; // Cache only the current line of the second matrix

      var b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    }
    function invert(out, a) {
      var a00 = a[0],
          a01 = a[1],
          a02 = a[2],
          a03 = a[3],
          a10 = a[4],
          a11 = a[5],
          a12 = a[6],
          a13 = a[7],
          a20 = a[8],
          a21 = a[9],
          a22 = a[10],
          a23 = a[11],
          a30 = a[12],
          a31 = a[13],
          a32 = a[14],
          a33 = a[15],
          b00 = a00 * a11 - a01 * a10,
          b01 = a00 * a12 - a02 * a10,
          b02 = a00 * a13 - a03 * a10,
          b03 = a01 * a12 - a02 * a11,
          b04 = a01 * a13 - a03 * a11,
          b05 = a02 * a13 - a03 * a12,
          b06 = a20 * a31 - a21 * a30,
          b07 = a20 * a32 - a22 * a30,
          b08 = a20 * a33 - a23 * a30,
          b09 = a21 * a32 - a22 * a31,
          b10 = a21 * a33 - a23 * a31,
          b11 = a22 * a33 - a23 * a32,
          // Calculate the determinant
      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    }
    /**
     * Set a mat4 to the identity matrix
     *
     * @param {mat4} out the receiving matrix
     * @returns {mat4} out
     */

    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    }
    /**
     * Copy the values from one mat4 to another
     *
     * @param {mat4} out the receiving matrix
     * @param {mat4} a the source matrix
     * @returns {mat4} out
     */

    function copy(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
      return out;
    }
    /*eslint-enable no-var*/

    /**
     * Set the components of a vec3 to the given values
     *
     * @param {vec3} out the receiving vector
     * @param {Number} x X component
     * @param {Number} y Y component
     * @param {Number} z Z component
     * @returns {vec3} out
     */
    function set$2(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
    /**
     * Adds two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */

    function add(out, a, b) {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out;
    }
    /**
     * Subtracts vector b from vector a
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */

    function subtract(out, a, b) {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out;
    }
    /**
     * Calculates the length of a vec3
     *
     * @param {vec3} a vector to calculate length of
     * @returns {Number} length of a
     */

    function length(a) {
      var x = a[0],
          y = a[1],
          z = a[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
    /**
     * Normalize a vec3
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a vector to normalize
     * @returns {vec3} out
     */

    function normalize(out, a) {
      var x = a[0],
          y = a[1],
          z = a[2];
      var len = x * x + y * y + z * z;

      if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
      }

      return out;
    }
    /**
     * Calculates the dot product of two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} dot product of a and b
     */

    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    /**
     * Scales a vec3 by a scalar number
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to scale
     * @param {Number} b amount to scale the vector by
     * @returns {vec3} out
     */

    function scale$1(out, a, b) {
      out[0] = a[0] * b;
      out[1] = a[1] * b;
      out[2] = a[2] * b;
      return out;
    }
    /**
     * Computes the cross product of two vec3's
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {vec3} out
     */

    function cross(out, a, b) {
      var ax = a[0],
          ay = a[1],
          az = a[2],
          bx = b[0],
          by = b[1],
          bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
    /**
     * Calculates the euclidian distance between two vec3's
     *
     * @param {vec3} a the first operand
     * @param {vec3} b the second operand
     * @returns {Number} distance between a and b
     */

    function distance(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      var z = b[2] - a[2];
      return Math.hypot ? Math.hypot(x, y, z) : hypot(x, y, z);
    }
    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '1'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */

    function transformMat4(out, a, m) {
      var x = a[0],
          y = a[1],
          z = a[2];
      var w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1.0;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
    }

    function hypot() {
      var y = 0;
      var i = arguments.length;

      while (i--) {
        y += arguments[i] * arguments[i];
      }

      return Math.sqrt(y);
    }

    function applyMatrix(out, v, e) {
      var x = v[0],
          y = v[1],
          z = v[2]; // const e = in;

      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      out[0] = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      out[1] = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      out[2] = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return out;
    }
    function matrixToQuaternion(out, te) {
      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;
      var s;

      if (trace > 0) {
        s = 0.5 / Math.sqrt(trace + 1.0);
        out.w = 0.25 / s;
        out.x = (m32 - m23) * s;
        out.y = (m13 - m31) * s;
        out.z = (m21 - m12) * s;
      } else if (m11 > m22 && m11 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
        out.w = (m32 - m23) / s;
        out.x = 0.25 * s;
        out.y = (m12 + m21) / s;
        out.z = (m13 + m31) / s;
      } else if (m22 > m33) {
        s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
        out.w = (m13 - m31) / s;
        out.x = (m12 + m21) / s;
        out.y = 0.25 * s;
        out.z = (m23 + m32) / s;
      } else {
        s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
        out.w = (m21 - m12) / s;
        out.x = (m13 + m31) / s;
        out.y = (m23 + m32) / s;
        out.z = 0.25 * s;
      }

      return this;
    }
    function quaternionToMatrix(out, q) {
      var te = out;
      var x = q.x,
          y = q.y,
          z = q.z,
          w = q.w;
      var x2 = x + x,
          y2 = y + y,
          z2 = z + z;
      var xx = x * x2,
          xy = x * y2,
          xz = x * z2;
      var yy = y * y2,
          yz = y * z2,
          zz = z * z2;
      var wx = w * x2,
          wy = w * y2,
          wz = w * z2;
      te[0] = 1 - (yy + zz);
      te[4] = xy - wz;
      te[8] = xz + wy;
      te[1] = xy + wz;
      te[5] = 1 - (xx + zz);
      te[9] = yz - wx;
      te[2] = xz - wy;
      te[6] = yz + wx;
      te[10] = 1 - (xx + yy); // last column

      te[3] = 0;
      te[7] = 0;
      te[11] = 0; // bottom row

      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return te;
    }
    function setPosition(out, v) {
      var te = out;
      te[12] = v[0];
      te[13] = v[1];
      te[14] = v[2];
      return out;
    }
    function lookAt(te, eye, target, up) {
      var x = [0, 0, 0];
      var y = [0, 0, 0];
      var z = [0, 0, 0];
      subtract(z, eye, target);

      if (length(z) === 0) {
        // eye and target are in the same position
        z[2] = 1;
      }

      normalize(z, z);
      cross(x, up, z);

      if (length(z) === 0) {
        // up and z are parallel
        if (Math.abs(up[2]) === 1) {
          z[0] += 0.0001;
        } else {
          z[2] += 0.0001;
        }

        normalize(z, z);
        cross(x, up, z);
      }

      normalize(x, x);
      cross(y, z, x);
      te[0] = x[0];
      te[4] = y[0];
      te[8] = z[0];
      te[1] = x[1];
      te[5] = y[1];
      te[9] = z[1];
      te[2] = x[2];
      te[6] = y[2];
      te[10] = z[2];
      return te;
    }

    var RADIAN = Math.PI / 180;
    var DEFAULT_FOV = 0.6435011087932844;
    var TEMP_COORD = new Coordinate(0, 0);
    /*!
     * contains code from mapbox-gl-js
     * https://github.com/mapbox/mapbox-gl-js
     * LICENSE : MIT
     * (c) mapbox
     *
     */

    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Get map's fov (field of view);
       * @return {Number} fov in degree
       */
      getFov: function getFov() {
        if (!this._fov) {
          this._fov = DEFAULT_FOV;
        }

        return this._fov / RADIAN;
      },

      /**
       * Set a new fov to map
       * @param {Number} fov new fov in degree
       * @return {Map} this
       */
      setFov: function setFov(fov) {
        if (this.isZooming()) {
          return this;
        }

        fov = Math.max(0.01, Math.min(60, fov));
        if (this._fov === fov) return this;
        var from = this.getFov();
        this._fov = fov * RADIAN;

        this._calcMatrices();

        this._renderLayers();
        /*
          * fovchange event
          * @event Map#fovchange
          * @type {Object}
          * @property {String} type                    - fovchange
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - fovchange from
          * @property {Number} to                      - fovchange to
        */


        this._fireEvent('fovchange', {
          'from': from,
          'to': this.getFov()
        });

        return this;
      },

      /**
       * Get map's bearing
       * @return {Number} bearing in degree
       */
      getBearing: function getBearing() {
        if (!this._angle) {
          return 0;
        }

        return -this._angle / RADIAN;
      },

      /**
       * Set a new bearing to map
       * @param {Number} bearing new bearing in degree
       * @return {Map} this
       */
      setBearing: function setBearing(bearing) {
        if (Browser$1.ie9) {
          throw new Error('map can\'t rotate in IE9.');
        }

        var b = -wrap(bearing, -180, 180) * RADIAN;
        if (this._angle === b) return this;
        var from = this.getBearing();
        /*
          * rotate event
          * @event Map#rotatestart
          * @type {Object}
          * @property {String} type                    - rotatestart
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - bearing rotate from
          * @property {Number} to                      - bearing rotate to
        */

        this._fireEvent('rotatestart', {
          'from': from,
          'to': b
        });

        this._angle = b;

        this._calcMatrices();

        this._renderLayers();
        /*
          * rotate event, alias of rotateend, deprecated
          *
          * @event Map#rotate
          * @type {Object}
          * @property {String} type                    - rotate
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - bearing rotate from
          * @property {Number} to                      - bearing rotate to
        */


        this._fireEvent('rotate', {
          'from': from,
          'to': b
        });
        /*
          * rotateend event
          * @event Map#rotateend
          * @type {Object}
          * @property {String} type                    - rotateend
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - bearing rotate from
          * @property {Number} to                      - bearing rotate to
        */


        this._fireEvent('rotateend', {
          'from': from,
          'to': b
        });

        return this;
      },

      /**
       * Get map's pitch
       * @return {Number} pitch in degree
       */
      getPitch: function getPitch() {
        if (!this._pitch) {
          return 0;
        }

        return this._pitch / Math.PI * 180;
      },

      /**
       * Set a new pitch to map
       * @param {Number} pitch new pitch in degree
       * @return {Map} this
       */
      setPitch: function setPitch(pitch) {
        if (Browser$1.ie9) {
          throw new Error('map can\'t tilt in IE9.');
        }

        var p = clamp(pitch, 0, this.options['maxPitch']) * RADIAN;
        if (this._pitch === p) return this;
        var from = this.getPitch();
        /*
          * rotate event
          * @event Map#pitchstart
          * @type {Object}
          * @property {String} type                    - pitchstart
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - pitch from
          * @property {Number} to                      - pitch to
        */

        this._fireEvent('pitchstart', {
          'from': from,
          'to': p
        });

        this._pitch = p;

        this._calcMatrices();

        this._renderLayers();
        /**
          * pitch event, alias of pitchend, deprecated
          * @event Map#pitch
          * @type {Object}
          * @property {String} type                    - pitch
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - pitch from
          * @property {Number} to                      - pitch to
          */


        this._fireEvent('pitch', {
          'from': from,
          'to': p
        });
        /**
          * pitchend event
          * @event Map#pitchend
          * @type {Object}
          * @property {String} type                    - pitchend
          * @property {Map} target                     - the map fires event
          * @property {Number} from                    - pitchend from
          * @property {Number} to                      - pitchend to
          */


        this._fireEvent('pitchend', {
          'from': from,
          'to': p
        });

        return this;
      },

      /**
       * Whether the map is rotating or tilting.
       * @return {Boolean}
       * @private
       */
      isTransforming: function isTransforming() {
        return !!(this._pitch || this._angle);
      },
      getFrustumAltitude: function getFrustumAltitude() {
        return this._frustumAltitude;
      },
      _calcFrustumAltitude: function _calcFrustumAltitude() {
        var pitch = 90 - this.getPitch();
        var fov = this.getFov() / 2;
        var cameraAlt = this.cameraPosition ? this.cameraPosition[2] : 0;

        if (fov <= pitch) {
          return cameraAlt;
        }

        fov = Math.PI * fov / 180;
        var d1 = new Point(this.cameraPosition).distanceTo(new Point(this.cameraLookAt)),
            d2 = cameraAlt * Math.tan(fov * 2);
        var d = Math.tan(fov) * (d1 + d2);
        return cameraAlt + d;
      },

      /**
       * Convert 2d point at target zoom to containerPoint at current zoom
       * @param  {Point} point 2d point at target zoom
       * @param  {Number} zoom  point's zoom
       * @param  {Number} [altitude=0]  target's altitude in 2d point system at target zoom
       * @return {Point}       containerPoint at current zoom
       * @private
       * @function
       */
      _pointToContainerPoint: function () {
        var a = [0, 0, 0];
        return function (point, zoom, altitude, out) {
          if (altitude === void 0) {
            altitude = 0;
          }

          point = this._pointToPoint(point, zoom, out);

          if (this.isTransforming() || altitude) {
            //convert altitude at zoom to current zoom
            altitude *= this._getResolution(zoom) / this._getResolution();
            var _scale = this._glScale;
            set$2(a, point.x * _scale, point.y * _scale, altitude * _scale);

            var t = this._projIfBehindCamera(a, this.cameraPosition, this.cameraForward);

            applyMatrix(t, t, this.projViewMatrix);
            var w2 = this.width / 2,
                h2 = this.height / 2;
            t[0] = t[0] * w2 + w2;
            t[1] = -(t[1] * h2) + h2;

            if (out) {
              out.x = t[0];
              out.y = t[1];
              return out;
            }

            return new Point(t[0], t[1]);
          } else {
            var centerPoint = this._prjToPoint(this._getPrjCenter(), undefined, TEMP_COORD);

            if (out) {
              out.x = point.x;
              out.y = point.y;
            } else {
              out = point;
            }

            out._sub(centerPoint.x, centerPoint.y);

            out.set(out.x, -out.y);
            return out._add(this.width / 2, this.height / 2);
          }
        };
      }(),
      // https://forum.unity.com/threads/camera-worldtoscreenpoint-bug.85311/#post-2121212
      _projIfBehindCamera: function () {
        var vectorFromCam = new Array(3);
        var proj = new Array(3);
        var sub = new Array(3);
        return function (position, cameraPos, camForward) {
          subtract(vectorFromCam, position, cameraPos);
          var camNormDot = dot(camForward, vectorFromCam);

          if (camNormDot <= 0) {
            scale$1(proj, camForward, camNormDot * 1.01);
            add(position, cameraPos, subtract(sub, vectorFromCam, proj));
          }

          return position;
        };
      }(),

      /**
       * Convert containerPoint at current zoom to 2d point at target zoom
       * from mapbox-gl-js
       * @param  {Point} p    container point at current zoom
       * @param  {Number} zoom target zoom, current zoom in default
       * @return {Point}      2d point at target zoom
       * @private
       * @function
       */
      _containerPointToPoint: function () {
        var cp = [0, 0, 0],
            coord0 = [0, 0, 0, 1],
            coord1 = [0, 0, 0, 1];
        return function (p, zoom, out) {
          if (this.isTransforming()) {
            var w2 = this.width / 2 || 1,
                h2 = this.height / 2 || 1;
            set$2(cp, (p.x - w2) / w2, (h2 - p.y) / h2, 0);
            set$2(coord0, cp[0], cp[1], 0);
            set$2(coord1, cp[0], cp[1], 1);
            coord0[3] = coord1[3] = 1;
            applyMatrix(coord0, coord0, this.projViewMatrixInverse);
            applyMatrix(coord1, coord1, this.projViewMatrixInverse);
            var x0 = coord0[0];
            var x1 = coord1[0];
            var y0 = coord0[1];
            var y1 = coord1[1];
            var z0 = coord0[2];
            var z1 = coord1[2];
            var t = z0 === z1 ? 0 : (0 - z0) / (z1 - z0);

            var _x = interpolate(x0, x1, t);

            var _y = interpolate(y0, y1, t);

            if (out) {
              out.x = _x;
              out.y = _y;
            } else {
              out = new Point(_x, _y);
            }

            out._multi(1 / this._glScale);

            return zoom === undefined || this.getZoom() === zoom ? out : this._pointToPointAtZoom(out, zoom, out);
          }

          var centerPoint = this._prjToPoint(this._getPrjCenter(), zoom, out),
              scale$$1 = zoom !== undefined ? this._getResolution() / this._getResolution(zoom) : 1;

          var x = scale$$1 * (p.x - this.width / 2),
              y = scale$$1 * (p.y - this.height / 2);
          return centerPoint._add(x, -y);
        };
      }(),

      /**
       * GL Matrices in maptalks (based on THREE):
       * //based on point at map's gl world zoom, by map.coordToPoint(coord, map.getGLZoom())
       * map.cameraPosition
       * map.cameraLookAt
       * map.cameraUp       //camera's up vector
       * map.cameraForward  //camera's forward vector
       * map.cameraWorldMatrix
       * map.projMatrix
       * map.viewMatrix = cameraWorldMatrix.inverse()
       * map.projViewMatrix = projMatrix * viewMatrix
       * map.projViewMatrixInverse = projViewMatrix.inverse()
       *  @private
       */
      _calcMatrices: function () {
        // closure matrixes to reuse
        var m0 = createMat4(),
            m1 = createMat4();
        return function () {
          //必须先删除缓存的常用值，否则后面计算常用值时，会循环引用造成错误
          delete this._mapRes;
          delete this._mapGlRes;
          delete this._mapExtent2D;
          delete this._mapGlExtent2D;
          var size = this.getSize();
          var w = size.width || 1,
              h = size.height || 1;
          this._glScale = this.getGLScale();
          var pitch = this.getPitch() * Math.PI / 180; // camera world matrix

          var worldMatrix = this._getCameraWorldMatrix(); // get field of view


          var fov = this.getFov() * Math.PI / 180;

          var farZ = this._getCameraFar(fov, this.getPitch());

          this.cameraFar = farZ;
          this.cameraNear = Math.max(this._glScale * this.getResolution(this.getGLZoom()) * Math.cos(pitch), 0.1); // camera projection matrix

          var projMatrix = this.projMatrix || createMat4();
          perspective(projMatrix, fov, w / h, this.cameraNear, farZ);
          this.projMatrix = projMatrix; // view matrix

          this.viewMatrix = invert(m0, worldMatrix); // matrix for world point => screen point

          this.projViewMatrix = multiply(this.projViewMatrix || createMat4(), projMatrix, this.viewMatrix);

          this._calcCascadeMatrixes(); // matrix for screen point => world point


          this.projViewMatrixInverse = multiply(this.projViewMatrixInverse || createMat4(), worldMatrix, invert(m1, projMatrix));
          this.domCssMatrix = this._calcDomMatrix();
          this._frustumAltitude = this._calcFrustumAltitude(); //缓存常用的值

          this._mapRes = this._getResolution();
          this._mapGlRes = this._getResolution(this.getGLZoom());
          this._mapExtent2D = this._get2DExtent();
          this._mapGlExtent2D = this._get2DExtent(this.getGLZoom());
        };
      }(),
      _getCameraFar: function _getCameraFar(fov, pitch) {
        var cameraCenterDistance = this.cameraCenterDistance = distance(this.cameraPosition, this.cameraLookAt);
        var farZ = cameraCenterDistance;

        if (pitch > 0) {
          var tanB = Math.tan(fov / 2);
          var tanP = Math.tan(pitch * Math.PI / 180);
          farZ += cameraCenterDistance * tanB / (1 / tanP - tanB);
        } //TODO 地下的图形无法显示


        return farZ + 0.01;
      },
      _calcCascadeMatrixes: function () {
        // const cameraLookAt = [];
        // const cameraPosition = [];
        // const cameraUp = [];
        // const cameraForward = [];
        // const cameraWorldMatrix = createMat4();
        var projMatrix = createMat4(); // const viewMatrix = createMat4();

        function cal(curPitch, pitch, out) {
          var w = this.width;
          var h = this.height;
          var fov = this.getFov() * Math.PI / 180; // const worldMatrix = this._getCameraWorldMatrix(
          //     pitch, this.getBearing(),
          //     cameraLookAt, cameraPosition, cameraUp, cameraForward, cameraWorldMatrix
          // );
          // get field of view

          var farZ = this._getCameraFar(fov, pitch);

          var cameraCenterDistance = this.cameraCenterDistance;
          farZ = cameraCenterDistance + (farZ - cameraCenterDistance) / Math.cos((90 - pitch) * Math.PI / 180) * Math.cos((90 - curPitch) * Math.PI / 180); // camera projection matrix

          perspective(projMatrix, fov, w / h, 0.1, farZ); // view matrix
          // mat4.invert(viewMatrix, worldMatrix);

          var viewMatrix = this.viewMatrix; // matrix for world point => screen point

          return multiply(out, projMatrix, viewMatrix);
        }

        return function () {
          var pitch = this.getPitch();
          var cascadePitch0 = this.options['cascadePitches'][0];
          var cascadePitch1 = this.options['cascadePitches'][1];
          var projViewMatrix0 = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || createMat4();
          var projViewMatrix1 = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || createMat4();

          if (pitch > cascadePitch0) {
            cal.call(this, pitch, cascadePitch0, projViewMatrix0);
          } else {
            copy(this.cascadeFrustumMatrix0, this.projViewMatrix);
          }

          if (pitch > cascadePitch1) {
            cal.call(this, pitch, cascadePitch1, projViewMatrix1);
          } else {
            copy(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0);
          }
        };
      }(),
      _calcDomMatrix: function () {
        var m = createMat4(),
            m1 = createMat4(),
            minusY = [1, -1, 1],
            arr = [0, 0, 0];
        return function () {
          var width = this.width || 1;
          var height = this.height || 1;
          var cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * height;
          scale(m, this.projMatrix, minusY);
          translate(m, m, set$2(arr, 0, 0, -cameraToCenterDistance)); //[0, 0, cameraToCenterDistance]

          if (this._pitch) {
            rotateX(m, m, this._pitch);
          }

          if (this._angle) {
            rotateZ(m, m, this._angle);
          }

          identity(m1);
          scale(m1, m1, set$2(arr, width / 2, -height / 2, 1)); //[this.width / 2, -this.height / 2, 1]

          return multiply(this.domCssMatrix || createMat4(), m1, m);
        };
      }(),
      _getCameraWorldMatrix: function () {
        var q = {};
        return function () {
          var targetZ = this.getGLZoom();
          var size = this.getSize(),
              scale$$1 = this.getGLScale();

          var center2D = this._prjToPoint(this._prjCenter, targetZ);

          this.cameraLookAt = set$2(this.cameraLookAt || [0, 0, 0], center2D.x, center2D.y, 0);
          var pitch = this.getPitch() * RADIAN;
          var bearing = this.getBearing() * RADIAN;

          var ratio = this._getFovRatio();

          var z = scale$$1 * (size.height || 1) / 2 / ratio;
          var cz = z * Math.cos(pitch); // and [dist] away from map's center on XY plane to tilt the scene.

          var dist = Math.sin(pitch) * z; // when map rotates, the camera's xy position is rotating with the given bearing and still keeps [dist] away from map's center

          var cx = center2D.x - dist * Math.sin(bearing);
          var cy = center2D.y - dist * Math.cos(bearing);
          this.cameraPosition = set$2(this.cameraPosition || [0, 0, 0], cx, cy, cz); // when map rotates, camera's up axis is pointing to bearing from south direction of map
          // default [0,1,0] is the Y axis while the angle of inclination always equal 0
          // if you want to rotate the map after up an incline,please rotateZ like this:
          // let up = new vec3(0,1,0);
          // up.rotateZ(target,radians);

          var d = dist || 1;
          var up = this.cameraUp = set$2(this.cameraUp || [0, 0, 0], Math.sin(bearing) * d, Math.cos(bearing) * d, 0);
          var m = this.cameraWorldMatrix = this.cameraWorldMatrix || createMat4();
          lookAt(m, this.cameraPosition, this.cameraLookAt, up);
          var cameraForward = this.cameraForward || [0, 0, 0];
          subtract(cameraForward, this.cameraLookAt, this.cameraPosition); // similar with unity's camera.transform.forward

          this.cameraForward = normalize(cameraForward, cameraForward); // math from THREE.js

          matrixToQuaternion(q, m);
          quaternionToMatrix(m, q);
          setPosition(m, this.cameraPosition); // mat4.scale(m, m, minusY);

          return m;
        };
      }(),
      _getFovRatio: function _getFovRatio() {
        var fov = this.getFov();
        return Math.tan(fov / 2 * RADIAN);
      },
      _renderLayers: function _renderLayers() {
        if (this.isInteracting()) {
          return;
        }

        var layers = this._getLayers(); // clear canvas layers to prevent unsync painting with tile layers.


        layers.forEach(function (layer) {
          if (!layer) {
            return;
          }

          var renderer = layer._getRenderer();

          if (renderer && renderer.setToRedraw) {
            renderer.setToRedraw();
          }
        });
      }
    });

    function createMat4() {
      return identity(new Array(16));
    }

    Map$1.include(
    /** @lends Map.prototype */
    {
      _onViewChange: function _onViewChange(view) {
        if (!this._viewHistory) {
          this._viewHistory = [];
          this._viewHistoryPointer = 0;
        }

        var old = this._getCurrentView();

        for (var i = this._viewHistory.length - 1; i >= 0; i--) {
          if (equalMapView(view, this._viewHistory[i])) {
            this._viewHistoryPointer = i;

            this._fireViewChange(old, view);

            return;
          }
        }

        if (this._viewHistoryPointer < this._viewHistory.length - 1) {
          // remove old 'next views'
          this._viewHistory.splice(this._viewHistoryPointer + 1);
        }

        this._viewHistory.push(view);

        var count = this.options['viewHistoryCount'];

        if (count > 0 && this._viewHistory.length > count) {
          // remove redundant view
          this._viewHistory.splice(0, this._viewHistory.length - count);
        }

        this._viewHistoryPointer = this._viewHistory.length - 1;
        /**
         * viewchange event
         * @event Map#viewchange
         * @type {Object}
         * @property {String} type - viewchange
         * @property {Map} target - map fires the event
         * @property {Object} old - old view
         * @property {Point} new  - new view
         */

        this._fireViewChange(old, view);
      },

      /**
       * Zoom to the previous map view in view history
       * @return {Object} map view
       */
      zoomToPreviousView: function zoomToPreviousView(options) {
        if (options === void 0) {
          options = {};
        }

        if (!this.hasPreviousView()) {
          return null;
        }

        var view = this._viewHistory[--this._viewHistoryPointer];

        this._zoomToView(view, options);

        return view;
      },

      /**
       * Whether has more previous view
       * @return {Boolean}
       */
      hasPreviousView: function hasPreviousView() {
        if (!this._viewHistory || this._viewHistoryPointer === 0) {
          return false;
        }

        return true;
      },

      /**
       * Zoom to the next view in view history
       * @return {Object} map view
       */
      zoomToNextView: function zoomToNextView(options) {
        if (options === void 0) {
          options = {};
        }

        if (!this.hasNextView()) {
          return null;
        }

        var view = this._viewHistory[++this._viewHistoryPointer];

        this._zoomToView(view, options);

        return view;
      },

      /**
       * Whether has more next view
       * @return {Boolean}
       */
      hasNextView: function hasNextView() {
        if (!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1) {
          return false;
        }

        return true;
      },
      _zoomToView: function _zoomToView(view, options) {
        var _this = this;

        var old = this.getView();

        if (options['animation']) {
          this._animateTo(view, {
            'duration': options['duration']
          }, function (frame) {
            if (frame.state.playState === 'finished') {
              _this._fireViewChange(old, view);
            }
          });
        } else {
          this.setView(view);

          this._fireViewChange(old, view);
        }
      },

      /**
       * Get map view history
       * @return {Object[]}
       */
      getViewHistory: function getViewHistory() {
        return this._viewHistory;
      },
      _fireViewChange: function _fireViewChange(old, view) {
        this._fireEvent('viewchange', {
          'old': old,
          'new': view
        });
      },
      _getCurrentView: function _getCurrentView() {
        if (!this._viewHistory) {
          return null;
        }

        return this._viewHistory[this._viewHistoryPointer];
      }
    });
    Map$1.mergeOptions({
      'viewHistory': true,
      'viewHistoryCount': 10
    });

    /**
     * @property {options} options
     * @property {String}  options.language         - language of the distance tool, zh-CN or en-US
     * @property {Boolean} options.metric           - display result in metric system
     * @property {Boolean} options.imperial         - display result in imperial system.
     * @property {Object}  options.symbol           - symbol of the line
     * @property {Object}  options.vertexSymbol     - symbol of the vertice
     * @property {Object}  options.labelOptions     - construct options of the vertice labels.
     * @memberOf DistanceTool
     * @instance
     */

    var options$h = {
      'mode': 'LineString',
      'language': 'zh-CN',
      //'en-US'
      'metric': true,
      'imperial': false,
      'symbol': {
        'lineColor': '#000',
        'lineWidth': 3,
        'lineOpacity': 1
      },
      'vertexSymbol': {
        'markerType': 'ellipse',
        'markerFill': '#fff',
        'markerLineColor': '#000',
        'markerLineWidth': 3,
        'markerWidth': 11,
        'markerHeight': 11
      },
      'labelOptions': {
        'textSymbol': {
          'textFaceName': 'monospace',
          'textLineSpacing': 1,
          'textHorizontalAlignment': 'right',
          'textDx': 15
        },
        'boxStyle': {
          'padding': [6, 2],
          'symbol': {
            'markerType': 'square',
            'markerFill': '#fff',
            'markerFillOpacity': 0.9,
            'markerLineColor': '#b4b3b3'
          }
        }
      },
      'clearButtonSymbol': [{
        'markerType': 'square',
        'markerFill': '#fff',
        'markerLineColor': '#b4b3b3',
        'markerLineWidth': 2,
        'markerWidth': 15,
        'markerHeight': 15,
        'markerDx': 20
      }, {
        'markerType': 'x',
        'markerWidth': 10,
        'markerHeight': 10,
        'markerDx': 20
      }]
    };
    /**
     * A map tool to help measure distance on the map
     * @category maptool
     * @extends DrawTool
     * @example
     * var distanceTool = new DistanceTool({
     *     'once' : true,
     *     'symbol': {
     *       'lineColor' : '#34495e',
     *       'lineWidth' : 2
     *     },
     *     'vertexSymbol' : {
     *       'markerType'        : 'ellipse',
     *       'markerFill'        : '#1bbc9b',
     *       'markerLineColor'   : '#000',
     *       'markerLineWidth'   : 3,
     *       'markerWidth'       : 10,
     *      'markerHeight'      : 10
     *    },
     *    'language' : 'en-US'
     *  }).addTo(map);
     *
     */

    var DistanceTool =
    /*#__PURE__*/
    function (_DrawTool) {
      _inheritsLoose(DistanceTool, _DrawTool);

      /**
       * @param {options} [options=null] - construct options
       * @param {String} [options.language=zh-CN]         - language of the distance tool, zh-CN or en-US
       * @param {Boolean} [options.metric=true]           - display result in metric system
       * @param {Boolean} [options.imperial=false]        - display result in imperial system.
       * @param {Object}  [options.symbol=null]           - symbol of the line
       * @param {Object}  [options.vertexSymbol=null]     - symbol of the vertice
       * @param {Object}  [options.labelOptions=null]     - construct options of the vertice labels.
       */
      function DistanceTool(options) {
        var _this;

        _this = _DrawTool.call(this, options) || this;

        _this.on('enable', _this._afterEnable, _assertThisInitialized(_assertThisInitialized(_this))).on('disable', _this._afterDisable, _assertThisInitialized(_assertThisInitialized(_this)));

        _this._measureLayers = [];
        return _this;
      }
      /**
       * Clear the measurements
       * @return {DistanceTool} this
       */


      var _proto = DistanceTool.prototype;

      _proto.clear = function clear() {
        if (isArrayHasData(this._measureLayers)) {
          for (var i = 0; i < this._measureLayers.length; i++) {
            this._measureLayers[i].remove();
          }
        }

        delete this._lastMeasure;
        delete this._lastVertex;
        this._measureLayers = [];
        return this;
      }
      /**
       * Get the VectorLayers with the geometries drawn on the map during measuring.
       * @return {Layer[]}
       */
      ;

      _proto.getMeasureLayers = function getMeasureLayers() {
        return this._measureLayers;
      }
      /**
       * Get last measuring result
       * @return {Number}
       */
      ;

      _proto.getLastMeasure = function getLastMeasure() {
        if (!this._lastMeasure) {
          return 0;
        }

        return this._lastMeasure;
      };

      _proto._measure = function _measure(toMeasure) {
        var map = this.getMap();
        var length;

        if (toMeasure instanceof Geometry) {
          length = map.computeGeometryLength(toMeasure);
        } else if (Array.isArray(toMeasure)) {
          length = map.getProjection().measureLength(toMeasure);
        }

        this._lastMeasure = length;
        var units;

        if (this.options['language'] === 'zh-CN') {
          units = [' 米', ' 公里', ' 英尺', ' 英里'];
        } else {
          units = [' m', ' km', ' feet', ' mile'];
        }

        var content = '';

        if (this.options['metric']) {
          content += length < 1000 ? length.toFixed(0) + units[0] : (length / 1000).toFixed(2) + units[1];
        }

        if (this.options['imperial']) {
          length *= 3.2808399;

          if (content.length > 0) {
            content += '\n';
          }

          content += length < 5280 ? length.toFixed(0) + units[2] : (length / 5280).toFixed(2) + units[3];
        }

        return content;
      };

      _proto._registerMeasureEvents = function _registerMeasureEvents() {
        this.on('drawstart', this._msOnDrawStart, this).on('drawvertex', this._msOnDrawVertex, this).on('mousemove', this._msOnMouseMove, this).on('drawend', this._msOnDrawEnd, this);
      };

      _proto._afterEnable = function _afterEnable() {
        this._registerMeasureEvents();
      };

      _proto._afterDisable = function _afterDisable() {
        this.off('drawstart', this._msOnDrawStart, this).off('drawvertex', this._msOnDrawVertex, this).off('mousemove', this._msOnMouseMove, this).off('drawend', this._msOnDrawEnd, this);
      };

      _proto._msOnDrawStart = function _msOnDrawStart(param) {
        var map = this.getMap();
        var uid = UID();
        var layerId = 'distancetool_' + uid;
        var markerLayerId = 'distancetool_markers_' + uid;

        if (!map.getLayer(layerId)) {
          this._measureLineLayer = new VectorLayer(layerId).addTo(map);
          this._measureMarkerLayer = new VectorLayer(markerLayerId).addTo(map);
        } else {
          this._measureLineLayer = map.getLayer(layerId);
          this._measureMarkerLayer = map.getLayer(markerLayerId);
        }

        this._measureLayers.push(this._measureLineLayer);

        this._measureLayers.push(this._measureMarkerLayer); //start marker


        new Marker(param['coordinate'], {
          'symbol': this.options['vertexSymbol']
        }).addTo(this._measureMarkerLayer);
        var content = this.options['language'] === 'zh-CN' ? '起点' : 'start';
        var startLabel = new Label(content, param['coordinate'], this.options['labelOptions']);
        this._lastVertex = startLabel;

        this._measureMarkerLayer.addGeometry(startLabel);
      };

      _proto._msOnMouseMove = function _msOnMouseMove(param) {
        var ms = this._measure(this._msGetCoordsToMeasure(param));

        if (!this._tailMarker) {
          var symbol = extendSymbol(this.options['vertexSymbol']);
          symbol['markerWidth'] /= 2;
          symbol['markerHeight'] /= 2;
          this._tailMarker = new Marker(param['coordinate'], {
            'symbol': symbol
          }).addTo(this._measureMarkerLayer);
          this._tailLabel = new Label(ms, param['coordinate'], this.options['labelOptions']).addTo(this._measureMarkerLayer);
        }

        this._tailMarker.setCoordinates(param['coordinate']);

        this._tailLabel.setContent(ms);

        this._tailLabel.setCoordinates(param['coordinate']);
      };

      _proto._msGetCoordsToMeasure = function _msGetCoordsToMeasure(param) {
        return param['geometry'].getCoordinates().concat([param['coordinate']]);
      };

      _proto._msOnDrawVertex = function _msOnDrawVertex(param) {
        var geometry = param['geometry']; //vertex marker

        new Marker(param['coordinate'], {
          'symbol': this.options['vertexSymbol']
        }).addTo(this._measureMarkerLayer);

        var length = this._measure(geometry);

        var vertexLabel = new Label(length, param['coordinate'], this.options['labelOptions']);

        this._measureMarkerLayer.addGeometry(vertexLabel);

        this._lastVertex = vertexLabel;
      };

      _proto._msOnDrawEnd = function _msOnDrawEnd(param) {
        this._clearTailMarker();

        var size = this._lastVertex.getSize();

        if (!size) {
          size = new Size(10, 10);
        }

        this._addClearMarker(this._lastVertex.getCoordinates(), size['width']);

        var geo = param['geometry'].copy();
        geo.addTo(this._measureLineLayer);
        this._lastMeasure = geo.getLength();
      };

      _proto._addClearMarker = function _addClearMarker(coordinates, dx) {
        var symbol = this.options['clearButtonSymbol'];
        var dxSymbol = {
          'markerDx': (symbol['markerDx'] || 0) + dx,
          'textDx': (symbol['textDx'] || 0) + dx
        };

        if (Array.isArray(symbol)) {
          dxSymbol = symbol.map(function (s) {
            if (s) {
              return {
                'markerDx': (s['markerDx'] || 0) + dx,
                'textDx': (s['textDx'] || 0) + dx
              };
            }

            return null;
          });
        }

        symbol = extendSymbol(symbol, dxSymbol);
        var endMarker = new Marker(coordinates, {
          'symbol': symbol
        });
        var measureLineLayer = this._measureLineLayer,
            measureMarkerLayer = this._measureMarkerLayer;
        endMarker.on('click', function () {
          measureLineLayer.remove();
          measureMarkerLayer.remove(); //return false to stop propagation of event.

          return false;
        }, this);
        endMarker.addTo(this._measureMarkerLayer);
      };

      _proto._clearTailMarker = function _clearTailMarker() {
        if (this._tailMarker) {
          this._tailMarker.remove();

          delete this._tailMarker;
        }

        if (this._tailLabel) {
          this._tailLabel.remove();

          delete this._tailLabel;
        }
      };

      return DistanceTool;
    }(DrawTool);

    DistanceTool.mergeOptions(options$h);

    /**
     * @property {options} options
     * @property {String}  options.language         - language of the distance tool, zh-CN or en-US
     * @property {Boolean} options.metric           - display result in metric system
     * @property {Boolean} options.imperial         - display result in imperial system.
     * @property {Object}  options.symbol           - symbol of the line
     * @property {Object}  options.vertexSymbol     - symbol of the vertice
     * @property {Object}  options.labelOptions     - construct options of the vertice labels.
     * @memberOf AreaTool
     * @instance
     */

    var options$i = {
      'mode': 'Polygon',
      'symbol': {
        'lineColor': '#000000',
        'lineWidth': 2,
        'lineOpacity': 1,
        'lineDasharray': '',
        'polygonFill': '#ffffff',
        'polygonOpacity': 0.5
      }
    };
    /**
     * A map tool to help measure area on the map
     * @category maptool
     * @extends DistanceTool
     * @example
     * var areaTool = new AreaTool({
     *     'once' : true,
     *     'symbol': {
     *       'lineColor' : '#34495e',
     *       'lineWidth' : 2
     *     },
     *     'vertexSymbol' : {
     *       'markerType'        : 'ellipse',
     *       'markerFill'        : '#1bbc9b',
     *       'markerLineColor'   : '#000',
     *       'markerLineWidth'   : 3,
     *       'markerWidth'       : 10,
     *      'markerHeight'      : 10
     *    },
     *    'language' : 'en-US'
     *  }).addTo(map);
     */

    var AreaTool =
    /*#__PURE__*/
    function (_DistanceTool) {
      _inheritsLoose(AreaTool, _DistanceTool);

      /**
       * @param {options} [options=null] - construct options
       * @param {String} [options.language=zh-CN]         - language of the distance tool, zh-CN or en-US
       * @param {Boolean} [options.metric=true]           - display result in metric system
       * @param {Boolean} [options.imperial=false]        - display result in imperial system.
       * @param {Object}  [options.symbol=null]           - symbol of the line
       * @param {Object}  [options.vertexSymbol=null]     - symbol of the vertice
       * @param {Object}  [options.labelOptions=null]     - construct options of the vertice labels.
       */
      function AreaTool(options) {
        var _this;

        _this = _DistanceTool.call(this, options) || this;

        _this.on('enable', _this._afterEnable, _assertThisInitialized(_assertThisInitialized(_this))).on('disable', _this._afterDisable, _assertThisInitialized(_assertThisInitialized(_this)));

        _this._measureLayers = [];
        return _this;
      }

      var _proto = AreaTool.prototype;

      _proto._measure = function _measure(toMeasure) {
        var map = this.getMap();
        var area;

        if (toMeasure instanceof Geometry) {
          area = map.computeGeometryArea(toMeasure);
        } else if (Array.isArray(toMeasure)) {
          area = map.getProjection().measureArea(toMeasure);
        }

        this._lastMeasure = area;
        var units;

        if (this.options['language'] === 'zh-CN') {
          units = [' 平方米', ' 平方公里', ' 平方英尺', ' 平方英里'];
        } else {
          units = [' sq.m', ' sq.km', ' sq.ft', ' sq.mi'];
        }

        var content = '';

        if (this.options['metric']) {
          content += area < 1E6 ? area.toFixed(0) + units[0] : (area / 1E6).toFixed(2) + units[1];
        }

        if (this.options['imperial']) {
          area *= 3.2808399;

          if (content.length > 0) {
            content += '\n';
          }

          var sqmi = 5280 * 5280;
          content += area < sqmi ? area.toFixed(0) + units[2] : (area / sqmi).toFixed(2) + units[3];
        }

        return content;
      };

      _proto._msGetCoordsToMeasure = function _msGetCoordsToMeasure(param) {
        return param['geometry'].getShell().concat([param['coordinate']]);
      };

      _proto._msOnDrawVertex = function _msOnDrawVertex(param) {
        var vertexMarker = new Marker(param['coordinate'], {
          'symbol': this.options['vertexSymbol']
        }).addTo(this._measureMarkerLayer);

        this._measure(param['geometry']);

        this._lastVertex = vertexMarker;
      };

      _proto._msOnDrawEnd = function _msOnDrawEnd(param) {
        this._clearTailMarker();

        var ms = this._measure(param['geometry']);

        var endLabel = new Label(ms, param['coordinate'], this.options['labelOptions']).addTo(this._measureMarkerLayer);
        var size = endLabel.getSize();

        if (!size) {
          size = new Size(10, 10);
        }

        this._addClearMarker(param['coordinate'], size['width']);

        var geo = param['geometry'].copy();
        geo.addTo(this._measureLineLayer);
        this._lastMeasure = geo.getArea();
      };

      return AreaTool;
    }(DistanceTool);

    AreaTool.mergeOptions(options$i);

    DrawTool.registerMode('circle', {
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click'],
      'create': function create(coordinate) {
        return new Circle(coordinate[0], 0);
      },
      'update': function update(path, geometry) {
        var map = geometry.getMap();
        var radius = map.computeLength(geometry.getCenter(), path[path.length - 1]);
        geometry.setRadius(radius);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('freeHandCircle', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(coordinate) {
        return new Circle(coordinate[0], 0);
      },
      'update': function update(path, geometry) {
        var map = geometry.getMap();
        var radius = map.computeLength(geometry.getCenter(), path[path.length - 1]);
        geometry.setRadius(radius);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('ellipse', {
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click'],
      'create': function create(coordinates) {
        return new Ellipse(coordinates[0], 0, 0);
      },
      'update': function update(path, geometry) {
        var map = geometry.getMap();
        var center = geometry.getCenter();
        var rx = map.computeLength(center, new Coordinate({
          x: path[path.length - 1].x,
          y: center.y
        }));
        var ry = map.computeLength(center, new Coordinate({
          x: center.x,
          y: path[path.length - 1].y
        }));
        geometry.setWidth(rx * 2);
        geometry.setHeight(ry * 2);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('freeHandEllipse', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(coordinates) {
        return new Ellipse(coordinates[0], 0, 0);
      },
      'update': function update(path, geometry) {
        var map = geometry.getMap();
        var center = geometry.getCenter();
        var rx = map.computeLength(center, new Coordinate({
          x: path[path.length - 1].x,
          y: center.y
        }));
        var ry = map.computeLength(center, new Coordinate({
          x: center.x,
          y: path[path.length - 1].y
        }));
        geometry.setWidth(rx * 2);
        geometry.setHeight(ry * 2);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('rectangle', {
      'clickLimit': 2,
      'action': ['click', 'mousemove', 'click'],
      'create': function create(coordinates) {
        var rect = new Polygon([]);
        rect._firstClick = coordinates[0];
        return rect;
      },
      'update': function update(coordinates, geometry, param) {
        var map = geometry.getMap();
        var containerPoint = param['containerPoint'];
        var firstClick = map.coordToContainerPoint(geometry._firstClick);
        var ring = [[firstClick.x, firstClick.y], [containerPoint.x, firstClick.y], [containerPoint.x, containerPoint.y], [firstClick.x, containerPoint.y]];
        geometry.setCoordinates(ring.map(function (c) {
          return map.containerPointToCoord(new Point(c));
        }));
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('freeHandRectangle', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(coordinates) {
        var rect = new Polygon([]);
        rect._firstClick = coordinates[0];
        return rect;
      },
      'update': function update(coordinates, geometry) {
        var firstClick = geometry._firstClick;
        var ring = [[firstClick.x, firstClick.y], [coordinates[0].x, firstClick.y], [coordinates[0].x, coordinates[0].y], [firstClick.x, coordinates[0].y]];
        geometry.setCoordinates(ring);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('point', {
      'clickLimit': 1,
      'action': ['click'],
      'create': function create(coordinate) {
        return new Marker(coordinate[0]);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('polygon', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function create(path) {
        return new LineString(path);
      },
      'update': function update(path, geometry) {
        var symbol = geometry.getSymbol();
        geometry.setCoordinates(path);
        var layer = geometry.getLayer();

        if (layer) {
          var polygon = layer.getGeometryById('polygon');

          if (!polygon && path.length >= 3) {
            polygon = new Polygon([path], {
              'id': 'polygon'
            });

            if (symbol) {
              var pSymbol = extendSymbol(symbol, {
                'lineOpacity': 0
              });
              polygon.setSymbol(pSymbol);
            }

            polygon.addTo(layer);
          }

          if (polygon) {
            polygon.setCoordinates(path);
          }
        }
      },
      'generate': function generate(geometry) {
        return new Polygon(geometry.getCoordinates(), {
          'symbol': geometry.getSymbol()
        });
      }
    });
    DrawTool.registerMode('freeHandPolygon', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(path) {
        return new LineString(path);
      },
      'update': function update(path, geometry) {
        var coordinates = geometry.getCoordinates();
        var symbol = geometry.getSymbol();
        geometry.setCoordinates(coordinates.concat(path));
        var layer = geometry.getLayer();

        if (layer) {
          var polygon = layer.getGeometryById('polygon');

          if (!polygon && path.length >= 3) {
            polygon = new Polygon([path], {
              'id': 'polygon'
            });

            if (symbol) {
              var pSymbol = extendSymbol(symbol, {
                'lineOpacity': 0
              });
              polygon.setSymbol(pSymbol);
            }

            polygon.addTo(layer);
          }

          if (polygon) {
            polygon.setCoordinates(path);
          }
        }
      },
      'generate': function generate(geometry) {
        return new Polygon(geometry.getCoordinates(), {
          'symbol': geometry.getSymbol()
        });
      }
    });
    DrawTool.registerMode('linestring', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function create(path) {
        return new LineString(path);
      },
      'update': function update(path, geometry) {
        geometry.setCoordinates(path);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('freeHandLinestring', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(path) {
        return new LineString(path);
      },
      'update': function update(path, geometry) {
        var coordinates = geometry.getCoordinates();
        geometry.setCoordinates(coordinates.concat(path));
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('arccurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function create(path) {
        return new ArcCurve(path);
      },
      'update': function update(path, geometry) {
        geometry.setCoordinates(path);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('quadbeziercurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function create(path) {
        return new QuadBezierCurve(path);
      },
      'update': function update(path, geometry) {
        geometry.setCoordinates(path);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });
    DrawTool.registerMode('cubicbeziercurve', {
      'action': ['click', 'mousemove', 'dblclick'],
      'create': function create(path) {
        return new CubicBezierCurve(path);
      },
      'update': function update(path, geometry) {
        geometry.setCoordinates(path);
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    }); // TODO When action contains 'mousedown', It is in drag mode.

    DrawTool.registerMode('boxZoom', {
      'action': ['mousedown', 'mousemove', 'mouseup'],
      'create': function create(coordinates) {
        var marker = new Marker(coordinates[0]);
        marker._firstClick = coordinates[0];
        return marker;
      },
      'update': function update(path, geometry, param) {
        var map = geometry.getMap();
        var p1 = map.coordToContainerPoint(geometry._firstClick),
            p2 = param['containerPoint'];
        var coords = map.containerPointToCoordinate(new Coordinate(Math.min(p1.x, p2.x), Math.min(p1.y, p2.y)));
        geometry.setCoordinates(coords).updateSymbol({
          markerWidth: Math.abs(p1.x - p2.x),
          markerHeight: Math.abs(p1.y - p2.y)
        });
      },
      'generate': function generate(geometry) {
        return geometry;
      }
    });

    function parse(arcConf) {
      var tileInfo = arcConf['tileInfo'],
          tileSize = [tileInfo['cols'], tileInfo['rows']],
          resolutions = [],
          lods = tileInfo['lods'];

      for (var i = 0, len = lods.length; i < len; i++) {
        resolutions.push(lods[i]['resolution']);
      }

      var fullExtent = arcConf['fullExtent'],
          origin = tileInfo['origin'],
          tileSystem = [1, -1, origin['x'], origin['y']];
      delete fullExtent['spatialReference'];
      return {
        'spatialReference': {
          'resolutions': resolutions,
          'fullExtent': fullExtent
        },
        'tileSystem': tileSystem,
        'tileSize': tileSize
      };
    }

    SpatialReference.loadArcgis = function (url, cb, options) {
      if (options === void 0) {
        options = {
          'jsonp': true
        };
      }

      if (isString(url) && url.substring(0, 1) !== '{') {
        Ajax.getJSON(url, function (err, json) {
          if (err) {
            cb(err);
            return;
          }

          var spatialRef = parse(json);
          cb(null, spatialRef);
        }, options);
      } else {
        if (isString(url)) {
          url = parseJSON(url);
        }

        var spatialRef = parse(url);
        cb(null, spatialRef);
      }

      return this;
    };

    /**
     * @property {Object} options
     * @property {Boolean} [options.eventsPropagation=false]  - whether stop ALL events' propagation.
     * @property {Boolean} [options.eventsToStop=null]  - UI's dom events to stop propagation if eventsPropagation is true.
     * @property {Number}  [options.dx=0]     - pixel offset on x axis
     * @property {Number}  [options.dy=0]     - pixel offset on y axis
     * @property {Boolean} [options.autoPan=false]  - set it to false if you don't want the map to do panning animation to fit the opened UI.
     * @property {Boolean} [options.autoPanDuration=600]    - duration for auto panning animation.
     * @property {Boolean} [options.single=true]    - whether the UI is a global single one, only one UI will be shown at the same time if set to true.
     * @property {Boolean} [options.animation=null]         - fade | scale | fade,scale, add animation effect when showing and hiding.
     * @property {Number}  [options.animationDuration=300]  - animation duration, in milliseconds.
     * @property {Boolean}  [options.pitchWithMap=false]    - whether tilt with map
     * @property {Boolean}  [options.rotateWithMap=false]  - whether rotate with map
     * @memberOf ui.UIComponent
     * @instance
     */

    var options$j = {
      'eventsPropagation': false,
      'eventsToStop': null,
      'dx': 0,
      'dy': 0,
      'autoPan': false,
      'autoPanDuration': 600,
      'single': true,
      'animation': 'scale',
      'animationOnHide': true,
      'animationDuration': 500,
      'pitchWithMap': false,
      'rotateWithMap': false
    };
    /**
     * @classdesc
     * Base class for all the UI component classes, a UI component is a HTMLElement positioned with geographic coordinate. <br>
     * It is abstract and not intended to be instantiated.
     *
     * @category ui
     * @abstract
     * @mixes Eventable
     * @memberOf ui
     * @extends Class
     */

    var UIComponent =
    /*#__PURE__*/
    function (_Eventable) {
      _inheritsLoose(UIComponent, _Eventable);

      /**
       *  Some instance methods subclasses needs to implement:  <br>
       *  <br>
       * 1. Optional, returns the Dom element's position offset  <br>
       * function getOffset : Point  <br>
       *  <br>
       * 2. Method to create UI's Dom element  <br>
       * function buildOn : HTMLElement  <br>
       *  <br>
       * 3 Optional, to provide an event map to register event listeners.  <br>
       * function getEvents : void  <br>
       * 4 Optional, a callback when dom is removed.  <br>
       * function onDomRemove : void  <br>
       * 5 Optional, a callback when UI Component is removed.  <br>
       * function onRemove : void  <br>
       * @param  {Object} options configuration options
       */
      function UIComponent(options) {
        return _Eventable.call(this, options) || this;
      }
      /**
       * Adds the UI Component to a geometry or a map
       * @param {Geometry|Map} owner - geometry or map to addto.
       * @returns {ui.UIComponent} this
       * @fires ui.UIComponent#add
       */


      var _proto = UIComponent.prototype;

      _proto.addTo = function addTo(owner) {
        this._owner = owner; // first time

        this._switchEvents('on');

        if (this.onAdd) {
          this.onAdd();
        }
        /**
         * add event.
         *
         * @event ui.UIComponent#add
         * @type {Object}
         * @property {String} type - add
         * @property {ui.UIComponent} target - UIComponent
         */


        this.fire('add');
        return this;
      }
      /**
       * Get the map it added to
       * @return {Map} map instance
       * @override
       */
      ;

      _proto.getMap = function getMap() {
        if (!this._owner) {
          return null;
        } // is a map


        if (this._owner.getBaseLayer) {
          return this._owner;
        }

        return this._owner.getMap();
      }
      /**
       * Show the UI Component, if it is a global single one, it will close previous one.
       * @param {Coordinate} [coordinate=null] - coordinate to show, default is owner's center
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#showstart
       * @fires ui.UIComponent#showend
       */
      ;

      _proto.show = function show(coordinate) {
        var map = this.getMap();

        if (!map) {
          return this;
        }

        if (!this._mapEventsOn) {
          this._switchMapEvents('on');
        }

        coordinate = coordinate || this._coordinate || this._owner.getCenter();
        var visible = this.isVisible();
        /**
         * showstart event.
         *
         * @event ui.UIComponent#showstart
         * @type {Object}
         * @property {String} type - showstart
         * @property {ui.UIComponent} target - UIComponent
         */

        this.fire('showstart');

        var container = this._getUIContainer();

        this._coordinate = coordinate;

        this._removePrevDOM();

        var dom = this.__uiDOM = this.buildOn(map);
        dom['eventsPropagation'] = this.options['eventsPropagation'];

        if (!dom) {
          /**
           * showend event.
           *
           * @event ui.UIComponent#showend
           * @type {Object}
           * @property {String} type - showend
           * @property {ui.UIComponent} target - UIComponent
           */
          this.fire('showend');
          return this;
        }

        this._measureSize(dom);

        if (this._singleton()) {
          map[this._uiDomKey()] = dom;
        }

        this._setPosition();

        dom.style[TRANSITION] = null;
        container.appendChild(dom);

        var anim = this._getAnimation();

        if (visible) {
          anim.ok = false;
        }

        if (anim.ok) {
          if (anim.fade) {
            dom.style.opacity = 0;
          }

          if (anim.scale) {
            if (this.getTransformOrigin) {
              var origin = this.getTransformOrigin();
              dom.style[TRANSFORMORIGIN] = origin;
            }

            dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
          }
        }

        dom.style.display = '';

        if (this.options['eventsToStop']) {
          on(dom, this.options['eventsToStop'], stopPropagation);
        } //autoPan


        if (this.options['autoPan']) {
          this._autoPan();
        }

        var transition = anim.transition;

        if (anim.ok && transition) {
          /* eslint-disable no-unused-expressions */
          // trigger transition
          dom.offsetHeight;
          /* eslint-enable no-unused-expressions */

          if (transition) {
            dom.style[TRANSITION] = transition;
          }

          if (anim.fade) {
            dom.style.opacity = 1;
          }

          if (anim.scale) {
            dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(1)';
          }
        }

        this.fire('showend');
        return this;
      }
      /**
       * Hide the UI Component.
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#hide
       */
      ;

      _proto.hide = function hide() {
        var _this = this;

        if (!this.getDOM() || !this.getMap()) {
          return this;
        }

        var anim = this._getAnimation(),
            dom = this.getDOM();

        if (!this.options['animationOnHide']) {
          anim.ok = false;
        }

        if (!anim.ok) {
          dom.style.display = 'none';
          /**
          * hide event.
          *
          * @event ui.UIComponent#hide
          * @type {Object}
          * @property {String} type - hide
          * @property {ui.UIComponent} target - UIComponent
          */

          this.fire('hide');
        } else {
          /* eslint-disable no-unused-expressions */
          dom.offsetHeight;
          /* eslint-enable no-unused-expressions */

          dom.style[TRANSITION] = anim.transition;
          setTimeout(function () {
            dom.style.display = 'none';

            _this.fire('hide');
          }, this.options['animationDuration']);
        }

        if (anim.fade) {
          dom.style.opacity = 0;
        }

        if (anim.scale) {
          dom.style[TRANSFORM] = this._toCSSTranslate(this._pos) + ' scale(0)';
        }

        return this;
      }
      /**
       * Decide whether the ui component is open
       * @returns {Boolean} true|false
       */
      ;

      _proto.isVisible = function isVisible() {
        var dom = this.getDOM();
        return this.getMap() && dom && dom.parentNode && dom.style.display !== 'none';
      }
      /**
       * Remove the UI Component
       * @return {ui.UIComponent} this
       * @fires ui.UIComponent#hide
       * @fires ui.UIComponent#remove
       */
      ;

      _proto.remove = function remove() {
        delete this._mapEventsOn;

        if (!this._owner) {
          return this;
        }

        this.hide();

        this._switchEvents('off');

        if (this.onRemove) {
          this.onRemove();
        }

        if (!this._singleton() && this.__uiDOM) {
          this._removePrevDOM();
        }

        delete this._owner;
        /**
         * remove event.
         *
         * @event ui.UIComponent#remove
         * @type {Object}
         * @property {String} type - remove
         * @property {ui.UIComponent} target - UIComponent
         */

        this.fire('remove');
        return this;
      }
      /**
       * Get pixel size of the UI Component.
       * @return {Size} size
       */
      ;

      _proto.getSize = function getSize() {
        if (this._size) {
          return this._size.copy();
        } else {
          return null;
        }
      };

      _proto.getOwner = function getOwner() {
        return this._owner;
      };

      _proto.getDOM = function getDOM() {
        return this.__uiDOM;
      };

      _proto.getPosition = function getPosition() {
        if (!this.getMap()) {
          return null;
        }

        var p = this._getViewPoint()._round();

        if (this.getOffset) {
          var o = this.getOffset()._round();

          if (o) {
            p._add(o);
          }
        }

        return p;
      };

      _proto._getAnimation = function _getAnimation() {
        var anim = {
          'fade': false,
          'scale': false
        };
        var animations = this.options['animation'] ? this.options['animation'].split(',') : [];

        for (var i = 0; i < animations.length; i++) {
          var trimed = trim(animations[i]);

          if (trimed === 'fade') {
            anim.fade = true;
          } else if (trimed === 'scale') {
            anim.scale = true;
          }
        }

        var transition = null;

        if (anim.fade) {
          transition = 'opacity ' + this.options['animationDuration'] + 'ms';
        }

        if (anim.scale) {
          transition = transition ? transition + ',' : '';
          transition += TRANSFORM + ' ' + this.options['animationDuration'] + 'ms';
        }

        anim.transition = transition;
        anim.ok = transition !== null;
        return anim;
      };

      _proto._getViewPoint = function _getViewPoint() {
        return this.getMap().coordToViewPoint(this._coordinate)._add(this.options['dx'], this.options['dy']);
      };

      _proto._autoPan = function _autoPan() {
        var map = this.getMap(),
            dom = this.getDOM();

        if (map.isMoving()) {
          return;
        }

        var point = this._pos;
        var mapSize = map.getSize(),
            mapWidth = mapSize['width'],
            mapHeight = mapSize['height'];
        var containerPoint = map.viewPointToContainerPoint(point);
        var clientWidth = parseInt(dom.clientWidth),
            clientHeight = parseInt(dom.clientHeight);
        var left = 0,
            top = 0;

        if (containerPoint.x < 0) {
          left = -(containerPoint.x - clientWidth / 2);
        } else if (containerPoint.x + clientWidth - 35 > mapWidth) {
          left = mapWidth - (containerPoint.x + clientWidth * 3 / 2);
        }

        if (containerPoint.y - clientHeight < 0) {
          top = -(containerPoint.y - clientHeight) + 50;
        } else if (containerPoint.y > mapHeight) {
          top = mapHeight - containerPoint.y - clientHeight - 30;
        }

        if (top !== 0 || left !== 0) {
          map.panBy(new Point(left, top), {
            'duration': this.options['autoPanDuration']
          });
        }
      }
      /**
       * Measure dom's size
       * @param  {HTMLElement} dom - element to measure
       * @return {Size} size
       * @private
       */
      ;

      _proto._measureSize = function _measureSize(dom) {
        var container = this._getUIContainer();

        dom.style.position = 'absolute';
        dom.style.left = -99999 + 'px';
        var anchor = dom.style.bottom ? 'bottom' : 'top';
        dom.style[anchor] = -99999 + 'px';
        dom.style.display = '';
        container.appendChild(dom);
        this._size = new Size(dom.clientWidth, dom.clientHeight);
        dom.style.display = 'none';
        dom.style.left = '0px';
        dom.style[anchor] = '0px';
        return this._size;
      }
      /**
       * Remove previous UI DOM if it has.
       *
       * @private
       */
      ;

      _proto._removePrevDOM = function _removePrevDOM() {
        if (this.onDomRemove) {
          this.onDomRemove();
        }

        var eventsToStop = this.options['eventsToStop'];

        if (this._singleton()) {
          var map = this.getMap(),
              key = this._uiDomKey();

          if (map[key]) {
            if (eventsToStop) {
              off(map[key], eventsToStop, stopPropagation);
            }

            removeDomNode(map[key]);
            delete map[key];
          }

          delete this.__uiDOM;
        } else if (this.__uiDOM) {
          if (eventsToStop) {
            off(this.__uiDOM, eventsToStop, stopPropagation);
          }

          removeDomNode(this.__uiDOM);
          delete this.__uiDOM;
        }
      }
      /**
       * generate the cache key to store the singletong UI DOM
       * @private
       * @return {String} cache key
       */
      ;

      _proto._uiDomKey = function _uiDomKey() {
        return '__ui_' + this._getClassName();
      };

      _proto._singleton = function _singleton() {
        return this.options['single'];
      };

      _proto._getUIContainer = function _getUIContainer() {
        return this.getMap()._panels['ui'];
      };

      _proto._getClassName = function _getClassName() {
        return 'UIComponent';
      };

      _proto._switchMapEvents = function _switchMapEvents(to) {
        var map = this.getMap();

        if (!map) {
          return;
        }

        this._mapEventsOn = to === 'on';

        var events = this._getDefaultEvents();

        if (this.getEvents) {
          extend(events, this.getEvents());
        }

        if (events) {
          for (var p in events) {
            if (events.hasOwnProperty(p)) {
              map[to](p, events[p], this);
            }
          }
        }
      };

      _proto._switchEvents = function _switchEvents(to) {
        this._switchMapEvents(to);

        var ownerEvents = this._getOwnerEvents();

        if (this._owner) {
          for (var p in ownerEvents) {
            if (ownerEvents.hasOwnProperty(p)) {
              this._owner[to](p, ownerEvents[p], this);
            }
          }
        }
      };

      _proto._getDefaultEvents = function _getDefaultEvents() {
        return {
          'zooming rotate pitch': this.onEvent,
          'zoomend': this.onZoomEnd,
          'moving': this.onMoving
        };
      };

      _proto._getOwnerEvents = function _getOwnerEvents() {
        var events = {};

        if (this._owner && this._owner instanceof Geometry) {
          events.positionchange = this.onGeometryPositionChange;
        }

        if (this.getOwnerEvents) {
          extend(events, this.getOwnerEvents());
        }

        return events;
      };

      _proto.onGeometryPositionChange = function onGeometryPositionChange(param) {
        if (this._owner && this.isVisible()) {
          this.show(param['target'].getCenter());
        }
      };

      _proto.onMoving = function onMoving() {
        if (this.isVisible() && this.getMap().isTransforming()) {
          this._updatePosition();
        }
      };

      _proto.onEvent = function onEvent() {
        if (this.isVisible()) {
          this._updatePosition();
        }
      };

      _proto.onZoomEnd = function onZoomEnd() {
        if (this.isVisible()) {
          // when zoomend, map container is reset, position should be updated in current frame
          this._setPosition();
        }
      };

      _proto._updatePosition = function _updatePosition() {
        // update position in the next frame to sync with layers
        var renderer = this.getMap()._getRenderer();

        renderer.callInNextFrame(this._setPosition.bind(this));
      };

      _proto._setPosition = function _setPosition() {
        var dom = this.getDOM();
        if (!dom) return;
        dom.style[TRANSITION] = null;
        var p = this.getPosition();
        this._pos = p;
        dom.style[TRANSFORM] = this._toCSSTranslate(p) + ' scale(1)';
      };

      _proto._toCSSTranslate = function _toCSSTranslate(p) {
        if (!p) {
          return '';
        }

        if (Browser$1.any3d) {
          var map = this.getMap(),
              bearing = map ? map.getBearing() : 0,
              pitch = map ? map.getPitch() : 0;
          var r = '';

          if (this.options['pitchWithMap'] && pitch) {
            r += " rotateX(" + Math.round(pitch) + "deg)";
          }

          if (this.options['rotateWithMap'] && bearing) {
            r += " rotateZ(" + Math.round(-bearing) + "deg)";
          }

          return 'translate3d(' + p.x + 'px,' + p.y + 'px, 0px)' + r;
        } else {
          return 'translate(' + p.x + 'px,' + p.y + 'px)';
        }
      }
      /*
       *
       * @param {Geometry||ui.UIMarker} owner
       * @return {Boolean}
       */
      ;

      UIComponent.isSupport = function isSupport(owner) {
        if (owner && isFunction(owner.on) && isFunction(owner.off) && isFunction(owner.getCenter)) {
          return true;
        }

        return false;
      };

      return UIComponent;
    }(Eventable(Class));

    UIComponent.mergeOptions(options$j);

    /**
     * @property {Object} options - construct options
     * @property {Boolean} [options.draggable=false]  - if the marker can be dragged.
     * @property {Number}  [options.single=false]     - if the marker is a global single one.
     * @property {String|HTMLElement}  options.content - content of the marker, can be a string type HTML code or a HTMLElement.
     * @memberOf ui.UIMarker
     * @instance
     */

    var options$k = {
      'eventsPropagation': true,
      'draggable': false,
      'single': false,
      'content': null
    };
    var domEvents =
    /**
     * mousedown event
     * @event ui.UIMarker#mousedown
     * @type {Object}
     * @property {String} type                    - mousedown
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousedown ' +
    /**
     * mouseup event
     * @event ui.UIMarker#mouseup
     * @type {Object}
     * @property {String} type                    - mouseup
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseup ' +
    /**
     * mouseenter event
     * @event ui.UIMarker#mouseenter
     * @type {Object}
     * @property {String} type                    - mouseenter
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseenter ' +
    /**
     * mouseover event
     * @event ui.UIMarker#mouseover
     * @type {Object}
     * @property {String} type                    - mouseover
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseover ' +
    /**
     * mouseout event
     * @event ui.UIMarker#mouseout
     * @type {Object}
     * @property {String} type                    - mouseout
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mouseout ' +
    /**
     * mousemove event
     * @event ui.UIMarker#mousemove
     * @type {Object}
     * @property {String} type                    - mousemove
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'mousemove ' +
    /**
     * click event
     * @event ui.UIMarker#click
     * @type {Object}
     * @property {String} type                    - click
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'click ' +
    /**
     * dblclick event
     * @event ui.UIMarker#dblclick
     * @type {Object}
     * @property {String} type                    - dblclick
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'dblclick ' +
    /**
     * contextmenu event
     * @event ui.UIMarker#contextmenu
     * @type {Object}
     * @property {String} type                    - contextmenu
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'contextmenu ' +
    /**
     * keypress event
     * @event ui.UIMarker#keypress
     * @type {Object}
     * @property {String} type                    - keypress
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'keypress ' +
    /**
     * touchstart event
     * @event ui.UIMarker#touchstart
     * @type {Object}
     * @property {String} type                    - touchstart
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchstart ' +
    /**
     * touchmove event
     * @event ui.UIMarker#touchmove
     * @type {Object}
     * @property {String} type                    - touchmove
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchmove ' +
    /**
     * touchend event
     * @event ui.UIMarker#touchend
     * @type {Object}
     * @property {String} type                    - touchend
     * @property {UIMarker} target    - the uimarker fires event
     * @property {Coordinate} coordinate - coordinate of the event
     * @property {Point} containerPoint  - container point of the event
     * @property {Point} viewPoint       - view point of the event
     * @property {Event} domEvent                 - dom event
     */
    'touchend';
    /**
     *
     * @classdesc
     * Class for UI Marker, a html based marker positioned by geographic coordinate. <br>
     *
     * @category ui
     * @extends ui.UIComponent
     * @mixes Handlerable
     * @memberOf ui
     * @example
     * var dom = document.createElement('div');
     * dom.innerHTML = 'hello ui marker';
     * var marker = new maptalks.ui.UIMarker([0, 0], {
     *      draggable : true,
     *      content : dom
     *  }).addTo(map);
     */

    var UIMarker =
    /*#__PURE__*/
    function (_Handlerable) {
      _inheritsLoose(UIMarker, _Handlerable);

      /**
       * As it's renderered by HTMLElement such as a DIV, it: <br>
       * 1. always on the top of all the map layers <br>
       * 2. can't be snapped as it's not drawn on the canvas. <br>
       * @param  {Coordinate} coordinate - UIMarker's coordinates
       * @param {Object} options - options defined in [UIMarker]{@link UIMarker#options}
       */
      function UIMarker(coordinate, options) {
        var _this;

        _this = _Handlerable.call(this, options) || this;
        _this._markerCoord = new Coordinate(coordinate);
        return _this;
      } // TODO: obtain class in super


      var _proto = UIMarker.prototype;

      _proto._getClassName = function _getClassName() {
        return 'UIMarker';
      }
      /**
       * Sets the coordinates
       * @param {Coordinate} coordinates - UIMarker's coordinate
       * @returns {UIMarker} this
       * @fires UIMarker#positionchange
       */
      ;

      _proto.setCoordinates = function setCoordinates(coordinates) {
        this._markerCoord = coordinates;
        /**
         * positionchange event.
         *
         * @event ui.UIMarker#positionchange
         * @type {Object}
         * @property {String} type - positionchange
         * @property {UIMarker} target - ui marker
         */

        this.fire('positionchange');

        if (this.isVisible()) {
          this._coordinate = this._markerCoord;

          this._setPosition();
        }

        return this;
      }
      /**
       * Gets the coordinates
       * @return {Coordinate} coordinates
       */
      ;

      _proto.getCoordinates = function getCoordinates() {
        return this._markerCoord;
      }
      /**
       * Sets the content of the UIMarker
       * @param {String|HTMLElement} content - UIMarker's content
       * @returns {UIMarker} this
       * @fires UIMarker#contentchange
       */
      ;

      _proto.setContent = function setContent(content) {
        var old = this.options['content'];
        this.options['content'] = content;
        /**
         * contentchange event.
         *
         * @event ui.UIMarker#contentchange
         * @type {Object}
         * @property {String} type - contentchange
         * @property {UIMarker} target - ui marker
         * @property {String|HTMLElement} old      - old content
         * @property {String|HTMLElement} new      - new content
         */

        this.fire('contentchange', {
          'old': old,
          'new': content
        });

        if (this.isVisible()) {
          this.show();
        }

        return this;
      }
      /**
       * Gets the content of the UIMarker
       * @return {String|HTMLElement} content
       */
      ;

      _proto.getContent = function getContent() {
        return this.options['content'];
      };

      _proto.onAdd = function onAdd() {
        this.show();
      }
      /**
       * Show the UIMarker
       * @returns {UIMarker} this
       * @fires UIMarker#showstart
       * @fires UIMarker#showend
       */
      ;

      _proto.show = function show() {
        return _Handlerable.prototype.show.call(this, this._markerCoord);
      }
      /**
       * Flash the UIMarker, show and hide by certain internal for times of count.
       *
       * @param {Number} [interval=100]     - interval of flash, in millisecond (ms)
       * @param {Number} [count=4]          - flash times
       * @param {Function} [cb=null]        - callback function when flash ended
       * @param {*} [context=null]          - callback context
       * @return {UIMarker} this
       */
      ;

      _proto.flash = function flash$$1(interval, count, cb, context) {
        return flash.call(this, interval, count, cb, context);
      }
      /**
       * A callback method to build UIMarker's HTMLElement
       * @protected
       * @param {Map} map - map to be built on
       * @return {HTMLElement} UIMarker's HTMLElement
       */
      ;

      _proto.buildOn = function buildOn() {
        var dom;

        if (isString(this.options['content'])) {
          dom = createEl('div');
          dom.innerHTML = this.options['content'];
        } else {
          dom = this.options['content'];
        }

        this._registerDOMEvents(dom);

        return dom;
      }
      /**
       * Gets UIMarker's HTMLElement's position offset, it's caculated dynamically accordiing to its actual size.
       * @protected
       * @return {Point} offset
       */
      ;

      _proto.getOffset = function getOffset() {
        var size = this.getSize();
        return new Point(-size.width / 2, -size.height / 2);
      }
      /**
       * Gets UIMarker's transform origin for animation transform
       * @protected
       * @return {Point} transform origin
       */
      ;

      _proto.getTransformOrigin = function getTransformOrigin() {
        return 'center center';
      };

      _proto.onDomRemove = function onDomRemove() {
        var dom = this.getDOM();

        this._removeDOMEvents(dom);
      }
      /**
       * Whether the uimarker is being dragged.
       * @returns {Boolean}
       */
      ;

      _proto.isDragging = function isDragging() {
        if (this['draggable']) {
          return this['draggable'].isDragging();
        }

        return false;
      };

      _proto._registerDOMEvents = function _registerDOMEvents(dom) {
        on(dom, domEvents, this._onDomEvents, this);
      };

      _proto._onDomEvents = function _onDomEvents(e) {
        var event = this.getMap()._parseEvent(e, e.type);

        this.fire(e.type, event);
      };

      _proto._removeDOMEvents = function _removeDOMEvents(dom) {
        off(dom, domEvents, this._onDomEvents, this);
      }
      /**
       * Get the connect points of panel for connector lines.
       * @private
       */
      ;

      _proto._getConnectPoints = function _getConnectPoints() {
        var map = this.getMap();
        var containerPoint = map.coordToContainerPoint(this.getCoordinates());
        var size = this.getSize(),
            width = size.width,
            height = size.height;
        var anchors = [//top center
        map.containerPointToCoordinate(containerPoint.add(-width / 2, 0)), //middle right
        map.containerPointToCoordinate(containerPoint.add(width / 2, 0)), //bottom center
        map.containerPointToCoordinate(containerPoint.add(0, height / 2)), //middle left
        map.containerPointToCoordinate(containerPoint.add(0, -height / 2))];
        return anchors;
      };

      return UIMarker;
    }(Handlerable(UIComponent));

    UIMarker.mergeOptions(options$k);
    var EVENTS$1 = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';

    var UIMarkerDragHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(UIMarkerDragHandler, _Handler);

      function UIMarkerDragHandler(target) {
        return _Handler.call(this, target) || this;
      }

      var _proto2 = UIMarkerDragHandler.prototype;

      _proto2.addHooks = function addHooks() {
        this.target.on(EVENTS$1, this._startDrag, this);
      };

      _proto2.removeHooks = function removeHooks() {
        this.target.off(EVENTS$1, this._startDrag, this);
      };

      _proto2._startDrag = function _startDrag(param) {
        var domEvent = param['domEvent'];

        if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
          return;
        }

        if (this.isDragging()) {
          return;
        }

        this.target.on('click', this._endDrag, this);
        this._lastCoord = param['coordinate'];
        this._lastPoint = param['containerPoint'];

        this._prepareDragHandler();

        this._dragHandler.onMouseDown(param['domEvent']);
        /**
         * drag start event
         * @event ui.UIMarker#dragstart
         * @type {Object}
         * @property {String} type                    - dragstart
         * @property {UIMarker} target    - the uimarker fires event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        this.target.fire('dragstart', param);
      };

      _proto2._prepareDragHandler = function _prepareDragHandler() {
        this._dragHandler = new DragHandler(this.target.getDOM(), {
          'cancelOn': this._cancelOn.bind(this),
          'ignoreMouseleave': true
        });

        this._dragHandler.on('mousedown', this._onMouseDown, this);

        this._dragHandler.on('dragging', this._dragging, this);

        this._dragHandler.on('mouseup', this._endDrag, this);

        this._dragHandler.enable();
      };

      _proto2._cancelOn = function _cancelOn(domEvent) {
        var target = domEvent.srcElement || domEvent.target,
            tagName = target.tagName.toLowerCase();

        if (tagName === 'button' || tagName === 'input' || tagName === 'select' || tagName === 'option' || tagName === 'textarea') {
          return true;
        }

        return false;
      };

      _proto2._onMouseDown = function _onMouseDown(param) {
        stopPropagation(param['domEvent']);
      };

      _proto2._dragging = function _dragging(param) {
        var target = this.target,
            map = target.getMap(),
            eventParam = map._parseEvent(param['domEvent']),
            domEvent = eventParam['domEvent'];

        if (domEvent.touches && domEvent.touches.length > 1) {
          return;
        }

        if (!this._isDragging) {
          this._isDragging = true;
          return;
        }

        var coord = eventParam['coordinate'],
            point = eventParam['containerPoint'];

        if (!this._lastCoord) {
          this._lastCoord = coord;
        }

        if (!this._lastPoint) {
          this._lastPoint = point;
        }

        var coordOffset = coord.sub(this._lastCoord),
            pointOffset = point.sub(this._lastPoint);
        this._lastCoord = coord;
        this._lastPoint = point;
        this.target.setCoordinates(this.target.getCoordinates().add(coordOffset));
        eventParam['coordOffset'] = coordOffset;
        eventParam['pointOffset'] = pointOffset;
        /**
         * dragging event
         * @event ui.UIMarker#dragging
         * @type {Object}
         * @property {String} type                    - dragging
         * @property {UIMarker} target    - the uimarker fires event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */

        target.fire('dragging', eventParam);
      };

      _proto2._endDrag = function _endDrag(param) {
        var target = this.target,
            map = target.getMap();

        if (this._dragHandler) {
          target.off('click', this._endDrag, this);

          this._dragHandler.disable();

          delete this._dragHandler;
        }

        delete this._lastCoord;
        delete this._lastPoint;
        this._isDragging = false;

        if (!map) {
          return;
        }

        var eventParam = map._parseEvent(param['domEvent']);
        /**
         * dragend event
         * @event ui.UIMarker#dragend
         * @type {Object}
         * @property {String} type                    - dragend
         * @property {UIMarker} target    - the uimarker fires event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        target.fire('dragend', eventParam);
      };

      _proto2.isDragging = function isDragging() {
        if (!this._isDragging) {
          return false;
        }

        return true;
      };

      return UIMarkerDragHandler;
    }(Handler$1);

    UIMarker.addInitHook('addHandler', 'draggable', UIMarkerDragHandler);

    /**
     * @property {Object} options
     * @property {Boolean} [options.autoPan=true]  - set it to false if you don't want the map to do panning animation to fit the opened window.
     * @property {Boolean} [options.autoCloseOn=null] - Auto close infowindow on map's events, e.g. "click contextmenu" will close infowindow with click or right click on map.
     * @property {Boolean} [options.autoOpenOn=null]  - Auto open infowindow on owner's events, e.g. "click" will open infowindow with click or right click on window's owner.
     * @property {Number}  [options.width=300]     - default width
     * @property {Number}  [options.minHeight=120] - minimun height
     * @property {Boolean} [options.custom=false]  - set it to true if you want a customized infowindow, customized html codes or a HTMLElement is set to content.
     * @property {String}  [options.title=null]    - title of the infowindow.
     * @property {String|HTMLElement}  options.content - content of the infowindow.
     * @memberOf ui.InfoWindow
     * @instance
     */

    var options$l = {
      'autoPan': true,
      'autoCloseOn': null,
      'autoOpenOn': 'click',
      'width': 300,
      'minHeight': 120,
      'custom': false,
      'title': null,
      'content': null
    };
    /**
     * @classdesc
     * Class for info window, a popup on the map to display any useful infomation you wanted.
     * @category ui
     * @extends ui.UIComponent
     * @param {Object} options - options defined in [InfoWindow]{@link InfoWindow#options}
     * @memberOf ui
     */

    var InfoWindow =
    /*#__PURE__*/
    function (_UIComponent) {
      _inheritsLoose(InfoWindow, _UIComponent);

      function InfoWindow() {
        return _UIComponent.apply(this, arguments) || this;
      }

      var _proto = InfoWindow.prototype;

      // TODO: obtain class in super
      _proto._getClassName = function _getClassName() {
        return 'InfoWindow';
      }
      /**
       * Adds the UI Component to a geometry or a map
       * @param {Geometry|Map} owner - geometry or map to addto.
       * @returns {UIComponent} this
       * @fires UIComponent#add
       */
      ;

      _proto.addTo = function addTo(owner) {
        if (owner instanceof Geometry) {
          if (owner.getInfoWindow() && owner.getInfoWindow() !== this) {
            owner.removeInfoWindow();
          }

          owner._infoWindow = this;
        }

        return _UIComponent.prototype.addTo.call(this, owner);
      }
      /**
       * Set the content of the infowindow.
       * @param {String|HTMLElement} content - content of the infowindow.
       * return {InfoWindow} this
       * @fires InfoWindow#contentchange
       */
      ;

      _proto.setContent = function setContent(content) {
        var old = this.options['content'];
        this.options['content'] = content;
        /**
         * contentchange event.
         *
         * @event InfoWindow#contentchange
         * @type {Object}
         * @property {String} type - contentchange
         * @property {InfoWindow} target - InfoWindow
         * @property {String|HTMLElement} old      - old content
         * @property {String|HTMLElement} new      - new content
         */

        this.fire('contentchange', {
          'old': old,
          'new': content
        });

        if (this.isVisible()) {
          this.show(this._coordinate);
        }

        return this;
      }
      /**
       * Get content of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      ;

      _proto.getContent = function getContent() {
        return this.options['content'];
      }
      /**
       * Set the title of the infowindow.
       * @param {String|HTMLElement} title - title of the infowindow.
       * return {InfoWindow} this
       * @fires InfoWindow#titlechange
       */
      ;

      _proto.setTitle = function setTitle(title) {
        var old = title;
        this.options['title'] = title;
        /**
         * titlechange event.
         *
         * @event InfoWindow#titlechange
         * @type {Object}
         * @property {String} type - titlechange
         * @property {InfoWindow} target - InfoWindow
         * @property {String} old      - old content
         * @property {String} new      - new content
         */

        this.fire('contentchange', {
          'old': old,
          'new': title
        });

        if (this.isVisible()) {
          this.show(this._coordinate);
        }

        return this;
      }
      /**
       * Get title of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      ;

      _proto.getTitle = function getTitle() {
        return this.options['title'];
      };

      _proto.buildOn = function buildOn() {
        if (this.options['custom']) {
          if (isString(this.options['content'])) {
            var _dom = createEl('div');

            _dom.innerHTML = this.options['content'];
            return _dom;
          } else {
            return this.options['content'];
          }
        }

        var dom = createEl('div');
        dom.className = 'maptalks-msgBox';
        dom.style.width = this._getWindowWidth() + 'px';
        dom.style.bottom = '0px'; // fix #657

        var content = '<em class="maptalks-ico"></em>';

        if (this.options['title']) {
          content += '<h2>' + this.options['title'] + '</h2>';
        }

        content += '<a href="javascript:void(0);" class="maptalks-close"></a><div class="maptalks-msgContent"></div>';
        dom.innerHTML = content;
        var msgContent = dom.querySelector('.maptalks-msgContent');

        if (isString(this.options['content'])) {
          msgContent.innerHTML = this.options['content'];
        } else {
          msgContent.appendChild(this.options['content']);
        }

        this._onCloseBtnClick = this.hide.bind(this);
        var closeBtn = dom.querySelector('.maptalks-close');
        addDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
        return dom;
      }
      /**
       * Gets InfoWindow's transform origin for animation transform
       * @protected
       * @return {Point} transform origin
       */
      ;

      _proto.getTransformOrigin = function getTransformOrigin() {
        var size = this.getSize();
        return size.width / 2 + 'px bottom';
      };

      _proto.getOffset = function getOffset() {
        var size = this.getSize();
        var o = new Point(-size['width'] / 2, 0);

        if (!this.options['custom']) {
          o._sub(4, 12);
        } else {
          o._sub(0, size['height']);
        }

        var owner = this.getOwner();

        if (owner instanceof Marker || owner instanceof MultiPoint) {
          var painter, markerSize;

          if (owner instanceof Marker) {
            painter = owner._getPainter();
            markerSize = owner.getSize();
          } else {
            var children = owner.getGeometries();

            if (!children || !children.length) {
              return o;
            }

            painter = children[0]._getPainter();
            markerSize = children[0].getSize();
          }

          if (painter) {
            var fixExtent = painter.getFixedExtent();

            o._add(fixExtent.xmax - markerSize.width / 2, fixExtent.ymin);
          }
        }

        return o;
      };

      _proto.show = function show(coordinate) {
        if (!this.getMap()) {
          return this;
        }

        if (!this.getMap().options['enableInfoWindow']) {
          return this;
        }

        return _UIComponent.prototype.show.call(this, coordinate);
      };

      _proto.getEvents = function getEvents() {
        if (!this.options['autoCloseOn']) {
          return null;
        }

        var events = {};
        events[this.options['autoCloseOn']] = this.hide;
        return events;
      };

      _proto.getOwnerEvents = function getOwnerEvents() {
        var owner = this.getOwner();

        if (!this.options['autoOpenOn'] || !owner) {
          return null;
        }

        var events = {};
        events[this.options['autoOpenOn']] = this._onAutoOpen;
        return events;
      };

      _proto.onRemove = function onRemove() {
        this.onDomRemove();
      };

      _proto.onDomRemove = function onDomRemove() {
        if (this._onCloseBtnClick) {
          var dom = this.getDOM();
          var closeBtn = dom.childNodes[2];
          removeDomEvent(closeBtn, 'click touchend', this._onCloseBtnClick);
          delete this._onCloseBtnClick;
        }
      };

      _proto._onAutoOpen = function _onAutoOpen(e) {
        var _this = this;

        var owner = this.getOwner();
        setTimeout(function () {
          if (owner instanceof Marker) {
            _this.show(owner.getCoordinates());
          } else if (owner instanceof MultiPoint) {
            _this.show(owner.findClosest(e.coordinate));
          } else {
            _this.show(e.coordinate);
          }
        }, 1);
      };

      _proto._getWindowWidth = function _getWindowWidth() {
        var defaultWidth = 300;
        var width = this.options['width'];

        if (!width) {
          width = defaultWidth;
        }

        return width;
      };

      return InfoWindow;
    }(UIComponent);

    InfoWindow.mergeOptions(options$l);

    /**
     * @property {Object} options
     * @property {Number}  [options.width=0]     - default width
     * @property {Number}  [options.height=0]     - default height
     * @property {String}  [options.animation='fade']     - default fade, scale | fade,scale are an alternative to set
     * @property {String}  [options.cssName=maptalks-tooltip]    - tooltip's css class name
     * @property {Number}  [options.showTimeout=400]      - timeout to show tooltip
     * @memberOf ui.ToolTip
     * @instance
     */

    var options$m = {
      'width': 0,
      'height': 0,
      'animation': 'fade',
      'cssName': 'maptalks-tooltip',
      'showTimeout': 400
    };
    /**
     * @classdesc
     * Class for tooltip, a tooltip used for showing some useful infomation attached to geometries on the map.
     * @category ui
     * @extends ui.UIComponent
     * @memberOf ui
     */

    var ToolTip =
    /*#__PURE__*/
    function (_UIComponent) {
      _inheritsLoose(ToolTip, _UIComponent);

      var _proto = ToolTip.prototype;

      // TODO:obtain class in super
      _proto._getClassName = function _getClassName() {
        return 'ToolTip';
      }
      /**
       * @param {String} content         - content of tooltip
       * @param {Object} [options=null]  - options defined in [ToolTip]{@link ToolTip#options}
       */
      ;

      function ToolTip(content, options) {
        var _this;

        if (options === void 0) {
          options = {};
        }

        _this = _UIComponent.call(this, options) || this;
        _this._content = content;
        return _this;
      }
      /**
       * Adds the UI Component to a geometry UIMarker Other graphic elements
       * @param {Geometry} owner - geometry to add.
       * @returns {UIComponent} this
       * @fires UIComponent#add
       */


      _proto.addTo = function addTo(owner) {
        if (ToolTip.isSupport(owner)) {
          owner.on('mousemove', this.onMouseMove, this);
          owner.on('mouseout', this.onMouseOut, this);
          return _UIComponent.prototype.addTo.call(this, owner);
        } else {
          throw new Error('Invalid geometry or UIMarker the tooltip is added to.');
        }
      }
      /**
       * set ToolTip's content's css class name.
       * @param {String} css class name - set for ToolTip's content.
       */
      ;

      _proto.setStyle = function setStyle$$1(cssName) {
        this.options.cssName = cssName;
        return this;
      }
      /**
       * get ToolTip's  content's css class name
       * @returns {String} css class name - set for ToolTip's content.
       */
      ;

      _proto.getStyle = function getStyle() {
        return this.options.cssName;
      }
      /**
       * get the UI Component's content
       * @returns {String} tooltip's content
       */
      ;

      _proto.getContent = function getContent() {
        return this._content;
      };

      _proto.buildOn = function buildOn() {
        var dom = createEl('div');
        var options = this.options || {};

        if (options.height) {
          dom.style.height = options.height + 'px';
        }

        if (options.width) {
          dom.style.width = options.width + 'px';
        }

        var cssName = options.cssName;

        if (!cssName && options.height) {
          dom.style.lineHeight = options.height + 'px';
        }

        dom.innerHTML = "<div class=\"" + cssName + "\">" + this._content + "</div>";
        return dom;
      };

      _proto.onMouseOut = function onMouseOut() {
        clearTimeout(this._timeout);

        if (this.isVisible()) {
          this._removePrevDOM();
        }
      };

      _proto.onMouseMove = function onMouseMove(e) {
        var _this2 = this;

        clearTimeout(this._timeout);
        var map = this.getMap();

        if (!map) {
          return;
        }

        var coord = map.locateByPoint(e.coordinate, -5, 25);

        if (this.options['showTimeout'] === 0) {
          this.show(coord);
        } else {
          this._timeout = setTimeout(function () {
            if (map) {
              _this2.show(coord);
            }
          }, this.options['showTimeout']);
        }
      }
      /**
       * remove the tooltip, this method will be called by 'this.remove()'
       */
      ;

      _proto.onRemove = function onRemove() {
        clearTimeout(this._timeout);

        if (this._owner) {
          this._owner.off('mouseover', this.onMouseOver, this);

          this._owner.off('mouseout', this.onMouseOut, this);
        }
      };

      return ToolTip;
    }(UIComponent);

    ToolTip.mergeOptions(options$m);

    /**
     * @property {Object} options
     * @property {Boolean} [options.autoPan=false]  - set it to false if you don't want the map to do panning animation to fit the opened menu.
     * @property {Number}  [options.width=160]      - default width
     * @property {Number}  [options.maxHeight=0]    - default max-height
     * @property {String|HTMLElement} [options.custom=false]  - set it to true if you want a customized menu, customized html codes or a HTMLElement is set to items.
     * @property {Object[]|String|HTMLElement}  options.items   - html code or a html element is options.custom is true. Or a menu items array, containing: item objects, "-" as a splitor line
     * @memberOf ui.Menu
     * @instance
     */

    var defaultOptions = {
      'animation': null,
      'animationDelay': 10,
      'animationOnHide': false,
      'autoPan': false,
      'width': 160,
      'maxHeight': 0,
      'custom': false,
      'items': []
    };
    /**
     * @classdesc
     * Class for context menu, useful for interactions with right clicks on the map.
     * @category ui
     * @extends ui.UIComponent
     * @memberOf ui
     */

    var Menu =
    /*#__PURE__*/
    function (_UIComponent) {
      _inheritsLoose(Menu, _UIComponent);

      /**
       * Menu items is set to options.items or by setItems method. <br>
       * <br>
       * Normally items is a object array, containing: <br>
       * 1. item object: {'item': 'This is a menu text', 'click': function() {alert('oops! You clicked!');)}} <br>
       * 2. minus string "-", which will draw a splitor line on the menu. <br>
       * <br>
       * If options.custom is set to true, the menu is considered as a customized one. Then items is the customized html codes or HTMLElement. <br>
       * @param {Object} options - options defined in [ui.Menu]{@link ui.Menu#options}
       */
      function Menu(options) {
        return _UIComponent.call(this, options) || this;
      } // TODO: obtain class in super


      var _proto = Menu.prototype;

      _proto._getClassName = function _getClassName() {
        return 'Menu';
      };

      _proto.addTo = function addTo(owner) {
        if (owner._menu && owner._menu !== this) {
          owner.removeMenu();
        }

        owner._menu = this;
        return UIComponent.prototype.addTo.apply(this, arguments);
      }
      /**
       * Set the items of the menu.
       * @param {Object[]|String|HTMLElement} items - items of the menu
       * return {ui.Menu} this
       * @example
       * menu.setItems([
       *      //return false to prevent event propagation
       *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},
       *     '-',
       *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},
       *     {'item': 'About', 'click': function() {alert('About Clicked!')}}
       * ]);
       */
      ;

      _proto.setItems = function setItems(items) {
        this.options['items'] = items;
        return this;
      }
      /**
       * Get items of  the menu.
       * @return {Object[]|String|HTMLElement} - items of the menu
       */
      ;

      _proto.getItems = function getItems() {
        return this.options['items'] || [];
      }
      /**
       * Create the menu DOM.
       * @protected
       * @return {HTMLElement} menu's DOM
       */
      ;

      _proto.buildOn = function buildOn() {
        if (this.options['custom']) {
          if (isString(this.options['items'])) {
            var container = createEl('div');
            container.innerHTML = this.options['items'];
            return container;
          } else {
            return this.options['items'];
          }
        } else {
          var dom = createEl('div');
          addClass(dom, 'maptalks-menu');
          dom.style.width = this._getMenuWidth() + 'px';
          /*const arrow = createEl('em');
          addClass(arrow, 'maptalks-ico');*/

          var menuItems = this._createMenuItemDom(); // dom.appendChild(arrow);


          dom.appendChild(menuItems);
          on(dom, 'contextmenu', preventDefault);
          return dom;
        }
      }
      /**
       * Offset of the menu DOM to fit the click position.
       * @return {Point} offset
       * @private
       */
      ;

      _proto.getOffset = function getOffset() {
        if (!this.getMap()) {
          return null;
        }

        var mapSize = this.getMap().getSize(),
            p = this.getMap().viewPointToContainerPoint(this._getViewPoint()),
            size = this.getSize();
        var dx = 0,
            dy = 0;

        if (p.x + size['width'] > mapSize['width']) {
          dx = -size['width'];
        }

        if (p.y + size['height'] > mapSize['height']) {
          dy = -size['height'];
        }

        return new Point(dx, dy);
      };

      _proto.getTransformOrigin = function getTransformOrigin() {
        var p = this.getOffset()._multi(-1);

        return p.x + 'px ' + p.y + 'px';
      };

      _proto.getEvents = function getEvents() {
        return {
          '_zoomstart _zoomend _movestart _dblclick _click': this._removePrevDOM
        };
      };

      _proto._createMenuItemDom = function _createMenuItemDom() {
        var me = this;
        var map = this.getMap();
        var ul = createEl('ul');
        addClass(ul, 'maptalks-menu-items');
        var items = this.getItems();

        function onMenuClick(index) {
          return function (e) {
            var param = map._parseEvent(e, 'click');

            param['target'] = me;
            param['owner'] = me._owner;
            param['index'] = index;

            var result = this._callback(param);

            if (result === false) {
              return;
            }

            me.hide();
          };
        }

        var item, itemDOM;

        for (var i = 0, len = items.length; i < len; i++) {
          item = items[i];

          if (item === '-' || item === '_') {
            itemDOM = createEl('li');
            addClass(itemDOM, 'maptalks-menu-splitter');
          } else {
            itemDOM = createEl('li');
            var itemTitle = item['item'];

            if (isFunction(itemTitle)) {
              itemTitle = itemTitle({
                'owner': this._owner,
                'index': i
              });
            }

            itemDOM.innerHTML = itemTitle;
            itemDOM._callback = item['click'];
            on(itemDOM, 'click', onMenuClick(i));
          }

          ul.appendChild(itemDOM);
        }

        var maxHeight = this.options['maxHeight'] || 0;

        if (maxHeight > 0) {
          setStyle(ul, 'max-height: ' + maxHeight + 'px; overflow-y: auto;');
        }

        return ul;
      };

      _proto._getMenuWidth = function _getMenuWidth() {
        var defaultWidth = 160;
        var width = this.options['width'] || defaultWidth;
        return width;
      };

      return Menu;
    }(UIComponent);

    Menu.mergeOptions(defaultOptions);

    /**
     * Mixin of the context menu methods.
     * @mixin ui.Menuable
     */

    var Menuable = {
      /**
       * Set a context menu
       * @param {Object} options - menu options
       * @return {*} this
       * @example
       * foo.setMenu({
       *  'width'  : 160,
       *  'custom' : false,
       *  'items' : [
       *      //return false to prevent event propagation
       *     {'item': 'Query', 'click': function() {alert('Query Clicked!'); return false;}},
       *     '-',
       *     {'item': 'Edit', 'click': function() {alert('Edit Clicked!')}},
       *     {'item': 'About', 'click': function() {alert('About Clicked!')}}
       *    ]
       * });
       * @function ui.Menuable.setMenu
       */
      setMenu: function setMenu(options) {
        this._menuOptions = options;

        if (this._menu) {
          this._menu.setOptions(options);
        } else {
          this.on('contextmenu', this._defaultOpenMenu, this);
        }

        return this;
      },

      /**
       * Open the context menu, default on the center of the geometry or map.
       * @param {Coordinate} [coordinate=null] - coordinate to open the context menu
       * @return {*} this
       * @function ui.Menuable.openMenu
       */
      openMenu: function openMenu(coordinate) {
        var map = this instanceof Map$1 ? this : this.getMap();

        if (!coordinate) {
          coordinate = this.getCenter();
        }

        if (!this._menu) {
          if (this._menuOptions && map) {
            this._bindMenu(this._menuOptions);

            this._menu.show(coordinate);
          }
        } else {
          this._menu.show(coordinate);
        }

        return this;
      },

      /**
       * Set menu items to the context menu
       * @param {Object[]} items - menu items
       * @return {*} this
       * @function ui.Menuable.setMenuItems
       */
      setMenuItems: function setMenuItems(items) {
        if (!this._menuOptions) {
          this._menuOptions = {};
        }

        if (Array.isArray(items)) {
          this._menuOptions['custom'] = false;
        }

        this._menuOptions['items'] = items;
        this.setMenu(this._menuOptions);
        return this;
      },

      /**
       * Get the context menu items
       * @return {Object[]}
       * @function ui.Menuable.getMenuItems
       */
      getMenuItems: function getMenuItems() {
        if (this._menu) {
          return this._menu.getItems();
        } else if (this._menuOptions) {
          return this._menuOptions['items'] || [];
        }

        return [];
      },

      /**
       * Close the contexnt menu
       * @return {*} this
       * @function ui.Menuable.closeMenu
       */
      closeMenu: function closeMenu() {
        if (this._menu) {
          this._menu.hide();
        }

        return this;
      },

      /**
       * Remove the context menu
       * @return {*} this
       * @function ui.Menuable.removeMenu
       */
      removeMenu: function removeMenu() {
        this.off('contextmenu', this._defaultOpenMenu, this);

        this._unbindMenu();

        delete this._menuOptions;
        return this;
      },
      _bindMenu: function _bindMenu(options) {
        this._menu = new Menu(options);

        this._menu.addTo(this);

        return this;
      },
      _unbindMenu: function _unbindMenu() {
        if (this._menu) {
          this.closeMenu();

          this._menu.remove();

          delete this._menu;
        }

        return this;
      },

      /**
       * If contextmenu is not listened, open the menu in default.<br>
       * Otherwise, do nothing here.
       * @param  {Object} param - event parameter
       * @return {Boolean} true | false to stop event propagation
       * @private
       */
      _defaultOpenMenu: function _defaultOpenMenu(param) {
        if (this.listens('contextmenu') > 1) {
          return true;
        } else {
          this.openMenu(param['coordinate']);
          return false;
        }
      }
    };
    Map$1.include(Menuable);
    Geometry.include(Menuable);



    var index$4 = /*#__PURE__*/Object.freeze({
        UIComponent: UIComponent,
        UIMarker: UIMarker,
        InfoWindow: InfoWindow,
        ToolTip: ToolTip,
        Menuable: Menuable,
        Menu: Menu
    });

    /**
     * Base class for all the map controls, you can extend it to build your own customized Control.
     * It is abstract and not intended to be instantiated.
     * @category control
     * @memberOf control
     * @abstract
     * @extends Class
     * @mixes Eventable
     */

    var Control =
    /*#__PURE__*/
    function (_Eventable) {
      _inheritsLoose(Control, _Eventable);

      /**
       * Methods needs to implement:  <br>
       *  <br>
       * 1. Method to create UI's Dom element  <br>
       * function buildOn : HTMLElement  <br>
       *  <br>
       * 2. Optional, a callback when the control is added.  <br>
       * function onAdd : void  <br>
       * 3. Optional, a callback when the control is removed.  <br>
       * function onRemove : void  <br>
       *  <br>
       * @param  {Object} [options=null] configuration options
       */
      function Control(options) {
        if (options && options['position'] && !isString(options['position'])) {
          options['position'] = extend({}, options['position']);
        }

        return _Eventable.call(this, options) || this;
      }
      /**
       * Adds the control to a map.
       * @param {Map} map
       * @returns {control.Control} this
       * @fires control.Control#add
       */


      var _proto = Control.prototype;

      _proto.addTo = function addTo(map) {
        this.remove();

        if (!map.options['control']) {
          return this;
        }

        this._map = map;
        var controlContainer = map._panels.control;
        this.__ctrlContainer = createEl('div');
        setStyle(this.__ctrlContainer, 'position:absolute;overflow:visible;'); // on(this.__ctrlContainer, 'mousedown mousemove click dblclick contextmenu', stopPropagation)

        this.update();
        controlContainer.appendChild(this.__ctrlContainer);

        if (this.onAdd) {
          this.onAdd();
        }
        /**
         * add event.
         *
         * @event control.Control#add
         * @type {Object}
         * @property {String} type - add
         * @property {control.Control} target - the control instance
         */


        this.fire('add', {
          'dom': controlContainer
        });
        return this;
      }
      /**
       * update control container
       * @return {control.Control} this
       */
      ;

      _proto.update = function update() {
        this.__ctrlContainer.innerHTML = '';
        this._controlDom = this.buildOn(this.getMap());

        if (this._controlDom) {
          this._updatePosition();

          this.__ctrlContainer.appendChild(this._controlDom);
        }

        return this;
      }
      /**
       * Get the map that the control is added to.
       * @return {Map}
       */
      ;

      _proto.getMap = function getMap() {
        return this._map;
      }
      /**
       * Get the position of the control
       * @return {Object}
       */
      ;

      _proto.getPosition = function getPosition() {
        return extend({}, this._parse(this.options['position']));
      }
      /**
       * update the control's position
       * @param {String|Object} position - can be one of 'top-left', 'top-right', 'bottom-left', 'bottom-right' or a position object like {'top': 40,'left': 60}
       * @return {control.Control} this
       * @fires control.Control#positionchange
       */
      ;

      _proto.setPosition = function setPosition(position) {
        if (isString(position)) {
          this.options['position'] = position;
        } else {
          this.options['position'] = extend({}, position);
        }

        this._updatePosition();

        return this;
      }
      /**
       * Get the container point of the control.
       * @return {Point}
       */
      ;

      _proto.getContainerPoint = function getContainerPoint() {
        var position = this.getPosition();
        var size = this.getMap().getSize();
        var x, y;

        if (!isNil(position['left'])) {
          x = parseInt(position['left']);
        } else if (!isNil(position['right'])) {
          x = size['width'] - parseInt(position['right']);
        }

        if (!isNil(position['top'])) {
          y = parseInt(position['top']);
        } else if (!isNil(position['bottom'])) {
          y = size['height'] - parseInt(position['bottom']);
        }

        return new Point(x, y);
      }
      /**
       * Get the control's container.
       * Container is a div element wrapping the control's dom and decides the control's position and display.
       * @return {HTMLElement}
       */
      ;

      _proto.getContainer = function getContainer() {
        return this.__ctrlContainer;
      }
      /**
       * Get html dom element of the control
       * @return {HTMLElement}
       */
      ;

      _proto.getDOM = function getDOM() {
        return this._controlDom;
      }
      /**
       * Show
       * @return {control.Control} this
       */
      ;

      _proto.show = function show() {
        this.__ctrlContainer.style.display = '';
        return this;
      }
      /**
       * Hide
       * @return {control.Control} this
       */
      ;

      _proto.hide = function hide() {
        this.__ctrlContainer.style.display = 'none';
        return this;
      }
      /**
       * Whether the control is visible
       * @return {Boolean}
       */
      ;

      _proto.isVisible = function isVisible() {
        return this.__ctrlContainer && this.__ctrlContainer.style.display === '';
      }
      /**
       * Remove itself from the map
       * @return {control.Control} this
       * @fires control.Control#remove
       */
      ;

      _proto.remove = function remove() {
        if (!this._map) {
          return this;
        }

        removeDomNode(this.__ctrlContainer);

        if (this.onRemove) {
          this.onRemove();
        }

        delete this._map;
        delete this.__ctrlContainer;
        delete this._controlDom;
        /**
         * remove event.
         *
         * @event control.Control#remove
         * @type {Object}
         * @property {String} type - remove
         * @property {control.Control} target - the control instance
         */

        this.fire('remove');
        return this;
      };

      _proto._parse = function _parse(position) {
        var p = position;

        if (isString(position)) {
          p = Control['positions'][p];
        }

        return p;
      };

      _proto._updatePosition = function _updatePosition() {
        var position = this.getPosition();

        if (!position) {
          //default one
          position = {
            'top': 20,
            'left': 20
          };
        }

        for (var p in position) {
          if (position.hasOwnProperty(p)) {
            position[p] = parseInt(position[p]);
            this.__ctrlContainer.style[p] = position[p] + 'px';
          }
        }
        /**
         * Control's position update event.
         *
         * @event control.Control#positionchange
         * @type {Object}
         * @property {String} type - positionchange
         * @property {control.Control} target - the control instance
         * @property {Object} position - Position of the control, eg:{"top" : 100, "left" : 50}
         */


        this.fire('positionchange', {
          'position': extend({}, position)
        });
      };

      return Control;
    }(Eventable(Class));

    Control.positions = {
      'top-left': {
        'top': 20,
        'left': 20
      },
      'top-right': {
        'top': 20,
        'right': 20
      },
      'bottom-left': {
        'bottom': 20,
        'left': 20
      },
      'bottom-right': {
        'bottom': 20,
        'right': 20
      }
    };
    Map$1.mergeOptions({
      'control': true
    });
    Map$1.include(
    /** @lends Map.prototype */
    {
      /**
       * Add a control on the map.
       * @param {control.Control} control - contorl to add
       * @return {Map} this
       */
      addControl: function addControl(control) {
        // if map container is a canvas, can't add control on it.
        if (this._containerDOM.getContext) {
          return this;
        }

        control.addTo(this);
        return this;
      },

      /**
       * Remove a control from the map.
       * @param {control.Control} control - control to remove
       * @return {Map} this
       */
      removeControl: function removeControl(control) {
        if (!control || control.getMap() !== this) {
          return this;
        }

        control.remove();
        return this;
      }
    });

    /**
     * @property {Object} options - options
     * @property {Object} [options.position='bottom-left'] - position of the control, this option defined in [Control.position]{@link Control#positions}.
     * @property {String} [options.content='Powered by <a href="http://maptalks.org" target="_blank">maptalks</a>']  - content of the attribution control, HTML format
     * @memberOf control.Attribution
     * @instance
     */

    var options$n = {
      'position': {
        'bottom': 0,
        'left': 0
      },
      'content': '<a href="http://maptalks.org" target="_blank">maptalks</a>'
    };
    var layerEvents = 'addlayer removelayer setbaselayer baselayerremove';
    /**
     * @classdesc
     * A control to allows to display attribution content in a small text box on the map.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var map = new maptalks.Map('map', {
     *    center: [-0.113049, 51.498568],
     *    zoom: 14,
     *    attribution: {
     *       content : 'my attribution',
     *       position : 'bottom-left'
     *    },
     *    baseLayer: new maptalks.TileLayer('base', {
     *        urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
     *        subdomains: ['a','b','c','d'],
     *        attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
     *    })
     * });
     * map.addLayer(new maptalks.TileLayer('base', {
     *      urlTemplate: 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
     *      subdomains: ['a','b','c','d'],
     *      attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
     * }));
     */

    var Attribution =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Attribution, _Control);

      function Attribution() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Attribution.prototype;

      _proto.buildOn = function buildOn() {
        this._attributionContainer = createEl('div');
        this._attributionContainer.className = 'maptalks-attribution';

        this._update();

        return this._attributionContainer;
      };

      _proto.onAdd = function onAdd() {
        this.getMap().on(layerEvents, this._update, this);
      };

      _proto.onRemove = function onRemove() {
        this.getMap().off(layerEvents, this._update, this);
      };

      _proto._update = function _update() {
        var map = this.getMap();

        if (!map) {
          return;
        }

        var attributions = map._getLayers(function (layer) {
          return layer.options['attribution'];
        }).reverse().map(function (layer) {
          return layer.options['attribution'];
        });

        var content = this.options['content'] + (attributions.length > 0 ? ' - ' + attributions.join(', ') : '');
        this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + content + '</span>';
      };

      return Attribution;
    }(Control);

    Attribution.mergeOptions(options$n);
    Map$1.mergeOptions({
      'attribution': true
    });
    Map$1.addOnLoadHook(function () {
      var a = this.options['attribution'] || this.options['attributionControl'];

      if (a) {
        this.attributionControl = new Attribution(a);
        this.addControl(this.attributionControl);
      }
    });

    /**
     * @property {Object} options - options
     * @property {Object} [options.position='top-right'] - position of the control
     * @property {Object} [options.baseTitle='Base Layers'] - title of the base layers
     * @property {Object} [options.overlayTitle='Layers'] - title of the overlay layers
     * @property {Object} [options.excludeLayers=[]] - ids of layers that don't display in layerswitcher
     * @property {Object} [options.containerClass=maptalks-layer-switcher] - layerswitcher's container div's CSS class
     *
     * @memberOf control.LayerSwitcher
     * @instance
     */

    var options$o = {
      'position': 'top-right',
      'baseTitle': 'Base Layers',
      'overlayTitle': 'Layers',
      'excludeLayers': [],
      'containerClass': 'maptalks-layer-switcher'
    };
    /**
     * @classdesc
     * A LayerSwitcher control for the map.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var LayerSwitcher = new LayerSwitcher({
     *     position : {'top': '0', 'right': '0'}
     * }).addTo(map);
    */

    var LayerSwitcher =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(LayerSwitcher, _Control);

      function LayerSwitcher() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = LayerSwitcher.prototype;

      /**
       * method to build DOM of the control
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn() {
        var container = this.container = createEl('div', this.options['containerClass']),
            panel = this.panel = createEl('div', 'panel'),
            button = this.button = createEl('button');
        container.appendChild(button);
        container.appendChild(panel);
        return container;
      };

      _proto.onAdd = function onAdd() {
        on(this.button, 'mouseover', this._show, this);
        on(this.panel, 'mouseleave', this._hide, this);
        on(this.getMap(), 'click', this._hide, this);
      };

      _proto.onRemove = function onRemove() {
        if (this.panel) {
          off(this.button, 'mouseover', this._show, this);
          off(this.panel, 'mouseleave', this._hide, this);
          off(this.getMap(), 'click', this._hide, this);
          removeDomNode(this.panel);
          removeDomNode(this.button);
          delete this.panel;
          delete this.button;
          delete this.container;
        }
      };

      _proto._show = function _show() {
        if (!hasClass(this.container, 'shown')) {
          addClass(this.container, 'shown');

          this._createPanel();
        }
      };

      _proto._hide = function _hide(e) {
        if (!this.panel.contains(e.toElement || e.relatedTarget)) {
          setClass(this.container, this.options['containerClass']);
        }
      };

      _proto._createPanel = function _createPanel() {
        this.panel.innerHTML = '';
        var ul = createEl('ul');
        this.panel.appendChild(ul);

        this._renderLayers(this.getMap(), ul);
      };

      _proto._renderLayers = function _renderLayers(map, elm) {
        var base = map.getBaseLayer(),
            layers = map.getLayers(),
            len = layers.length;

        if (base) {
          var baseLayers = base.layers || [base],
              li = createEl('li', 'group'),
              ul = createEl('ul'),
              label = createEl('label');
          label.innerHTML = this.options['baseTitle'];
          li.appendChild(label);

          for (var i = 0, _len = baseLayers.length; i < _len; i++) {
            var layer = baseLayers[i];

            if (this._isExcluded(layer)) {
              ul.appendChild(this._renderLayer(baseLayers[i], true));
              li.appendChild(ul);
              elm.appendChild(li);
            }
          }
        }

        if (len) {
          var _li = createEl('li', 'group'),
              _ul = createEl('ul'),
              _label = createEl('label');

          _label.innerHTML = this.options['overlayTitle'];

          _li.appendChild(_label);

          for (var _i = 0; _i < len; _i++) {
            var _layer = layers[_i];

            if (this._isExcluded(_layer)) {
              _ul.appendChild(this._renderLayer(_layer));
            }
          }

          _li.appendChild(_ul);

          elm.appendChild(_li);
        }
      };

      _proto._isExcluded = function _isExcluded(layer) {
        var id = layer.getId(),
            excludeLayers = this.options['excludeLayers'];
        return !(excludeLayers.length && excludeLayers.indexOf(id) >= 0);
      };

      _proto._renderLayer = function _renderLayer(layer, isBase) {
        var _this = this;

        var li = createEl('li', 'layer'),
            label = createEl('label'),
            input = createEl('input'),
            map = this.getMap();
        var visible = layer.options['visible'];
        layer.options['visible'] = true;
        var enabled = layer.isVisible();
        layer.options['visible'] = visible;
        li.className = 'layer';

        if (isBase) {
          input.type = 'radio';
          input.name = 'base';
        } else {
          input.type = 'checkbox';
        }

        input.checked = visible && enabled;

        if (!enabled) {
          input.setAttribute('disabled', 'disabled');
        }

        input.onchange = function (e) {
          if (e.target.type === 'radio') {
            var baseLayer = map.getBaseLayer(),
                baseLayers = baseLayer.layers;

            if (baseLayers) {
              for (var i = 0, len = baseLayers.length; i < len; i++) {
                var _baseLayer = baseLayers[i];

                _baseLayer[_baseLayer === layer ? 'show' : 'hide']();
              }
            } else if (!baseLayer.isVisible()) {
              baseLayer.show();
            }

            map._fireEvent('setbaselayer');
          } else {
            layer[e.target.checked ? 'show' : 'hide']();
          }

          _this.fire('layerchange', {
            target: layer
          });
        };

        li.appendChild(input);
        label.innerHTML = layer.getId();
        li.appendChild(label);
        return li;
      };

      return LayerSwitcher;
    }(Control);

    LayerSwitcher.mergeOptions(options$o);
    Map$1.mergeOptions({
      'layerSwitcherControl': false
    });
    Map$1.addOnLoadHook(function () {
      if (this.options['layerSwitcherControl']) {
        this.layerSwitcherControl = new LayerSwitcher(this.options['layerSwitcherControl']);
        this.addControl(this.layerSwitcherControl);
      }
    });

    /**
     * @property {Object} options - options
     * @property {Object} [options.position='bottom-right'] - position of the control
     * @property {Number} [options.level=4]  - the zoom level of the overview
     * @property {Object} [options.maximize=true]  - whether to maximize overview when added
     * @property {Object} [options.size=[300, 200]  - size of the Control
     * @property {Object} [options.symbol={}] - symbol of the overview rectangle
     * @property {Object} [options.containerClass=maptalks-overview] - overview's container div's CSS class
     * @property {Object} [options.buttonClass=maptalks-overview-button] - overview's minimize/maximize button's CSS class
     *
     * @memberOf control.Overview
     * @instance
     */

    var options$p = {
      'level': 4,
      'position': {
        'right': 1,
        'bottom': 1
      },
      'size': [300, 200],
      'maximize': true,
      'symbol': {
        'lineWidth': 3,
        'lineColor': '#1bbc9b',
        'polygonFill': '#1bbc9b',
        'polygonOpacity': 0.4
      },
      'containerClass': 'maptalks-overview',
      'buttonClass': 'maptalks-overview-button'
    };
    /**
     * @classdesc
     * An overview control for the map.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var overview = new Overview({
     *     position : {'bottom': '0', 'right': '0'},
     *     size : {'width' : 300,'height' : 200}
     * }).addTo(map);
     */

    var Overview =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Overview, _Control);

      function Overview() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Overview.prototype;

      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn() {
        var size = this.options['size'];

        if (!this.options['maximize']) {
          size = [0, 0];
        }

        var container = createEl('div');
        var mapContainer = this.mapContainer = createEl('div');
        mapContainer.style.width = size[0] + 'px';
        mapContainer.style.height = size[1] + 'px';
        mapContainer.className = this.options['containerClass'];
        var button = this.button = createEl('div');
        button.className = this.options['buttonClass'];
        container.appendChild(mapContainer);
        container.appendChild(button);
        return container;
      };

      _proto.onAdd = function onAdd() {
        if (this.options['maximize']) {
          this._createOverview();
        }

        this.getMap().on('resize moving zooming rotate dragrotating viewchange', this._update, this).on('setbaselayer', this._updateBaseLayer, this).on('spatialreferencechange', this._updateSpatialReference, this);
        on(this.button, 'click', this._onButtonClick, this);

        this._updateButtonText();
      };

      _proto.onRemove = function onRemove() {
        this.getMap().off('resize moving zooming rotate dragrotating viewchange', this._update, this).off('setbaselayer', this._updateBaseLayer, this).off('spatialreferencechange', this._updateSpatialReference, this);

        if (this._overview) {
          this._overview.remove();

          delete this._overview;
          delete this._perspective;
        }

        off(this.button, 'click', this._onButtonClick, this);
      }
      /**
       * Maximize overview control
       * @returns {control.Overview}
       */
      ;

      _proto.maxmize = function maxmize() {
        var size = this.options['size'];
        var dom = this.mapContainer;
        dom.style.width = size[0] + 'px';
        dom.style.height = size[1] + 'px';

        this._createOverview();

        return this;
      }
      /**
       * Minimize overview control
       * @returns {control.Overview}
       */
      ;

      _proto.minimize = function minimize() {
        if (this._overview) {
          this._overview.remove();
        }

        delete this._overview;
        delete this._perspective;
        var dom = this.mapContainer;
        dom.style.width = 0 + 'px';
        dom.style.height = 0 + 'px';
        return this;
      }
      /**
       * Return overview's map object
       * @returns {Map}
       */
      ;

      _proto.getOverviewMap = function getOverviewMap() {
        return this._overview;
      };

      _proto._onButtonClick = function _onButtonClick() {
        if (!this._overview) {
          this.maxmize();
        } else {
          this.minimize();
        }

        this._updateButtonText();
      };

      _proto._updateButtonText = function _updateButtonText() {
        if (this._overview) {
          this.button.innerHTML = '-';
        } else {
          this.button.innerHTML = '+';
        }
      };

      _proto._createOverview = function _createOverview() {
        var map = this.getMap(),
            dom = this.mapContainer;
        var options = map.config();
        extend(options, {
          'center': map.getCenter(),
          'zoom': this._getOverviewZoom(),
          'zoomAnimationDuration': 150,
          'pitch': 0,
          'bearing': 0,
          'scrollWheelZoom': false,
          'checkSize': false,
          'doubleClickZoom': false,
          'touchZoom': false,
          'control': false,
          'draggable': false,
          'maxExtent': null
        });
        this._overview = new Map$1(dom, options);

        this._updateBaseLayer();

        this._perspective = new Polygon(this._getPerspectiveCoords(), {
          'draggable': true,
          'cursor': 'move',
          'symbol': this.options['symbol']
        }).on('dragend', this._onDragEnd, this);
        new VectorLayer('perspective_layer', this._perspective).addTo(this._overview);
        this.fire('load');
      };

      _proto._getOverviewZoom = function _getOverviewZoom() {
        var map = this.getMap(),
            zoom = map.getZoom(),
            minZoom = map.getMinZoom(),
            level = this.options['level'];

        if (level > 0) {
          for (var i = level; i > 0; i--) {
            if (zoom - i >= minZoom) {
              return zoom - i;
            }
          }
        } else {
          for (var _i = level; _i < 0; _i++) {
            if (zoom - _i >= minZoom) {
              return zoom - _i;
            }
          }
        }

        return zoom;
      };

      _proto._onDragEnd = function _onDragEnd() {
        var center = this._perspective.getCenter();

        this._overview.setCenter(center);

        this.getMap().panTo(center);
      };

      _proto._getPerspectiveCoords = function _getPerspectiveCoords() {
        var map = this.getMap();
        return map.getContainerExtent().toArray().map(function (c) {
          return map.containerPointToCoordinate(c);
        });
      };

      _proto._update = function _update() {
        if (!this._overview) {
          return;
        } // refresh map's dom position


        computeDomPosition(this._overview._containerDOM);

        var coords = this._getPerspectiveCoords();

        this._perspective.setCoordinates(coords);

        this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom());
      };

      _proto._updateSpatialReference = function _updateSpatialReference() {
        if (!this._overview) {
          return;
        }

        var map = this.getMap();
        var spatialRef = map.options['spatialReference'];

        this._overview.setSpatialReference(spatialRef);
      };

      _proto._updateBaseLayer = function _updateBaseLayer() {
        if (!this._overview) {
          return;
        }

        var map = this.getMap(),
            baseLayer = map.getBaseLayer();

        if (!baseLayer) {
          this._overview.setBaseLayer(null);

          return;
        }

        var layers = baseLayer.layers;
        var showIndex = 0;

        if (layers) {
          for (var i = 0, l = layers.length; i < l; i++) {
            var _layer = layers[i];

            if (_layer.isVisible()) {
              showIndex = i;
              break;
            }
          }
        }

        var json = baseLayer.toJSON();
        var options = null;

        if (layers) {
          options = json.layers[showIndex].options;
          options.visible = true;
        } else {
          options = json.options;
        }

        this._overview.setMinZoom(options.minZoom || null).setMaxZoom(options.maxZoom || null);

        delete options.minZoom;
        delete options.maxZoom;
        delete json.options.canvas;
        json.options.visible = true;
        json.options.renderer = 'canvas';
        var layer = Layer.fromJSON(json);

        for (var p in baseLayer) {
          if (isFunction(baseLayer[p]) && baseLayer.hasOwnProperty(p) && baseLayer[p] !== baseLayer.constructor.prototype[p]) {
            layer[p] = baseLayer[p];
          }
        }

        this._overview.setBaseLayer(layer);
      };

      return Overview;
    }(Control);

    Overview.mergeOptions(options$p);
    Map$1.mergeOptions({
      'overviewControl': false
    });
    Map$1.addOnLoadHook(function () {
      if (this.options['overviewControl']) {
        this.overviewControl = new Overview(this.options['overviewControl']);
        this.addControl(this.overviewControl);
      }
    });

    /**
     * @property {Object} options - options
     * @property {Object} [options.position='top-right']       - position of the control
     * @property {Boolean} [options.draggable=true]            - whether the panel can be dragged
     * @property {Boolean} [options.custom=false]              - whether the panel's content is customized .
     * @property {String|HTMLElement} options.content          - panel's content, can be a dom element or a string.
     * @property {Boolean} [options.closeButton=true]          - whether to display the close button on the panel.
     * @memberOf control.Panel
     * @instance
     */

    var options$q = {
      'position': 'top-right',
      'draggable': true,
      'custom': false,
      'content': '',
      'closeButton': true
    };
    /**
     * @classdesc
     * Class for panel controls.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var panel = new Panel({
     *     position : {'bottom': '0', 'right': '0'},
     *     draggable : true,
     *     custom : false,
     *     content : '<div class="map-panel">hello </div>',
     *     closeButton : true
     * }).addTo(map);
     */

    var Panel =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Panel, _Control);

      function Panel() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Panel.prototype;

      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn() {
        var dom;

        if (this.options['custom']) {
          if (isString(this.options['content'])) {
            dom = createEl('div');
            dom.innerHTML = this.options['content'];
          } else {
            dom = this.options['content'];
          }
        } else {
          dom = createEl('div', 'maptalks-panel');

          if (this.options['closeButton']) {
            var closeButton = createEl('a', 'maptalks-close');
            closeButton.href = 'javascript:;';

            closeButton.onclick = function () {
              dom.style.display = 'none';
            };

            dom.appendChild(closeButton);
          }

          var panelContent = createEl('div', 'maptalks-panel-content');
          panelContent.innerHTML = this.options['content'];
          dom.appendChild(panelContent);
        }

        this.draggable = new DragHandler(dom, {
          'cancelOn': this._cancelOn.bind(this),
          'ignoreMouseleave': true
        });
        this.draggable.on('dragstart', this._onDragStart, this).on('dragging', this._onDragging, this).on('dragend', this._onDragEnd, this);

        if (this.options['draggable']) {
          this.draggable.enable();
        }

        return dom;
      }
      /**
       * update control container
       * @return {control.Panel} this
       */
      ;

      _proto.update = function update() {
        if (this.draggable) {
          this.draggable.disable();
          delete this.draggable;
        }

        return Control.prototype.update.call(this);
      }
      /**
       * Set the content of the Panel.
       * @param {String|HTMLElement} content - content of the infowindow.
       * return {control.Panel} this
       * @fires Panel#contentchange
       */
      ;

      _proto.setContent = function setContent(content) {
        var old = this.options['content'];
        this.options['content'] = content;
        /**
         * contentchange event.
         *
         * @event Panel#contentchange
         * @type {Object}
         * @property {String} type - contentchange
         * @property {control.Panel} target - Panel
         * @property {String|HTMLElement} old      - old content
         * @property {String|HTMLElement} new      - new content
         */

        this.fire('contentchange', {
          'old': old,
          'new': content
        });

        if (this.isVisible()) {
          this.update();
        }

        return this;
      }
      /**
       * Get content of  the infowindow.
       * @return {String|HTMLElement} - content of the infowindow
       */
      ;

      _proto.getContent = function getContent() {
        return this.options['content'];
      };

      _proto._cancelOn = function _cancelOn(domEvent) {
        var target = domEvent.srcElement || domEvent.target,
            tagName = target.tagName.toLowerCase();

        if (tagName === 'button' || tagName === 'input' || tagName === 'select' || tagName === 'option' || tagName === 'textarea') {
          return true;
        }

        return false;
      };

      _proto._onDragStart = function _onDragStart(param) {
        this._startPos = param['mousePos'];
        this._startPosition = extend({}, this.getPosition());
        /**
         * drag start event
         * @event control.Panel#dragstart
         * @type {Object}
         * @property {String} type        - dragstart
         * @property {UIMarker} target    - the panel control fires event
         * @property {Point} mousePos     - mouse position
         * @property {Event} domEvent     - dom event
         */

        this.fire('dragstart', param);
      };

      _proto._onDragging = function _onDragging(param) {
        var pos = param['mousePos'];
        var offset = pos.sub(this._startPos);
        var startPosition = this._startPosition;
        var position = this.getPosition();

        if (!isNil(position['top'])) {
          position['top'] = parseInt(startPosition['top']) + offset.y;
        }

        if (!isNil(position['bottom'])) {
          position['bottom'] = parseInt(startPosition['bottom']) - offset.y;
        }

        if (!isNil(position['left'])) {
          position['left'] = parseInt(startPosition['left']) + offset.x;
        }

        if (!isNil(position['right'])) {
          position['right'] = parseInt(startPosition['right']) - offset.x;
        }

        this.setPosition(position);
        /**
         * dragging event
         * @event control.Panel#dragging
         * @type {Object}
         * @property {String} type        - dragging
         * @property {UIMarker} target    - the panel control fires event
         * @property {Point} mousePos     - mouse position
         * @property {Event} domEvent     - dom event
         */

        this.fire('dragging', param);
      };

      _proto._onDragEnd = function _onDragEnd(param) {
        delete this._startPos;
        delete this._startPosition;
        /**
         * drag end event
         * @event control.Panel#dragend
         * @type {Object}
         * @property {String} type        - dragend
         * @property {UIMarker} target    - the panel control fires event
         * @property {Point} mousePos     - mouse position
         * @property {Event} domEvent     - dom event
         */

        this.fire('dragend', param);
      }
      /**
       * Get the connect points of panel for connector lines.
       * @private
       */
      ;

      _proto._getConnectPoints = function _getConnectPoints() {
        var map = this.getMap();
        var containerPoint = this.getContainerPoint();
        var dom = this.getDOM(),
            width = parseInt(dom.clientWidth),
            height = parseInt(dom.clientHeight);
        var anchors = [//top center
        map.containerPointToCoordinate(containerPoint.add(width / 2, 0)), //middle right
        map.containerPointToCoordinate(containerPoint.add(width, height / 2)), //bottom center
        map.containerPointToCoordinate(containerPoint.add(width / 2, height)), //middle left
        map.containerPointToCoordinate(containerPoint.add(0, height / 2))];
        return anchors;
      };

      return Panel;
    }(Control);

    Panel.mergeOptions(options$q);

    /**
     * @property {Object} [options=null] - options
     * @property {String|Object}   [options.position="bottom-left"]  - position of the scale control.
     * @property {Number} [options.maxWidth=100]               - max width of the scale control.
     * @property {Boolean} [options.metric=true]               - Whether to show the metric scale line (m/km).
     * @property {Boolean} [options.imperial=false]            - Whether to show the imperial scale line (mi/ft).
     * @property {String|Object} [options.containerClass=null]           - scalControl's container div's CSS class
     * @instance
     * @memberOf control.Scale
     */

    var options$r = {
      'position': 'bottom-left',
      'maxWidth': 100,
      'metric': true,
      'imperial': false,
      'containerClass': null
    };
    /**
     * @classdesc
     * Based on scale control of Leaflet, a simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var scale = new Scale({
     *     position : 'bottom-left',
     *     maxWidth : 160,
     *     metric : true,
     *     imperial : true,
     *     containerClass : null
     * }).addTo(map);
     */

    var Scale =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Scale, _Control);

      function Scale() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Scale.prototype;

      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn(map) {
        this._map = map;
        this._scaleContainer = createEl('div', this.options['containerClass']);

        this._addScales();

        map.on('zoomend', this._update, this);

        if (this._map._loaded) {
          this._update();
        }

        return this._scaleContainer;
      };

      _proto.onRemove = function onRemove() {
        this.getMap().off('zoomend', this._update, this);
      };

      _proto._addScales = function _addScales() {
        var css = 'border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;' + 'color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden' + ';-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);';

        if (this.options['metric']) {
          this._mScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
        }

        if (this.options['imperial']) {
          this._iScale = createElOn('div', this.options['containerClass'] ? null : css, this._scaleContainer);
        }
      };

      _proto._update = function _update() {
        var map = this._map;
        var maxMeters = map.pixelToDistance(this.options['maxWidth'], 0);

        this._updateScales(maxMeters);
      };

      _proto._updateScales = function _updateScales(maxMeters) {
        if (this.options['metric'] && maxMeters) {
          this._updateMetric(maxMeters);
        }

        if (this.options['imperial'] && maxMeters) {
          this._updateImperial(maxMeters);
        }
      };

      _proto._updateMetric = function _updateMetric(maxMeters) {
        var meters = this._getRoundNum(maxMeters),
            label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

        this._updateScale(this._mScale, label, meters / maxMeters);
      };

      _proto._updateImperial = function _updateImperial(maxMeters) {
        var maxFeet = maxMeters * 3.2808399;
        var maxMiles, miles, feet;

        if (maxFeet > 5280) {
          maxMiles = maxFeet / 5280;
          miles = this._getRoundNum(maxMiles);

          this._updateScale(this._iScale, miles + ' mile', miles / maxMiles);
        } else {
          feet = this._getRoundNum(maxFeet);

          this._updateScale(this._iScale, feet + ' feet', feet / maxFeet);
        }
      };

      _proto._updateScale = function _updateScale(scale, text, ratio) {
        scale['style']['width'] = Math.round(this.options['maxWidth'] * ratio) + 'px';
        scale['innerHTML'] = text;
      };

      _proto._getRoundNum = function _getRoundNum(num) {
        var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1);
        var d = num / pow10;
        d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
        return pow10 * d;
      };

      return Scale;
    }(Control);

    Scale.mergeOptions(options$r);
    Map$1.mergeOptions({
      'scaleControl': false
    });
    Map$1.addOnLoadHook(function () {
      if (this.options['scaleControl']) {
        this.scaleControl = new Scale(this.options['scaleControl']);
        this.addControl(this.scaleControl);
      }
    });

    /**
     * @property {Object}   options - options
     * @property {String|Object}   [options.position="top-right"]          - position of the toolbar control.
     * @property {Boolean}  [options.vertical=true]                        - Whether the toolbar is a vertical one.
     * @property {Boolean}  [options.reverseMenu=false]                    - Whether to reverse direction of drop menu.
     * @property {Object[]} options.items                                  - items on the toolbar
     * @memberOf control.Toolbar
     * @instance
     */

    var options$s = {
      'height': 28,
      'vertical': false,
      'position': 'top-right',
      'reverseMenu': false,
      'items': {//default buttons
      }
    };
    /**
     * @classdesc
     * A toolbar control of the map.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var toolbar = new Toolbar({
     *     position : 'top-right',
     *     items: [
     *          {
     *            item: 'item1',
     *            click: function () {
     *              alert('item1 clicked');
     *            }
     *          },
     *          {
     *            item: 'item2',
     *            click: function () {
     *              alert('item2 clicked');
     *            }
     *          }
     *      ]
     * }).addTo(map);
     */

    var Toolbar =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Toolbar, _Control);

      function Toolbar() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Toolbar.prototype;

      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn(map) {
        this._map = map;
        var dom = createEl('div');
        var ul = createEl('ul', 'maptalks-toolbar-hx');
        dom.appendChild(ul);

        if (this.options['vertical']) {
          addClass(dom, 'maptalks-toolbar-vertical');
        } else {
          addClass(dom, 'maptalks-toolbar-horizonal');
        }

        var me = this;

        function onButtonClick(fn, index, childIndex, targetDom) {
          var item = me._getItems()[index];

          return function (e) {
            stopPropagation(e);
            return fn({
              'target': item,
              'index': index,
              'childIndex': childIndex,
              'dom': targetDom
            });
          };
        }

        var items = this.options['items'];

        if (isArrayHasData(items)) {
          for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var li = createEl('li');

            if (this.options['height'] !== 28) {
              li.style.lineHeight = this.options['height'] + 'px';
            }

            li.style.height = this.options['height'] + 'px';
            li.style.cursor = 'pointer';

            if (isHTML(item['item'])) {
              li.style.textAlign = 'center';
              var itemSize = measureDom('div', item['item']); //vertical-middle

              li.innerHTML = '<div style="margin-top:' + (this.options['height'] - itemSize['height']) / 2 + 'px;">' + item['item'] + '</div>';
            } else {
              li.innerHTML = item['item'];
            }

            if (item['click']) {
              on(li, 'click', onButtonClick(item['click'], i, null, li));
            }

            if (isArrayHasData(item['children'])) {
              var dropMenu = this._createDropMenu(i);

              li.appendChild(dropMenu);
              li._menu = dropMenu;
              on(li, 'mouseover', function () {
                this._menu.style.display = '';
              });
              on(li, 'mouseout', function () {
                this._menu.style.display = 'none';
              });
            }

            ul.appendChild(li);
          }
        }

        return dom;
      };

      _proto._createDropMenu = function _createDropMenu(index) {
        var me = this;

        function onButtonClick(fn, index, childIndex) {
          var item = me._getItems()[index]['children'][childIndex];

          return function (e) {
            stopPropagation(e);
            return fn({
              'target': item,
              'index': index,
              'childIndex': childIndex
            });
          };
        }

        var menuDom = createEl('div', 'maptalks-dropMenu'),
            items = this._getItems(),
            len = items.length,
            menuUL = createEl('ul'),
            children = items[index]['children'];

        if (index === len - 1 && children) {
          menuDom.style.cssText = 'right: 0px;';
          menuUL.style.cssText = 'right: 0px;position: absolute;';

          if (this.options['reverseMenu']) {
            menuUL.style.bottom = 0;
          }
        }

        menuDom.appendChild(createEl('em', 'maptalks-ico'));
        var liWidth = 0;

        for (var i = 0, l = children.length; i < l; i++) {
          var size = stringLength(children[i]['item'], '12px');

          if (size.width > liWidth) {
            liWidth = size.width;
          }
        }

        for (var _i = 0, _l = children.length; _i < _l; _i++) {
          var child = children[_i];
          var li = createEl('li');
          li.innerHTML = '<a href="javascript:;">' + child['item'] + '</a>';
          li.style.cursor = 'pointer';
          li.style.width = liWidth + 24 + 'px'; // 20 for text-intent

          on(li.childNodes[0], 'click', onButtonClick(child['click'], index, _i));
          menuUL.appendChild(li);
        }

        if (this.options['vertical']) {
          var width = liWidth < 95 ? 95 : liWidth;

          if (this.options['reverseMenu']) {
            menuDom.style.right = -(width + 10 * 2) + 'px';
          } else {
            menuDom.style.left = -(width + 10 * 2) + 'px'; // 10: padding in .maptalks-toolbar-vertical li
          }
        } else if (this.options['reverseMenu']) {
          menuDom.style.bottom = '28px';
        } else {
          menuDom.style.top = '28px';
        }

        menuDom.appendChild(menuUL);
        menuDom.style.display = 'none';
        return menuDom;
      };

      _proto._getItems = function _getItems() {
        return this.options['items'] || [];
      };

      return Toolbar;
    }(Control);

    Toolbar.mergeOptions(options$s);

    /**
     * @property {Object}   options - options
     * @property {String|Object}   [options.position="top-left"]  - position of the zoom control.
     * @property {Boolean}  [options.slider=true]                         - Whether to display the slider
     * @property {Boolean}  [options.zoomLevel=true]                      - Whether to display the text box of zoom level
     * @memberOf control.Zoom
     * @instance
     */

    var options$t = {
      'position': 'top-left',
      'slider': true,
      'zoomLevel': true,
      'seamless': false
    };
    var UNIT = 10;
    /**
     * @classdesc
     * A zoom control with buttons to zoomin/zoomout and a slider indicator for the zoom level.
     * @category control
     * @extends control.Control
     * @memberOf control
     * @example
     * var zoomControl = new Zoom({
     *     position : 'top-left',
     *     slider : true,
     *     zoomLevel : false
     * }).addTo(map);
     */

    var Zoom =
    /*#__PURE__*/
    function (_Control) {
      _inheritsLoose(Zoom, _Control);

      function Zoom() {
        return _Control.apply(this, arguments) || this;
      }

      var _proto = Zoom.prototype;

      /**
       * method to build DOM of the control
       * @param  {Map} map map to build on
       * @return {HTMLDOMElement}
       */
      _proto.buildOn = function buildOn(map) {
        var options = this.options;
        var dom = createEl('div', 'maptalks-zoom');

        if (options['zoomLevel']) {
          var levelDOM = createEl('span', 'maptalks-zoom-zoomlevel');
          dom.appendChild(levelDOM);
          this._levelDOM = levelDOM;
        }

        var zoomDOM = createEl('div', 'maptalks-zoom-slider');
        var zoomInButton = createEl('a', 'maptalks-zoom-zoomin');
        zoomInButton.href = 'javascript:;';
        zoomInButton.innerHTML = '+';
        zoomDOM.appendChild(zoomInButton);
        this._zoomInButton = zoomInButton;

        if (options['slider']) {
          var box = createEl('div', 'maptalks-zoom-slider-box');
          var ruler = createEl('div', 'maptalks-zoom-slider-ruler');
          var reading = createEl('span', 'maptalks-zoom-slider-reading');
          var dot = createEl('span', 'maptalks-zoom-slider-dot');
          ruler.appendChild(reading);
          box.appendChild(ruler);
          box.appendChild(dot);
          zoomDOM.appendChild(box);
          this._sliderBox = box;
          this._sliderRuler = ruler;
          this._sliderReading = reading;
          this._sliderDot = dot;
        }

        var zoomOutButton = createEl('a', 'maptalks-zoom-zoomout');
        zoomOutButton.href = 'javascript:;';
        zoomOutButton.innerHTML = '-';
        zoomDOM.appendChild(zoomOutButton);
        this._zoomOutButton = zoomOutButton;
        dom.appendChild(zoomDOM);
        map.on('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);

        this._update();

        this._registerDomEvents();

        return dom;
      };

      _proto.onRemove = function onRemove() {
        this.getMap().off('_zoomend _zooming _zoomstart _spatialreferencechange', this._update, this);

        if (this._zoomInButton) {
          off(this._zoomInButton, 'click', this._onZoomInClick, this);
        }

        if (this._zoomOutButton) {
          off(this._zoomOutButton, 'click', this._onZoomOutClick, this);
        }

        if (this._sliderRuler) {
          off(this._sliderRuler, 'click', this._onClickRuler, this);
          this.dotDragger.disable();
          delete this.dotDragger;
        }
      };

      _proto._update = function _update() {
        var map = this.getMap();

        if (this._sliderBox) {
          var totalRange = (map.getMaxZoom() - map.getMinZoom()) * UNIT;
          this._sliderBox.style.height = totalRange + 16 + 'px';
          this._sliderRuler.style.height = totalRange + 8 + 'px';
          this._sliderRuler.style.cursor = 'pointer';
          var zoomRange = (map.getMaxZoom() - map.getZoom()) * UNIT; //this._sliderReading.style.height = (map.getZoom() - map.getMinZoom()) * UNIT + 'px';

          this._sliderReading.style.height = (map.getZoom() - map.getMinZoom() + 1) * UNIT + 'px';
          this._sliderDot.style.top = zoomRange + 'px';
        }

        this._updateText();
      };

      _proto._updateText = function _updateText() {
        if (this._levelDOM) {
          var map = this.getMap();
          var zoom = map.getZoom();

          if (!isInteger(zoom)) {
            zoom = Math.floor(zoom * 10) / 10;
          }

          this._levelDOM.innerHTML = zoom;
        }
      };

      _proto._registerDomEvents = function _registerDomEvents() {
        if (this._zoomInButton) {
          on(this._zoomInButton, 'click', this._onZoomInClick, this);
        }

        if (this._zoomOutButton) {
          on(this._zoomOutButton, 'click', this._onZoomOutClick, this);
        }

        if (this._sliderRuler) {
          on(this._sliderRuler, 'click', this._onClickRuler, this);
          this.dotDragger = new DragHandler(this._sliderDot, {
            'ignoreMouseleave': true
          });
          this.dotDragger.on('dragstart', this._onDotDragstart, this).on('dragging dragend', this._onDotDrag, this).enable();
        }
      };

      _proto._onZoomInClick = function _onZoomInClick(e) {
        preventDefault(e);
        this.getMap().zoomIn();
      };

      _proto._onZoomOutClick = function _onZoomOutClick(e) {
        preventDefault(e);
        this.getMap().zoomOut();
      };

      _proto._onClickRuler = function _onClickRuler(e) {
        preventDefault(e);
        var map = this.getMap(),
            point = getEventContainerPoint(e, this._sliderRuler),
            h = point.y;
        var maxZoom = map.getMaxZoom(),
            zoom = Math.floor(maxZoom - h / UNIT);
        map.setZoom(zoom);
      };

      _proto._onDotDragstart = function _onDotDragstart(e) {
        preventDefault(e.domEvent);

        var map = this.getMap(),
            origin = map.getSize().toPoint()._multi(1 / 2);

        map.onZoomStart(map.getZoom(), origin);
      };

      _proto._onDotDrag = function _onDotDrag(e) {
        preventDefault(e.domEvent);

        var map = this.getMap(),
            origin = map.getSize().toPoint()._multi(1 / 2),
            point = getEventContainerPoint(e.domEvent, this._sliderRuler),
            maxZoom = map.getMaxZoom(),
            minZoom = map.getMinZoom();

        var top = point.y,
            z = maxZoom - top / UNIT;

        if (maxZoom < z) {
          z = maxZoom;
          top = 0;
        } else if (minZoom > z) {
          z = minZoom;
          top = (maxZoom - minZoom) * UNIT;
        }

        if (e.type === 'dragging') {
          map.onZooming(z, origin, 1);
        } else if (e.type === 'dragend') {
          if (this.options['seamless']) {
            map.onZoomEnd(z, origin);
          } else {
            map.onZoomEnd(Math.round(z), origin);
          }
        }

        this._sliderDot.style.top = top + 'px'; //this._sliderReading.style.height = (map.getZoom() - minZoom) * UNIT + 'px';

        this._sliderReading.style.height = (map.getZoom() - minZoom + 1) * UNIT + 'px';

        this._updateText();
      };

      return Zoom;
    }(Control);

    Zoom.mergeOptions(options$t);
    Map$1.mergeOptions({
      'zoomControl': false
    });
    Map$1.addOnLoadHook(function () {
      if (this.options['zoomControl']) {
        this.zoomControl = new Zoom(this.options['zoomControl']);
        this.addControl(this.zoomControl);
      }
    });



    var index$5 = /*#__PURE__*/Object.freeze({
        Control: Control,
        Attribution: Attribution,
        LayerSwitcher: LayerSwitcher,
        Overview: Overview,
        Panel: Panel,
        Scale: Scale,
        Toolbar: Toolbar,
        Zoom: Zoom
    });

    /**
     * @classdesc
     * A class internally used by tile layer helps to descibe tile system used by different tile services.<br>
     *
     * @class
     * @category layer
     * @example
     * var ts = new TileSystem([1, -1, -20037508.34, 20037508.34]);
     */

    var TileSystem =
    /*#__PURE__*/
    function () {
      /**
       * Similar with [transformation]{@link Transformation}, it contains 4 numbers: sx, sy, ox, oy.<br>
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}
       * @param  {Number} sx the order of X-axis tile index, 1 means right is larger and -1 means the reverse, left is larger;
       * @param  {Number} sy the order of Y-axis tile index, 1 means top is larger and -1 means the reverse, bottom is larger;
       * @param  {Number} ox x of the origin point of the world's projected coordinate system
       * @param  {Number} oy y of the origin point of the world's projected coordinate system
       */
      function TileSystem(sx, sy, ox, oy) {
        if (Array.isArray(sx)) {
          this.scale = {
            x: sx[0],
            y: sx[1]
          };
          this.origin = {
            x: sx[2],
            y: sx[3]
          };
        } else {
          this.scale = {
            x: sx,
            y: sy
          };
          this.origin = {
            x: ox,
            y: oy
          };
        }
      }
      /**
       * Get the default tile system's code for the projection.
       * @param  {Object} projection      - a projection object
       * @return {String} tile system code
       */


      TileSystem.getDefault = function getDefault(projection) {
        if (projection['code'].toLowerCase() === 'baidu') {
          return 'baidu';
        } else if (projection['code'].toLowerCase() === 'EPSG:4326'.toLowerCase()) {
          return 'tms-global-geodetic';
        } else if (projection['code'].toLowerCase() === 'identity') {
          return [1, -1, 0, 0];
        } else {
          return 'web-mercator';
        }
      };

      return TileSystem;
    }();

    var semiCircum = 6378137 * Math.PI;
    extend(TileSystem,
    /** @lends TileSystem */
    {
      /**
       * The most common used tile system, used by google maps, bing maps and amap, soso maps in China.
       * @see {@link https://en.wikipedia.org/wiki/Web_Mercator}
       * @constant
       * @static
       */
      'web-mercator': new TileSystem([1, -1, -semiCircum, semiCircum]),

      /**
       * Predefined tile system for TMS tile system, A tile system published by [OSGEO]{@link http://www.osgeo.org/}. <br>
       * Also used by mapbox's [mbtiles]{@link https://github.com/mapbox/mbtiles-spec} specification.
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification}
       * @constant
       * @static
       */
      'tms-global-mercator': new TileSystem([1, 1, -semiCircum, -semiCircum]),

      /**
       * Another tile system published by [OSGEO]{@link http://www.osgeo.org/}, based on EPSG:4326 SRS.
       * @see {@link http://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic}
       * @constant
       * @static
       */
      'tms-global-geodetic': new TileSystem([1, 1, -180, -90]),

      /**
       * Tile system used by [baidu]{@link http://map.baidu.com}
       * @constant
       * @static
       */
      'baidu': new TileSystem([1, 1, 0, 0])
    });

    /**
     * Tile config for tile layers, an utilities class for tile layers to render tiles
     * @class
     * @category layer
     * @private
     */

    var TileConfig =
    /*#__PURE__*/
    function () {
      /**
       * @param {TileSystem} tileSystem  - tileSystem
       * @param {Extent} fullExtent      - fullExtent of the tile layer
       * @param {Size} tileSize          - tile size
       */
      function TileConfig(map, tileSystem, fullExtent, tileSize) {
        this.map = map;
        this.tileSize = tileSize;
        this.fullExtent = fullExtent;
        this.prepareTileInfo(tileSystem, fullExtent);
        this._xScale = fullExtent['right'] >= fullExtent['left'] ? 1 : -1;
        this._yScale = fullExtent['top'] >= fullExtent['bottom'] ? 1 : -1;
        this._pointOrigin = map._prjToPoint(new Point(this.tileSystem['origin']), map.getGLZoom());
        this._glRes = map.getResolution(map.getGLZoom());
      }

      var _proto = TileConfig.prototype;

      _proto.prepareTileInfo = function prepareTileInfo(tileSystem, fullExtent) {
        if (isString(tileSystem)) {
          tileSystem = TileSystem[tileSystem.toLowerCase()];
        } else if (Array.isArray(tileSystem)) {
          tileSystem = new TileSystem(tileSystem);
        }

        if (!tileSystem) {
          throw new Error('Invalid TileSystem');
        }

        this.tileSystem = tileSystem; //自动计算transformation

        var a = fullExtent['right'] > fullExtent['left'] ? 1 : -1,
            b = fullExtent['top'] > fullExtent['bottom'] ? -1 : 1,
            c = tileSystem['origin']['x'],
            d = tileSystem['origin']['y'];
        this.transformation = new Transformation([a, b, c, d]);
      }
      /**
       * Get index of point's tile
       * @param  {Point} point - transformed point, this.transformation.transform(pCoord)
       * @param  {Number} res  - current resolution
       * @return {Object}       tile index
       */
      ;

      _proto._getTileNum = function _getTileNum(point, res) {
        var tileSystem = this.tileSystem,
            tileSize = this['tileSize'],
            delta = 1E-7;
        var tileX = Math.floor(delta * tileSystem['scale']['x'] + point.x / (tileSize['width'] * res));
        var tileY = Math.ceil(delta * tileSystem['scale']['y'] + point.y / (tileSize['height'] * res));
        return {
          'x': tileSystem['scale']['x'] * tileX,
          'y': tileSystem['scale']['y'] * tileY
        };
      }
      /**
       * Get tile index and offset from tile's northwest
       * @param  {Coordinate} pCoord   - projected coordinate
       * @param  {Number} res - current resolution
       * @return {Object}   tile index and offset
       */
      ;

      _proto.getTileIndex = function getTileIndex(pCoord, res, repeatWorld) {
        var tileSystem = this.tileSystem; // tileSize = this['tileSize'];

        var point = this.transformation.transform(pCoord, 1);

        var tileIndex = this._getTileNum(point, res); // const tileLeft = tileIndex['x'] * tileSize['width'];
        // const tileTop = tileIndex['y'] * tileSize['height'];
        // const offsetLeft = point.x / res - tileSystem['scale']['x'] * tileLeft;
        // const offsetTop = point.y / res + tileSystem['scale']['y'] * tileTop;
        //如果x方向为左大右小


        if (tileSystem['scale']['x'] < 0) {
          tileIndex['x'] -= 1;
        } //如果y方向上大下小


        if (tileSystem['scale']['y'] > 0) {
          tileIndex['y'] -= 1;
        } //有可能tileIndex超出世界范围


        return this.getNeighorTileIndex(tileIndex['x'], tileIndex['y'], 0, 0, res, repeatWorld);
      }
      /**
       * Get neibor's tile index
       * @param  {Number} tileX
       * @param  {Number} tileY
       * @param  {Number} offsetX
       * @param  {Number} offsetY
       * @param  {Number} zoomLevel
       * @return {Object}  tile's neighbor index
       */
      ;

      _proto.getNeighorTileIndex = function getNeighorTileIndex(tileX, tileY, offsetX, offsetY, res, repeatWorld) {
        var tileSystem = this.tileSystem;
        var x = tileX + tileSystem['scale']['x'] * offsetX;
        var y = tileY - tileSystem['scale']['y'] * offsetY;
        var out = false;
        var idx = x;
        var idy = y;

        var ext = this._getTileFullIndex(res);

        if (repeatWorld) {
          if (repeatWorld === true || repeatWorld === 'x') {
            //caculate tile index to request in url in repeated world.
            if (ext['xmax'] === ext['xmin']) {
              x = ext['xmin'];
            } else if (x < ext['xmin']) {
              x = ext['xmax'] - (ext['xmin'] - x) % (ext['xmax'] - ext['xmin']);

              if (x === ext['xmax']) {
                x = ext['xmin'];
              }
            } else if (x >= ext['xmax']) {
              x = ext['xmin'] + (x - ext['xmin']) % (ext['xmax'] - ext['xmin']);
            }
          }

          if (repeatWorld === true || repeatWorld === 'y') {
            if (ext['ymax'] === ext['ymin']) {
              y = ext['ymin'];
            } else if (y >= ext['ymax']) {
              y = ext['ymin'] + (y - ext['ymin']) % (ext['ymax'] - ext['ymin']);
            } else if (y < ext['ymin']) {
              y = ext['ymax'] - (ext['ymin'] - y) % (ext['ymax'] - ext['ymin']);

              if (y === ext['ymax']) {
                y = ext['ymin'];
              }
            }
          }
        }

        if (x < ext['xmin'] || x > ext['xmax'] || y > ext['ymax'] || y < ext['ymin']) {
          out = true;
        }

        return {
          // tile index to request in url
          'x': x,
          'y': y,
          // real tile index
          'idx': idx,
          'idy': idy,
          out: out
        };
      };

      _proto._getTileFullIndex = function _getTileFullIndex(res) {
        if (!this._tileFullIndex) {
          this._tileFullIndex = {};
        }

        if (this._tileFullIndex[res]) {
          return this._tileFullIndex[res];
        }

        var ext = this.fullExtent;
        var transformation = this.transformation;

        var nwIndex = this._getTileNum(transformation.transform(new Coordinate(ext['left'], ext['top']), 1), res);

        var seIndex = this._getTileNum(transformation.transform(new Coordinate(ext['right'], ext['bottom']), 1), res);

        var tileSystem = this.tileSystem; //如果x方向为左大右小

        if (tileSystem['scale']['x'] < 0) {
          nwIndex.x -= 1;
          seIndex.x -= 1;
        } //如果y方向上大下小


        if (tileSystem['scale']['y'] > 0) {
          nwIndex.y -= 1;
          seIndex.y -= 1;
        }

        this._tileFullIndex[res] = new Extent(nwIndex, seIndex);
        return this._tileFullIndex[res];
      }
      /**
       * Get tile's north west's projected coordinate
       * @param  {Number} tileX
       * @param  {Number} tileY
       * @param  {Number} res
       * @return {Number[]}
       */
      ;

      _proto.getTilePrjNW = function getTilePrjNW(tileX, tileY, res) {
        var tileSystem = this.tileSystem;
        var tileSize = this['tileSize'];
        var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * res * tileSize['height'];
        var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * res * tileSize['width'];
        return new Coordinate(x, y);
      };

      _proto.getTilePointNW = function getTilePointNW(tileX, tileY, res) {
        // res = res / this._glRes;
        var scale = this._glRes / res;
        var tileSystem = this.tileSystem;
        var tileSize = this['tileSize'];
        var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 1 : 0)) * tileSize['height'];
        var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 0 : 1)) * tileSize['width'];
        return new Point(x, y);
      }
      /**
       * Get tile's south east's projected coordinate
       * @param  {Number} tileX
       * @param  {Number} tileY
       * @param  {Number} res
       * @return {Number[]}
       */
      ;

      _proto.getTilePrjSE = function getTilePrjSE(tileX, tileY, res) {
        var tileSystem = this.tileSystem;
        var tileSize = this['tileSize'];
        var y = tileSystem['origin']['y'] + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * res * tileSize['height'];
        var x = tileSystem['origin']['x'] + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * res * tileSize['width'];
        return new Coordinate(x, y);
      };

      _proto.getTilePointSE = function getTilePointSE(tileX, tileY, res) {
        var scale = this._glRes / res;
        var tileSystem = this.tileSystem;
        var tileSize = this['tileSize'];
        var y = this._pointOrigin.y * scale + this._yScale * tileSystem['scale']['y'] * (tileY + (tileSystem['scale']['y'] === 1 ? 0 : 1)) * tileSize['height'];
        var x = this._pointOrigin.x * scale + this._xScale * tileSystem['scale']['x'] * (tileX + (tileSystem['scale']['x'] === 1 ? 1 : 0)) * tileSize['width'];
        return new Point(x, y);
      }
      /**
       * Get tile's projected extent
       * @param  {Number} tileX
       * @param  {Number} tileY
       * @param  {Number} res
       * @return {Extent}
       */
      ;

      _proto.getTilePrjExtent = function getTilePrjExtent(tileX, tileY, res) {
        var nw = this.getTilePrjNW(tileX, tileY, res),
            se = this.getTilePrjSE(tileX, tileY, res);
        return new Extent(nw, se);
      };

      return TileConfig;
    }();

    /*!
    * Contains code from THREE.js
    * MIT License
    * https://github.com/mrdoob/three.js
    */
    var planes = [];

    for (var i = 0; i < 6; i++) {
      planes[i] = [];
    }
    var p = [];
    function intersectsBox(matrix, box, mask) {
      setPlanes(matrix);

      for (var i = 0; i < 6; i++) {
        if (mask && mask.charAt(i) === '0') {
          continue;
        }

        var plane = planes[i]; // corner at max distance

        p[0] = plane[0] > 0 ? box[1][0] : box[0][0];
        p[1] = plane[1] > 0 ? box[1][1] : box[0][1];
        p[2] = plane[2] > 0 ? box[1][2] : box[0][2];

        if (distanceToPoint(plane, p) < 0) {
          return false;
        }
      }

      return true;
    }

    function setPlanes(m) {
      var me = m;
      var me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
      var me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
      var me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
      var me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15]; //right

      setComponents(planes[0], me3 - me0, me7 - me4, me11 - me8, me15 - me12); //left

      setComponents(planes[1], me3 + me0, me7 + me4, me11 + me8, me15 + me12); //bottom

      setComponents(planes[2], me3 + me1, me7 + me5, me11 + me9, me15 + me13); //top

      setComponents(planes[3], me3 - me1, me7 - me5, me11 - me9, me15 - me13); //z-far

      setComponents(planes[4], me3 - me2, me7 - me6, me11 - me10, me15 - me14); //z-near

      setComponents(planes[5], me3 + me2, me7 + me6, me11 + me10, me15 + me14);
    }

    var normalLength = 1.0 / 6;

    function setComponents(out, x, y, z, w) {
      out[0] = x * normalLength;
      out[1] = y * normalLength;
      out[2] = z * normalLength;
      out[3] = w * normalLength;
      return out;
    }

    function distanceToPoint(plane, p) {
      return plane[0] * p[0] + plane[1] * p[1] + plane[2] * p[2] + plane[3];
    }

    var isSetAvailable = typeof Set !== 'undefined';

    var TileHashset =
    /*#__PURE__*/
    function () {
      function TileHashset() {
        this._table = isSetAvailable ? new Set() : {};
      }

      var _proto = TileHashset.prototype;

      _proto.add = function add$$1(key) {
        if (isSetAvailable) {
          this._table.add(key);
        } else {
          this._table[key] = true;
        }
      };

      _proto.has = function has(key) {
        if (isSetAvailable) {
          return this._table.has(key);
        } else {
          return this._table[key];
        }
      };

      _proto.reset = function reset() {
        if (isSetAvailable) {
          this._table.clear();
        } else {
          this._table = {};
        }
      };

      return TileHashset;
    }();
    /**
     * @property {Object}              options                     - TileLayer's options
     * @property {String|Function}     options.urlTemplate         - url templates
     * @property {String[]|Number[]}   [options.subdomains=null]   - subdomains to replace '{s}' in urlTemplate
     * @property {Object}              [options.spatialReference=null] - TileLayer's spatial reference
     * @property {Number[]}            [options.tileSize=[256, 256]] - size of the tile image, [width, height]
     * @property {Number[]|Function}   [options.offset=[0, 0]]       - overall tile offset, [dx, dy], useful for tile sources from difference coordinate systems, e.g. (wgs84 and gcj02)
     * @property {Number[]}            [options.tileSystem=null]     - tile system number arrays
     * @property {Number}              [options.maxAvailableZoom=null] - Maximum zoom level for which tiles are available. Data from tiles at the maxAvailableZoom are used when displaying the map at higher zoom levels.
     * @property {Boolean}             [options.repeatWorld=true]  - tiles will be loaded repeatedly outside the world.
     * @property {Boolean}             [options.background=true]   - whether to draw a background during or after interacting, true by default
     * @property {Number}              [options.backgroundZoomDiff=6] - the zoom diff to find parent tile as background
     * @property {Boolean|Function}    [options.placeholder=false]    - a placeholder image to replace loading tile, can be a function with a parameter of the tile canvas
     * @property {String}              [options.fragmentShader=null]  - custom fragment shader, replace <a href="https://github.com/maptalks/maptalks.js/blob/master/src/renderer/layer/tilelayer/TileLayerGLRenderer.js#L8">the default fragment shader</a>
     * @property {String}              [options.crossOrigin=null]    - tile image's corssOrigin
     * @property {Boolean}             [options.fadeAnimation=true]  - fade animation when loading tiles
     * @property {Boolean}             [options.debug=false]         - if set to true, tiles will have borders and a title of its coordinates.
     * @property {String}              [options.renderer=gl]         - TileLayer's renderer, canvas or gl. gl tiles requires image CORS that canvas doesn't. canvas tiles can't pitch.
     * @property {Number}              [options.maxCacheSize=256]    - maximum number of tiles to cache
     * @property {Boolean}             [options.cascadeTiles=true]      - draw cascaded tiles of different zooms to reduce tiles
     * @property {Number}              [options.zoomOffset=0]           - offset from map's zoom to tile's zoom
     * @property {Number}              [options.tileRetryCount=0]       - retry count of tiles
     * @memberOf TileLayer
     * @instance
     */


    var options$u = {
      'urlTemplate': null,
      'subdomains': null,
      'repeatWorld': true,
      'background': true,
      'backgroundZoomDiff': 6,
      'loadingLimitOnInteracting': 3,
      'tileRetryCount': 0,
      'placeholder': false,
      'crossOrigin': null,
      'tileSize': [256, 256],
      'offset': [0, 0],
      'tileSystem': null,
      'fadeAnimation': !IS_NODE,
      'debug': false,
      'spatialReference': null,
      'maxCacheSize': 256,
      'renderer': function () {
        return Browser$1.webgl ? 'gl' : 'canvas';
      }(),
      'clipByPitch': true,
      'maxAvailableZoom': null,
      'cascadeTiles': true,
      'zoomOffset': 0
    };
    var URL_PATTERN = /\{ *([\w_]+) *\}/g; // const MAX_VISIBLE_SIZE = 5;

    var TEMP_POINT = new Point(0, 0);
    var TEMP_POINT0$3 = new Point(0, 0);
    var TEMP_POINT1$2 = new Point(0, 0);
    var TEMP_POINT2$1 = new Point(0, 0);
    var TEMP_POINT3 = new Point(0, 0);
    var TEMP_POINT4 = new Point(0, 0);
    var TEMP_POINT5 = new Point(0, 0);
    var TEMP_POINT6 = new Point(0, 0); // const TEMP_POINT_EXTENT = new PointExtent();

    var TILE_BOX = [[0, 0, 0], [0, 0, 0]];
    var ARR3 = [];
    /**
     * @classdesc
     * A layer used to display tiled map services, such as [google maps]{@link http://maps.google.com}, [open street maps]{@link http://www.osm.org}
     * @category layer
     * @extends Layer
     * @param {String|Number} id - tile layer's id
     * @param {Object} [options=null] - options defined in [TileLayer]{@link TileLayer#options}
     * @example
     * new TileLayer("tile",{
            urlTemplate : 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            subdomains:['a','b','c']
        })
     */

    var TileLayer =
    /*#__PURE__*/
    function (_Layer) {
      _inheritsLoose(TileLayer, _Layer);

      function TileLayer() {
        return _Layer.apply(this, arguments) || this;
      }

      /**
       * Reproduce a TileLayer from layer's profile JSON.
       * @param  {Object} layerJSON - layer's profile JSON
       * @return {TileLayer}
       * @static
       * @private
       * @function
       */
      TileLayer.fromJSON = function fromJSON(layerJSON) {
        if (!layerJSON || layerJSON['type'] !== 'TileLayer') {
          return null;
        }

        return new TileLayer(layerJSON['id'], layerJSON['options']);
      }
      /**
       * Get tile size of the tile layer
       * @return {Size}
       */
      ;

      var _proto2 = TileLayer.prototype;

      _proto2.getTileSize = function getTileSize() {
        var size = this.options['tileSize'];

        if (isNumber(size)) {
          size = [size, size];
        }

        return new Size(size);
      }
      /**
       * Get tiles at zoom z (or current zoom)
       * @param {Number} z - zoom
       * @return {Object[]} tile descriptors
       */
      ;

      _proto2.getTiles = function getTiles(z, parentLayer) {
        var map = this.getMap();
        var pitch = map.getPitch();
        var parentRenderer = parentLayer && parentLayer.getRenderer();
        var mapExtent = map.getContainerExtent();
        var tileGrids = [];
        var count = 0;
        var minZoom = this.getMinZoom();
        var cascadePitch0 = map.options['cascadePitches'][0];
        var tileZoom = isNil(z) ? this._getTileZoom(map.getZoom()) : z;
        this._visitedTiles = new TileHashset();
        this._coordCache = {};

        if (!isNil(z) || !this.options['cascadeTiles'] || pitch <= cascadePitch0 || !isNil(minZoom) && tileZoom <= minZoom) {
          var _currentTiles = this._getTiles(tileZoom, mapExtent, 2, parentRenderer);

          if (_currentTiles) {
            count += _currentTiles.tiles.length;
            tileGrids.push(_currentTiles);
          }

          return {
            tileGrids: tileGrids,
            count: count
          };
        }

        var visualHeight0 = Math.floor(map._getVisualHeight(cascadePitch0));
        var extent0 = new PointExtent(0, map.height - visualHeight0, map.width, map.height);

        var currentTiles = this._getTiles(tileZoom, extent0, 0, parentRenderer);

        count += currentTiles ? currentTiles.tiles.length : 0;
        tileGrids.push(currentTiles);
        var cascadeHeight = extent0.ymin;
        var d = map.getSpatialReference().getZoomDirection();
        var cascadePitch1 = map.options['cascadePitches'][1];
        var cascadeLevels = d;
        var cascadeTiles1;

        if (pitch > cascadePitch1) {
          if (tileZoom - cascadeLevels <= minZoom) {
            cascadeLevels = 0;
          }

          var visualHeight1 = Math.floor(map._getVisualHeight(cascadePitch1));
          var extent1 = new PointExtent(0, map.height - visualHeight1, map.width, cascadeHeight);
          cascadeTiles1 = this._getTiles(tileZoom - cascadeLevels, extent1, 1, parentRenderer);
          count += cascadeTiles1 ? cascadeTiles1.tiles.length : 0;
          cascadeHeight = extent1.ymin;
          cascadeLevels += 4 * d;
        }

        var cascadeTiles2;

        if (tileZoom - cascadeLevels >= minZoom) {
          var extent2 = new PointExtent(0, mapExtent.ymin, map.width, cascadeHeight);
          cascadeTiles2 = this._getTiles(tileZoom - cascadeLevels, extent2, 2, parentRenderer);
          count += cascadeTiles2 ? cascadeTiles2.tiles.length : 0;
          tileGrids.push(cascadeTiles2);
        }

        if (cascadeTiles1) {
          tileGrids.push(cascadeTiles1);
        } // console.log(currentTiles && currentTiles.tiles.length, cascadeTiles1 && cascadeTiles1.tiles.length, cascadeTiles2 && cascadeTiles2.tiles.length);


        return {
          tileGrids: tileGrids,
          count: count
        };
      }
      /**
       * Get tile's url
       * @param {Number} x
       * @param {Number} y
       * @param {Number} z
       * @returns {String} url
       */
      ;

      _proto2.getTileUrl = function getTileUrl(x, y, z) {
        var urlTemplate = this.options['urlTemplate'];
        var domain = '';

        if (this.options['subdomains']) {
          var subdomains = this.options['subdomains'];

          if (isArrayHasData(subdomains)) {
            var length$$1 = subdomains.length;
            var s = (x + y) % length$$1;

            if (s < 0) {
              s = 0;
            }

            domain = subdomains[s];
          }
        }

        if (isFunction(urlTemplate)) {
          return urlTemplate(x, y, z, domain);
        }

        var data = {
          'x': x,
          'y': y,
          'z': z,
          's': domain
        };
        return urlTemplate.replace(URL_PATTERN, function (str, key) {
          var value = data[key];

          if (value === undefined) {
            throw new Error('No value provided for variable ' + str);
          } else if (typeof value === 'function') {
            value = value(data);
          }

          return value;
        });
      }
      /**
       * Clear the layer
       * @return {TileLayer} this
       */
      ;

      _proto2.clear = function clear() {
        if (this._renderer) {
          this._renderer.clear();
        }
        /**
         * clear event, fired when tile layer is cleared.
         *
         * @event TileLayer#clear
         * @type {Object}
         * @property {String} type - clear
         * @property {TileLayer} target - tile layer
         */


        this.fire('clear');
        return this;
      }
      /**
       * Export the tile layer's profile json. <br>
       * Layer's profile is a snapshot of the layer in JSON format. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return {Object} layer's profile JSON
       */
      ;

      _proto2.toJSON = function toJSON() {
        var profile = {
          'type': this.getJSONType(),
          'id': this.getId(),
          'options': this.config()
        };
        return profile;
      }
      /**
       * Get tilelayer's spatial reference.
       * @returns {SpatialReference} spatial reference
       */
      ;

      _proto2.getSpatialReference = function getSpatialReference() {
        var map = this.getMap();

        if (map && (!this.options['spatialReference'] || SpatialReference.equals(this.options['spatialReference'], map.options['spatialReference']))) {
          return map.getSpatialReference();
        }

        this._sr = this._sr || new SpatialReference(this.options['spatialReference']);

        if (this._srMinZoom === undefined) {
          this._srMinZoom = this._sr.getMinZoom();
          this._srMaxZoom = this._sr.getMaxZoom();
        }

        return this._sr;
      };

      _proto2.getMinZoom = function getMinZoom() {
        var sr = this.getSpatialReference();

        if (sr !== this.getMap().getSpatialReference()) {
          return Math.max(_Layer.prototype.getMinZoom.call(this), this._srMinZoom);
        }

        return _Layer.prototype.getMinZoom.call(this);
      };

      _proto2.getMaxZoom = function getMaxZoom() {
        var sr = this.getSpatialReference();

        if (sr !== this.getMap().getSpatialReference()) {
          return Math.min(_Layer.prototype.getMaxZoom.call(this), this._srMaxZoom);
        }

        return _Layer.prototype.getMaxZoom.call(this);
      };

      _proto2._getTileZoom = function _getTileZoom(zoom) {
        if (!isInteger(zoom)) {
          zoom = Math.round(zoom);
        }

        var maxZoom = this.options['maxAvailableZoom'];

        if (!isNil(maxZoom) && zoom > maxZoom) {
          zoom = maxZoom;
        }

        return zoom;
      };

      _proto2._getTiles = function _getTiles(tileZoom, containerExtent, cascadeLevel, parentRenderer) {
        var _this = this;

        // rendWhenReady = false;
        var map = this.getMap();
        var z = tileZoom;
        var frustumMatrix = map.projViewMatrix;

        if (cascadeLevel < 2) {
          if (cascadeLevel === 0) {
            z -= 1;
          }

          frustumMatrix = cascadeLevel === 0 ? map.cascadeFrustumMatrix0 : cascadeLevel === 1 ? map.cascadeFrustumMatrix1 : map.projViewMatrix;
        }

        var zoom = z + this.options['zoomOffset'];

        var offset = this._getTileOffset(zoom),
            hasOffset = offset[0] || offset[1];

        var emptyGrid = {
          'zoom': z,
          'extent': null,
          'offset': offset,
          'tiles': []
        };

        if (zoom < 0) {
          return emptyGrid;
        }

        var minZoom = this.getMinZoom(),
            maxZoom = this.getMaxZoom();

        if (!map || !this.isVisible() || !map.width || !map.height) {
          return emptyGrid;
        }

        if (!isNil(minZoom) && z < minZoom || !isNil(maxZoom) && z > maxZoom) {
          return emptyGrid;
        }

        var tileConfig = this._getTileConfig();

        if (!tileConfig) {
          return emptyGrid;
        }

        var sr = this.getSpatialReference();
        var mapSR = map.getSpatialReference();
        var res = sr.getResolution(zoom);
        var glScale = map.getGLScale(z);
        var repeatWorld = sr === mapSR && this.options['repeatWorld'];
        var extent2d = containerExtent.convertTo(function (c) {
          if (c.y > 0 && c.y < map.height) {
            var key = (c.x === 0 ? 0 : 1) + c.y;

            if (!_this._coordCache[key]) {
              _this._coordCache[key] = map._containerPointToPoint(c);
            }

            return _this._coordCache[key];
          }

          return map._containerPointToPoint(c, undefined, TEMP_POINT);
        }); // const innerExtent2D = this._getInnerExtent(z, containerExtent, extent2d)._add(offset);

        extent2d._add(offset);

        var maskExtent = this._getMask2DExtent();

        if (maskExtent) {
          var intersection = maskExtent.intersection(extent2d);

          if (!intersection) {
            return emptyGrid;
          }

          containerExtent = intersection.convertTo(function (c) {
            return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT);
          });
        } //Get description of center tile including left and top offset


        var prjCenter = map._containerPointToPrj(containerExtent.getCenter(), TEMP_POINT0$3);

        var centerPoint = map._prjToPoint(prjCenter, undefined, TEMP_POINT1$2);

        var c;

        if (hasOffset) {
          c = this._project(map._pointToPrj(centerPoint._add(offset), undefined, TEMP_POINT1$2), TEMP_POINT1$2);
        } else {
          c = this._project(prjCenter, TEMP_POINT1$2);
        }

        TEMP_POINT2$1.x = extent2d.xmin;
        TEMP_POINT2$1.y = extent2d.ymax;
        TEMP_POINT3.x = extent2d.xmax;
        TEMP_POINT3.y = extent2d.ymin;

        var pmin = this._project(map._pointToPrj(TEMP_POINT2$1, undefined, TEMP_POINT2$1), TEMP_POINT2$1);

        var pmax = this._project(map._pointToPrj(TEMP_POINT3, undefined, TEMP_POINT3), TEMP_POINT3);

        var centerTile = tileConfig.getTileIndex(c, res, repeatWorld);
        var ltTile = tileConfig.getTileIndex(pmin, res, repeatWorld);
        var rbTile = tileConfig.getTileIndex(pmax, res, repeatWorld); // Number of tiles around the center tile

        var top = Math.ceil(Math.abs(centerTile.idy - ltTile.idy)),
            left = Math.ceil(Math.abs(centerTile.idx - ltTile.idx)),
            bottom = Math.ceil(Math.abs(centerTile.idy - rbTile.idy)),
            right = Math.ceil(Math.abs(centerTile.idx - rbTile.idx));
        var allCount = (top + bottom + 1) * (left + right + 1);
        var tileSize = this.getTileSize();

        var renderer = this.getRenderer() || parentRenderer,
            scale = this._getTileConfig().tileSystem.scale;

        var tiles = [],
            extent = new PointExtent();

        for (var i = -top; i <= bottom; i++) {
          var j = -left;
          var leftVisitEnd = -Infinity;
          var rightVisitEnd = false;

          while (j >= leftVisitEnd && j <= right) {
            var idx = tileConfig.getNeighorTileIndex(centerTile.idx, centerTile.idy, j, i, res, repeatWorld);

            if (leftVisitEnd === -Infinity) {
              //从左往右遍历中
              j++;
            } else {
              //从右往左遍历中
              j--;
            }

            var tileId = this._getTileId(idx.idx, idx.idy, z);

            if (idx.out || this._visitedTiles && this._visitedTiles.has(tileId)) {
              continue;
            } //unique id of the tile


            var tileInfo = renderer && renderer.isTileCachedOrLoading(tileId);

            if (tileInfo) {
              tileInfo = tileInfo.info;
            }

            var p = void 0;

            if (tileInfo) {
              var _tileInfo = tileInfo,
                  point0 = _tileInfo.point0;
              p = tileInfo.point.set(point0.x, point0.y);
            } else if (!this._hasOwnSR) {
              p = tileConfig.getTilePointNW(idx.x, idx.y, res); // const pnw = tileConfig.getTilePrjNW(idx.x, idx.y, res);
              // p = map._prjToPoint(this._unproject(pnw, TEMP_POINT3), z);
            } else {
              var pnw = tileConfig.getTilePrjNW(idx.x, idx.y, res);
              p = map._prjToPoint(this._unproject(pnw, TEMP_POINT3), z);
            }

            var width = void 0,
                height = void 0;

            if (sr === mapSR) {
              width = tileSize.width;
              height = tileSize.height;
            } else {
              var pp = void 0;

              if (!this._hasOwnSR) {
                pp = tileConfig.getTilePointSE(idx.x, idx.y, res);
              } else {
                var pse = tileConfig.getTilePrjSE(idx.x, idx.y, res);
                pp = map._prjToPoint(this._unproject(pse, TEMP_POINT3), z, TEMP_POINT3);
              }

              width = Math.ceil(Math.abs(pp.x - p.x));
              height = Math.ceil(Math.abs(pp.y - p.y));
            }

            var dx = scale.x * (idx.idx - idx.x) * width,
                dy = scale.y * (idx.idy - idx.y) * height;

            if (dx || dy) {
              p._add(dx, dy);
            }

            if (hasOffset) {
              p._sub(offset);
            }

            var tileExtent = tileInfo && tileInfo.extent2d || new PointExtent(p.x, p.y, p.x + width, p.y - height);

            if (allCount <= 4 || rightVisitEnd || this._isTileInExtent(frustumMatrix, tileExtent, glScale)) {
              if (this._visitedTiles && cascadeLevel === 0) {
                this._visitedTiles.add(tileId);
              }

              if (cascadeLevel === 0) {
                this._splitTiles(frustumMatrix, tiles, renderer, idx, z + 1, tileExtent, offset, dx, dy);

                extent._combine(tileExtent);
              } else {
                if (!tileInfo) {
                  tileInfo = {
                    //reserve point caculated by tileConfig
                    //so add offset because we have p._sub(offset) and p._add(dx, dy) if hasOffset
                    'point0': p.add(offset)._sub(dx, dy),
                    'point': p,
                    'z': z,
                    'x': idx.x,
                    'y': idx.y,
                    'extent2d': tileExtent,
                    'mask': cascadeLevel,
                    'size': [width, height],
                    'id': tileId,
                    'dupKey': tileId,
                    'layer': this.getId(),
                    'url': this.getTileUrl(idx.x, idx.y, zoom)
                  };
                }

                if (hasOffset) {
                  tileExtent.set(p.x, p.y, p.x + width, p.y - height);
                  tileInfo.point = p._add(offset);

                  tileExtent._add(offset);
                }

                tiles.push(tileInfo);

                extent._combine(tileExtent);
              }

              if (leftVisitEnd === -Infinity) {
                //从左往右第一次遇到可视的瓦片，改为从右往左遍历
                leftVisitEnd = j;
                j = right; // - Math.max(j - -left - 4, 0);
                // rightVisitEnd = true;
              } else if (!rightVisitEnd) {
                //从右往左第一次遇到可视瓦片，之后的瓦片全部可视
                rightVisitEnd = true;
              }
            }
          }
        }

        if (tiles.length) {
          //sort tiles according to tile's distance to center
          var center = map._containerPointToPoint(containerExtent.getCenter(), z, TEMP_POINT)._add(offset);

          tiles.sort(function (a, b) {
            return a.point.distanceTo(center) - b.point.distanceTo(center);
          });
        }

        return {
          'offset': offset,
          'zoom': tileZoom,
          'extent': extent,
          'tiles': tiles
        };
      };

      _proto2._splitTiles = function _splitTiles(frustumMatrix, tiles, renderer, tileIdx, z, tileExtent, offset, dx, dy) {
        // const hasOffset = offset[0] || offset[1];
        var glScale = this.getMap().getGLScale(z);
        var nw = TEMP_POINT4.set(tileExtent.xmin * 2, tileExtent.ymax * 2);

        var nw0 = TEMP_POINT5.set(tileExtent.xmin, tileExtent.ymax)._add(offset)._sub(dx, dy)._multi(2);

        var w = tileExtent.getWidth();
        var h = tileExtent.getHeight();
        var idx = tileIdx.idx * 2;
        var idy = tileIdx.idy * 2;
        var x = tileIdx.x * 2;
        var y = tileIdx.y * 2;

        var tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 0, 0, w, h, nw, nw0, offset, glScale);

        if (tile) tiles.push(tile);
        tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 0, 1, w, h, nw, nw0, offset, glScale);
        if (tile) tiles.push(tile);
        tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 1, 0, w, h, nw, nw0, offset, glScale);
        if (tile) tiles.push(tile);
        tile = this._checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, 1, 1, w, h, nw, nw0, offset, glScale);
        if (tile) tiles.push(tile);
      };

      _proto2._checkAndAddTile = function _checkAndAddTile(frustumMatrix, renderer, idx, idy, x, y, z, i, j, w, h, nw, nw0, offset, glScale) {
        var tileId = this._getTileId(idx + i, idy + j, z);

        if (this._visitedTiles && this._visitedTiles.has(tileId)) {
          return null;
        }

        var childExtent = new PointExtent(nw.x + i * w, nw.y - j * h, nw.x + (i + 1) * w, nw.y - (j + 1) * h);

        if (
        /*!rightVisitEnd && */
        !this._isSplittedTileInExtent(frustumMatrix, childExtent, glScale)) {
          return null;
        }

        var hasOffset = offset[0] || offset[1];
        var tileInfo = renderer && renderer.isTileCachedOrLoading(tileId);

        if (!tileInfo) {
          //reserve point caculated by tileConfig
          //so add offset because we have p._sub(offset) and p._add(dx, dy) if hasOffset
          tileInfo = {
            'point0': nw0.add(i * w, -j * h),
            'point': nw.add(i * w, -j * h),
            'z': z,
            'x': x + i,
            'y': y + j,
            'extent2d': childExtent,
            'size': [w, h],
            'id': tileId,
            'dupKey': tileId,
            'layer': this.getId(),
            'url': this.getTileUrl(x + i, y + j, z + this.options['zoomOffset'])
          };
        } else {
          tileInfo = tileInfo.info;
        }

        if (hasOffset) {
          tileInfo.extent2d = childExtent;

          tileInfo.extent2d._add(offset);

          tileInfo.point.set(nw.x, nw.y)._add(offset);
        }

        return tileInfo;
      };

      _proto2._getTileOffset = function _getTileOffset(z) {
        var map = this.getMap();

        var scale = map._getResolution() / map._getResolution(z);

        var offset = this.options['offset'];

        if (isFunction(offset)) {
          offset = offset(this);
        }

        offset[0] *= scale;
        offset[1] *= scale;
        return offset;
      };

      _proto2._getTileId = function _getTileId(x, y, zoom, id) {
        //id is to mark GroupTileLayer's child layers
        return (id || this.getId()) + "_" + y + "_" + x + "_" + zoom;
      };

      _proto2._project = function _project(pcoord, out) {
        if (this._hasOwnSR) {
          var map = this.getMap();
          var mapProjection = map.getProjection();
          var projection = this.getSpatialReference().getProjection();
          return projection.project(mapProjection.unproject(pcoord, out), out);
        } else {
          return pcoord;
        }
      };

      _proto2._unproject = function _unproject(pcoord, out) {
        if (this._hasOwnSR) {
          var map = this.getMap();
          var sr = this.getSpatialReference();
          var mapProjection = map.getProjection();
          var projection = sr.getProjection();
          return mapProjection.project(projection.unproject(pcoord, out), out);
        } else {
          return pcoord;
        }
      }
      /**
       * initialize [tileConfig]{@link TileConfig} for the tilelayer
       * @private
       */
      ;

      _proto2._initTileConfig = function _initTileConfig() {
        var map = this.getMap(),
            tileSize = this.getTileSize();
        var sr = this.getSpatialReference();
        var projection = sr.getProjection(),
            fullExtent = sr.getFullExtent();
        this._defaultTileConfig = new TileConfig(map, TileSystem.getDefault(projection), fullExtent, tileSize);

        if (this.options['tileSystem']) {
          this._tileConfig = new TileConfig(map, this.options['tileSystem'], fullExtent, tileSize);
        } //inherit baselayer's tileconfig


        if (map && !this._tileConfig && map.getSpatialReference() === sr && map.getBaseLayer() && map.getBaseLayer() !== this && map.getBaseLayer()._getTileConfig) {
          var base = map.getBaseLayer()._getTileConfig();

          this._tileConfig = new TileConfig(map, base.tileSystem, base.fullExtent, tileSize);
        }

        this._hasOwnSR = sr !== map.getSpatialReference();
      };

      _proto2._getTileConfig = function _getTileConfig() {
        if (!this._defaultTileConfig) {
          this._initTileConfig();
        }

        return this._tileConfig || this._defaultTileConfig;
      };

      _proto2._bindMap = function _bindMap(map) {
        var baseLayer = map.getBaseLayer();

        if (baseLayer === this) {
          if (!baseLayer.options.hasOwnProperty('forceRenderOnMoving')) {
            this.config({
              'forceRenderOnMoving': true
            });
          }
        }

        return _Layer.prototype._bindMap.apply(this, arguments);
      };

      _proto2._isTileInExtent = function _isTileInExtent(frustumMatrix, tileExtent, glScale) {
        var map = this.getMap();
        var matrix;

        if (frustumMatrix !== map.projViewMatrix) {
          var tileCenter = tileExtent.getCenter(TEMP_POINT6)._multi(glScale);

          set$2(ARR3, tileCenter.x, tileCenter.y, 0);
          var ndc = transformMat4(ARR3, ARR3, map.projViewMatrix); //地图中心下方的瓦片与 map.projViewMatrix 比较
          //地图中心上方的瓦片与 map.cascadeFrustumMatrix 比较

          matrix = ndc[1] < 0 ? map.projViewMatrix : frustumMatrix;
        } else {
          matrix = map.projViewMatrix;
        }

        TILE_BOX[0][0] = tileExtent.xmin * glScale;
        TILE_BOX[0][1] = tileExtent.ymin * glScale;
        TILE_BOX[1][0] = tileExtent.xmax * glScale;
        TILE_BOX[1][1] = tileExtent.ymax * glScale;
        return intersectsBox(matrix, TILE_BOX);
      };

      _proto2._isSplittedTileInExtent = function _isSplittedTileInExtent(frustumMatrix, tileExtent, glScale) {
        var map = this.getMap();
        TILE_BOX[0][0] = tileExtent.xmin * glScale;
        TILE_BOX[0][1] = tileExtent.ymin * glScale;
        TILE_BOX[1][0] = tileExtent.xmax * glScale;
        TILE_BOX[1][1] = tileExtent.ymax * glScale;
        return intersectsBox(map.projViewMatrix, TILE_BOX);
      };

      _proto2.getEvents = function getEvents() {
        return {
          'spatialreferencechange': this._onSpatialReferenceChange
        };
      };

      _proto2._onSpatialReferenceChange = function _onSpatialReferenceChange() {
        delete this._tileConfig;
        delete this._defaultTileConfig;
        delete this._sr;
        var renderer = this.getRenderer();

        if (renderer) {
          renderer.clear();
        }
      };

      return TileLayer;
    }(Layer);

    TileLayer.registerJSONType('TileLayer');
    TileLayer.mergeOptions(options$u);
    // function pnpoly(nvert, vertx, verty, testx, testy) {
    //     let i, j, c = 0;
    //     for (i = 0, j = nvert - 1; i < nvert; j = i++) {
    //         if (((verty[i] > testy) !== (verty[j] > testy)) &&
    //            (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i])) {
    //             c = !c;
    //         }
    //     }
    //     return c;
    // }

    /**
     * @classdesc
     * A layer used to display a group of tile layers. <br>
     * Its performance is better than add TileLayers seperately and it can help prevent limits of active webgl contexts: <br>
     * "WARNING: Too many active WebGL contexts. Oldest context will be lost"
     * @category layer
     * @extends TileLayer
     * @param {String|Number} id - tile layer's id
     * @param {TileLayer[]} layers  - TileLayers to add
     * @param {Object} [options=null] - options defined in [TileLayer]{@link TileLayer#options}
     * @example
     * new GroupTileLayer("group-tiles",[
        new maptalks.WMSTileLayer('wms', {
          'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',
          'crs' : 'EPSG:3857',
          'layers' : 'ne:ne',
          'styles' : '',
          'version' : '1.3.0',
          'format': 'image/png',
          'transparent' : true,
          'uppercase' : true
        }),
        new maptalks.TileLayer('tile2',{
          urlTemplate: 'http://korona.geog.uni-heidelberg.de/tiles/adminb/x={x}&y={y}&z={z}'
        })
      ])
     */

    var GroupTileLayer =
    /*#__PURE__*/
    function (_TileLayer) {
      _inheritsLoose(GroupTileLayer, _TileLayer);

      /**
       * Reproduce a GroupTileLayer from layer's profile JSON.
       * @param  {Object} layerJSON - layer's profile JSON
       * @return {GroupTileLayer}
       * @static
       * @private
       * @function
       */
      GroupTileLayer.fromJSON = function fromJSON(layerJSON) {
        if (!layerJSON || layerJSON['type'] !== 'GroupTileLayer') {
          return null;
        }

        var layers = layerJSON['layers'].map(function (json) {
          return Layer.fromJSON(json);
        });
        return new GroupTileLayer(layerJSON['id'], layers, layerJSON['options']);
      }
      /**
       * @param {String|Number} id    - layer's id
       * @param {TileLayer[]} layers  - TileLayers to add
       * @param {Object}  [options=null]          - construct options
       * @param {*}  [options.*=null]             - options defined in [TileLayer]{@link TileLayer#options}
       */
      ;

      function GroupTileLayer(id, layers, options) {
        var _this;

        _this = _TileLayer.call(this, id, options) || this;
        _this.layers = layers || [];

        _this._checkChildren();

        _this.layerMap = {};
        _this._groupChildren = [];
        return _this;
      }
      /**
       * Get children TileLayer
       * @returns {TileLayer[]}
       */


      var _proto = GroupTileLayer.prototype;

      _proto.getLayers = function getLayers() {
        return this.layers;
      }
      /**
       * Export the GroupTileLayer's profile json. <br>
       * Layer's profile is a snapshot of the layer in JSON format. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return {Object} layer's profile JSON
       */
      ;

      _proto.toJSON = function toJSON() {
        var profile = {
          'type': this.getJSONType(),
          'id': this.getId(),
          'layers': this.layers.map(function (layer) {
            return layer.toJSON();
          }),
          'options': this.config()
        };
        return profile;
      }
      /**
       * Get tiles at zoom (or current zoom)
       * @param {Number} z
       * @returns {Object} tiles
       */
      ;

      _proto.getTiles = function getTiles(z) {
        var layers = this.layers;
        var tiles = [];
        var count = 0;

        for (var i = 0, l = layers.length; i < l; i++) {
          var layer = layers[i];

          if (!layer.options['visible']) {
            continue;
          }

          var childGrid = layer.getTiles(z, this);

          if (!childGrid || childGrid.count === 0) {
            continue;
          }

          count += childGrid.count;
          pushIn(tiles, childGrid.tileGrids);
        }

        return {
          count: count,
          tileGrids: tiles
        };
      };

      _proto.onAdd = function onAdd() {
        var _this2 = this;

        var map = this.getMap();
        this.layers.forEach(function (layer) {
          _this2.layerMap[layer.getId()] = layer;

          if (layer.getChildLayer) {
            _this2._groupChildren.push(layer);
          }

          layer._bindMap(map);

          layer.on('show hide', _this2._onLayerShowHide, _this2);
        });

        _TileLayer.prototype.onAdd.call(this);
      };

      _proto.onRemove = function onRemove() {
        var _this3 = this;

        this.layers.forEach(function (layer) {
          layer._doRemove();

          layer.off('show hide', _this3._onLayerShowHide, _this3);
        });
        this.layerMap = {};
        this._groupChildren = [];

        _TileLayer.prototype.onRemove.call(this);
      };

      _proto.getChildLayer = function getChildLayer(id) {
        var layer = this.layerMap[id];

        if (layer) {
          return layer;
        }

        for (var i = 0; i < this._groupChildren.length; i++) {
          var child = this._groupChildren[i].getChildLayer(id);

          if (child) {
            return child;
          }
        }

        return null;
      };

      _proto._onLayerShowHide = function _onLayerShowHide() {
        var renderer = this.getRenderer();

        if (renderer) {
          renderer.setToRedraw();
        }
      };

      _proto.isVisible = function isVisible() {
        if (!_TileLayer.prototype.isVisible.call(this)) {
          return false;
        }

        var children = this.layers;

        for (var i = 0, l = children.length; i < l; i++) {
          if (children[i].isVisible()) {
            return true;
          }
        }

        return false;
      };

      _proto._checkChildren = function _checkChildren() {
        var _this4 = this;

        var ids = {};
        this.layers.forEach(function (layer) {
          var layerId = layer.getId();

          if (ids[layerId]) {
            throw new Error("Duplicate child layer id (" + layerId + ") in the GroupTileLayer (" + _this4.getId() + ")");
          } else {
            ids[layerId] = 1;
          }
        });
      };

      return GroupTileLayer;
    }(TileLayer);

    GroupTileLayer.registerJSONType('GroupTileLayer');

    /**
     * @property {Object}              options                     - TileLayer's options
     * @property {String}              [options.service=WMS]       - WMS Service
     * @property {String}              options.layers              - Comma-separated list of WMS layers to show.
     * @property {String}              [options.styles='']         - Comma-separated list of WMS styles.
     * @property {String}              [options.format=image/jpeg] - WMS image format (use `'image/png'` for layers with transparency).
     * @property {String}              [options.transparent=false] - Version of the WMS service to use
     * @property {String}              [options.version=1.1.1]     - size of the tile image
     * @property {String}              [options.crs=null]          - Coordinate Reference System to use for the WMS requests, defaults to map CRS. Don't change this if you're not sure what it means.
     * @property {Boolean}             [options.uppercase=false]   - If `true`, WMS request parameter keys will be uppercase.
     * @property {Boolean}             [options.detectRetina=false]   - If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
     * @memberOf WMSTileLayer
     * @instance
     */

    var options$v = {
      crs: null,
      uppercase: false,
      detectRetina: false
    };
    var defaultWmsParams = {
      service: 'WMS',
      request: 'GetMap',
      layers: '',
      styles: '',
      format: 'image/jpeg',
      transparent: false,
      version: '1.1.1'
    };
    /**
     * @classdesc
     * Used to display [WMS]{https://en.wikipedia.org/wiki/Web_Map_Service} services as tile layers on the map. Extends [TileLayer]{@link TileLayer}.
     * Implemented based on Leaflet's TileLayer.WMS.
     * @category layer
     * @extends TileLayer
     * @param {String|Number} id - tile layer's id
     * @param {Object} [options=null] - options defined in [WMSTileLayer]{@link TileLayer#options}
     * @example
     * var layer = new maptalks.WMSTileLayer('wms', {
     *     'urlTemplate' : 'https://demo.boundlessgeo.com/geoserver/ows',
     *     'crs' : 'EPSG:3857',
     *     'layers' : 'ne:ne',
     *     'styles' : '',
     *     'version' : '1.3.0',
     *     'format': 'image/png',
     *     'transparent' : true,
     *     'uppercase' : true
     * });
     */

    var WMSTileLayer =
    /*#__PURE__*/
    function (_TileLayer) {
      _inheritsLoose(WMSTileLayer, _TileLayer);

      function WMSTileLayer(id, options) {
        var _this;

        _this = _TileLayer.call(this, id) || this;
        var wmsParams = extend({}, defaultWmsParams);

        for (var p in options) {
          if (!(p in _this.options)) {
            wmsParams[p] = options[p];
          }
        }

        _this.setOptions(options);

        _this.setZIndex(options.zIndex);

        var tileSize = _this.getTileSize();

        wmsParams.width = tileSize.width;
        wmsParams.height = tileSize.height;
        _this.wmsParams = wmsParams;
        _this._wmsVersion = parseFloat(wmsParams.version);
        return _this;
      }

      var _proto = WMSTileLayer.prototype;

      _proto.onAdd = function onAdd() {
        var dpr = this.getMap().getDevicePixelRatio();
        var r = options$v.detectRetina ? dpr : 1;
        this.wmsParams.width *= r;
        this.wmsParams.height *= r;
        var crs = this.options.crs || this.getMap().getProjection().code;
        var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
        this.wmsParams[projectionKey] = crs;

        _TileLayer.prototype.onAdd.call(this);
      };

      _proto.getTileUrl = function getTileUrl(x, y, z) {
        var res = this.getSpatialReference().getResolution(z),
            tileConfig = this._getTileConfig(),
            tileExtent = tileConfig.getTilePrjExtent(x, y, res);

        var max = tileExtent.getMax(),
            min = tileExtent.getMin();
        var bbox = (this._wmsVersion >= 1.3 && this.wmsParams.crs === 'EPSG:4326' ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(',');

        var url = _TileLayer.prototype.getTileUrl.call(this, x, y, z);

        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
      }
      /**
       * Export the WMSTileLayer's json. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return {Object} layer's JSON
       */
      ;

      _proto.toJSON = function toJSON() {
        return {
          'type': 'WMSTileLayer',
          'id': this.getId(),
          'options': this.config()
        };
      }
      /**
       * Reproduce a WMSTileLayer from layer's JSON.
       * @param  {Object} layerJSON - layer's JSON
       * @return {WMSTileLayer}
       * @static
       * @private
       * @function
       */
      ;

      WMSTileLayer.fromJSON = function fromJSON(layerJSON) {
        if (!layerJSON || layerJSON['type'] !== 'WMSTileLayer') {
          return null;
        }

        return new WMSTileLayer(layerJSON['id'], layerJSON['options']);
      };

      return WMSTileLayer;
    }(TileLayer);

    WMSTileLayer.registerJSONType('WMSTileLayer');
    WMSTileLayer.mergeOptions(options$v);
    // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
    // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
    // be appended at the end. If `uppercase` is `true`, the parameter names will
    // be uppercased (e.g. `'?A=foo&B=bar'`)

    function getParamString(obj, existingUrl, uppercase) {
      var params = [];

      for (var i in obj) {
        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
      }

      return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
    }

    /**
     * @classdesc
     * @ignore
     * @category layer
     * @extends TileLayer
     * @param {String|Number} id - tile layer's id
     * @param {Object} [options=null] - options defined in [CanvasTileLayer]{@link TileLayer#options}
     * @example
     * var layer = new CanvasTileLayer("tile");
     * layer.drawTile = ()
     */

    var CanvasTileLayer =
    /*#__PURE__*/
    function (_TileLayer) {
      _inheritsLoose(CanvasTileLayer, _TileLayer);

      function CanvasTileLayer(id, options) {
        var _this;

        _this = _TileLayer.call(this, id, options) || this;

        if (!_this.options.hasOwnProperty('forceRenderOnMoving')) {
          // force not to forceRenderOnMoving
          _this.options['forceRenderOnMoving'] = false;
        }

        return _this;
      }
      /**
       * The interface method to draw on canvsa tile
       * @param  {HTMLCanvasElement} canvas  canvas to draw on
       * @param  {Object} options current options
       * @param  {Object} options current options
       */


      var _proto = CanvasTileLayer.prototype;

      _proto.drawTile = function drawTile()
      /*canvas, options*/
      {}
      /**
       * Export the CanvasTileLayer's json. <br>
       * It can be used to reproduce the instance by [fromJSON]{@link Layer#fromJSON} method
       * @return {Object} layer's JSON
       */
      ;

      _proto.toJSON = function toJSON() {
        return {
          'type': 'CanvasTileLayer',
          'id': this.getId(),
          'options': this.config()
        };
      }
      /**
       * Reproduce a CanvasTileLayer from layer's JSON.
       * @param  {Object} layerJSON - layer's JSON
       * @return {CanvasTileLayer}
       * @static
       * @private
       * @function
       */
      ;

      CanvasTileLayer.fromJSON = function fromJSON(layerJSON) {
        if (!layerJSON || layerJSON['type'] !== 'CanvasTileLayer') {
          return null;
        }

        return new CanvasTileLayer(layerJSON['id'], layerJSON['options']);
      };

      return CanvasTileLayer;
    }(TileLayer);

    CanvasTileLayer.registerJSONType('CanvasTileLayer');

    function createGLContext(canvas, options) {
      var attributes = {
        'alpha': true,
        'stencil': true,
        'preserveDrawingBuffer': true,
        'antialias': false
      };
      var names = ['webgl', 'experimental-webgl'];
      var context = null;
      /* eslint-disable no-empty */

      for (var i = 0; i < names.length; ++i) {
        try {
          context = canvas.getContext(names[i], options || attributes);
        } catch (e) {}

        if (context) {
          break;
        }
      }

      return context;
      /* eslint-enable no-empty */
    }
    /**
    * Create a shader object
    * @param gl GL context
    * @param type the type of the shader object to be created
    * @param source shader program (string)
    * @return created shader object, or null if the creation has failed.
    * @private
    */

    function compileShader(gl, type, source) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

      if (!compiled) {
        var error = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error('Failed to compile shader: ' + error);
      }

      return shader;
    }
    /**
     * Create the linked program object
     * @param {String} vert a vertex shader program (string)
     * @param {String} frag a fragment shader program (string)
     * @return {WebGLProgram} created program object, or null if the creation has failed
     * @private
     */

    function createProgram(gl, vert, frag) {
      var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vert);
      var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, frag);

      if (!vertexShader || !fragmentShader) {
        return null;
      }

      var program = gl.createProgram();

      if (!program) {
        return null;
      }

      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      return {
        program: program,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      };
    }
    /**
     * Enable vertex attributes
     * @param {Array} attributes [[name, stride, type], [name, stride, type]...]
     * @example
     * rendererr.enableVertexAttrib([
     *  ['a_position', 3, 'FLOAT'],
     *  ['a_normal', 3, 'FLOAT']
     * ]);
     * @private
     */

    function enableVertexAttrib(gl, program, attributes) {
      if (Array.isArray(attributes[0])) {
        var FSIZE = Float32Array.BYTES_PER_ELEMENT;
        var STRIDE = 0;

        for (var i = 0; i < attributes.length; i++) {
          STRIDE += attributes[i][1] || 0;
        }

        var offset = 0;

        for (var _i = 0; _i < attributes.length; _i++) {
          var attr = gl.getAttribLocation(program, attributes[_i][0]);

          if (attr < 0) {
            throw new Error('Failed to get the storage location of ' + attributes[_i][0]);
          }

          gl.vertexAttribPointer(attr, attributes[_i][1], gl[attributes[_i][2] || 'FLOAT'], false, FSIZE * STRIDE, FSIZE * offset);
          offset += attributes[_i][1] || 0;
          gl.enableVertexAttribArray(attr);
        }
      } else {
        var _attr = gl.getAttribLocation(program, attributes[0]);

        gl.vertexAttribPointer(_attr, attributes[1], gl[attributes[2] || 'FLOAT'], false, 0, 0);
        gl.enableVertexAttribArray(_attr);
      }
    }

    var shaders = {
      'vertexShader': "\n        attribute vec3 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 1.0);\n\n            v_texCoord = a_texCoord;\n        }\n    ",
      // fragment shader, can be replaced by layer.options.fragmentShader
      'fragmentShader': "\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug == 1.0) {\n                gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n        }\n    "
    }; //reusable temporary variables

    var v2 = [0, 0],
        v3 = [0, 0, 0],
        arr16 = new Array(16);
    /**
     * A mixin providing image support in WebGL env
     * @mixin ImageGLRenderable
     * @protected
     */

    var ImageGLRenderable = function ImageGLRenderable(Base) {
      var renderable =
      /*#__PURE__*/
      function (_Base) {
        _inheritsLoose(renderable, _Base);

        function renderable() {
          return _Base.apply(this, arguments) || this;
        }

        var _proto = renderable.prototype;

        /**
         * Draw an image at x, y at map's gl zoom
         * @param {Image|Canvas} image
         * @param {Number} x - x at map's gl zoom
         * @param {Number} y - y at map's gl zoom
         * @param {Number} w - width at map's gl zoom
         * @param {Number} h - height at map's gl zoom
         * @param {Number} opacity
         */
        _proto.drawGLImage = function drawGLImage(image, x, y, w, h, scale$$1, opacity, debug) {
          if (this.gl.program !== this.program) {
            this.useProgram(this.program);
          }

          var gl = this.gl;
          this.loadTexture(image);
          v3[0] = x || 0;
          v3[1] = y || 0;
          var uMatrix = identity(arr16);
          translate(uMatrix, uMatrix, v3);
          scale(uMatrix, uMatrix, [scale$$1, scale$$1, 1]);
          multiply(uMatrix, this.getMap().projViewMatrix, uMatrix);
          gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
          gl.uniform1f(this.program['u_opacity'], opacity);
          gl.uniform1f(this.program['u_debug'], 0);
          var glBuffer = image.glBuffer;

          if (glBuffer && (glBuffer.width !== w || glBuffer.height !== h)) {
            this.saveImageBuffer(glBuffer);
            delete image.glBuffer;
          }

          if (!image.glBuffer) {
            image.glBuffer = this.bufferTileData(0, 0, w, h);
          } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer);
          }

          v2[0] = 'a_position';
          v2[1] = 3;
          v2[2] = image.glBuffer.type;
          this.enableVertexAttrib(v2); // ['a_position', 3]

          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

          if (debug) {
            this.drawDebug(uMatrix, v2, 0, 0, w, h);
          }
        };

        _proto.drawDebug = function drawDebug(uMatrix, attrib, x, y, w, h) {
          var gl = this.gl;
          gl.bindBuffer(gl.ARRAY_BUFFER, this._debugBuffer);
          this.enableVertexAttrib(['a_position', 2, 'FLOAT']);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, y, x + w, y, x + w, y - h, x, y - h, x, y]), gl.DYNAMIC_DRAW);
          gl.uniformMatrix4fv(this.program['u_matrix'], false, uMatrix);
          gl.uniform1f(this.program['u_debug'], 1);
          gl.drawArrays(gl.LINE_STRIP, 0, 5);
        };

        _proto.bufferTileData = function bufferTileData(x, y, w, h, buffer) {
          var x1 = x;
          var x2 = x + w;
          var y1 = y;
          var y2 = y - h;
          var data;

          if (isInteger(x1) && isInteger(x2) && isInteger(y1) && isInteger(y2)) {
            data = this.set12Int(x1, y1, 0, x1, y2, 0, x2, y1, 0, x2, y2, 0);
          } else {
            data = this.set12(x1, y1, 0, x1, y2, 0, x2, y1, 0, x2, y2, 0);
          }

          var glBuffer = this.loadImageBuffer(data, buffer);
          glBuffer.width = w;
          glBuffer.height = h;
          glBuffer.type = data instanceof Int16Array ? 'SHORT' : 'FLOAT';
          return glBuffer;
        }
        /**
         * Draw the tile image as tins
         * @param {HtmlElement} image
         * @param {Array} vertices  - tin vertices
         * @param {Array} texCoords - texture coords
         * @param {Array} indices   - element indexes
         * @param {number} opacity
         */
        ;

        _proto.drawTinImage = function drawTinImage(image, vertices, texCoords, indices, opacity) {
          var gl = this.gl;
          this.loadTexture(image);
          gl.uniformMatrix4fv(this.program['u_matrix'], false, this.getMap().projViewMatrix);
          gl.uniform1f(this.program['u_opacity'], opacity); //bufferdata vertices

          gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
          this.enableVertexAttrib(['a_position', 3]); //TODO save buffer to avoid repeatedly bufferData

          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW); //bufferdata tex coords

          gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
          this.enableVertexAttrib(['a_texCoord', 2]);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.DYNAMIC_DRAW); //bufferdata indices

          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.DYNAMIC_DRAW); //draw

          gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
        }
        /**
         * Create another GL canvas to draw gl images
         * For layer renderer that needs 2 seperate canvases for 2d and gl
         */
        ;

        _proto.createCanvas2 = function createCanvas2() {
          this.canvas2 = Canvas$1.createCanvas(this.canvas.width, this.canvas.height);
        }
        /**
         * Get webgl context(this.gl). It prefers canvas2, and will change to this.canvas if canvas2 is not created
         */
        ;

        _proto.createGLContext = function createGLContext$$1() {
          if (this.canvas.gl && this.canvas.gl.wrap) {
            this.gl = this.canvas.gl.wrap();
          } else {
            this.gl = createGLContext(this.canvas2 || this.canvas, this.layer.options['glOptions']);
          }

          var gl = this.gl;
          gl.clearColor(0.0, 0.0, 0.0, 0.0);
          gl.disable(gl.DEPTH_TEST);
          gl.enable(gl.STENCIL_TEST);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          this.program = this.createProgram(shaders['vertexShader'], this.layer.options['fragmentShader'] || shaders['fragmentShader'], ['u_matrix', 'u_image', 'u_opacity', 'u_debug']);
          this._debugBuffer = this.createBuffer();
          this.useProgram(this.program); // input texture vec data

          this.texBuffer = this.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
          this.enableVertexAttrib(['a_texCoord', 2, 'UNSIGNED_BYTE']);
          gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
          this.enableSampler('u_image'); // Enable texture unit 0

          gl.activeTexture(gl['TEXTURE0']);
          gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        }
        /**
         * Resize GL canvas with renderer's 2D canvas
         */
        ;

        _proto.resizeGLCanvas = function resizeGLCanvas() {
          if (this.gl) {
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
          }

          if (!this.canvas2) {
            return;
          }

          if (this.canvas2.width !== this.canvas.width || this.canvas2.height !== this.canvas.height) {
            this.canvas2.width = this.canvas.width;
            this.canvas2.height = this.canvas.height;
          }
        }
        /**
         * Clear gl canvas
         */
        ;

        _proto.clearGLCanvas = function clearGLCanvas() {
          if (this.gl) {
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT);
          }
        };

        _proto.disposeImage = function disposeImage(image) {
          if (!image) {
            return;
          }

          if (image.texture) {
            this.saveTexture(image.texture);
          }

          if (image.glBuffer) {
            this.saveImageBuffer(image.glBuffer);
          }

          delete image.texture;
          delete image.glBuffer;
        };

        _proto._createTexture = function _createTexture(image) {
          var gl = this.gl;
          var texture = this.getTexture() || gl.createTexture(); // Create a texture object
          // Bind the texture object to the target

          gl.bindTexture(gl.TEXTURE_2D, texture); // from mapbox-gl-js
          // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

          if (isInteger(log2(image.width)) && isInteger(log2(image.width))) {
            gl.generateMipmap(gl.TEXTURE_2D);
          }

          return texture;
        }
        /**
         * Get a texture from cache or create one if cache is empty
         * @returns {WebGLTexture}
         */
        ;

        _proto.getTexture = function getTexture() {
          if (!this._textures) {
            this._textures = [];
          }

          var textures = this._textures;
          return textures && textures.length > 0 ? textures.pop() : null;
        }
        /**
         * Save a texture to the cache
         * @param {WebGLTexture} texture
         */
        ;

        _proto.saveTexture = function saveTexture(texture) {
          this._textures.push(texture);
        }
        /**
         * Load image into a text and bind it with WebGLContext
         * @param {Image|Canvas} image
         * @returns {WebGLTexture}
         */
        ;

        _proto.loadTexture = function loadTexture(image) {
          var gl = this.gl;
          var texture = image.texture; // Create a texture object

          if (!texture) {
            texture = this._createTexture(image);
            image.texture = texture;
          }

          gl.bindTexture(gl.TEXTURE_2D, texture);
          return texture;
        }
        /**
         * Get a texture from cache or create one if cache is empty
         * @returns {WebGLTexture}
         */
        ;

        _proto.getImageBuffer = function getImageBuffer() {
          if (!this._imageBuffers) {
            this._imageBuffers = [];
          }

          var imageBuffers = this._imageBuffers;
          return imageBuffers && imageBuffers.length > 0 ? imageBuffers.pop() : null;
        }
        /**
         * Save a texture to the cache
         * @param {WebGLTexture} texture
         */
        ;

        _proto.saveImageBuffer = function saveImageBuffer(buffer) {
          this._imageBuffers.push(buffer);
        }
        /**
         * Load image into a text and bind it with WebGLContext
         * @returns {WebGLTexture}
         */
        ;

        _proto.loadImageBuffer = function loadImageBuffer(data, glBuffer) {
          var gl = this.gl; // Create a buffer object

          var buffer = glBuffer || this.createImageBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
          return buffer;
        };

        _proto.createImageBuffer = function createImageBuffer() {
          return this.getImageBuffer() || this.createBuffer();
        }
        /**
         * remove all the resources and remove gl canvas
         */
        ;

        _proto.removeGLCanvas = function removeGLCanvas() {
          // release resources
          var gl = this.gl;

          if (!gl) {
            return;
          }

          if (this._debugBuffer) {
            gl.deleteBuffer(this._debugBuffer);
            delete this._debugBuffer;
          }

          if (this._buffers) {
            this._buffers.forEach(function (b) {
              gl.deleteBuffer(b);
            });

            delete this._buffers;
          }

          if (this._textures) {
            this._textures.forEach(function (t) {
              return gl.deleteTexture(t);
            });

            delete this._textures;
          }

          var program = gl.program;
          gl.deleteShader(program.fragmentShader);
          gl.deleteShader(program.vertexShader);
          gl.deleteProgram(program);
          delete this.gl;
          delete this.canvas2;
        } //----------------------- webgl utils unlike to change ---------------------------------

        /**
         * Create a WebGL buffer
         * @returns {WebGLBuffer}
         */
        ;

        _proto.createBuffer = function createBuffer() {
          var gl = this.gl; // Create the buffer object

          var buffer = gl.createBuffer();

          if (!buffer) {
            throw new Error('Failed to create the buffer object');
          }

          if (!this._buffers) {
            this._buffers = [];
          }

          this._buffers.push(buffer);

          return buffer;
        }
        /**
         * Enable vertex attributes
         * @param {Array} attributes [[name, stride, type], [name, stride, type]...]
         * @example
         * rendererr.enableVertexAttrib([
         *  ['a_position', 3, 'FLOAT'],
         *  ['a_normal', 3, 'FLOAT']
         * ]);
         */
        ;

        _proto.enableVertexAttrib = function enableVertexAttrib$$1(attributes) {
          enableVertexAttrib(this.gl, this.gl.program, attributes);
        }
        /**
         * Create the linked program object
         * @param {String} vert a vertex shader program (string)
         * @param {String} frag a fragment shader program (string)
         * @return {WebGLProgram} created program object, or null if the creation has failed
         */
        ;

        _proto.createProgram = function createProgram$$1(vert, frag, uniforms) {
          var gl = this.gl;

          var _createProgram2 = createProgram(gl, vert, frag),
              program = _createProgram2.program,
              vertexShader = _createProgram2.vertexShader,
              fragmentShader = _createProgram2.fragmentShader;

          program.vertexShader = vertexShader;
          program.fragmentShader = fragmentShader;

          this._initUniforms(program, uniforms);

          return program;
        }
        /**
         * use the given program
         * @param {WebGLProgram} program
         */
        ;

        _proto.useProgram = function useProgram(program) {
          var gl = this.gl;
          gl.useProgram(program);
          gl.program = program;
          return this;
        }
        /**
         * Enable a sampler, and set texture
         * @param {WebGLSampler} sampler
         * @param {ptr} texture id
         */
        ;

        _proto.enableSampler = function enableSampler(sampler, texIdx) {
          var gl = this.gl;

          var uSampler = this._getUniform(gl.program, sampler);

          if (!texIdx) {
            texIdx = 0;
          } // Set the texture unit to the sampler


          gl.uniform1i(uSampler, texIdx);
          return uSampler;
        };

        _proto._initUniforms = function _initUniforms(program, uniforms) {
          for (var i = 0; i < uniforms.length; i++) {
            var name = uniforms[i];
            var uniform = uniforms[i];
            var b = name.indexOf('[');

            if (b >= 0) {
              name = name.substring(0, b);

              if (!IS_NODE) {
                // In browser, remove [0] from uniforma declaration
                uniform = uniform.substring(0, b);
              }
            }

            program[name] = this._getUniform(program, uniform);
          }
        };

        _proto._getUniform = function _getUniform(program, uniformName) {
          var gl = this.gl;
          var uniform = gl.getUniformLocation(program, uniformName);

          if (!uniform) {
            throw new Error('Failed to get the storage location of ' + uniformName);
          }

          return uniform;
        };

        return renderable;
      }(Base);

      extend(renderable.prototype, {
        set12: function () {
          var out = Browser$1.ie9 ? null : new Float32Array(12);
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            out[0] = a0;
            out[1] = a1;
            out[2] = a2;
            out[3] = a3;
            out[4] = a4;
            out[5] = a5;
            out[6] = a6;
            out[7] = a7;
            out[8] = a8;
            out[9] = a9;
            out[10] = a10;
            out[11] = a11;
            return out;
          };
        }(),
        set12Int: function () {
          var out = Browser$1.ie9 ? null : new Int16Array(12);
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
            out[0] = a0;
            out[1] = a1;
            out[2] = a2;
            out[3] = a3;
            out[4] = a4;
            out[5] = a5;
            out[6] = a6;
            out[7] = a7;
            out[8] = a8;
            out[9] = a9;
            out[10] = a10;
            out[11] = a11;
            return out;
          };
        }()
      });
      return renderable;
    };

    /**
     * @property {Object}              options                     - ImageLayer's options
     * @property {String}              [options.crossOrigin=null]    - image's corssOrigin
     * @property {String}              [options.renderer=gl]         - ImageLayer's renderer, canvas or gl. gl tiles requires image CORS that canvas doesn't. canvas tiles can't pitch.
     * @memberOf ImageLayer
     * @instance
     */

    var options$w = {
      renderer: Browser$1.webgl ? 'gl' : 'canvas',
      crossOrigin: null
    };
    var TEMP_POINT$1 = new Point(0, 0);
    /**
     * @classdesc
     * A layer used to display images, you can specify each image's geographic extent and opacity
     * @category layer
     * @extends Layer
     * @param {String|Number} id - tile layer's id
     * @param {Object[]} [images=null] - images
     * @param {Object} [options=null] - options defined in [ImageLayer]{@link ImageLayer#options}
     * @example
     * new ImageLayer("images", [{
            url : 'http://example.com/foo.png',
            extent: [xmin, ymin, xmax, ymax],
            opacity : 1
        }])
     */

    var ImageLayer =
    /*#__PURE__*/
    function (_Layer) {
      _inheritsLoose(ImageLayer, _Layer);

      function ImageLayer(id, images, options) {
        var _this;

        if (images && !Array.isArray(images) && !images.url) {
          options = images;
          images = null;
        }

        _this = _Layer.call(this, id, options) || this;
        _this._images = images;
        return _this;
      }

      var _proto = ImageLayer.prototype;

      _proto.onAdd = function onAdd() {
        this._prepareImages(this._images);
      }
      /**
       * Set images and redraw
       * @param {Object[]} images - new images
       * @return {ImageLayer} this
       */
      ;

      _proto.setImages = function setImages(images) {
        this._images = images;

        this._prepareImages(images);

        return this;
      }
      /**
       * Get images
       * @return {Object[]}
       */
      ;

      _proto.getImages = function getImages() {
        return this._images;
      };

      _proto._prepareImages = function _prepareImages(images) {
        images = images || [];

        if (!Array.isArray(images)) {
          images = [images];
        }

        var map = this.getMap();
        this._imageData = images.map(function (img) {
          var extent = new Extent(img.extent);
          return extend({}, img, {
            extent: extent,
            extent2d: extent.convertTo(function (c) {
              return map.coordToPoint(c, map.getGLZoom());
            })
          });
        });
        this._images = images;
        var renderer = this.getRenderer();

        if (renderer) {
          renderer.refreshImages();
        }
      };

      return ImageLayer;
    }(Layer);

    ImageLayer.mergeOptions(options$w);
    var EMPTY_ARRAY = [];
    var ImageLayerCanvasRenderer =
    /*#__PURE__*/
    function (_CanvasRenderer) {
      _inheritsLoose(ImageLayerCanvasRenderer, _CanvasRenderer);

      function ImageLayerCanvasRenderer() {
        return _CanvasRenderer.apply(this, arguments) || this;
      }

      var _proto2 = ImageLayerCanvasRenderer.prototype;

      _proto2.isDrawable = function isDrawable() {
        if (this.getMap().getPitch()) {
          if (console) {
            console.warn('ImageLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
          }

          return false;
        }

        return true;
      };

      _proto2.checkResources = function checkResources() {
        var _this2 = this;

        if (this._imageLoaded) {
          return EMPTY_ARRAY;
        }

        var layer = this.layer;

        var urls = layer._imageData.map(function (img) {
          return [img.url, null, null];
        });

        if (this.resources) {
          var unloaded = [];
          var resources = new ResourceCache();
          urls.forEach(function (url) {
            if (_this2.resources.isResourceLoaded(url)) {
              var img = _this2.resources.getImage(url);

              resources.addResource(url, img);
            } else {
              unloaded.push(url);
            }
          });
          this.resources.forEach(function (url, res) {
            if (!resources.isResourceLoaded(url)) {
              _this2.retireImage(res.image);
            }
          });
          this.resources = resources;
          urls = unloaded;
        }

        this._imageLoaded = true;
        return urls;
      };

      _proto2.retireImage = function retireImage()
      /* image */
      {};

      _proto2.refreshImages = function refreshImages() {
        this._imageLoaded = false;
        this.setToRedraw();
      };

      _proto2.needToRedraw = function needToRedraw() {
        var map = this.getMap(); // don't redraw when map is zooming without pitch and layer doesn't have any point symbolizer.

        if (map.isZooming() && !map.getPitch()) {
          return false;
        }

        return _CanvasRenderer.prototype.needToRedraw.call(this);
      };

      _proto2.draw = function draw() {
        if (!this.isDrawable()) {
          return;
        }

        this.prepareCanvas();
        this._painted = false;

        this._drawImages();

        this.completeRender();
      };

      _proto2._drawImages = function _drawImages() {
        var imgData = this.layer._imageData;
        var map = this.getMap();

        var mapExtent = map._get2DExtent(map.getGLZoom());

        if (imgData && imgData.length) {
          for (var i = 0; i < imgData.length; i++) {
            var extent = imgData[i].extent2d;
            var image = this.resources && this.resources.getImage(imgData[i].url);

            if (image && mapExtent.intersects(extent)) {
              this._painted = true;

              this._drawImage(image, extent, imgData[i].opacity || 1);
            }
          }
        }
      };

      _proto2._drawImage = function _drawImage(image, extent, opacity) {
        var globalAlpha = 0;
        var ctx = this.context;

        if (opacity < 1) {
          globalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = opacity;
        }

        var map = this.getMap();
        var nw = TEMP_POINT$1.set(extent.xmin, extent.ymax);

        var point = map._pointToContainerPoint(nw, map.getGLZoom());

        var x = point.x,
            y = point.y;
        var bearing = map.getBearing();

        if (bearing) {
          ctx.save();
          ctx.translate(x, y);

          if (bearing) {
            ctx.rotate(-bearing * Math.PI / 180);
          }

          x = y = 0;
        }

        var scale = map.getGLScale();
        ctx.drawImage(image, x, y, extent.getWidth() / scale, extent.getHeight() / scale);

        if (bearing) {
          ctx.restore();
        }

        if (globalAlpha) {
          ctx.globalAlpha = globalAlpha;
        }
      };

      _proto2.drawOnInteracting = function drawOnInteracting() {
        this.draw();
      };

      return ImageLayerCanvasRenderer;
    }(CanvasRenderer);
    var ImageLayerGLRenderer =
    /*#__PURE__*/
    function (_ImageGLRenderable) {
      _inheritsLoose(ImageLayerGLRenderer, _ImageGLRenderable);

      function ImageLayerGLRenderer() {
        return _ImageGLRenderable.apply(this, arguments) || this;
      }

      var _proto3 = ImageLayerGLRenderer.prototype;

      //override to set to always drawable
      _proto3.isDrawable = function isDrawable() {
        return true;
      };

      _proto3._drawImage = function _drawImage(image, extent, opacity) {
        this.drawGLImage(image, extent.xmin, extent.ymax, extent.getWidth(), extent.getHeight(), 1, opacity);
      };

      _proto3.createContext = function createContext() {
        this.createGLContext();
      };

      _proto3.resizeCanvas = function resizeCanvas(canvasSize) {
        if (!this.canvas) {
          return;
        }

        _ImageGLRenderable.prototype.resizeCanvas.call(this, canvasSize);

        this.resizeGLCanvas();
      };

      _proto3.clearCanvas = function clearCanvas() {
        if (!this.canvas) {
          return;
        }

        _ImageGLRenderable.prototype.clearCanvas.call(this);

        this.clearGLCanvas();
      };

      _proto3.retireImage = function retireImage(image) {
        this.disposeImage(image);
      };

      _proto3.onRemove = function onRemove() {
        this.removeGLCanvas();

        _ImageGLRenderable.prototype.onRemove.call(this);
      };

      return ImageLayerGLRenderer;
    }(ImageGLRenderable(ImageLayerCanvasRenderer));
    ImageLayer.registerRenderer('canvas', ImageLayerCanvasRenderer);
    ImageLayer.registerRenderer('gl', ImageLayerGLRenderer);

    var CanvasLayerRenderer =
    /*#__PURE__*/
    function (_CanvasRenderer) {
      _inheritsLoose(CanvasLayerRenderer, _CanvasRenderer);

      function CanvasLayerRenderer() {
        return _CanvasRenderer.apply(this, arguments) || this;
      }

      var _proto = CanvasLayerRenderer.prototype;

      _proto.getPrepareParams = function getPrepareParams() {
        return [];
      };

      _proto.getDrawParams = function getDrawParams() {
        return [];
      };

      _proto.onCanvasCreate = function onCanvasCreate() {
        if (this.canvas && this.layer.options['doubleBuffer']) {
          this.buffer = Canvas$1.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass);
        }
      };

      _proto.needToRedraw = function needToRedraw() {
        if (this.layer.options['animation']) {
          return true;
        }

        var map = this.getMap();

        if (map.isInteracting() && !this.layer.drawOnInteracting) {
          return false;
        }

        return _CanvasRenderer.prototype.needToRedraw.call(this);
      };

      _proto.draw = function draw() {
        this.prepareCanvas();
        this.prepareDrawContext();

        this._drawLayer();
      };

      _proto.drawOnInteracting = function drawOnInteracting() {
        this._drawLayerOnInteracting();
      };

      _proto.getCanvasImage = function getCanvasImage() {
        var canvasImg = _CanvasRenderer.prototype.getCanvasImage.call(this);

        if (canvasImg && canvasImg.image && this.layer.options['doubleBuffer']) {
          var canvas = canvasImg.image;

          if (this.buffer.width !== canvas.width || this.buffer.height !== canvas.height) {
            this.buffer.width = canvas.width;
            this.buffer.height = canvas.height;
          }

          var bufferContext = this.buffer.getContext('2d');
          var prevent = this.layer.doubleBuffer(bufferContext, this.context);

          if (prevent === undefined || prevent) {
            Canvas$1.image(bufferContext, canvas, 0, 0);
            canvasImg.image = this.buffer;
          }
        }

        return canvasImg;
      };

      _proto.remove = function remove() {
        delete this._drawContext;
        return _CanvasRenderer.prototype.remove.call(this);
      };

      _proto.onZoomStart = function onZoomStart(param) {
        this.layer.onZoomStart(param);

        _CanvasRenderer.prototype.onZoomStart.call(this, param);
      };

      _proto.onZooming = function onZooming(param) {
        this.layer.onZooming(param);

        _CanvasRenderer.prototype.onZooming.call(this, param);
      };

      _proto.onZoomEnd = function onZoomEnd(param) {
        this.layer.onZoomEnd(param);

        _CanvasRenderer.prototype.onZoomEnd.call(this, param);
      };

      _proto.onMoveStart = function onMoveStart(param) {
        this.layer.onMoveStart(param);

        _CanvasRenderer.prototype.onMoveStart.call(this, param);
      };

      _proto.onMoving = function onMoving(param) {
        this.layer.onMoving(param);

        _CanvasRenderer.prototype.onMoving.call(this, param);
      };

      _proto.onMoveEnd = function onMoveEnd(param) {
        this.layer.onMoveEnd(param);

        _CanvasRenderer.prototype.onMoveEnd.call(this, param);
      };

      _proto.onResize = function onResize(param) {
        this.layer.onResize(param);

        _CanvasRenderer.prototype.onResize.call(this, param);
      };

      _proto.prepareDrawContext = function prepareDrawContext() {
        if (!this._predrawed) {
          var params = ensureParams(this.getPrepareParams());
          this._drawContext = this.layer.prepareToDraw.apply(this.layer, [this.context].concat(params));

          if (!this._drawContext) {
            this._drawContext = [];
          }

          if (!Array.isArray(this._drawContext)) {
            this._drawContext = [this._drawContext];
          }

          this._predrawed = true;
        }
      };

      _proto._prepareDrawParams = function _prepareDrawParams() {
        if (!this.getMap()) {
          return null;
        }

        var view = this.getViewExtent();

        if (view['maskExtent'] && !view['extent'].intersects(view['maskExtent'])) {
          this.completeRender();
          return null;
        }

        var args = [this.context, view];
        var params = ensureParams(this.getDrawParams());
        args.push.apply(args, params);
        args.push.apply(args, this._drawContext);
        return args;
      };

      _proto._drawLayer = function _drawLayer() {
        var args = this._prepareDrawParams();

        if (!args) {
          return;
        }

        this.layer.draw.apply(this.layer, args);
        this.completeRender();
      };

      _proto._drawLayerOnInteracting = function _drawLayerOnInteracting() {
        if (!this.layer.drawOnInteracting) {
          return;
        }

        var args = this._prepareDrawParams();

        if (!args) {
          return;
        }

        this.layer.drawOnInteracting.apply(this.layer, args);
        this.completeRender();
      };

      return CanvasLayerRenderer;
    }(CanvasRenderer);

    function ensureParams(params) {
      if (!params) {
        params = [];
      }

      if (!Array.isArray(params)) {
        params = [params];
      }

      return params;
    }

    /**
     * @property {Object} options                  - configuration options
     * @property {Boolean} [options.doubleBuffer=false]    - layer is rendered with doubleBuffer
     * @property {Boolean} [options.animation=false]       - if the layer is an animated layer
     * @property {Boolean} [fps=1000 / 16]                 - animation fps
     * @memberOf CanvasLayer
     * @instance
     */

    var options$x = {
      'doubleBuffer': false,
      'animation': false
    };
    /**
     * A layer with a HTML5 2D canvas context.<br>
     * CanvasLayer provides some interface methods for canvas context operations. <br>
     * You can use it directly, but can't serialize/deserialize a CanvasLayer with JSON in this way. <br>
     * It is more recommended to extend it with a subclass and implement canvas paintings inside the subclass.
     * @example
     *  var layer = new CanvasLayer('canvas');
     *
     *  layer.prepareToDraw = function (context) {
     *      var size = map.getSize();
     *      return [size.width, size.height]
     *  };
     *
     *  layer.draw = function (context, width, height) {
     *      context.fillStyle = "#f00";
     *      context.fillRect(0, 0, w, h);
     *  };
     *  layer.addTo(map);
     * @category layer
     * @extends Layer
     * @param {String|Number} id - layer's id
     * @param {Object} options - options defined in [options]{@link CanvasLayer#options}
     */

    var CanvasLayer =
    /*#__PURE__*/
    function (_Layer) {
      _inheritsLoose(CanvasLayer, _Layer);

      function CanvasLayer() {
        return _Layer.apply(this, arguments) || this;
      }

      var _proto = CanvasLayer.prototype;

      _proto.isCanvasRender = function isCanvasRender() {
        return true;
      }
      /**
       * An optional interface function called only once before the first draw, useful for preparing your canvas operations.
       * @param  {CanvasRenderingContext2D } context - CanvasRenderingContext2D of the layer canvas.
       * @return {Object[]} objects that will be passed to function draw(context, ..) as parameters.
       */
      ;

      _proto.prepareToDraw = function prepareToDraw() {}
      /**
       * The required interface function to draw things on the layer canvas.
       * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.
       * @param  {*} params.. - parameters returned by function prepareToDraw(context).
       */
      ;

      _proto.draw = function draw() {}
      /**
       * An optional interface function to draw while map is interacting.
       * By default, it will call draw method instead.
       * You can override this method if you are clear with what to draw when interacting to improve performance.
       * @param  {CanvasRenderingContext2D} context - CanvasRenderingContext2D of the layer canvas.
       * @param  {*} params.. - parameters returned by function prepareToDraw(context).
       */
      // drawOnInteracting() {
      //     return this.draw.apply(this, arguments);
      // }

      /**
       * Redraw the layer
       * @return {CanvasLayer} this
       */
      ;

      _proto.redraw = function redraw() {
        if (this._getRenderer()) {
          this._getRenderer().setToRedraw();
        }

        return this;
      }
      /**
       * Start animation
       * @return {CanvasLayer} this
       */
      ;

      _proto.play = function play() {
        this.config('animation', true);
        return this;
      }
      /**
       * Pause the animation
       * @return {CanvasLayer} this
       */
      ;

      _proto.pause = function pause() {
        this.config('animation', false);
        return this;
      }
      /**
       * If the animation is playing
       * @return {Boolean}
       */
      ;

      _proto.isPlaying = function isPlaying() {
        return this.options['animation'];
      }
      /**
       * Clear layer's canvas
       * @return {CanvasLayer} this
       */
      ;

      _proto.clearCanvas = function clearCanvas() {
        if (this._getRenderer()) {
          this._getRenderer().clearCanvas();
        }

        return this;
      }
      /**
       * Ask the map to redraw the layer canvas without firing any event.
       * @return {CanvasLayer} this
       */
      ;

      _proto.requestMapToRender = function requestMapToRender() {
        if (this._getRenderer()) {
          this._getRenderer().requestMapToRender();
        }

        return this;
      }
      /**
       * Ask the map to redraw the layer canvas and fire layerload event
       * @return {CanvasLayer} this
       */
      ;

      _proto.completeRender = function completeRender() {
        if (this._getRenderer()) {
          this._getRenderer().completeRender();
        }

        return this;
      }
      /**
       * Callback function when layer's canvas is created. <br>
       * Override it to do anything needed.
       */
      ;

      _proto.onCanvasCreate = function onCanvasCreate() {
        return this;
      }
      /**
       * The event callback for map's zoomstart event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onZoomStart = function onZoomStart() {}
      /**
       * The event callback for map's zooming event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onZooming = function onZooming() {}
      /**
       * The event callback for map's zoomend event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onZoomEnd = function onZoomEnd() {}
      /**
       * The event callback for map's movestart event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onMoveStart = function onMoveStart() {}
      /**
       * The event callback for map's moving event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onMoving = function onMoving() {}
      /**
       * The event callback for map's moveend event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onMoveEnd = function onMoveEnd() {}
      /**
       * The event callback for map's resize event.
       * @param  {Object} param - event parameter
       */
      ;

      _proto.onResize = function onResize() {}
      /**
       * The callback function to double buffer. <br>
       * In default, it just draws and return, and you can override it if you need to process the canvas image before drawn.
       * @param  {CanvasRenderingContext2D} bufferContext CanvasRenderingContext2D of double buffer of the layer canvas.
       * @param  {CanvasRenderingContext2D} context CanvasRenderingContext2D of the layer canvas.
       */
      ;

      _proto.doubleBuffer = function doubleBuffer(bufferContext
      /*, context*/
      ) {
        bufferContext.clearRect(0, 0, bufferContext.canvas.width, bufferContext.canvas.height);
        return this;
      };

      return CanvasLayer;
    }(Layer);

    CanvasLayer.mergeOptions(options$x);
    CanvasLayer.registerRenderer('canvas', CanvasLayerRenderer);

    var TEMP_POINT$2 = new Point(0, 0);
    /**
     * @property {Object} options                  - configuration options
     * @property {Boolean} [options.animation=true]       - if the layer is an animated layer
     * @memberOf ParticleLayer
     * @instance
     */

    var options$y = {
      'animation': true
    };
    /**
     * @classdesc
     * A layer to draw particles. <br>
     * ParticleLayer provides some interface methods to render particles. <br>
     * You can use it directly, but can't serialize/deserialize a ParticleLayer with JSON in this way. <br>
     * It is more recommended to extend it with a subclass.
     * @example
     * import { ParticleLayer } from 'maptalks';
     * var layer = new ParticleLayer('particle');
     *
     * layer.getParticles = function (t) {
     *     return particles[t];
     * };
     * layer.addTo(map);
     * @category layer
     * @extends CanvasLayer
     * @param {String} id - layer's id
     * @param {Object} [options=null] - options defined in [options]{@link ParticleLayer#options}
     */

    var ParticleLayer =
    /*#__PURE__*/
    function (_CanvasLayer) {
      _inheritsLoose(ParticleLayer, _CanvasLayer);

      function ParticleLayer() {
        return _CanvasLayer.apply(this, arguments) || this;
      }

      var _proto = ParticleLayer.prototype;

      /**
       * Interface method to get particles's position at time t.
       * @param  {Number} t - current time in milliseconds
       */
      _proto.getParticles = function getParticles() {};

      _proto.draw = function draw(context, view) {
        var points = this.getParticles(now());

        if (!points || points.length === 0) {
          var renderer = this._getRenderer();

          if (renderer) {
            this._getRenderer()._shouldClear = true;
          }

          return;
        }

        var map = this.getMap();
        var extent = view.extent;

        if (view.maskExtent) {
          extent = view.extent.intersection(view.maskExtent);
        }

        extent = extent.convertTo(function (c) {
          return map._pointToContainerPoint(c, undefined, 0, TEMP_POINT$2);
        });
        var e = 2 * Math.PI;

        for (var i = 0, l = points.length; i < l; i++) {
          var pos = points[i].point;

          if (extent.contains(pos)) {
            var color = points[i].color || this.options['lineColor'] || '#fff',
                r = points[i].r;

            if (context.fillStyle !== color) {
              context.fillStyle = color;
            }

            if (r <= 2) {
              context.fillRect(pos.x - r / 2, pos.y - r / 2, r, r);
            } else {
              context.beginPath();
              context.arc(pos.x, pos.y, r / 2, 0, e);
              context.fill();
            }
          }
        }

        this._fillCanvas(context);
      };

      _proto._fillCanvas = function _fillCanvas(context) {
        var g = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';
        var trail = this.options['trail'] || 30;
        context.fillStyle = 'rgba(0, 0, 0, ' + 1 / trail + ')';
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
        context.globalCompositeOperation = g;
      };

      return ParticleLayer;
    }(CanvasLayer);

    ParticleLayer.mergeOptions(options$y);
    ParticleLayer.registerRenderer('canvas',
    /*#__PURE__*/
    function (_CanvasLayerRenderer) {
      _inheritsLoose(_class, _CanvasLayerRenderer);

      function _class() {
        return _CanvasLayerRenderer.apply(this, arguments) || this;
      }

      var _proto2 = _class.prototype;

      _proto2.draw = function draw() {
        if (!this.canvas || !this.layer.options['animation'] || this._shouldClear) {
          this.prepareCanvas();
          this._shouldClear = false;
        }

        this.prepareDrawContext();

        this._drawLayer();
      };

      _proto2.drawOnInteracting = function drawOnInteracting() {
        this.draw();
        this._shouldClear = false;
      };

      _proto2.onSkipDrawOnInteracting = function onSkipDrawOnInteracting() {
        this._shouldClear = true;
      };

      return _class;
    }(CanvasLayerRenderer));

    var EDIT_STAGE_LAYER_PREFIX = INTERNAL_LAYER_PREFIX + '_edit_stage_';

    function createHandleSymbol(markerType, opacity) {
      return {
        'markerType': markerType,
        'markerFill': '#fff',
        'markerLineColor': '#000',
        'markerLineWidth': 2,
        'markerWidth': 10,
        'markerHeight': 10,
        'opacity': opacity
      };
    }

    var options$z = {
      //fix outline's aspect ratio when resizing
      'fixAspectRatio': false,
      // geometry's symbol when editing
      'symbol': null,
      'removeVertexOn': 'contextmenu',
      //symbols of edit handles
      'centerHandleSymbol': createHandleSymbol('ellipse', 1),
      'vertexHandleSymbol': createHandleSymbol('square', 1),
      'newVertexHandleSymbol': createHandleSymbol('square', 0.4)
    };
    /**
     * Geometry editor used internally for geometry editing.
     * @category geometry
     * @protected
     * @extends Class
     * @mixes Eventable
     */

    var GeometryEditor =
    /*#__PURE__*/
    function (_Eventable) {
      _inheritsLoose(GeometryEditor, _Eventable);

      /**
       * @param {Geometry} geometry geometry to edit
       * @param {Object} [opts=null] options
       * @param {Object} [opts.symbol=null] symbol of being edited.
       */
      function GeometryEditor(geometry, opts) {
        var _this;

        _this = _Eventable.call(this, opts) || this;
        _this._geometry = geometry;

        if (!_this._geometry) {
          return _assertThisInitialized(_this);
        }

        return _this;
      }
      /**
       * Get map
       * @return {Map} map
       */


      var _proto = GeometryEditor.prototype;

      _proto.getMap = function getMap() {
        return this._geometry.getMap();
      }
      /**
       * Prepare to edit
       */
      ;

      _proto.prepare = function prepare() {
        var map = this.getMap();

        if (!map) {
          return;
        }
        /**
         * reserve the original symbol
         */


        if (this.options['symbol']) {
          this._originalSymbol = this._geometry.getSymbol();

          this._geometry.setSymbol(this.options['symbol']);
        }

        this._prepareEditStageLayer();
      };

      _proto._prepareEditStageLayer = function _prepareEditStageLayer() {
        var map = this.getMap();
        var uid = UID();
        var stageId = EDIT_STAGE_LAYER_PREFIX + uid,
            shadowId = EDIT_STAGE_LAYER_PREFIX + uid + '_shadow';
        this._editStageLayer = map.getLayer(stageId);
        this._shadowLayer = map.getLayer(shadowId);

        if (!this._editStageLayer) {
          this._editStageLayer = new VectorLayer(stageId);
          map.addLayer(this._editStageLayer);
        }

        if (!this._shadowLayer) {
          this._shadowLayer = new VectorLayer(shadowId);
          map.addLayer(this._shadowLayer);
        }
      }
      /**
       * Start to edit
       */
      ;

      _proto.start = function start() {
        var _this2 = this;

        if (!this._geometry || !this._geometry.getMap() || this._geometry.editing) {
          return;
        }

        var map = this.getMap();
        this.editing = true;
        var geometry = this._geometry;
        this._geometryDraggble = geometry.options['draggable'];
        geometry.config('draggable', false);
        this.prepare(); //edits are applied to a shadow of geometry to improve performance.

        var shadow = geometry.copy();
        shadow.setSymbol(geometry._getInternalSymbol()); //geometry copy没有将event复制到新建的geometry,对于编辑这个功能会存在一些问题
        //原geometry上可能绑定了其它监听其click/dragging的事件,在编辑时就无法响应了.

        shadow.copyEventListeners(geometry);

        if (geometry._getParent()) {
          shadow.copyEventListeners(geometry._getParent());
        }

        shadow._setEventTarget(geometry); //drag shadow by center handle instead.


        shadow.setId(null).config({
          'draggable': false
        });
        this._shadow = shadow;

        this._switchGeometryEvents('on');

        geometry.hide();

        if (geometry instanceof Marker || geometry instanceof Circle || geometry instanceof Rectangle || geometry instanceof Ellipse) {
          //ouline has to be added before shadow to let shadow on top of it, otherwise shadow's events will be overrided by outline
          this._createOrRefreshOutline();
        }

        this._shadowLayer.bringToFront().addGeometry(shadow);

        this._editStageLayer.bringToFront();

        this._addListener([map, 'zoomstart', function () {
          _this2._editStageLayer.hide();
        }]);

        this._addListener([map, 'zoomend', function () {
          _this2._editStageLayer.show();
        }]);

        if (!(geometry instanceof Marker)) {
          this._createCenterHandle();
        } else {
          shadow.config('draggable', true);
          shadow.on('dragend', this._onMarkerDragEnd, this);
        }

        if (geometry instanceof Marker) {
          this.createMarkerEditor();
        } else if (geometry instanceof Circle) {
          this.createCircleEditor();
        } else if (geometry instanceof Rectangle) {
          this.createEllipseOrRectEditor();
        } else if (geometry instanceof Ellipse) {
          this.createEllipseOrRectEditor();
        } else if (geometry instanceof Sector) ; else if (geometry instanceof Polygon || geometry instanceof LineString) {
          this.createPolygonEditor();
        }
      }
      /**
       * Stop editing
       */
      ;

      _proto.stop = function stop() {
        delete this._history;
        delete this._historyPointer;
        delete this._editOutline;

        this._switchGeometryEvents('off');

        var map = this.getMap();

        if (!map) {
          return;
        }

        delete this._shadow;

        this._geometry.config('draggable', this._geometryDraggble);

        delete this._geometryDraggble;

        this._geometry.show();

        this._editStageLayer.remove();

        this._shadowLayer.remove();

        this._clearAllListeners();

        this._refreshHooks = [];

        if (this.options['symbol']) {
          this._geometry.setSymbol(this._originalSymbol);

          delete this._originalSymbol;
        }

        this.editing = false;
      }
      /**
       * Whether the editor is editing
       * @return {Boolean}
       */
      ;

      _proto.isEditing = function isEditing() {
        if (isNil(this.editing)) {
          return false;
        }

        return this.editing;
      };

      _proto._getGeometryEvents = function _getGeometryEvents() {
        return {
          'symbolchange': this._onGeoSymbolChange,
          'positionchange shapechange': this._exeAndReset
        };
      };

      _proto._switchGeometryEvents = function _switchGeometryEvents(oper) {
        if (this._geometry) {
          var events = this._getGeometryEvents();

          for (var p in events) {
            this._geometry[oper](p, events[p], this);
          }
        }
      };

      _proto._onGeoSymbolChange = function _onGeoSymbolChange(param) {
        if (this._shadow) {
          this._shadow.setSymbol(param.target._getInternalSymbol());
        }
      };

      _proto._onMarkerDragEnd = function _onMarkerDragEnd() {
        this._update('setCoordinates', this._shadow.getCoordinates().toArray());

        this._refresh();
      }
      /**
       * create rectangle outline of the geometry
       * @private
       */
      ;

      _proto._createOrRefreshOutline = function _createOrRefreshOutline() {
        var geometry = this._geometry;
        var outline = this._editOutline;

        if (!outline) {
          outline = geometry.getOutline();

          this._editStageLayer.addGeometry(outline);

          this._editOutline = outline;

          this._addRefreshHook(this._createOrRefreshOutline);
        } else {
          outline.remove();
          this._editOutline = outline = geometry.getOutline();

          this._editStageLayer.addGeometry(outline);
        }

        return outline;
      };

      _proto._createCenterHandle = function _createCenterHandle() {
        var _this3 = this;

        var center = this._shadow.getCenter();

        var symbol = this.options['centerHandleSymbol'];
        var shadow;
        var handle = this.createHandle(center, {
          'symbol': symbol,
          'cursor': 'move',
          onDown: function onDown() {
            shadow = _this3._shadow.copy();
            var symbol = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
            shadow.setSymbol(symbol).addTo(_this3._editStageLayer);
          },
          onMove: function onMove(v, param) {
            var offset = param['coordOffset'];
            shadow.translate(offset);
          },
          onUp: function onUp() {
            _this3._update('setCoordinates', Coordinate.toNumberArrays(shadow.getCoordinates()));

            shadow.remove();

            _this3._refresh();
          }
        });

        this._addRefreshHook(function () {
          var center = _this3._shadow.getCenter();

          handle.setCoordinates(center);
        });
      };

      _proto._createHandleInstance = function _createHandleInstance(coordinate, opts) {
        var symbol = opts['symbol'];
        var handle = new Marker(coordinate, {
          'draggable': true,
          'dragShadow': false,
          'dragOnAxis': opts['axis'],
          'cursor': opts['cursor'],
          'symbol': symbol
        });
        return handle;
      };

      _proto.createHandle = function createHandle(coordinate, opts) {
        if (!opts) {
          opts = {};
        }

        var map = this.getMap();

        var handle = this._createHandleInstance(coordinate, opts);

        var me = this;

        function onHandleDragstart(param) {
          if (opts.onDown) {
            /**
             * change geometry shape start event, fired when drag to change geometry shape.
             *
             * @event Geometry#handledragstart
             * @type {Object}
             * @property {String} type - handledragstart
             * @property {Geometry} target - the geometry fires the event
             */
            this._geometry.fire('handledragstart');

            opts.onDown.call(me, param['viewPoint'], param);
          }

          return false;
        }

        function onHandleDragging(param) {
          me._hideContext();

          var viewPoint = map._prjToViewPoint(handle._getPrjCoordinates());

          if (opts.onMove) {
            /**
             * changing geometry shape event, fired when dragging to change geometry shape.
             *
             * @event Geometry#handledragging
             * @type {Object}
             * @property {String} type - handledragging
             * @property {Geometry} target - the geometry fires the event
             */
            this._geometry.fire('handledragging');

            opts.onMove.call(me, viewPoint, param);
          }

          return false;
        }

        function onHandleDragEnd(ev) {
          if (opts.onUp) {
            /**
             * changed geometry shape event, fired when drag end to change geometry shape.
             *
             * @event Geometry#handledragend
             * @type {Object}
             * @property {String} type - handledragend
             * @property {Geometry} target - the geometry fires the event
             */
            this._geometry.fire('handledragend');

            opts.onUp.call(me, ev);
          }

          return false;
        }

        function onHandleRemove() {
          handle.config('draggable', false);
          handle.off('dragstart', onHandleDragstart, me);
          handle.off('dragging', onHandleDragging, me);
          handle.off('dragend', onHandleDragEnd, me);
          handle.off('removestart', onHandleRemove, me);
          delete handle['maptalks--editor-refresh-fn'];
        }

        handle.on('dragstart', onHandleDragstart, this);
        handle.on('dragging', onHandleDragging, this);
        handle.on('dragend', onHandleDragEnd, this);
        handle.on('removestart', onHandleRemove, this); //拖动移图

        if (opts.onRefresh) {
          handle['maptalks--editor-refresh-fn'] = opts.onRefresh;
        }

        this._editStageLayer.addGeometry(handle);

        return handle;
      }
      /**
       * create resize handles for geometry that can resize.
       * @param {Array} blackList handle indexes that doesn't display, to prevent change a geometry's coordinates
       * @param {fn} onHandleMove callback
       * @private
       */
      ;

      _proto._createResizeHandles = function _createResizeHandles(blackList, onHandleMove, onHandleUp) {
        var _this4 = this;

        //cursor styles.
        var cursors = ['nw-resize', 'n-resize', 'ne-resize', 'w-resize', 'e-resize', 'sw-resize', 's-resize', 'se-resize']; //defines dragOnAxis of resize handle

        var axis = [null, 'y', null, 'x', 'x', null, 'y', null];
        var geometry = this._geometry;

        function getResizeAnchors(ext) {
          return [// ext.getMin(),
          new Point(ext['xmin'], ext['ymax']), new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymax']), new Point(ext['xmax'], ext['ymax']), new Point(ext['xmin'], (ext['ymax'] + ext['ymin']) / 2), new Point(ext['xmax'], (ext['ymax'] + ext['ymin']) / 2), new Point(ext['xmin'], ext['ymin']), new Point((ext['xmax'] + ext['xmin']) / 2, ext['ymin']), new Point(ext['xmax'], ext['ymin'])];
        }

        if (!blackList) {
          blackList = [];
        }

        var me = this;
        var resizeHandles = [],
            anchorIndexes = {},
            map = this.getMap(),
            handleSymbol = this.options['vertexHandleSymbol'];

        var fnLocateHandles = function fnLocateHandles() {
          var pExt = geometry._getPainter().get2DExtent(),
              anchors = getResizeAnchors(pExt);

          var _loop = function _loop(i) {
            //ignore anchors in blacklist
            if (Array.isArray(blackList)) {
              var isBlack = blackList.some(function (ele) {
                return ele === i;
              });

              if (isBlack) {
                return "continue";
              }
            }

            var anchor = anchors[i],
                coordinate = map.pointToCoordinate(anchor);

            if (resizeHandles.length < anchors.length - blackList.length) {
              var handle = _this4.createHandle(coordinate, {
                'symbol': handleSymbol,
                'cursor': cursors[i],
                'axis': axis[i],
                onMove: function (_index) {
                  return function (handleViewPoint) {
                    me._updating = true;
                    onHandleMove(handleViewPoint, _index);
                    geometry.fire('resizing');
                  };
                }(i),
                onUp: function onUp() {
                  me._updating = false;
                  onHandleUp();

                  _this4._refresh();
                }
              });

              handle.setId(i);
              anchorIndexes[i] = resizeHandles.length;
              resizeHandles.push(handle);
            } else {
              resizeHandles[anchorIndexes[i]].setCoordinates(coordinate);
            }
          };

          for (var i = 0; i < anchors.length; i++) {
            var _ret = _loop(i);

            if (_ret === "continue") continue;
          }
        };

        fnLocateHandles(); //refresh hooks to refresh handles' coordinates

        this._addRefreshHook(fnLocateHandles);

        return resizeHandles;
      }
      /**
       * Create marker editor
       * @private
       */
      ;

      _proto.createMarkerEditor = function createMarkerEditor() {
        var _this5 = this;

        var geometryToEdit = this._geometry,
            shadow = this._shadow,
            map = this.getMap();

        if (!shadow._canEdit()) {
          if (console) {
            console.warn('A marker can\'t be resized with symbol:', shadow.getSymbol());
          }

          return;
        }

        if (!this._history) {
          this._recordHistory(getUpdates());
        } //only image marker and vector marker can be edited now.


        var symbol = shadow._getInternalSymbol();

        var dxdy = new Point(0, 0);

        if (isNumber(symbol['markerDx'])) {
          dxdy.x = symbol['markerDx'];
        }

        if (isNumber(symbol['markerDy'])) {
          dxdy.y = symbol['markerDy'];
        }

        var blackList = null;

        if (VectorMarkerSymbolizer.test(symbol)) {
          if (symbol['markerType'] === 'pin' || symbol['markerType'] === 'pie' || symbol['markerType'] === 'bar') {
            //as these types of markers' anchor stands on its bottom
            blackList = [5, 6, 7];
          }
        } else if (ImageMarkerSymbolizer.test(symbol) || VectorPathMarkerSymbolizer.test(symbol)) {
          blackList = [5, 6, 7];
        } //defines what can be resized by the handle
        //0: resize width; 1: resize height; 2: resize both width and height.


        var resizeAbilities = [2, 1, 2, 0, 0, 2, 1, 2];
        var aspectRatio;

        if (this.options['fixAspectRatio']) {
          var size = shadow.getSize();
          aspectRatio = size.width / size.height;
        }

        var resizeHandles = this._createResizeHandles(null, function (handleViewPoint, i) {
          if (blackList && blackList.indexOf(i) >= 0) {
            //need to change marker's coordinates
            var newCoordinates = map.viewPointToCoordinate(handleViewPoint.sub(dxdy));
            var coordinates = shadow.getCoordinates();
            newCoordinates.x = coordinates.x;
            shadow.setCoordinates(newCoordinates);

            _this5._updateCoordFromShadow(true); // geometryToEdit.setCoordinates(newCoordinates);
            //coordinates changed, and use mirror handle instead to caculate width and height


            var mirrorHandle = resizeHandles[resizeHandles.length - 1 - i];
            var mirrorViewPoint = map.coordToViewPoint(mirrorHandle.getCoordinates());
            handleViewPoint = mirrorViewPoint;
          } //caculate width and height


          var viewCenter = map._pointToViewPoint(shadow._getCenter2DPoint()).add(dxdy),
              symbol = shadow._getInternalSymbol();

          var wh = handleViewPoint.sub(viewCenter);

          if (blackList && handleViewPoint.y > viewCenter.y) {
            wh.y = 0;
          } //if this marker's anchor is on its bottom, height doesn't need to multiply by 2.


          var r = blackList ? 1 : 2;
          var width = Math.abs(wh.x) * 2,
              height = Math.abs(wh.y) * r;

          if (aspectRatio) {
            width = Math.max(width, height * aspectRatio);
            height = width / aspectRatio;
          }

          var ability = resizeAbilities[i];

          if (!(shadow instanceof TextBox)) {
            if (aspectRatio || ability === 0 || ability === 2) {
              symbol['markerWidth'] = width;
            }

            if (aspectRatio || ability === 1 || ability === 2) {
              symbol['markerHeight'] = height;
            }

            shadow.setSymbol(symbol);
            geometryToEdit.setSymbol(symbol);
          } else {
            if (aspectRatio || ability === 0 || ability === 2) {
              shadow.setWidth(width);
              geometryToEdit.setWidth(width);
            }

            if (aspectRatio || ability === 1 || ability === 2) {
              shadow.setHeight(height);
              geometryToEdit.setHeight(height);
            }
          }
        }, function () {
          _this5._update(getUpdates());
        });

        function getUpdates() {
          var updates = [['setCoordinates', shadow.getCoordinates().toArray()]];

          if (shadow instanceof TextBox) {
            updates.push(['setWidth', shadow.getWidth()]);
            updates.push(['setHeight', shadow.getHeight()]);
          } else {
            updates.push(['setSymbol', shadow.getSymbol()]);
          }

          return updates;
        }

        function onZoomEnd() {
          this._refresh();
        }

        this._addListener([map, 'zoomend', onZoomEnd]);
      }
      /**
       * Create circle editor
       * @private
       */
      ;

      _proto.createCircleEditor = function createCircleEditor() {
        var _this6 = this;

        var circle = this._geometry,
            shadow = this._shadow;
        var map = this.getMap();

        if (!this._history) {
          this._recordHistory([['setCoordinates', shadow.getCoordinates().toArray()], ['setRadius', shadow.getRadius()]]);
        }

        this._createResizeHandles(null, function (handleViewPoint) {
          var viewCenter = map._pointToViewPoint(shadow._getCenter2DPoint());

          var wh = handleViewPoint.sub(viewCenter);
          var w = Math.abs(wh.x),
              h = Math.abs(wh.y);
          var r;

          if (w > h) {
            r = map.pixelToDistance(w, 0);
          } else {
            r = map.pixelToDistance(0, h);
          }

          shadow.setRadius(r);
          circle.setRadius(r);
        }, function () {
          _this6._update('setRadius', shadow.getRadius());
        });
      }
      /**
       * editor of ellipse or rectangle
       * @private
       */
      ;

      _proto.createEllipseOrRectEditor = function createEllipseOrRectEditor() {
        var _this7 = this;

        //defines what can be resized by the handle
        //0: resize width; 1: resize height; 2: resize both width and height.
        var resizeAbilities = [2, 1, 2, 0, 0, 2, 1, 2];
        var geometryToEdit = this._geometry,
            shadow = this._shadow;

        if (!this._history) {
          this._recordHistory(getUpdates());
        }

        var map = this.getMap();
        var isRect = this._geometry instanceof Rectangle;
        var aspectRatio;

        if (this.options['fixAspectRatio']) {
          aspectRatio = geometryToEdit.getWidth() / geometryToEdit.getHeight();
        }

        var resizeHandles = this._createResizeHandles(null, function (mouseViewPoint, i) {
          //ratio of width and height
          var r = isRect ? 1 : 2;
          var pointSub, w, h;
          var targetPoint = mouseViewPoint;
          var ability = resizeAbilities[i];

          if (isRect) {
            var mirror = resizeHandles[7 - i];
            var mirrorViewPoint = map.coordToViewPoint(mirror.getCoordinates());
            pointSub = targetPoint.sub(mirrorViewPoint);
            var absSub = pointSub.abs();
            w = map.pixelToDistance(absSub.x, 0);
            h = map.pixelToDistance(0, absSub.y);
            var size = geometryToEdit.getSize();

            if (ability === 0) {
              // changing width
              // -  -  -
              // 0     0
              // -  -  -
              // Rectangle's northwest's y is (y - height / 2)
              if (aspectRatio) {
                // update rectangle's height with aspect ratio
                absSub.y = absSub.x / aspectRatio;
                size.height = Math.abs(absSub.y);
                h = w / aspectRatio;
              }

              targetPoint.y = mirrorViewPoint.y - size.height / 2;
            } else if (ability === 1) {
              // changing height
              // -  1  -
              // |     |
              // -  1  -
              // Rectangle's northwest's x is (x - width / 2)
              if (aspectRatio) {
                // update rectangle's width with aspect ratio
                absSub.x = absSub.y * aspectRatio;
                size.width = Math.abs(absSub.x);
                w = h * aspectRatio;
              }

              targetPoint.x = mirrorViewPoint.x - size.width / 2;
            } else if (aspectRatio) {
              // corner handles, relocate the target point according to aspect ratio.
              if (w > h * aspectRatio) {
                h = w / aspectRatio;
                targetPoint.y = mirrorViewPoint.y + absSub.x * sign(pointSub.y) / aspectRatio;
              } else {
                w = h * aspectRatio;
                targetPoint.x = mirrorViewPoint.x + absSub.y * sign(pointSub.x) * aspectRatio;
              }
            } //change rectangle's coordinates


            var newCoordinates = map.viewPointToCoordinate(new Point(Math.min(targetPoint.x, mirrorViewPoint.x), Math.min(targetPoint.y, mirrorViewPoint.y)));
            shadow.setCoordinates(newCoordinates);

            _this7._updateCoordFromShadow(true); // geometryToEdit.setCoordinates(newCoordinates);

          } else {
            var viewCenter = map.coordToViewPoint(geometryToEdit.getCenter());
            pointSub = viewCenter.sub(targetPoint)._abs();
            w = map.pixelToDistance(pointSub.x, 0);
            h = map.pixelToDistance(0, pointSub.y);

            if (aspectRatio) {
              w = Math.max(w, h * aspectRatio);
              h = w / aspectRatio;
            }
          }

          if (aspectRatio || ability === 0 || ability === 2) {
            shadow.setWidth(w * r);
            geometryToEdit.setWidth(w * r);
          }

          if (aspectRatio || ability === 1 || ability === 2) {
            shadow.setHeight(h * r);
            geometryToEdit.setHeight(h * r);
          }
        }, function () {
          _this7._update(getUpdates());
        });

        function getUpdates() {
          return [['setCoordinates', shadow.getCoordinates().toArray()], ['setWidth', shadow.getWidth()], ['setHeight', shadow.getHeight()]];
        }
      }
      /**
       * Editor for polygon
       * @private
       */
      ;

      _proto.createPolygonEditor = function createPolygonEditor() {
        var map = this.getMap(),
            shadow = this._shadow,
            me = this,
            projection = map.getProjection();

        if (!this._history) {
          this._recordHistory('setCoordinates', Coordinate.toNumberArrays(shadow.getCoordinates()));
        }

        var verticeLimit = shadow instanceof Polygon ? 3 : 2;
        var propertyOfVertexRefreshFn = 'maptalks--editor-refresh-fn',
            propertyOfVertexIndex = 'maptalks--editor-vertex-index';
        var vertexHandles = [],
            newVertexHandles = [];

        function getVertexCoordinates() {
          if (shadow instanceof Polygon) {
            var coordinates = shadow.getCoordinates()[0];
            return coordinates.slice(0, coordinates.length - 1);
          } else {
            return shadow.getCoordinates();
          }
        }

        function getVertexPrjCoordinates() {
          return shadow._getPrjCoordinates();
        }

        function onVertexAddOrRemove() {
          //restore index property of each handles.
          for (var i = vertexHandles.length - 1; i >= 0; i--) {
            vertexHandles[i][propertyOfVertexIndex] = i;
          }

          for (var _i = newVertexHandles.length - 1; _i >= 0; _i--) {
            newVertexHandles[_i][propertyOfVertexIndex] = _i;
          }

          me._updateCoordFromShadow();
        }

        function removeVertex(param) {
          var handle = param['target'],
              index = handle[propertyOfVertexIndex];
          var prjCoordinates = getVertexPrjCoordinates();

          if (prjCoordinates.length <= verticeLimit) {
            return;
          }

          prjCoordinates.splice(index, 1);

          shadow._setPrjCoordinates(prjCoordinates);

          shadow._updateCache(); //remove vertex handle


          vertexHandles.splice(index, 1)[0].remove(); //remove two neighbor "new vertex" handles

          if (index < newVertexHandles.length) {
            newVertexHandles.splice(index, 1)[0].remove();
          }

          var nextIndex;

          if (index === 0) {
            nextIndex = newVertexHandles.length - 1;
          } else {
            nextIndex = index - 1;
          }

          newVertexHandles.splice(nextIndex, 1)[0].remove(); //add a new "new vertex" handle.

          newVertexHandles.splice(nextIndex, 0, createNewVertexHandle.call(me, nextIndex));
          onVertexAddOrRemove();

          me._refresh();
        }

        function moveVertexHandle(handleViewPoint, index) {
          var vertice = getVertexPrjCoordinates();

          var nVertex = map._viewPointToPrj(handleViewPoint);

          var pVertex = vertice[index];
          pVertex.x = nVertex.x;
          pVertex.y = nVertex.y;

          shadow._updateCache();

          shadow.onShapeChanged();

          me._updateCoordFromShadow(true);

          var nextIndex;

          if (index === 0) {
            nextIndex = newVertexHandles.length - 1;
          } else {
            nextIndex = index - 1;
          } //refresh two neighbor "new vertex" handles.


          if (newVertexHandles[index]) {
            newVertexHandles[index][propertyOfVertexRefreshFn]();
          }

          if (newVertexHandles[nextIndex]) {
            newVertexHandles[nextIndex][propertyOfVertexRefreshFn]();
          }
        }

        function createVertexHandle(index) {
          var vertex = getVertexCoordinates()[index];
          var handle = me.createHandle(vertex, {
            'symbol': me.options['vertexHandleSymbol'],
            'cursor': 'pointer',
            'axis': null,
            onMove: function onMove(handleViewPoint) {
              moveVertexHandle(handleViewPoint, handle[propertyOfVertexIndex]);
            },
            onRefresh: function onRefresh() {
              vertex = getVertexCoordinates()[handle[propertyOfVertexIndex]];
              handle.setCoordinates(vertex);
            },
            onUp: function onUp() {
              me._refresh();

              me._updateCoordFromShadow();
            },
            onDown: function onDown(param, e) {
              if (e && e.domEvent && e.domEvent.button === 2) {
                return;
              }
            }
          });
          handle[propertyOfVertexIndex] = index;
          handle.on(me.options['removeVertexOn'], removeVertex);
          return handle;
        }

        function createNewVertexHandle(index) {
          var vertexCoordinates = getVertexCoordinates();
          var nextVertex;

          if (index + 1 >= vertexCoordinates.length) {
            nextVertex = vertexCoordinates[0];
          } else {
            nextVertex = vertexCoordinates[index + 1];
          }

          var vertex = vertexCoordinates[index].add(nextVertex).multi(1 / 2);
          var handle = me.createHandle(vertex, {
            'symbol': me.options['newVertexHandleSymbol'],
            'cursor': 'pointer',
            'axis': null,
            onDown: function onDown(param, e) {
              if (e && e.domEvent && e.domEvent.button === 2) {
                return;
              }

              var prjCoordinates = getVertexPrjCoordinates();
              var vertexIndex = handle[propertyOfVertexIndex]; //add a new vertex

              var pVertex = projection.project(handle.getCoordinates()); //update shadow's vertice

              prjCoordinates.splice(vertexIndex + 1, 0, pVertex);

              shadow._setPrjCoordinates(prjCoordinates);

              shadow._updateCache();

              var symbol = handle.getSymbol();
              delete symbol['opacity'];
              handle.setSymbol(symbol); //add two "new vertex" handles

              newVertexHandles.splice(vertexIndex, 0, createNewVertexHandle.call(me, vertexIndex), createNewVertexHandle.call(me, vertexIndex + 1));
            },
            onMove: function onMove(handleViewPoint) {
              moveVertexHandle(handleViewPoint, handle[propertyOfVertexIndex] + 1);
            },
            onUp: function onUp(e) {
              if (e && e.domEvent && e.domEvent.button === 2) {
                return;
              }

              var vertexIndex = handle[propertyOfVertexIndex]; //remove this handle

              removeFromArray(handle, newVertexHandles);
              handle.remove(); //add a new vertex handle

              vertexHandles.splice(vertexIndex + 1, 0, createVertexHandle.call(me, vertexIndex + 1));
              onVertexAddOrRemove();

              me._updateCoordFromShadow();

              me._refresh();
            },
            onRefresh: function onRefresh() {
              vertexCoordinates = getVertexCoordinates();
              var vertexIndex = handle[propertyOfVertexIndex];
              var nextIndex;

              if (vertexIndex === vertexCoordinates.length - 1) {
                nextIndex = 0;
              } else {
                nextIndex = vertexIndex + 1;
              }

              var refreshVertex = vertexCoordinates[vertexIndex].add(vertexCoordinates[nextIndex]).multi(1 / 2);
              handle.setCoordinates(refreshVertex);
            }
          });
          handle[propertyOfVertexIndex] = index;
          return handle;
        }

        var vertexCoordinates = getVertexCoordinates();

        for (var i = 0, len = vertexCoordinates.length; i < len; i++) {
          vertexHandles.push(createVertexHandle.call(this, i));

          if (i < len - 1) {
            newVertexHandles.push(createNewVertexHandle.call(this, i));
          }
        }

        if (shadow instanceof Polygon) {
          //1 more vertex handle for polygon
          newVertexHandles.push(createNewVertexHandle.call(this, vertexCoordinates.length - 1));
        }

        this._addRefreshHook(function () {
          for (var _i2 = newVertexHandles.length - 1; _i2 >= 0; _i2--) {
            newVertexHandles[_i2][propertyOfVertexRefreshFn]();
          }

          for (var _i3 = vertexHandles.length - 1; _i3 >= 0; _i3--) {
            vertexHandles[_i3][propertyOfVertexRefreshFn]();
          }
        });
      };

      _proto._refresh = function _refresh() {
        if (this._refreshHooks) {
          for (var i = this._refreshHooks.length - 1; i >= 0; i--) {
            this._refreshHooks[i].call(this);
          }
        }
      };

      _proto._hideContext = function _hideContext() {
        if (this._geometry) {
          this._geometry.closeMenu();

          this._geometry.closeInfoWindow();
        }
      };

      _proto._addListener = function _addListener(listener) {
        if (!this._eventListeners) {
          this._eventListeners = [];
        }

        this._eventListeners.push(listener);

        listener[0].on(listener[1], listener[2], this);
      };

      _proto._clearAllListeners = function _clearAllListeners() {
        if (this._eventListeners && this._eventListeners.length > 0) {
          for (var i = this._eventListeners.length - 1; i >= 0; i--) {
            var listener = this._eventListeners[i];
            listener[0].off(listener[1], listener[2], this);
          }

          this._eventListeners = [];
        }
      };

      _proto._addRefreshHook = function _addRefreshHook(fn) {
        if (!fn) {
          return;
        }

        if (!this._refreshHooks) {
          this._refreshHooks = [];
        }

        this._refreshHooks.push(fn);
      };

      _proto._update = function _update(method) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        this._exeHistory([method, args]);

        this._recordHistory.apply(this, [method].concat(args));
      };

      _proto._updateCoordFromShadow = function _updateCoordFromShadow(ignoreRecord) {
        if (!this._shadow) {
          return;
        }

        var coords = this._shadow.getCoordinates();

        var geo = this._geometry;
        var updating = this._updating;
        this._updating = true;
        geo.setCoordinates(coords);

        if (!ignoreRecord) {
          this._recordHistory('setCoordinates', Coordinate.toNumberArrays(geo.getCoordinates()));
        }

        this._updating = updating;
      };

      _proto._recordHistory = function _recordHistory(method) {
        if (!this._history) {
          this._history = [];
          this._historyPointer = 0;
        }

        if (this._historyPointer < this._history.length - 1) {
          // remove old 'next views'
          this._history.splice(this._historyPointer + 1);
        }

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        this._history.push([method, args]);

        this._historyPointer = this._history.length - 1;
        /**
         * edit record event, fired when an edit happend and being recorded
         *
         * @event Geometry#editrecord
         * @type {Object}
         * @property {String} type - editrecord
         * @property {Geometry} target - the geometry fires the event
         */

        this._geometry.fire('editrecord');
      }
      /**
       * Get previous map view in view history
       * @return {Object} map view
       */
      ;

      _proto.undo = function undo() {
        if (!this._history || this._historyPointer === 0) {
          return this;
        }

        var record = this._history[--this._historyPointer];

        this._exeAndReset(record);

        return this;
      }
      /**
       * Get next view in view history
       * @return {Object} map view
       */
      ;

      _proto.redo = function redo() {
        if (!this._history || this._historyPointer === this._history.length - 1) {
          return null;
        }

        var record = this._history[++this._historyPointer];

        this._exeAndReset(record);

        return this;
      };

      _proto._exeAndReset = function _exeAndReset(record) {
        if (this._updating) {
          return;
        }

        this._exeHistory(record);

        var history = this._history,
            pointer = this._historyPointer;
        this.stop();
        this._history = history;
        this._historyPointer = pointer;
        this.start();
      };

      _proto._exeHistory = function _exeHistory(record) {
        var _this8 = this;

        if (!Array.isArray(record)) {
          return;
        }

        var updating = this._updating;
        this._updating = true;
        var geo = this._geometry;

        if (Array.isArray(record[0])) {
          record[0].forEach(function (o) {
            var m = o[0],
                args = o.slice(1);

            _this8._shadow[m].apply(_this8._shadow, args);

            geo[m].apply(geo, args);
          });
        } else {
          this._shadow[record[0]].apply(this._shadow, record[1]);

          geo[record[0]].apply(geo, record[1]);
        }

        this._updating = updating;
      };

      return GeometryEditor;
    }(Eventable(Class));

    GeometryEditor.mergeOptions(options$z);

    /**
     * Mixin methods for text editing.
     * @mixin TextEditable
     */

    var TextEditable = {
      /**
       * Start to edit the text, editing will be ended automatically whenever map is clicked.
       *
       * @return {TextMarker} this
       * @fires TextMarker#edittextstart
       */
      startEditText: function startEditText() {
        if (!this.getMap()) {
          return this;
        }

        this.hide();
        this.endEditText();

        this._prepareEditor();
        /**
         * edittextstart when starting to edit text content
         * @event TextMarker#edittextstart
         * @type {Object}
         * @property {String} type - edittextstart
         * @property {TextMarker} target - fires the event
         */


        this._fireEvent('edittextstart');

        return this;
      },

      /**
       * End text edit.
       *
       * @return {TextMarker} this
       * @fires TextMarker#edittextend
       */
      endEditText: function endEditText() {
        if (this._textEditor) {
          var html = this._textEditor.innerHTML;
          html = html.replace(/<p>/ig, '').replace(/<\/p>/ig, '<br/>');
          this._textEditor.innerHTML = html; // trim enter chars in the end of text for IE

          var content = this._textEditor.innerText.replace(/[\r\n]+$/gi, '');

          this.setContent(content);
          off(this._textEditor, 'mousedown dblclick', stopPropagation);
          this.getMap().off('mousedown', this.endEditText, this);

          this._editUIMarker.remove();

          delete this._editUIMarker;
          this._textEditor.onkeyup = null;
          delete this._textEditor;
          this.show();
          /**
           * edittextend when ended editing text content
           * @event TextMarker#edittextend
           * @type {Object}
           * @property {String} type - edittextend
           * @property {TextMarker} target - textMarker fires the event
           */

          this._fireEvent('edittextend');
        }

        return this;
      },

      /**
       * Whether the text is being edited.
       *
       * @return {Boolean}
       */
      isEditingText: function isEditingText() {
        if (this._textEditor) {
          return true;
        }

        return false;
      },

      /**
       * Get the text editor which is an [ui.UIMarker]{@link ui.UIMarker}
       * @return {ui.UIMarker} text editor
       */
      getTextEditor: function getTextEditor() {
        return this._editUIMarker;
      },
      _prepareEditor: function _prepareEditor() {
        var map = this.getMap();

        var editContainer = this._createEditor();

        this._textEditor = editContainer;
        map.on('mousedown', this.endEditText, this);

        var offset = this._getEditorOffset();

        this._editUIMarker = new UIMarker(this.getCoordinates(), {
          'animation': null,
          'content': editContainer,
          'dx': offset.dx,
          'dy': offset.dy
        }).addTo(map);

        this._setCursorToLast(this._textEditor);
      },
      _getEditorOffset: function _getEditorOffset() {
        var symbol = this._getInternalSymbol() || {};
        var dx = 0,
            dy = 0;
        var textAlign = symbol['textHorizontalAlignment'];

        if (textAlign === 'middle' || isNil(textAlign)) {
          dx = (symbol['textDx'] || 0) - 2;
          dy = (symbol['textDy'] || 0) - 2;
        } else {
          dx = (symbol['markerDx'] || 0) - 2;
          dy = (symbol['markerDy'] || 0) - 2;
        }

        return {
          'dx': dx,
          'dy': dy
        };
      },
      _createEditor: function _createEditor() {
        var content = this.getContent();
        var labelSize = this.getSize(),
            symbol = this._getInternalSymbol() || {},
            width = labelSize.width,
            textColor = symbol['textFill'] || '#000000',
            textSize = symbol['textSize'] || 12,
            height = labelSize.height,
            lineColor = symbol['markerLineColor'] || '#000',
            fill = symbol['markerFill'] || '#3398CC',
            spacing = symbol['textLineSpacing'] || 0;
        var editor = createEl('div');
        editor.contentEditable = true;
        editor.style.cssText = "background:" + fill + "; border:1px solid " + lineColor + ";\n            color:" + textColor + ";font-size:" + textSize + "px;width:" + (width - 2) + "px;height:" + (height - 2) + "px;margin: auto;\n            line-height:" + (textSize + spacing) + "px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;";
        editor.innerText = content;
        on(editor, 'mousedown dblclick', stopPropagation);

        editor.onkeyup = function (event) {
          var h = editor.style.height || 0;

          if (event.keyCode === 13) {
            editor.style.height = parseInt(h) + textSize / 2 + 'px';
          }
        };

        return editor;
      },
      _setCursorToLast: function _setCursorToLast(obj) {
        var range;

        if (window.getSelection) {
          obj.focus();
          range = window.getSelection();
          range.selectAllChildren(obj);
          range.collapseToEnd();
        } else if (document.selection) {
          range = document.selection.createRange();
          range.moveToElementText(obj);
          range.collapse(false);
          range.select();
        }
      }
    };
    TextMarker.include(TextEditable);

    Geometry.include(
    /** @lends Geometry.prototype */
    {
      /**
       * Animate the geometry
       *
       * @param  {Object}   styles          - styles to animate
       * @param  {Object}   [options=null]  - animation options
       * @param  {NUmber}   [options.duration=1000]      - duration
       * @param  {Number}   [options.startTime=null]  - time to start animation in ms
       * @param  {String}   [options.easing=linear]   - animation easing: in, out, inAndOut, linear, upAndDown
       * @param  {Boolean}  [options.repeat=false]      - repeat animation
       * @param  {Function} [step=null]  - step function during animation, animation frame as the parameter
       * @return {animation.Player} animation player
       * @example
       * var player = marker.animate({
       *     'symbol': {
       *         'markerHeight': 82
       *      }
       * }, {
       *     'duration': 2000
       * }, function (frame) {
       *     if (frame.state.playState === 'finished') {
       *         console.log('animation finished');
       *     }
       * });
       * player.pause();
       */
      animate: function animate(styles, options, step) {
        var _this = this;

        if (this._animPlayer) {
          this._animPlayer.finish();
        }

        if (isFunction(options)) {
          step = options;
        }

        if (!options) {
          options = {};
        }

        var map = this.getMap(),
            projection = this._getProjection(),
            symbol = this.getSymbol() || {},
            stylesToAnimate = this._prepareAnimationStyles(styles);

        var preTranslate;
        var isFocusing = options['focus'];
        delete this._animationStarted; // geometry.animate can be called without map

        if (map) {
          // merge geometry animation framing into map's frame loop
          var renderer = map._getRenderer();

          var framer = function framer(fn) {
            renderer.callInNextFrame(fn);
          };

          options['framer'] = framer;
        }

        var player = Animation.animate(stylesToAnimate, options, function (frame) {
          if (map && map.isRemoved()) {
            player.finish();
            return;
          }

          if (map && !_this._animationStarted && isFocusing) {
            map.onMoveStart();
          }

          var styles = frame.styles;

          for (var p in styles) {
            if (p !== 'symbol' && p !== 'translate' && styles.hasOwnProperty(p)) {
              var fnName = 'set' + p[0].toUpperCase() + p.slice(1);

              _this[fnName](styles[p]);
            }
          }

          var translate = styles['translate'];

          if (translate) {
            var toTranslate = translate;

            if (preTranslate) {
              toTranslate = translate.sub(preTranslate);
            }

            preTranslate = translate;

            _this.translate(toTranslate);
          }

          var dSymbol = styles['symbol'];

          if (dSymbol) {
            _this.setSymbol(extendSymbol(symbol, dSymbol));
          }

          if (map && isFocusing) {
            var pcenter = projection.project(_this.getCenter());

            map._setPrjCenter(pcenter);

            var e = map._parseEventFromCoord(projection.unproject(pcenter));

            if (player.playState !== 'running') {
              map.onMoveEnd(e);
            } else {
              map.onMoving(e);
            }
          }

          _this._fireAnimateEvent(player.playState);

          if (step) {
            step(frame);
          }
        });
        this._animPlayer = player;
        return this._animPlayer.play();
      },

      /**
       * Prepare styles for animation
       * @return {Object} styles
       * @private
       */
      _prepareAnimationStyles: function _prepareAnimationStyles(styles) {
        var symbol = this._getInternalSymbol();

        var stylesToAnimate = {};

        for (var p in styles) {
          if (styles.hasOwnProperty(p)) {
            var v = styles[p];

            if (p !== 'translate' && p !== 'symbol') {
              //this.getRadius() / this.getWidth(), etc.
              var fnName = 'get' + p[0].toUpperCase() + p.substring(1);
              var current = this[fnName]();
              stylesToAnimate[p] = [current, v];
            } else if (p === 'symbol') {
              var symbolToAnimate = void 0;

              if (Array.isArray(styles['symbol'])) {
                if (!Array.isArray(symbol)) {
                  throw new Error('geometry\'symbol isn\'t a composite symbol, while the symbol in styles is.');
                }

                symbolToAnimate = [];
                var symbolInStyles = styles['symbol'];

                for (var i = 0; i < symbolInStyles.length; i++) {
                  if (!symbolInStyles[i]) {
                    symbolToAnimate.push(null);
                    continue;
                  }

                  var a = {};

                  for (var sp in symbolInStyles[i]) {
                    if (symbolInStyles[i].hasOwnProperty(sp)) {
                      a[sp] = [symbol[i][sp], symbolInStyles[i][sp]];
                    }
                  }

                  symbolToAnimate.push(a);
                }
              } else {
                if (Array.isArray(symbol)) {
                  throw new Error('geometry\'symbol is a composite symbol, while the symbol in styles isn\'t.');
                }

                symbolToAnimate = {};

                for (var _sp in v) {
                  if (v.hasOwnProperty(_sp)) {
                    symbolToAnimate[_sp] = [symbol[_sp], v[_sp]];
                  }
                }
              }

              stylesToAnimate['symbol'] = symbolToAnimate;
            } else if (p === 'translate') {
              stylesToAnimate['translate'] = new Coordinate(v);
            }
          }
        }

        return stylesToAnimate;
      },
      _fireAnimateEvent: function _fireAnimateEvent(playState) {
        if (playState === 'finished') {
          delete this._animationStarted;
          /**
           * fired when geometry's animation ended.
           *
           * @event Geometry#animateend
           * @type {Object}
           * @property {String} type - animateend
           * @property {Geometry} target - the geometry fires the event
           */

          this._fireEvent('animateend');
        } else if (playState === 'running') {
          if (this._animationStarted) {
            /**
             * fired when geometry is animating.
             *
             * @event Geometry#animating
             * @type {Object}
             * @property {String} type - animating
             * @property {Geometry} target - the geometry fires the event
             */
            this._fireEvent('animating');
          } else {
            /**
             * fired when geometry's animation start.
             *
             * @event Geometry#animatestart
             * @type {Object}
             * @property {String} type - animatestart
             * @property {Geometry} target - the geometry fires the event
             */
            this._fireEvent('animatestart');

            this._animationStarted = true;
          }
        }
      }
    });

    var DRAG_STAGE_LAYER_ID = INTERNAL_LAYER_PREFIX + '_drag_stage';
    var EVENTS$2 = Browser$1.touch ? 'touchstart mousedown' : 'mousedown';
    /**
     * Drag handler for geometries.
     * @category handler
     * @extends Handler
     * @ignore
     */

    var GeometryDragHandler =
    /*#__PURE__*/
    function (_Handler) {
      _inheritsLoose(GeometryDragHandler, _Handler);

      /**
       * @param  {Geometry} target geometry target to drag
       */
      function GeometryDragHandler(target) {
        return _Handler.call(this, target) || this;
      }

      var _proto = GeometryDragHandler.prototype;

      _proto.addHooks = function addHooks() {
        this.target.on(EVENTS$2, this._startDrag, this);
      };

      _proto.removeHooks = function removeHooks() {
        this._endDrag();

        this.target.off(EVENTS$2, this._startDrag, this);
        delete this.container;
      };

      _proto._prepareDragHandler = function _prepareDragHandler() {
        this._dragHandler = new DragHandler(this.container);

        this._dragHandler.on('dragging', this._dragging, this).on('mouseup', this._endDrag, this).enable();
      };

      _proto._prepareShadow = function _prepareShadow() {
        var target = this.target;

        this._prepareDragStageLayer();

        if (this._shadow) {
          this._shadow.remove();
        }

        var shadow = this._shadow = target.copy();

        this._shadow.setSymbol(target._getInternalSymbol());

        if (target.options['dragShadow']) {
          var symbol = lowerSymbolOpacity(shadow._getInternalSymbol(), 0.5);
          shadow.setSymbol(symbol);
        }

        shadow.setId(null);

        this._prepareShadowConnectors();
      };

      _proto._prepareShadowConnectors = function _prepareShadowConnectors() {
        //copy connectors
        var target = this.target;
        var shadow = this._shadow;

        var resources = this._dragStageLayer._getRenderer().resources;

        var shadowConnectors = [];

        if (ConnectorLine._hasConnectors(target)) {
          var connectors = ConnectorLine._getConnectors(target);

          for (var i = 0, l = connectors.length; i < l; i++) {
            var targetConn = connectors[i];

            var connOptions = targetConn.config(),
                connSymbol = targetConn._getInternalSymbol();

            connOptions['symbol'] = lowerSymbolOpacity(connSymbol, 0.5);
            var conn = void 0;

            if (targetConn.getConnectSource() === target) {
              conn = new targetConn.constructor(shadow, targetConn.getConnectTarget(), connOptions);
            } else {
              conn = new targetConn.constructor(targetConn.getConnectSource(), shadow, connOptions);
            }

            shadowConnectors.push(conn);

            if (targetConn.getLayer() && targetConn.getLayer()._getRenderer()) {
              resources.merge(targetConn.getLayer()._getRenderer().resources);
            }
          }
        }

        this._shadowConnectors = shadowConnectors;
        shadowConnectors.push(shadow);

        this._dragStageLayer.bringToFront().addGeometry(shadowConnectors);
      };

      _proto._onTargetUpdated = function _onTargetUpdated() {
        if (this._shadow) {
          this._shadow.setSymbol(this.target._getSymbol());
        }
      };

      _proto._prepareDragStageLayer = function _prepareDragStageLayer() {
        var map = this.target.getMap(),
            layer = this.target.getLayer();
        this._dragStageLayer = map.getLayer(DRAG_STAGE_LAYER_ID);

        if (!this._dragStageLayer) {
          this._dragStageLayer = new VectorLayer(DRAG_STAGE_LAYER_ID, {
            enableAltitude: layer.options['enableAltitude'],
            altitudeProperty: layer.options['altitudeProperty']
          });
          map.addLayer(this._dragStageLayer);
        } //copy resources to avoid repeat resource loading.


        var resources = new ResourceCache();
        resources.merge(layer._getRenderer().resources);
        this._dragStageLayer._getRenderer().resources = resources;
      };

      _proto._startDrag = function _startDrag(param) {
        var map = this.target.getMap();

        if (!map) {
          return;
        }

        var parent = this.target._getParent();

        if (parent) {
          return;
        }

        if (this.isDragging()) {
          return;
        }

        var domEvent = param['domEvent'];

        if (domEvent.touches && domEvent.touches.length > 1 || domEvent.button === 2) {
          return;
        }

        this.container = map._panels.mapWrapper || map._containerDOM;
        this.target.on('click', this._endDrag, this);
        this._lastCoord = this._correctCoord(param['coordinate']);
        this._lastPoint = param['containerPoint'];

        this._prepareDragHandler();

        this._dragHandler.onMouseDown(param['domEvent']);

        on(this.container, 'mouseleave', this._endDrag, this);
        this._startParam = param;
        this._moved = false;
        return;
      };

      _proto._dragging = function _dragging(param) {
        var target = this.target;

        var map = target.getMap(),
            e = map._parseEvent(param['domEvent']);

        var domEvent = e['domEvent'];

        if (domEvent.touches && domEvent.touches.length > 1) {
          return;
        }

        if (!this._moved) {
          this._moved = true;
          target.on('symbolchange', this._onTargetUpdated, this);
          this._isDragging = true;

          this._prepareShadow();

          if (!target.options['dragShadow']) {
            target.hide();
          }

          this._shadow._fireEvent('dragstart', e);
          /**
           * drag start event
           * @event Geometry#dragstart
           * @type {Object}
           * @property {String} type           - dragstart
           * @property {Geometry} target       - the geometry fires event
           * @property {Coordinate} coordinate - coordinate of the event
           * @property {Point} containerPoint  - container point of the event
           * @property {Point} viewPoint       - view point of the event
           * @property {Event} domEvent                 - dom event
           */


          this.target._fireEvent('dragstart', this._startParam || e);

          delete this._startParam;
          return;
        }

        if (!this._shadow) {
          return;
        }

        var axis = this._shadow.options['dragOnAxis'],
            coord = this._correctCoord(e['coordinate']),
            point = e['containerPoint'];

        this._lastPoint = this._lastPoint || point;
        this._lastCoord = this._lastCoord || coord;
        var pointOffset = point.sub(this._lastPoint);
        var coordOffset = coord.sub(this._lastCoord);

        if (axis === 'x') {
          pointOffset.y = coordOffset.y = 0;
        } else if (axis === 'y') {
          pointOffset.x = coordOffset.x = 0;
        }

        this._lastPoint = point;
        this._lastCoord = coord;

        this._shadow.translate(coordOffset);

        if (!target.options['dragShadow']) {
          target.translate(coordOffset);
        }

        e['coordOffset'] = coordOffset;
        e['pointOffset'] = pointOffset;

        this._shadow._fireEvent('dragging', e);
        /**
         * dragging event
         * @event Geometry#dragging
         * @type {Object}
         * @property {String} type                    - dragging
         * @property {Geometry} target       - the geometry fires event
         * @property {Coordinate} coordinate - coordinate of the event
         * @property {Point} containerPoint  - container point of the event
         * @property {Point} viewPoint       - view point of the event
         * @property {Event} domEvent                 - dom event
         */


        target._fireEvent('dragging', e);
      };

      _proto._endDrag = function _endDrag(param) {
        if (this._dragHandler) {
          this._dragHandler.disable();

          delete this._dragHandler;
        }

        if (this.container) {
          off(this.container, 'mouseleave', this._endDrag, this);
        }

        if (!this.target) {
          return;
        }

        var target = this.target;
        target.off('click', this._endDrag, this);
        target.off('symbolchange', this._onTargetUpdated, this);
        delete this._lastCoord;
        delete this._lastPoint;
        this._isDragging = false;
        var map = target.getMap();

        if (this.enabled() && map) {
          var e = map._parseEvent(param ? param['domEvent'] : null);

          this._updateTargetAndRemoveShadow(e);

          if (this._moved) {
            /**
             * dragend event
             * @event Geometry#dragend
             * @type {Object}
             * @property {String} type                    - dragend
             * @property {Geometry} target       - the geometry fires event
             * @property {Coordinate} coordinate - coordinate of the event
             * @property {Point} containerPoint  - container point of the event
             * @property {Point} viewPoint       - view point of the event
             * @property {Event} domEvent                 - dom event
             */
            target._fireEvent('dragend', e);
          }
        }
      };

      _proto.isDragging = function isDragging() {
        if (!this._isDragging) {
          return false;
        }

        return true;
      };

      _proto._updateTargetAndRemoveShadow = function _updateTargetAndRemoveShadow(eventParam) {
        var target = this.target,
            map = target.getMap();

        if (!target.options['dragShadow']) {
          target.show();
        }

        var shadow = this._shadow;

        if (shadow) {
          if (target.options['dragShadow']) {
            target.setCoordinates(shadow.getCoordinates());
          }

          shadow._fireEvent('dragend', eventParam);

          shadow.remove();
          delete this._shadow;
        }

        if (this._shadowConnectors) {
          map.getLayer(DRAG_STAGE_LAYER_ID).removeGeometry(this._shadowConnectors);
          delete this._shadowConnectors;
        }

        if (this._dragStageLayer) {
          this._dragStageLayer.remove();
        }
      } //find correct coordinate for coordOffset if geometry has altitude
      ;

      _proto._correctCoord = function _correctCoord(coord) {
        var map = this.target.getMap();

        if (!map.getPitch()) {
          return coord;
        }

        var painter = this.target._getPainter();

        if (!painter.getMinAltitude()) {
          return coord;
        }

        var alt = (painter.getMinAltitude() + painter.getMaxAltitude()) / 2;
        return map.locateByPoint(coord, 0, -alt);
      };

      return GeometryDragHandler;
    }(Handler$1);

    Geometry.mergeOptions({
      'draggable': false,
      'dragShadow': true,
      'dragOnAxis': null
    });
    Geometry.addInitHook('addHandler', 'draggable', GeometryDragHandler);
    Geometry.include(
    /** @lends Geometry.prototype */
    {
      /**
       * Whether the geometry is being dragged.
       * @reutrn {Boolean}
       */
      isDragging: function isDragging() {
        if (this._getParent()) {
          return this._getParent().isDragging();
        }

        if (this['draggable']) {
          return this['draggable'].isDragging();
        }

        return false;
      }
    });

    Geometry.include(
    /** @lends Geometry.prototype */
    {
      /**
       * Start to edit
       * @param {Object} [options=null]        - edit options
       * @param {Object} [options.symbol=null] - symbol for the geometry during editing
       * @param {Object} [options.fixAspectRatio=false]    - fix outline's aspect ratio when resizing
       * @param {Object} [options.centerHandleSymbol=null] - symbol of center handle
       * @param {Object} [options.vertexHandleSymbol=null] - symbol of vertex handle
       * @param {Object} [options.newVertexHandleSymbol=null] - symbol of new vertex handle
       * @param {Object} [options.removeVertexOn=contextmenu] - event to remove a vertex from line or polygon, contextmenu by default
       * @return {Geometry} this
       */
      startEdit: function startEdit(opts) {
        if (!this.getMap() || !this.options['editable']) {
          return this;
        }

        this.endEdit();
        this._editor = new GeometryEditor(this, opts);

        this._editor.start();
        /**
         * start edit event
         *
         * @event Geometry#editstart
         * @type {Object}
         * @property {String} type - editstart
         * @property {Geometry} target - the geometry fires the event
         */


        this.fire('editstart');
        return this;
      },

      /**
       * End editing.
       * @return {Geometry} this
       */
      endEdit: function endEdit() {
        if (this._editor) {
          this._editor.stop();

          delete this._editor;
          /**
           * end edit event
           *
           * @event Geometry#editend
           * @type {Object}
           * @property {String} type - editend
           * @property {Geometry} target - the geometry fires the event
           */

          this.fire('editend');
        }

        return this;
      },

      /**
       * Redo the edit
       * @return {Geometry} this
       */
      redoEdit: function redoEdit() {
        if (!this.isEditing()) {
          return this;
        }

        this._editor.redo();
        /**
         * redo edit event
         *
         * @event Geometry#redoedit
         * @type {Object}
         * @property {String} type - redoedit
         * @property {Geometry} target - the geometry fires the event
         */


        this.fire('redoedit');
        return this;
      },

      /**
       * Undo the edit
       * @return {Geometry} this
       */
      undoEdit: function undoEdit() {
        if (!this.isEditing()) {
          return this;
        }

        this._editor.undo();
        /**
         * undo edit event
         *
         * @event Geometry#undoedit
         * @type {Object}
         * @property {String} type - undoedit
         * @property {Geometry} target - the geometry fires the event
         */


        this.fire('undoedit');
        return this;
      },

      /**
       * Whether the geometry is being edited.
       * @return {Boolean}
       */
      isEditing: function isEditing() {
        if (this._editor) {
          return this._editor.isEditing();
        }

        return false;
      }
    });

    Geometry.include(
    /** @lends Geometry.prototype */
    {
      /**
       * The event handler for all the events.
       * @param  {Event} event - dom event
       * @private
       */
      _onEvent: function _onEvent(event, type) {
        if (!this.getMap()) {
          return;
        }

        var eventType = type || this._getEventTypeToFire(event);

        if (eventType === 'contextmenu' && this.listens('contextmenu')) {
          stopPropagation(event);
          preventDefault(event);
        }

        var params = this._getEventParams(event);

        this._fireEvent(eventType, params);
      },
      _getEventTypeToFire: function _getEventTypeToFire(domEvent) {
        // let eventType = domEvent.type;
        // //change event type to contextmenu
        // if (eventType === 'click' || eventType === 'mousedown') {
        //     if (domEvent.button === 2) {
        //         eventType = 'contextmenu';
        //     }
        // }
        return domEvent.type;
      },

      /**
       * Generate event parameters
       * @param  {Event} event - dom event
       * @return {Object}
       * @private
       */
      _getEventParams: function _getEventParams(e) {
        var map = this.getMap();
        var eventParam = {
          'domEvent': e
        };
        var actual = e.touches && e.touches.length > 0 ? e.touches[0] : e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : e;

        if (actual) {
          var containerPoint = getEventContainerPoint(actual, map._containerDOM);
          eventParam['coordinate'] = map.containerPointToCoordinate(containerPoint);
          eventParam['containerPoint'] = containerPoint;
          eventParam['viewPoint'] = map.containerPointToViewPoint(containerPoint);
          eventParam['pont2d'] = map._containerPointToPoint(containerPoint);
        }

        return eventParam;
      }
    });

    Geometry.include(
    /** @lends Geometry.prototype */
    {
      /**
       * Set an InfoWindow to the geometry
       * @param {Object} options - construct [options]{@link ui.InfoWindow#options} for the InfoWindow
       * @return {Geometry} this
       * @example
       * geometry.setInfoWindow({
       *     title    : 'This is a title',
       *     content  : '<div style="color:#f00">This is content of the InfoWindow</div>'
       * });
       */
      setInfoWindow: function setInfoWindow(options) {
        this.removeInfoWindow();

        if (options instanceof InfoWindow) {
          this._infoWindow = options;
          this._infoWinOptions = extend({}, this._infoWindow.options);

          this._infoWindow.addTo(this);

          return this;
        }

        this._infoWinOptions = extend({}, options);

        if (this._infoWindow) {
          this._infoWindow.setOptions(options);
        } else if (this.getMap()) {
          this._bindInfoWindow(this._infoWinOptions);
        }

        return this;
      },

      /**
       * Get the InfoWindow instance.
       * @return {ui.InfoWindow}
       */
      getInfoWindow: function getInfoWindow() {
        if (!this._infoWindow) {
          return null;
        }

        return this._infoWindow;
      },

      /**
       * Open the InfoWindow, default on the center of the geometry.
       * @param  {Coordinate} [coordinate=null] - coordinate to open the InfoWindow
       * @return {Geometry} this
       */
      openInfoWindow: function openInfoWindow(coordinate) {
        if (!this.getMap()) {
          return this;
        }

        if (!coordinate) {
          coordinate = this.getCenter();
        }

        if (!this._infoWindow) {
          if (this._infoWinOptions && this.getMap()) {
            this._bindInfoWindow(this._infoWinOptions);

            this._infoWindow.show(coordinate);
          }
        } else {
          this._infoWindow.show(coordinate);
        }

        return this;
      },

      /**
       * Close the InfoWindow
       * @return {Geometry} this
       */
      closeInfoWindow: function closeInfoWindow() {
        if (this._infoWindow) {
          this._infoWindow.hide();
        }

        return this;
      },

      /**
       * Remove the InfoWindow
       * @return {Geometry} this
       */
      removeInfoWindow: function removeInfoWindow() {
        this._unbindInfoWindow();

        delete this._infoWinOptions;
        delete this._infoWindow;
        return this;
      },
      _bindInfoWindow: function _bindInfoWindow(options) {
        this._infoWindow = new InfoWindow(options);

        this._infoWindow.addTo(this);

        return this;
      },
      _unbindInfoWindow: function _unbindInfoWindow() {
        if (this._infoWindow) {
          this.closeInfoWindow();

          this._infoWindow.remove();

          delete this._infoWindow;
        }

        return this;
      }
    });

    /**
     * from mapbox-gl-js
     * A [least-recently-used cache](http://en.wikipedia.org/wiki/Cache_algorithms)
     * with hash lookup made possible by keeping a list of keys in parallel to
     * an array of dictionary of values
     *
     * @private
     */
    var LRUCache =
    /*#__PURE__*/
    function () {
      /**
       * @param {number} max number of permitted values
       * @param {Function} onRemove callback called with items when they expire
       */
      function LRUCache(max, onRemove) {
        this.max = max;
        this.onRemove = onRemove;
        this.reset();
      }
      /**
       * Clear the cache
       *
       * @returns {LRUCache} this cache
       * @private
       */


      var _proto = LRUCache.prototype;

      _proto.reset = function reset() {
        for (var key in this.data) {
          this.onRemove(this.data[key]);
        }

        this.data = {};
        this.order = [];
        return this;
      };

      _proto.clear = function clear() {
        this.reset();
        delete this.onRemove;
      }
      /**
       * Add a key, value combination to the cache, trimming its size if this pushes
       * it over max length.
       *
       * @param {string} key lookup key for the item
       * @param {*} data any value
       *
       * @returns {LRUCache} this cache
       * @private
       */
      ;

      _proto.add = function add(key, data) {
        if (this.has(key)) {
          this.order.splice(this.order.indexOf(key), 1);
          this.data[key] = data;
          this.order.push(key);
        } else {
          this.data[key] = data;
          this.order.push(key);

          if (this.order.length > this.max) {
            var removedData = this.getAndRemove(this.order[0]);
            if (removedData) this.onRemove(removedData);
          }
        }

        return this;
      }
      /**
       * Determine whether the value attached to `key` is present
       *
       * @param {String} key the key to be looked-up
       * @returns {Boolean} whether the cache has this value
       * @private
       */
      ;

      _proto.has = function has(key) {
        return key in this.data;
      }
      /**
       * List all keys in the cache
       *
       * @returns {Array<string>} an array of keys in this cache.
       * @private
       */
      ;

      _proto.keys = function keys() {
        return this.order;
      }
      /**
       * Get the value attached to a specific key and remove data from cache.
       * If the key is not found, returns `null`
       *
       * @param {string} key the key to look up
       * @returns {*} the data, or null if it isn't found
       * @private
       */
      ;

      _proto.getAndRemove = function getAndRemove(key) {
        if (!this.has(key)) {
          return null;
        }

        var data = this.data[key];
        delete this.data[key];
        this.order.splice(this.order.indexOf(key), 1);
        return data;
      }
      /**
       * Get the value attached to a specific key without removing data
       * from the cache. If the key is not found, returns `null`
       *
       * @param {string} key the key to look up
       * @returns {*} the data, or null if it isn't found
       * @private
       */
      ;

      _proto.get = function get(key) {
        if (!this.has(key)) {
          return null;
        }

        var data = this.data[key];
        return data;
      }
      /**
       * Remove a key/value combination from the cache.
       *
       * @param {string} key the key for the pair to delete
       * @returns {LRUCache} this cache
       * @private
       */
      ;

      _proto.remove = function remove(key) {
        if (!this.has(key)) {
          return this;
        }

        var data = this.data[key];
        delete this.data[key];
        this.onRemove(data);
        this.order.splice(this.order.indexOf(key), 1);
        return this;
      }
      /**
       * Change the max size of the cache.
       *
       * @param {number} max the max size of the cache
       * @returns {LRUCache} this cache
       * @private
       */
      ;

      _proto.setMaxSize = function setMaxSize(max) {
        this.max = max;

        while (this.order.length > this.max) {
          var removedData = this.getAndRemove(this.order[0]);
          if (removedData) this.onRemove(removedData);
        }

        return this;
      };

      return LRUCache;
    }();

    var TEMP_POINT$3 = new Point(0, 0);
    var TEMP_POINT1$3 = new Point(0, 0);
    var TEMP_POINT2$2 = new Point(0, 0);
    /**
     * @classdesc
     * Renderer class based on HTML5 Canvas2D for TileLayers
     * @class
     * @protected
     * @memberOf renderer
     * @extends {renderer.CanvasRenderer}
     */

    var TileLayerCanvasRenderer =
    /*#__PURE__*/
    function (_CanvasRenderer) {
      _inheritsLoose(TileLayerCanvasRenderer, _CanvasRenderer);

      /**
       *
       * @param {TileLayer} layer - TileLayer to render
       */
      function TileLayerCanvasRenderer(layer) {
        var _this;

        _this = _CanvasRenderer.call(this, layer) || this;
        _this.tilesInView = {};
        _this.tilesLoading = {};
        _this._parentTiles = [];
        _this._childTiles = [];
        _this.tileCache = new LRUCache(layer.options['maxCacheSize'], _this.deleteTile.bind(_assertThisInitialized(_assertThisInitialized(_this))));
        return _this;
      }

      var _proto = TileLayerCanvasRenderer.prototype;

      _proto.getCurrentTileZoom = function getCurrentTileZoom() {
        return this._tileZoom;
      };

      _proto.draw = function draw() {
        var map = this.getMap();

        if (!this.isDrawable()) {
          return;
        }

        var mask2DExtent = this.prepareCanvas();

        if (mask2DExtent) {
          if (!mask2DExtent.intersects(this.canvasExtent2D)) {
            this.completeRender();
            return;
          }
        }

        var layer = this.layer;
        var tileGrids = layer.getTiles().tileGrids;

        if (!tileGrids || !tileGrids.length) {
          this.completeRender();
          return;
        }

        var loadingCount = 0;
        var loading = false;
        var checkedTiles = {};
        var tiles = [],
            parentTiles = [],
            parentKeys = {},
            childTiles = [],
            childKeys = {},
            placeholders = [],
            placeholderKeys = {}; //visit all the tiles

        var tileQueue = {};

        var preLoadingCount = this._markTiles(),
            loadingLimit = this._getLoadLimit();

        var l = tileGrids.length; // main tile grid is the last one (draws on top)

        this._tileZoom = tileGrids[0]['zoom'];
        this._tileOffset = tileGrids[0]['offset'];

        for (var i = 0; i < l; i++) {
          var tileGrid = tileGrids[i];
          var allTiles = tileGrid['tiles'];

          var placeholder = this._generatePlaceHolder(tileGrid.zoom);

          for (var _i = 0, _l = allTiles.length; _i < _l; _i++) {
            var tile = allTiles[_i],
                tileId = tile['id']; //load tile in cache at first if it has.

            var tileLoading = false;

            if (this._isLoadingTile(tileId)) {
              tileLoading = loading = true;
              this.tilesLoading[tileId].current = true;
            } else {
              var cached = this._getCachedTile(tileId);

              if (cached) {
                if (this.getTileOpacity(cached.image) < 1) {
                  tileLoading = loading = true;
                }

                tiles.push(cached);
              } else {
                tileLoading = loading = true;
                var hitLimit = loadingLimit && loadingCount + preLoadingCount[0] > loadingLimit;

                if (!hitLimit && (!map.isInteracting() || map.isMoving() || map.isRotating())) {
                  loadingCount++;
                  tileQueue[tileId + '@' + tile['point'].toArray().join()] = tile;
                }
              }
            }

            if (!tileLoading) continue;

            if (checkedTiles[tileId]) {
              continue;
            }

            checkedTiles[tileId] = 1;

            if (placeholder && !placeholderKeys[tileId]) {
              //tell gl renderer not to bind gl buffer with image
              tile.cache = false;
              placeholders.push({
                image: placeholder,
                info: tile
              });
              placeholderKeys[tileId] = 1;
            }

            var parentTile = this._findParentTile(tile);

            if (parentTile) {
              var parentId = parentTile.info.id;

              if (parentKeys[parentId] === undefined) {
                parentKeys[parentId] = parentTiles.length;
                parentTiles.push(parentTile);
              }
              /* else {
                 //replace with parentTile of above tiles
                 parentTiles[parentKeys[parentId]] = parentTile;
              } */

            } else if (!parentTiles.length) {
              var children = this._findChildTiles(tile);

              if (children.length) {
                children.forEach(function (c) {
                  if (!childKeys[c.info.id]) {
                    childTiles.push(c);
                    childKeys[c.info.id] = 1;
                  }
                });
              }
            }
          }
        }

        if (parentTiles.length) {
          childTiles.length = 0;
          this._childTiles.length = 0;
        }

        this._drawTiles(tiles, parentTiles, childTiles, placeholders);

        if (!loadingCount) {
          if (!loading) {
            //redraw to remove parent tiles if any left in last paint
            if (!map.isAnimating() && (this._parentTiles.length || this._childTiles.length)) {
              this._parentTiles = [];
              this._childTiles = [];
              this.setToRedraw();
            }

            this.completeRender();
          }
        } else {
          this.loadTileQueue(tileQueue);
        }

        this._retireTiles();
      };

      _proto.isTileCachedOrLoading = function isTileCachedOrLoading(tileId) {
        return this.tilesLoading[tileId] || this.tilesInView[tileId] || this.tileCache.get(tileId);
      };

      _proto._drawTiles = function _drawTiles(tiles, parentTiles, childTiles, placeholders) {
        var _this2 = this;

        if (parentTiles.length) {
          //closer the latter (to draw on top)
          parentTiles.sort(function (t1, t2) {
            return Math.abs(t2.info.z - _this2._tileZoom) - Math.abs(t1.info.z - _this2._tileZoom);
          });
          this._parentTiles = parentTiles;
        }

        if (childTiles.length) {
          this._childTiles = childTiles;
        }

        var context = {
          tiles: tiles,
          parentTiles: this._parentTiles,
          childTiles: this._childTiles
        };
        this.onDrawTileStart(context);

        this._parentTiles.forEach(function (t) {
          return _this2._drawTileAndCache(t);
        });

        this._childTiles.forEach(function (t) {
          return _this2._drawTileOffset(t.info, t.image);
        });

        placeholders.forEach(function (t) {
          return _this2._drawTileOffset(t.info, t.image);
        });
        var layer = this.layer,
            map = this.getMap();

        if (!layer.options['cascadeTiles'] || map.getPitch() <= map.options['cascadePitches'][0]) {
          tiles.forEach(function (t) {
            return _this2._drawTileAndCache(t);
          });
        } else {
          //write current tiles and update stencil buffer to clip parent|child tiles with current tiles
          this.writeZoomStencil();
          var started = false;

          for (var i = 0, l = tiles.length; i < l; i++) {
            if (tiles[i].info.z !== this._tileZoom) {
              if (!started) {
                this.startZoomStencilTest();
                started = true;
              } else {
                this.resumeZoomStencilTest();
              }
            } else if (started) {
              this.pauseZoomStencilTest();
            }

            this._drawTileAndCache(tiles[i]);
          }

          this.endZoomStencilTest();
        }

        this.onDrawTileEnd(context);
      };

      _proto.writeZoomStencil = function writeZoomStencil() {};

      _proto.startZoomStencilTest = function startZoomStencilTest() {};

      _proto.endZoomStencilTest = function endZoomStencilTest() {};

      _proto.pauseZoomStencilTest = function pauseZoomStencilTest() {};

      _proto.resumeZoomStencilTest = function resumeZoomStencilTest() {};

      _proto.onDrawTileStart = function onDrawTileStart() {};

      _proto.onDrawTileEnd = function onDrawTileEnd() {};

      _proto._drawTileOffset = function _drawTileOffset(info, image) {
        var offset = this._tileOffset;

        if (!offset[0] && !offset[1]) {
          this.drawTile(info, image);
          return;
        }

        var map = this.getMap(); //tempararily add offset to tile info

        var scale = map._getResolution(this._tileZoom) / map._getResolution(info.z);

        offset[0] *= scale;
        offset[1] *= scale;

        info.point._sub(offset);

        info.extent2d._sub(offset);

        this.drawTile(info, image); //restore

        info.point._add(offset);

        info.extent2d._add(offset);

        offset[0] /= scale;
        offset[1] /= scale;
      };

      _proto._drawTileAndCache = function _drawTileAndCache(tile) {
        tile.current = true;
        this.tilesInView[tile.info.id] = tile;

        this._drawTileOffset(tile.info, tile.image);

        this.tileCache.add(tile.info.id, tile);
      };

      _proto.drawOnInteracting = function drawOnInteracting() {
        this.draw();
      };

      _proto.needToRedraw = function needToRedraw() {
        var map = this.getMap();

        if (map.getPitch()) {
          return _CanvasRenderer.prototype.needToRedraw.call(this);
        }

        if (map.isRotating() || map.isZooming()) {
          return true;
        }

        if (map.isMoving()) {
          return !!this.layer.options['forceRenderOnMoving'];
        }

        return _CanvasRenderer.prototype.needToRedraw.call(this);
      };

      _proto.hitDetect = function hitDetect() {
        return false;
      } // limit tile number to load when map is interacting
      ;

      _proto._getLoadLimit = function _getLoadLimit() {
        if (this.getMap().isInteracting()) {
          return this.layer.options['loadingLimitOnInteracting'];
        }

        return 0;
      };

      _proto.isDrawable = function isDrawable() {
        if (this.getMap().getPitch()) {
          if (console) {
            console.warn('TileLayer with canvas renderer can\'t be pitched, use gl renderer (\'renderer\' : \'gl\') instead.');
          }

          this.clear();
          return false;
        }

        return true;
      };

      _proto.clear = function clear() {
        this._retireTiles(true);

        this.tileCache.reset();
        this.tilesInView = {};
        this.tilesLoading = {};
        this._parentTiles = [];
        this._childTiles = [];

        _CanvasRenderer.prototype.clear.call(this);
      };

      _proto._isLoadingTile = function _isLoadingTile(tileId) {
        return !!this.tilesLoading[tileId];
      };

      _proto.clipCanvas = function clipCanvas(context) {
        // const mask = this.layer.getMask();
        // if (!mask) {
        //     return this._clipByPitch(context);
        // }
        return _CanvasRenderer.prototype.clipCanvas.call(this, context);
      } // clip canvas to avoid rough edge of tiles
      ;

      _proto._clipByPitch = function _clipByPitch(ctx) {
        var map = this.getMap();

        if (map.getPitch() <= map.options['maxVisualPitch']) {
          return false;
        }

        if (!this.layer.options['clipByPitch']) {
          return false;
        }

        var clipExtent = map.getContainerExtent();
        var r = map.getDevicePixelRatio();
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
        ctx.beginPath();
        ctx.rect(0, Math.ceil(clipExtent.ymin) * r, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(clipExtent.getHeight()) * r);
        ctx.stroke();
        ctx.clip();
        return true;
      };

      _proto.loadTileQueue = function loadTileQueue(tileQueue) {
        this.tileToLoadCount = 0;

        for (var p in tileQueue) {
          tileQueue.hasOwnProperty(p) && this.tileToLoadCount++;
        }

        for (var _p in tileQueue) {
          if (tileQueue.hasOwnProperty(_p)) {
            var tile = tileQueue[_p];
            var tileImage = this.loadTile(tile);

            if (tileImage.loadTime === undefined) {
              // tile image's loading may not be async
              this.tilesLoading[tile['id']] = {
                image: tileImage,
                current: true,
                info: tile
              };
            }
          }
        }
      };

      _proto.loadTile = function loadTile(tile) {
        var tileSize = this.layer.getTileSize();
        var tileImage = new Image();
        tileImage.width = tileSize['width'];
        tileImage.height = tileSize['height'];
        tileImage.onload = this.onTileLoad.bind(this, tileImage, tile);
        tileImage.onerror = this.onTileError.bind(this, tileImage, tile);
        this.loadTileImage(tileImage, tile['url']);
        return tileImage;
      };

      _proto.loadTileImage = function loadTileImage(tileImage, url) {
        var crossOrigin = this.layer.options['crossOrigin'];

        if (!isNil(crossOrigin)) {
          tileImage.crossOrigin = crossOrigin;
        }

        return loadImage(tileImage, [url]);
      };

      _proto.abortTileLoading = function abortTileLoading(tileImage) {
        if (!tileImage) return;
        tileImage.onload = falseFn;
        tileImage.onerror = falseFn;
        tileImage.src = emptyImageUrl;
      };

      _proto.onTileLoad = function onTileLoad(tileImage, tileInfo) {
        if (!this.layer) {
          return;
        }

        var id = tileInfo['id'];

        if (!this.tilesInView) {
          // removed
          return;
        }

        tileImage.loadTime = now();
        delete this.tilesLoading[id];
        this.tileToLoadCount--;

        this._addTileToCache(tileInfo, tileImage);

        this.setToRedraw();
        /**
         * tileload event, fired when tile is loaded.
         *
         * @event TileLayer#tileload
         * @type {Object}
         * @property {String} type - tileload
         * @property {TileLayer} target - tile layer
         * @property {Object} tileInfo - tile info
         * @property {Image} tileImage - tile image
         */

        this.layer.fire('tileload', {
          tile: tileInfo,
          tileImage: tileImage
        });
      };

      _proto.onTileError = function onTileError(tileImage, tileInfo) {
        if (!this.layer) {
          return;
        }

        tileImage.onerrorTick = tileImage.onerrorTick || 0;
        var tileRetryCount = this.layer.options['tileRetryCount'];

        if (tileRetryCount > tileImage.onerrorTick) {
          tileImage.onerrorTick++;
          tileImage.src = tileInfo.url;
          return;
        }

        if (tileImage instanceof Image) {
          this.abortTileLoading(tileImage, tileInfo);
        }

        tileImage.loadTime = 0;
        delete this.tilesLoading[tileInfo['id']];
        this.tileToLoadCount--;

        this._addTileToCache(tileInfo, tileImage);

        this.setToRedraw();
        /**
         * tileerror event, fired when tile loading has error.
         *
         * @event TileLayer#tileerror
         * @type {Object}
         * @property {String} type - tileerror
         * @property {TileLayer} target - tile layer
         * @property {Object} tileInfo - tile info
         */

        this.layer.fire('tileerror', {
          tile: tileInfo
        });
      };

      _proto.drawTile = function drawTile(tileInfo, tileImage) {
        if (!tileImage || !this.getMap()) {
          return;
        }

        var point = tileInfo.point,
            tileZoom = tileInfo.z,
            tileId = tileInfo.id;

        var map = this.getMap(),
            tileSize = tileInfo.size,
            zoom = map.getZoom(),
            ctx = this.context,
            cp = map._pointToContainerPoint(point, tileZoom, 0, TEMP_POINT$3),
            bearing = map.getBearing(),
            transformed = bearing || zoom !== tileZoom;

        var opacity = this.getTileOpacity(tileImage);
        var alpha = ctx.globalAlpha;

        if (opacity < 1) {
          ctx.globalAlpha = opacity;
          this.setToRedraw();
        }

        if (!transformed) {
          cp._round();
        }

        var x = cp.x,
            y = cp.y;
        var w = tileSize[0],
            h = tileSize[1];

        if (transformed) {
          w += 0.1;
          h += 0.1;
          ctx.save();
          ctx.translate(x, y);

          if (bearing) {
            ctx.rotate(-bearing * Math.PI / 180);
          }

          if (zoom !== tileZoom) {
            var scale = map._getResolution(tileZoom) / map._getResolution();

            ctx.scale(scale, scale);
          }

          x = y = 0;
        }

        Canvas$1.image(ctx, tileImage, x, y, w, h);

        if (this.layer.options['debug']) {
          var color = this.layer.options['debugOutline'],
              xyz = tileId.split('_');
          var length = xyz.length;
          ctx.save();
          ctx.strokeStyle = color;
          ctx.fillStyle = color;
          ctx.strokeWidth = 10;
          ctx.font = '15px monospace';

          var _point = new Point(x, y);

          Canvas$1.rectangle(ctx, _point, {
            width: w,
            height: h
          }, 1, 0);
          Canvas$1.fillText(ctx, 'x:' + xyz[length - 2] + ', y:' + xyz[length - 3] + ', z:' + xyz[length - 1], _point._add(10, 20), color);
          Canvas$1.drawCross(ctx, x + w / 2, y + h / 2, 2, color);
          ctx.restore();
        }

        if (transformed) {
          ctx.restore();
        }

        if (ctx.globalAlpha !== alpha) {
          ctx.globalAlpha = alpha;
        }

        this.setCanvasUpdated();
      };

      _proto._findChildTiles = function _findChildTiles(info) {
        var layer = this._getLayerOfTile(info.layer);

        if (!layer.options['background']) {
          return [];
        }

        var map = this.getMap();
        var children = [];

        var min = info.extent2d.getMin(),
            max = info.extent2d.getMax(),
            pmin = layer._project(map._pointToPrj(min, info.z, TEMP_POINT1$3), TEMP_POINT1$3),
            pmax = layer._project(map._pointToPrj(max, info.z, TEMP_POINT2$2), TEMP_POINT2$2);

        var zoomDiff = 2;

        for (var i = 1; i < zoomDiff; i++) {
          this._findChildTilesAt(children, pmin, pmax, layer, info.z + i);
        }

        return children;
      };

      _proto._findChildTilesAt = function _findChildTilesAt(children, pmin, pmax, layer, childZoom) {
        var zoomOffset = layer.options['zoomOffset'];
        var layerId = layer.getId(),
            res = layer.getSpatialReference().getResolution(childZoom + zoomOffset);

        if (!res) {
          return;
        }

        var dmin = layer._getTileConfig().getTileIndex(pmin, res),
            dmax = layer._getTileConfig().getTileIndex(pmax, res);

        var sx = Math.min(dmin.idx, dmax.idx),
            ex = Math.max(dmin.idx, dmax.idx);
        var sy = Math.min(dmin.idy, dmax.idy),
            ey = Math.max(dmin.idy, dmax.idy);
        var id, tile;

        for (var i = sx; i < ex; i++) {
          for (var ii = sy; ii < ey; ii++) {
            id = layer._getTileId(i, ii, childZoom + zoomOffset, layerId);

            if (this.tileCache.has(id)) {
              tile = this.tileCache.getAndRemove(id);
              children.push(tile);
              this.tileCache.add(id, tile);
            }
          }
        }
      };

      _proto._findParentTile = function _findParentTile(info) {
        var map = this.getMap(),
            layer = this._getLayerOfTile(info.layer);

        if (!layer.options['background']) {
          return null;
        }

        var sr = layer.getSpatialReference();
        var d = sr.getZoomDirection(),
            zoomOffset = layer.options['zoomOffset'],
            zoomDiff = layer.options['backgroundZoomDiff'];

        var center = info.extent2d.getCenter(),
            prj = layer._project(map._pointToPrj(center, info.z));

        for (var diff = 1; diff <= zoomDiff; diff++) {
          var z = info.z - d * diff;
          var res = sr.getResolution(z + zoomOffset);
          if (!res) continue;

          var tileIndex = layer._getTileConfig().getTileIndex(prj, res);

          var id = layer._getTileId(tileIndex.x, tileIndex.y, z + zoomOffset, info.layer);

          if (this.tileCache.has(id)) {
            var tile = this.tileCache.getAndRemove(id);
            this.tileCache.add(id, tile);
            return tile;
          }
        }

        return null;
      };

      _proto._getLayerOfTile = function _getLayerOfTile(layerId) {
        return this.layer.getChildLayer ? this.layer.getChildLayer(layerId) : this.layer;
      };

      _proto._getCachedTile = function _getCachedTile(tileId) {
        var tilesInView = this.tilesInView;
        var cached = this.tileCache.getAndRemove(tileId);

        if (cached) {
          tilesInView[tileId] = cached;
          var tilesLoading = this.tilesLoading;

          if (tilesLoading && tilesLoading[tileId]) {
            tilesLoading[tileId].current = false;
            var _tilesLoading$tileId = tilesLoading[tileId],
                image = _tilesLoading$tileId.image,
                info = _tilesLoading$tileId.info;
            this.abortTileLoading(image, info);
            console.log('_getCachedTile');
            delete tilesLoading[tileId];
          }
        } else {
          cached = tilesInView[tileId];
        }

        return cached;
      };

      _proto._addTileToCache = function _addTileToCache(tileInfo, tileImage) {
        this.tilesInView[tileInfo.id] = {
          image: tileImage,
          current: true,
          info: tileInfo
        };
      };

      _proto.getTileOpacity = function getTileOpacity(tileImage) {
        if (!this.layer.options['fadeAnimation'] || !tileImage.loadTime) {
          return 1;
        }

        return Math.min(1, (now() - tileImage.loadTime) / (1000 / 60 * 10));
      };

      _proto.onRemove = function onRemove() {
        this.clear();
        delete this.tileCache;
        delete this._tilePlaceHolder;

        _CanvasRenderer.prototype.onRemove.call(this);
      };

      _proto._markTiles = function _markTiles() {
        var a = 0,
            b = 0;

        if (this.tilesLoading) {
          for (var p in this.tilesLoading) {
            this.tilesLoading[p].current = false;
            a++;
          }
        }

        if (this.tilesInView) {
          for (var _p2 in this.tilesInView) {
            this.tilesInView[_p2].current = false;
            b++;
          }
        }

        return [a, b];
      };

      _proto._retireTiles = function _retireTiles(force) {
        for (var i in this.tilesLoading) {
          var tile = this.tilesLoading[i];

          if (force || !tile.current) {
            // abort loading tiles
            if (tile.image) {
              this.abortTileLoading(tile.image, tile.info);
            }

            this.deleteTile(tile);
            delete this.tilesLoading[i];
          }
        }

        for (var _i2 in this.tilesInView) {
          var _tile = this.tilesInView[_i2];

          if (!_tile.current) {
            delete this.tilesInView[_i2];

            if (!this.tileCache.has(_i2)) {
              this.deleteTile(_tile);
            }
          }
        }
      };

      _proto.deleteTile = function deleteTile(tile) {
        if (!tile || !tile.image) {
          return;
        }

        tile.image.onload = null;
        tile.image.onerror = null;
      };

      _proto._generatePlaceHolder = function _generatePlaceHolder(z) {
        var map = this.getMap();
        var placeholder = this.layer.options['placeholder'];

        if (!placeholder || map.getPitch()) {
          return null;
        }

        var tileSize = this.layer.getTileSize(),
            scale = map._getResolution(z) / map._getResolution(),
            canvas = this._tilePlaceHolder = this._tilePlaceHolder || Canvas$1.createCanvas(1, 1);

        canvas.width = tileSize.width * scale;
        canvas.height = tileSize.height * scale;

        if (isFunction(placeholder)) {
          placeholder(canvas);
        } else {
          defaultPlaceholder(canvas);
        }

        return canvas;
      };

      return TileLayerCanvasRenderer;
    }(CanvasRenderer);

    TileLayer.registerRenderer('canvas', TileLayerCanvasRenderer);

    function falseFn() {
      return false;
    }

    function defaultPlaceholder(canvas) {
      var ctx = canvas.getContext('2d'),
          cw = canvas.width,
          ch = canvas.height,
          w = cw / 16,
          h = ch / 16;
      ctx.beginPath();

      for (var i = 0; i < 16; i++) {
        ctx.moveTo(0, i * h);
        ctx.lineTo(cw, i * h);
        ctx.moveTo(i * w, 0);
        ctx.lineTo(i * w, ch);
      }

      ctx.strokeStyle = 'rgba(180, 180, 180, 0.1)';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.beginPath();
      var path = [[0, 0], [cw, 0], [0, ch], [cw, ch], [0, 0], [0, ch], [cw, 0], [cw, ch], [0, ch / 2], [cw, ch / 2], [cw / 2, 0], [cw / 2, ch]];

      for (var _i3 = 1; _i3 < path.length; _i3 += 2) {
        ctx.moveTo(path[_i3 - 1][0], path[_i3 - 1][1]);
        ctx.lineTo(path[_i3][0], path[_i3][1]);
      }

      ctx.lineWidth = 1 * 4;
      ctx.stroke();
    }

    /**
     * @classdesc
     * Renderer class based on HTML5 WebGL for TileLayers
     * @class
     * @protected
     * @memberOf renderer
     * @extends {renderer.TileLayerCanvasRenderer}
     * @param {TileLayer} layer - TileLayer to render
     */

    var TileLayerGLRenderer =
    /*#__PURE__*/
    function (_ImageGLRenderable) {
      _inheritsLoose(TileLayerGLRenderer, _ImageGLRenderable);

      function TileLayerGLRenderer() {
        return _ImageGLRenderable.apply(this, arguments) || this;
      }

      var _proto = TileLayerGLRenderer.prototype;

      //override to set to always drawable
      _proto.isDrawable = function isDrawable() {
        return true;
      };

      _proto.needToRedraw = function needToRedraw() {
        var map = this.getMap();

        if (this._gl() && !map.getPitch() && map.isZooming() && !map.isMoving() && !map.isRotating()) {
          return true;
        }

        return _ImageGLRenderable.prototype.needToRedraw.call(this);
      };

      _proto.drawTile = function drawTile(tileInfo, tileImage) {
        var map = this.getMap();

        if (!tileInfo || !map || !tileImage) {
          return;
        }

        var scale = tileInfo._glScale = tileInfo._glScale || map.getGLScale(tileInfo.z),
            w = tileInfo.size[0],
            h = tileInfo.size[1];

        if (tileInfo.cache !== false) {
          this._bindGLBuffer(tileImage, w, h);
        }

        if (!this._gl()) {
          // fall back to canvas 2D, which is faster
          _ImageGLRenderable.prototype.drawTile.call(this, tileInfo, tileImage);

          return;
        }

        var point = tileInfo.point;
        var x = point.x * scale,
            y = point.y * scale;
        var opacity = this.getTileOpacity(tileImage);
        this.drawGLImage(tileImage, x, y, w, h, scale, opacity, this.layer.options['debug']);

        if (opacity < 1) {
          this.setToRedraw();
        } else {
          this.setCanvasUpdated();
        }
      };

      _proto.writeZoomStencil = function writeZoomStencil() {
        var gl = this.gl;
        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
      };

      _proto.startZoomStencilTest = function startZoomStencilTest() {
        var gl = this.gl;
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        gl.stencilFunc(gl.EQUAL, 0, 0xFF);
      };

      _proto.endZoomStencilTest = function endZoomStencilTest() {
        this.pauseZoomStencilTest();
      };

      _proto.pauseZoomStencilTest = function pauseZoomStencilTest() {
        var gl = this.gl;
        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
      };

      _proto.resumeZoomStencilTest = function resumeZoomStencilTest() {
        var gl = this.gl;
        gl.stencilFunc(gl.EQUAL, 0, 0xFF);
      };

      _proto._bindGLBuffer = function _bindGLBuffer(image, w, h) {
        if (!image.glBuffer) {
          image.glBuffer = this.bufferTileData(0, 0, w, h);
        }
      };

      _proto.loadTileImage = function loadTileImage(tileImage, url) {
        //image must set cors in webgl
        var crossOrigin = this.layer.options['crossOrigin'];
        tileImage.crossOrigin = crossOrigin !== null ? crossOrigin : '';
        tileImage.src = url;
        return;
      } // prepare gl, create program, create buffers and fill unchanged data: image samplers, texture coordinates
      ;

      _proto.onCanvasCreate = function onCanvasCreate() {
        //not in a GroupGLLayer
        if (!this.canvas.gl || !this.canvas.gl.wrap) {
          this.createCanvas2();
        }
      };

      _proto.createContext = function createContext() {
        _ImageGLRenderable.prototype.createContext.call(this);

        this.createGLContext();
      };

      _proto.resizeCanvas = function resizeCanvas(canvasSize) {
        if (!this.canvas) {
          return;
        }

        _ImageGLRenderable.prototype.resizeCanvas.call(this, canvasSize);

        this.resizeGLCanvas();
      };

      _proto.clearCanvas = function clearCanvas() {
        if (!this.canvas) {
          return;
        }

        _ImageGLRenderable.prototype.clearCanvas.call(this);

        this.clearGLCanvas();
      };

      _proto.getCanvasImage = function getCanvasImage() {
        if (!this._gl() || !this.canvas2) {
          return _ImageGLRenderable.prototype.getCanvasImage.call(this);
        }

        var img = _ImageGLRenderable.prototype.getCanvasImage.call(this);

        if (img) {
          img.image = this.canvas2;
        }

        return img;
      } // decide whether the layer is renderer with gl.
      // when map is pitching, or fragmentShader is set in options
      ;

      _proto._gl = function _gl() {
        if (this.canvas.gl && this.canvas.gl.wrap) {
          //in GroupGLLayer
          return true;
        }

        var map = this.getMap();
        return map && (map.getPitch() || map.getBearing()) || this.layer && !!this.layer.options['fragmentShader'];
      };

      _proto.deleteTile = function deleteTile(tile) {
        _ImageGLRenderable.prototype.deleteTile.call(this, tile);

        if (tile && tile.image) {
          this.disposeImage(tile.image);
        }

        delete tile.image;
      };

      _proto.onRemove = function onRemove() {
        _ImageGLRenderable.prototype.onRemove.call(this);

        this.removeGLCanvas();
      };

      return TileLayerGLRenderer;
    }(ImageGLRenderable(TileLayerCanvasRenderer));

    TileLayer.registerRenderer('gl', TileLayerGLRenderer);

    function _loadTile(tile) {
      var tileSize = this.layer.getTileSize(),
          canvasClass = this.canvas.constructor,
          map = this.getMap();
      var r = map.getDevicePixelRatio();
      var tileCanvas = Canvas$1.createCanvas(tileSize['width'] * r, tileSize['height'] * r, canvasClass);
      tileCanvas['layer'] = this.layer;
      var me = this;
      var extent = new Extent(map.pointToCoordinate(tile['point']), map.pointToCoordinate(tile['point'].add(tileSize.toPoint())), map.getProjection());
      this.layer.drawTile(tileCanvas, {
        'url': tile['url'],
        'point': tile['point'],
        'center': map.pointToCoordinate(tile['point'].add(tileSize['width'] / 2, tileSize['height'] / 2)),
        'extent': extent,
        'z': tile['z'],
        'x': tile['x'],
        'y': tile['y']
      }, function (error) {
        if (error) {
          me.onTileError(tileCanvas, tile);
          return;
        }

        me.onTileLoad(tileCanvas, tile);
      });
      return tileCanvas;
    }

    var CanvasRenderer$1 =
    /*#__PURE__*/
    function (_TileLayerCanvasRende) {
      _inheritsLoose(CanvasRenderer, _TileLayerCanvasRende);

      function CanvasRenderer() {
        return _TileLayerCanvasRende.apply(this, arguments) || this;
      }

      var _proto = CanvasRenderer.prototype;

      _proto.loadTile = function loadTile() {
        return _loadTile.apply(this, arguments);
      };

      return CanvasRenderer;
    }(TileLayerCanvasRenderer);

    var GLRenderer =
    /*#__PURE__*/
    function (_TileLayerGLRenderer) {
      _inheritsLoose(GLRenderer, _TileLayerGLRenderer);

      function GLRenderer() {
        return _TileLayerGLRenderer.apply(this, arguments) || this;
      }

      var _proto2 = GLRenderer.prototype;

      _proto2.loadTile = function loadTile() {
        return _loadTile.apply(this, arguments);
      };

      return GLRenderer;
    }(TileLayerGLRenderer);

    CanvasTileLayer.registerRenderer('canvas', CanvasRenderer$1);
    CanvasTileLayer.registerRenderer('gl', GLRenderer);

    /**
     * @classdesc
     * A parent renderer class for OverlayLayer to inherit by OverlayLayer's subclasses.
     * @protected
     * @memberOf renderer
     * @name OverlayLayerCanvasRenderer
     * @extends renderer.CanvasRenderer
     */

    var OverlayLayerRenderer =
    /*#__PURE__*/
    function (_CanvasRenderer) {
      _inheritsLoose(OverlayLayerRenderer, _CanvasRenderer);

      function OverlayLayerRenderer() {
        return _CanvasRenderer.apply(this, arguments) || this;
      }

      var _proto = OverlayLayerRenderer.prototype;

      // possible memory leaks:
      // 1. if geometries' symbols with external resources change frequently,
      // resources of old symbols will still be stored.
      // 2. removed geometries' resources won't be removed.
      _proto.checkResources = function checkResources() {
        var geometries = this._geosToCheck;

        if (!this._resourceChecked && !geometries) {
          geometries = this.layer._geoList;
        }

        if (!isArrayHasData(geometries)) {
          return [];
        }

        var resources = [];
        var cache = {};

        for (var i = geometries.length - 1; i >= 0; i--) {
          var geo = geometries[i];

          var res = geo._getExternalResources();

          if (!res.length) {
            continue;
          }

          if (!this.resources) {
            resources.push.apply(resources, res);
          } else {
            for (var _i = 0; _i < res.length; _i++) {
              var url = res[_i][0];

              if (!this.resources.isResourceLoaded(res[_i]) && !cache[url]) {
                resources.push(res[_i]);
                cache[url] = 1;
              }
            }
          }
        }

        this._resourceChecked = true;
        delete this._geosToCheck;
        return resources;
      };

      _proto.render = function render() {
        this.layer._sortGeometries();

        return _CanvasRenderer.prototype.render.apply(this, arguments);
      };

      _proto._addGeoToCheckRes = function _addGeoToCheckRes(res) {
        if (!res) {
          return;
        }

        if (!Array.isArray(res)) {
          res = [res];
        }

        if (!this._geosToCheck) {
          this._geosToCheck = [];
        }

        pushIn(this._geosToCheck, res);
      };

      _proto.onGeometryAdd = function onGeometryAdd(geometries) {
        this._addGeoToCheckRes(geometries);

        redraw(this);
      };

      _proto.onGeometryRemove = function onGeometryRemove() {
        redraw(this);
      };

      _proto.onGeometrySymbolChange = function onGeometrySymbolChange(e) {
        this._addGeoToCheckRes(e.target);

        redraw(this);
      };

      _proto.onGeometryShapeChange = function onGeometryShapeChange() {
        redraw(this);
      };

      _proto.onGeometryPositionChange = function onGeometryPositionChange() {
        redraw(this);
      };

      _proto.onGeometryZIndexChange = function onGeometryZIndexChange() {
        redraw(this);
      };

      _proto.onGeometryShow = function onGeometryShow() {
        redraw(this);
      };

      _proto.onGeometryHide = function onGeometryHide() {
        redraw(this);
      };

      _proto.onGeometryPropertiesChange = function onGeometryPropertiesChange() {
        redraw(this);
      };

      return OverlayLayerRenderer;
    }(CanvasRenderer);

    function redraw(renderer) {
      if (renderer.layer.options['drawImmediate']) {
        renderer.render();
      }

      renderer.setToRedraw();
    }

    var TEMP_EXTENT$4 = new PointExtent();
    /**
     * @classdesc
     * Renderer class based on HTML5 Canvas2D for VectorLayers
     * @protected
     * @memberOf renderer
     * @name VectorLayerCanvasRenderer
     * @extends renderer.OverlaylayerCanvasRenderer
     * @param {VectorLayer} layer - layer to render
     */

    var VectorLayerRenderer =
    /*#__PURE__*/
    function (_OverlayLayerCanvasRe) {
      _inheritsLoose(VectorLayerRenderer, _OverlayLayerCanvasRe);

      function VectorLayerRenderer() {
        return _OverlayLayerCanvasRe.apply(this, arguments) || this;
      }

      var _proto = VectorLayerRenderer.prototype;

      _proto.checkResources = function checkResources() {
        var _this = this;

        var resources = _OverlayLayerCanvasRe.prototype.checkResources.apply(this, arguments);

        var style = this.layer.getStyle();

        if (style) {
          if (!Array.isArray(style)) {
            style = [style];
          }

          style.forEach(function (s) {
            var res = getExternalResources(s['symbol'], true);

            for (var i = 0, l = res.length; i < l; i++) {
              if (!_this.resources.isResourceLoaded(res[i])) {
                resources.push(res[i]);
              }
            }
          });
        }

        return resources;
      };

      _proto.needToRedraw = function needToRedraw() {
        var map = this.getMap();

        if (map.isInteracting() && this.layer.options['enableAltitude']) {
          return true;
        } // don't redraw when map is zooming without pitch and layer doesn't have any point symbolizer.


        if (map.isZooming() && !map.isRotating() && !map.getPitch() && !this._hasPoint && this.layer.constructor === VectorLayer) {
          return false;
        }

        return _OverlayLayerCanvasRe.prototype.needToRedraw.call(this);
      }
      /**
       * render layer
       * @param  {Geometry[]} geometries   geometries to render
       * @param  {Boolean} ignorePromise   whether escape step of promise
       */
      ;

      _proto.draw = function draw() {
        if (!this.getMap()) {
          return;
        }

        if (!this.layer.isVisible() || this.layer.isEmpty()) {
          this.clearCanvas();
          this.completeRender();
          return;
        }

        this.prepareCanvas();
        this.drawGeos();
        this.completeRender();
      };

      _proto.isBlank = function isBlank() {
        if (!this.context) {
          return false;
        }

        return !this.context.canvas._drawn;
      };

      _proto.drawOnInteracting = function drawOnInteracting() {
        if (!this._geosToDraw) {
          return;
        }

        this._updateDisplayExtent();

        var map = this.getMap(); //refresh geometries on zooming

        var count = this.layer.getCount();
        var res = this.getMap().getResolution();

        if (map.isZooming() && map.options['seamlessZoom'] && this._drawnRes !== undefined && res > this._drawnRes * 1.5 && this._geosToDraw.length < count || map.isMoving() || map.isInteracting()) {
          this.prepareToDraw();
          this.forEachGeo(this.checkGeo, this);
          this._drawnRes = res;
        }

        for (var i = 0, l = this._geosToDraw.length; i < l; i++) {
          var geo = this._geosToDraw[i];

          if (!geo.isVisible()) {
            continue;
          }

          geo._paint(this._displayExtent);
        }
      }
      /**
       * Show and render
       * @override
       */
      ;

      _proto.show = function show() {
        this.layer.forEach(function (geo) {
          geo._repaint();
        });

        _OverlayLayerCanvasRe.prototype.show.apply(this, arguments);
      };

      _proto.forEachGeo = function forEachGeo(fn, context) {
        this.layer.forEach(fn, context);
      };

      _proto.drawGeos = function drawGeos() {
        this._drawnRes = this.getMap().getResolution();

        this._updateDisplayExtent();

        this.prepareToDraw();
        this.forEachGeo(this.checkGeo, this);

        for (var i = 0, len = this._geosToDraw.length; i < len; i++) {
          this._geosToDraw[i]._paint();
        }
      };

      _proto.prepareToDraw = function prepareToDraw() {
        this._hasPoint = false;
        this._geosToDraw = [];
      };

      _proto.checkGeo = function checkGeo(geo) {
        if (!geo || !geo.isVisible() || !geo.getMap() || !geo.getLayer() || !geo.getLayer().isCanvasRender()) {
          return;
        }

        var painter = geo._getPainter();

        var extent2D = painter.get2DExtent(this.resources, TEMP_EXTENT$4);

        if (!extent2D || !extent2D.intersects(this._displayExtent)) {
          return;
        }

        if (painter.hasPoint()) {
          this._hasPoint = true;
        }

        this._geosToDraw.push(geo);
      };

      _proto.onZoomEnd = function onZoomEnd() {
        delete this.canvasExtent2D;

        _OverlayLayerCanvasRe.prototype.onZoomEnd.apply(this, arguments);
      };

      _proto.onRemove = function onRemove() {
        this.forEachGeo(function (g) {
          g.onHide();
        });
        delete this._geosToDraw;
      };

      _proto.onGeometryPropertiesChange = function onGeometryPropertiesChange(param) {
        if (param) {
          this.layer._styleGeometry(param['target']);
        }

        _OverlayLayerCanvasRe.prototype.onGeometryPropertiesChange.call(this, param);
      };

      _proto._updateDisplayExtent = function _updateDisplayExtent() {
        var extent2D = this.canvasExtent2D;

        if (this._maskExtent) {
          if (!this._maskExtent.intersects(extent2D)) {
            this.completeRender();
            return;
          }

          extent2D = extent2D.intersection(this._maskExtent);
        }

        this._displayExtent = extent2D;
      };

      _proto.identify = function identify(coordinate, options) {
        if (options === void 0) {
          options = {};
        }

        var geometries = this._geosToDraw;

        if (!geometries) {
          return [];
        }

        return this.layer._hitGeos(geometries, coordinate, options);
      };

      return VectorLayerRenderer;
    }(OverlayLayerRenderer);

    VectorLayer.registerRenderer('canvas', VectorLayerRenderer);

    /**
     * @classdesc
     * Base class for all the map renderers.
     * @class
     * @abstract
     * @protected
     * @memberOf renderer
     * @extends {Class}
     */

    var MapRenderer =
    /*#__PURE__*/
    function (_Class) {
      _inheritsLoose(MapRenderer, _Class);

      function MapRenderer(map) {
        var _this;

        _this = _Class.call(this) || this;
        _this.map = map;
        _this._handlerQueue = {};
        return _this;
      }

      var _proto = MapRenderer.prototype;

      _proto.callInNextFrame = function callInNextFrame(fn) {
        this._handlerQueue.push(fn);
      };

      _proto.executeFrameCallbacks = function executeFrameCallbacks() {
        var running = this._handlerQueue;
        this._handlerQueue = [];

        for (var i = 0, l = running.length; i < l; i++) {
          running[i]();
        }
      }
      /**
       * Move map platform with offset
       * @param  {Point} offset
       * @return {this}
       */
      ;

      _proto.offsetPlatform = function offsetPlatform(offset, force) {
        if (!this.map._panels.front) {
          return this;
        }

        if (!force && offset.x === 0 && offset.y === 0) {
          return this;
        }

        var panels = this.map._panels;
        var hasFront = this._frontCount = panels.back.layerDOM.childElementCount;
        var hasBack = this._backCount = panels.front.layerDOM.childElementCount;
        var hasUI = this._uiCount = panels.front.uiDOM.childElementCount;

        if (hasFront || hasBack || hasUI) {
          var pos = this.map.offsetPlatform();

          if (offset) {
            pos = pos.add(offset)._round();
          } else {
            pos = pos.round();
          }

          if (hasBack) {
            offsetDom(panels.back, pos);
          }

          if (hasFront || hasUI) {
            offsetDom(panels.front, pos);
          }
        }

        return this;
      };

      _proto.domChanged = function domChanged() {
        var panels = this.map._panels;

        if (!panels.front) {
          return false;
        }

        var frontCount = panels.back.layerDOM.childElementCount;

        if (this._frontCount === undefined || this._frontCount !== frontCount) {
          return true;
        }

        var backCount = panels.front.layerDOM.childElementCount;

        if (this._backCount === undefined || this._backCount !== backCount) {
          return true;
        }

        var uiCount = panels.front.uiDOM.childElementCount;

        if (this._uiCount === undefined || this._uiCount !== uiCount) {
          return true;
        }

        return false;
      };

      _proto.resetContainer = function resetContainer() {
        if (!this.map) {
          return;
        }

        this.map._resetMapViewPoint();

        if (this.map._panels.front) {
          var pos = new Point(0, 0);
          offsetDom(this.map._panels.back, pos);
          offsetDom(this.map._panels.front, pos);
        }
      };

      _proto.onZoomEnd = function onZoomEnd() {
        this.resetContainer();
      };

      _proto.onLoad = function onLoad() {
        this._frameLoop();
      };

      return MapRenderer;
    }(Class);

    /**
     * @classdesc
     * Renderer class based on HTML5 Canvas for maps.
     * @class
     * @protected
     * @extends {renderer.MapRenderer}
     * @memberOf renderer
     */

    var MapCanvasRenderer =
    /*#__PURE__*/
    function (_MapRenderer) {
      _inheritsLoose(MapCanvasRenderer, _MapRenderer);

      /**
       * @param {Map} map - map for the renderer
       */
      function MapCanvasRenderer(map) {
        var _this;

        _this = _MapRenderer.call(this, map) || this; //container is a <canvas> element

        _this._containerIsCanvas = !!map._containerDOM.getContext;

        _this._registerEvents();

        _this._loopTime = 0;
        return _this;
      }

      var _proto = MapCanvasRenderer.prototype;

      _proto.load = function load() {
        this.initContainer();
      }
      /**
       * render layers in current frame
       * @return {Boolean} return false to cease frame loop
       */
      ;

      _proto.renderFrame = function renderFrame(framestamp) {
        if (!this.map) {
          return false;
        }

        delete this._isViewChanged;
        var map = this.map;

        map._fireEvent('framestart');

        this.updateMapDOM();

        var layers = this._getAllLayerToRender();

        this.drawLayers(layers, framestamp);
        var updated = this.drawLayerCanvas(layers);

        if (updated) {
          this._drawCenterCross();
        } // this._drawContainerExtent();
        // CAUTION: the order to fire frameend and layerload events
        // fire frameend before layerload, reason:
        // 1. frameend is often used internally by maptalks and plugins
        // 2. layerload is often used externally by tests or user apps


        map._fireEvent('frameend');

        this._recordView(); // refresh map's state
        // It must be before events and frame callback, because map state may be changed in callbacks.


        this._mapview = this._getMapView();
        delete this._spatialRefChanged;

        this._fireLayerLoadEvents();

        this.executeFrameCallbacks();
        this._canvasUpdated = false;
        return true;
      };

      _proto.updateMapDOM = function updateMapDOM() {
        var map = this.map; // when map is zooming, container is being transformed with matrix, panel doesn't need to be moved.

        if (map.isZooming()) {
          return;
        }

        var offset = map._getViewPointFrameOffset();

        if (offset) {
          map.offsetPlatform(offset);
        } else if (this.domChanged()) {
          this.offsetPlatform(null, true);
        }
      };

      _proto.drawLayers = function drawLayers(layers, framestamp) {
        var map = this.map,
            isInteracting = map.isInteracting(),
            // all the visible canvas layers' ids.
        canvasIds = [],
            // all the updated canvas layers's ids.
        updatedIds = [],
            fps = map.options['fpsOnInteracting'] || 0,
            timeLimit = fps === 0 ? 0 : 1000 / fps,
            // time of layer drawing
        layerLimit = this.map.options['layerCanvasLimitOnInteracting'],
            l = layers.length;
        var baseLayer = map.getBaseLayer();
        var t = 0;

        for (var i = 0; i < l; i++) {
          var layer = layers[i];

          if (!layer.isVisible()) {
            continue;
          }

          var isCanvas = layer.isCanvasRender();

          if (isCanvas) {
            canvasIds.push(layer.getId());
          }

          var renderer = layer._getRenderer();

          if (!renderer) {
            continue;
          } // if need to call layer's draw/drawInteracting


          var needsRedraw = this._checkLayerRedraw(layer);

          if (isCanvas && renderer.isCanvasUpdated()) {
            // don't need to call layer's draw/drawOnInteracting but need to redraw layer's updated canvas
            if (!needsRedraw) {
              updatedIds.push(layer.getId());
            }

            this.setLayerCanvasUpdated();
          }

          var transformMatrix = renderer.__zoomTransformMatrix;
          delete renderer.__zoomTransformMatrix;

          if (!needsRedraw) {
            if (isCanvas && isInteracting) {
              if (map.isZooming() && !map.getPitch()) {
                // transform layer's current canvas when zooming
                renderer.prepareRender();
                renderer.__zoomTransformMatrix = this._zoomMatrix;
              } else if (map.getPitch() || map.isRotating()) {
                // when map is pitching or rotating, clear the layer canvas
                // otherwise, leave layer's canvas unchanged
                renderer.clearCanvas();
              }
            }

            continue;
          }

          if (isInteracting && isCanvas) {
            if (layerLimit > 0 && l - 1 - i > layerLimit && layer !== baseLayer) {
              layer._getRenderer().clearCanvas();

              continue;
            }

            t += this._drawCanvasLayerOnInteracting(layer, t, timeLimit, framestamp);
          } else if (isInteracting && renderer.drawOnInteracting) {
            // dom layers
            if (renderer.prepareRender) {
              renderer.prepareRender();
            }

            renderer.drawOnInteracting(this._eventParam, framestamp);
          } else {
            // map is not interacting, call layer's render
            renderer.render(framestamp); //地图缩放完以后，如果下一次render需要载入资源，仍需要设置transformMatrix
            //防止在资源载入完成之前，缺少transformMatrix导致的绘制错误

            if (isCanvas && transformMatrix && renderer.isLoadingResource()) {
              renderer.__zoomTransformMatrix = transformMatrix;
            }
          }

          if (isCanvas) {
            updatedIds.push(layer.getId());
            this.setLayerCanvasUpdated();
          }
        } // compare:
        // 1. previous drawn layers and current drawn layers
        // 2. previous canvas layers and current canvas layers
        // set map to redraw if either changed


        var preCanvasIds = this._canvasIds || [];
        var preUpdatedIds = this._updatedIds || [];
        this._canvasIds = canvasIds;
        this._updatedIds = updatedIds;

        if (!this.isLayerCanvasUpdated()) {
          var sep = '---';

          if (preCanvasIds.join(sep) !== canvasIds.join(sep) || preUpdatedIds.join(sep) !== updatedIds.join(sep)) {
            this.setLayerCanvasUpdated();
          }
        }
      }
      /**
       * check if need to call layer's draw/drawInteracting
       * @param  {Layer} layer
       * @return {Boolean}
       */
      ;

      _proto._checkLayerRedraw = function _checkLayerRedraw(layer) {
        if (this.isSpatialReferenceChanged()) {
          return true;
        }

        var map = this.map;

        var renderer = layer._getRenderer();

        if (layer.isCanvasRender()) {
          return renderer.testIfNeedRedraw();
        } else {
          if (renderer.needToRedraw && renderer.needToRedraw()) {
            return true;
          } // dom layers, redraw it if map is interacting or state is changed


          return map.isInteracting() || this.isViewChanged();
        }
      }
      /**
       * Draw canvas rendered layer when map is interacting
       * @param  {Layer} layer
       * @param  {Number} t     current consumed time of layer drawing
       * @param  {Number} timeLimit time limit for layer drawing
       * @return {Number}       time to draw this layer
       * @private
       */
      ;

      _proto._drawCanvasLayerOnInteracting = function _drawCanvasLayerOnInteracting(layer, t, timeLimit, framestamp) {
        var map = this.map,
            renderer = layer._getRenderer(),
            drawTime = renderer.getDrawTime(),
            inTime = timeLimit === 0 || timeLimit > 0 && t + drawTime <= timeLimit;

        if (renderer.mustRenderOnInteracting && renderer.mustRenderOnInteracting()) {
          renderer.render(framestamp);
        } else if (renderer.drawOnInteracting && (layer === map.getBaseLayer() || inTime || map.isZooming() && layer.options['forceRenderOnZooming'] || map.isMoving() && layer.options['forceRenderOnMoving'] || map.isRotating() && layer.options['forceRenderOnRotating'])) {
          // call drawOnInteracting to redraw the layer
          renderer.prepareRender();
          renderer.prepareCanvas();
          renderer.drawOnInteracting(this._eventParam, framestamp);
          return drawTime;
        } else if (map.isZooming() && !map.getPitch() && !map.isRotating()) {
          // when:
          // 1. layer's renderer doesn't have drawOnInteracting
          // 2. timeLimit is exceeded
          // then:
          // transform layer's current canvas when zooming
          renderer.prepareRender();
          renderer.__zoomTransformMatrix = this._zoomMatrix;
        } else if (map.getPitch() || map.isRotating()) {
          // when map is pitching or rotating, clear the layer canvas
          // otherwise, leave layer's canvas unchanged
          renderer.clearCanvas();
        }

        if (renderer.drawOnInteracting && !inTime) {
          renderer.onSkipDrawOnInteracting(this._eventParam, framestamp);
        }

        return 0;
      }
      /**
       * Fire layerload events.
       * Make sure layer are drawn on map when firing the events
       * @private
       */
      ;

      _proto._fireLayerLoadEvents = function _fireLayerLoadEvents() {
        if (this._updatedIds && this._updatedIds.length > 0) {
          var map = this.map; //firing order as FIFO, painting as FILO, so the order needs to be reversed

          this._updatedIds.reverse().forEach(function (id) {
            var layer = map.getLayer(id);

            if (!layer) {
              return;
            }

            var renderer = layer._getRenderer();

            if (!renderer || !renderer.isRenderComplete()) {
              return;
            }
            /**
             * layerload event, fired when layer is loaded.
             *
             * @event Layer#layerload
             * @type {Object}
             * @property {String} type - layerload
             * @property {Layer} target - layer
             */


            layer.fire('layerload');
          });
        }
      };

      _proto.isLayerCanvasUpdated = function isLayerCanvasUpdated() {
        return this._canvasUpdated;
      };

      _proto.setLayerCanvasUpdated = function setLayerCanvasUpdated() {
        this._canvasUpdated = true;
      }
      /**
       * Renders the layers
       */
      ;

      _proto.drawLayerCanvas = function drawLayerCanvas(layers) {
        var map = this.map;

        if (!map) {
          return false;
        }

        if (!this.isLayerCanvasUpdated() && !this.isViewChanged()) {
          return false;
        }

        if (!this.canvas) {
          this.createCanvas();
        }
        /**
         * renderstart event, an event fired when map starts to render.
         * @event Map#renderstart
         * @type {Object}
         * @property {String} type           - renderstart
         * @property {Map} target            - the map fires event
         * @property {CanvasRenderingContext2D} context  - canvas context
         */


        map._fireEvent('renderstart', {
          'context': this.context
        });

        if (!this._updateCanvasSize()) {
          this.clearCanvas();
        }

        var interacting = map.isInteracting(),
            limit = map.options['layerCanvasLimitOnInteracting'];
        var len = layers.length;
        var baseLayerImage;
        var images = [];

        for (var i = 0; i < len; i++) {
          if (!layers[i].isVisible() || !layers[i].isCanvasRender()) {
            continue;
          }

          var renderer = layers[i]._getRenderer();

          if (!renderer) {
            continue;
          }

          var layerImage = this._getLayerImage(layers[i]);

          if (layerImage && layerImage['image']) {
            if (layers[i] === map.getBaseLayer()) {
              baseLayerImage = [layers[i], layerImage];
            } else {
              images.push([layers[i], layerImage]);
            }
          }
        }

        if (baseLayerImage) {
          this._drawLayerCanvasImage(baseLayerImage[0], baseLayerImage[1]);

          this._drawFog();
        }

        len = images.length;
        var start = interacting && limit >= 0 && len > limit ? len - limit : 0;

        for (var _i = start; _i < len; _i++) {
          this._drawLayerCanvasImage(images[_i][0], images[_i][1]);
        }
        /**
         * renderend event, an event fired when map ends rendering.
         * @event Map#renderend
         * @type {Object}
         * @property {String} type                      - renderend
         * @property {Map} target              - the map fires event
         * @property {CanvasRenderingContext2D} context - canvas context
         */


        map._fireEvent('renderend', {
          'context': this.context
        });

        return true;
      };

      _proto.setToRedraw = function setToRedraw() {
        var layers = this._getAllLayerToRender();

        for (var i = 0, l = layers.length; i < l; i++) {
          var renderer = layers[i].getRenderer();

          if (renderer && renderer.canvas && renderer.setToRedraw) {
            //to fix lost webgl context
            renderer.setToRedraw();
          }
        }
      };

      _proto.updateMapSize = function updateMapSize(size) {
        if (!size || this._containerIsCanvas) {
          return;
        }

        var width = size['width'] + 'px',
            height = size['height'] + 'px';
        var panels = this.map._panels;
        panels.mapWrapper.style.width = width;
        panels.mapWrapper.style.height = height;

        this._updateCanvasSize();
      };

      _proto.getMainPanel = function getMainPanel() {
        if (!this.map) {
          return null;
        }

        if (this._containerIsCanvas) {
          return this.map._containerDOM;
        }

        if (this.map._panels) {
          return this.map._panels.mapWrapper;
        }

        return null;
      };

      _proto.toDataURL = function toDataURL(mimeType) {
        if (!this.canvas) {
          return null;
        }

        return this.canvas.toDataURL(mimeType);
      };

      _proto.remove = function remove() {
        if (Browser$1.webgl && typeof document !== 'undefined') {
          removeDomEvent(document, 'visibilitychange', this._onVisibilitychange, this);
        }

        if (this._resizeInterval) {
          clearInterval(this._resizeInterval);
        }

        delete this.context;
        delete this.canvas;
        delete this.map;
        delete this._spatialRefChanged;

        this._cancelFrameLoop();
      };

      _proto.hitDetect = function hitDetect(point) {
        var map = this.map;

        if (!map || !map.options['hitDetect'] || map.isInteracting()) {
          return;
        }

        var layers = map._getLayers();

        var cursor = 'default';
        var limit = map.options['hitDetectLimit'] || 0;
        var counter = 0;

        for (var i = layers.length - 1; i >= 0; i--) {
          var layer = layers[i]; // 此处如果未开启，无需执行后面判断

          if (!layer.options['hitDetect'] || layer.isEmpty && layer.isEmpty()) {
            continue;
          }

          var renderer = layer._getRenderer();

          if (!renderer || !renderer.hitDetect) {
            continue;
          }

          if (renderer.isBlank && renderer.isBlank()) {
            continue;
          } // renderer.hitDetect(point)) .  This can't ignore the shadows.

          /**
           * TODO
           *  This requires a better way to judge
           */


          if (layer.options['cursor'] !== 'default' && renderer.hitDetect(point)) {
            cursor = layer.options['cursor'] || 'pointer';
            break;
          }

          counter++;

          if (limit > 0 && counter > limit) {
            break;
          }
        }

        map._trySetCursor(cursor);
      };

      _proto._getLayerImage = function _getLayerImage(layer) {
        var renderer = layer._getRenderer();

        if (renderer.getCanvasImage) {
          return renderer.getCanvasImage();
        }

        return null;
      }
      /**
       * initialize container DOM of panels
       */
      ;

      _proto.initContainer = function initContainer() {
        var panels = this.map._panels;

        function createContainer(name, className, cssText, enableSelect) {
          var c = createEl('div', className);

          if (cssText) {
            c.style.cssText = cssText;
          }

          panels[name] = c;

          if (!enableSelect) {
            preventSelection(c);
          }

          return c;
        }

        var containerDOM = this.map._containerDOM;

        if (this._containerIsCanvas) {
          //container is a <canvas> element.
          return;
        }

        containerDOM.innerHTML = '';
        var POSITION0 = 'position:absolute;top:0px;left:0px;';
        var mapWrapper = createContainer('mapWrapper', 'maptalks-wrapper', 'position:absolute;overflow:hidden;', true),
            mapAllLayers = createContainer('allLayers', 'maptalks-all-layers', POSITION0 + 'padding:0px;margin:0px;z-index:0;overflow:visible;', true),
            backStatic = createContainer('backStatic', 'maptalks-back-static', POSITION0 + 'z-index:0;', true),
            back = createContainer('back', 'maptalks-back', POSITION0 + 'z-index:1;'),
            backLayer = createContainer('backLayer', 'maptalks-back-layer', POSITION0),
            canvasContainer = createContainer('canvasContainer', 'maptalks-canvas-layer', POSITION0 + 'border:none;z-index:2;'),
            frontStatic = createContainer('frontStatic', 'maptalks-front-static', POSITION0 + 'z-index:3;', true),
            front = createContainer('front', 'maptalks-front', POSITION0 + 'z-index:4;', true),
            frontLayer = createContainer('frontLayer', 'maptalks-front-layer', POSITION0 + 'z-index:0;'),
            // children's zIndex in frontLayer will be set by map.addLayer, ui container's z-index is set to 10000 to make sure it's always on the top.
        ui = createContainer('ui', 'maptalks-ui', POSITION0 + 'border:none;z-index:1;', true),
            control = createContainer('control', 'maptalks-control', 'z-index:1', true);
        containerDOM.appendChild(mapWrapper);
        mapAllLayers.appendChild(backStatic);
        back.appendChild(backLayer);
        back.layerDOM = backLayer;
        mapAllLayers.appendChild(back);
        mapAllLayers.appendChild(canvasContainer);
        front.appendChild(frontLayer);
        front.layerDOM = frontLayer;
        front.uiDOM = ui;
        mapAllLayers.appendChild(frontStatic);
        mapAllLayers.appendChild(front);
        front.appendChild(ui);
        mapWrapper.appendChild(mapAllLayers);
        mapWrapper.appendChild(control);
        this.createCanvas();
        this.resetContainer();

        var mapSize = this.map._getContainerDomSize();

        this.updateMapSize(mapSize);
      }
      /**
       * Is current map's state changed?
       * @return {Boolean}
       */
      ;

      _proto.isViewChanged = function isViewChanged() {
        if (this._isViewChanged !== undefined) {
          return this._isViewChanged;
        }

        var previous = this._mapview;

        var view = this._getMapView();

        this._isViewChanged = !previous || !equalMapView(previous, view);
        return this._isViewChanged;
      };

      _proto._recordView = function _recordView() {
        var map = this.map;

        if (!map._onViewChange || map.isInteracting() || map.isAnimating()) {
          return;
        }

        if (!equalMapView(map.getView(), map._getCurrentView())) {
          map._onViewChange(map.getView());
        }
      };

      _proto.isSpatialReferenceChanged = function isSpatialReferenceChanged() {
        return this._spatialRefChanged;
      };

      _proto._getMapView = function _getMapView() {
        var map = this.map;

        var center = map._getPrjCenter();

        return {
          x: center.x,
          y: center.y,
          zoom: map.getZoom(),
          pitch: map.getPitch(),
          bearing: map.getBearing(),
          width: map.width,
          height: map.height
        };
      }
      /**
      * Main frame loop
      */
      ;

      _proto._frameLoop = function _frameLoop(framestamp) {
        var _this2 = this;

        if (!this.map) {
          this._cancelFrameLoop();

          return;
        }

        this.renderFrame(framestamp);
        if (IS_NODE) return; // Keep registering ourselves for the next animation frame

        this._animationFrame = requestAnimFrame(function (framestamp) {
          _this2._frameLoop(framestamp);
        });
      };

      _proto.onLoad = function onLoad() {
        var _this3 = this;

        // NODE环境下, 不走requestAnimationFrame绘图, 当底图加载完成回调时触发frameLoop绘制底图
        if (IS_NODE) {
          this._getAllLayerToRender().forEach(function (layer) {
            layer.on('tileload', function () {
              layer._renderer.tileToLoadCount === 0 && _this3._frameLoop();
            });
          });
        }

        this._frameLoop();
      };

      _proto._needDrawLayers = function _needDrawLayers() {
        var layers = this._getAllLayerToRender();

        var needDrawLayer = false;

        for (var i = 0, len = layers.length; i < len; i++) {
          var renderer = layers[i]._getRenderer();

          if (!renderer._renderComplete) {
            needDrawLayer = true;
            break;
          }
        }

        return needDrawLayer;
      };

      _proto._cancelFrameLoop = function _cancelFrameLoop() {
        if (this._animationFrame) {
          cancelAnimFrame(this._animationFrame);
        }
      };

      _proto._drawLayerCanvasImage = function _drawLayerCanvasImage(layer, layerImage) {
        var ctx = this.context;
        var point = layerImage['point'].round();
        var dpr = this.map.getDevicePixelRatio();

        if (dpr !== 1) {
          point._multi(dpr);
        }

        var canvasImage = layerImage['image'];
        var width = canvasImage.width,
            height = canvasImage.height;

        if (point.x + width <= 0 || point.y + height <= 0) {
          return;
        } //opacity of the layer image


        var op = layer.options['opacity'];

        if (!isNumber(op)) {
          op = 1;
        }

        if (op <= 0) {
          return;
        }

        var imgOp = layerImage['opacity'];

        if (!isNumber(imgOp)) {
          imgOp = 1;
        }

        if (imgOp <= 0) {
          return;
        }

        var alpha = ctx.globalAlpha;

        if (op < 1) {
          ctx.globalAlpha *= op;
        }

        if (imgOp < 1) {
          ctx.globalAlpha *= imgOp;
        }

        if (layer.options['cssFilter']) {
          ctx.filter = layer.options['cssFilter'];
        }

        var renderer = layer.getRenderer();
        var matrix = renderer.__zoomTransformMatrix;
        var clipped = renderer.clipCanvas(this.context);

        if (matrix) {
          ctx.save();
          ctx.setTransform.apply(ctx, matrix);
        }
        /*let outlineColor = layer.options['debugOutline'];
        if (outlineColor) {
            if (outlineColor === true) {
                outlineColor = '#0f0';
            }
            this.context.strokeStyle = outlineColor;
            this.context.fillStyle = outlineColor;
            this.context.lineWidth = 10;
            Canvas2D.rectangle(ctx, point, layerImage.size, 1, 0);
            ctx.fillText([layer.getId(), point.toArray().join(), layerImage.size.toArray().join(), canvasImage.width + ',' + canvasImage.height].join(' '),
                point.x + 18, point.y + 18);
        }*/


        ctx.drawImage(canvasImage, 0, 0, width, height, point.x, point.y, width, height);

        if (matrix) {
          ctx.restore();
        }

        if (clipped) {
          ctx.restore();
        }

        if (ctx.filter !== 'none') {
          ctx.filter = 'none';
        }

        ctx.globalAlpha = alpha;
      };

      _proto._drawCenterCross = function _drawCenterCross() {
        var cross = this.map.options['centerCross'];

        if (cross) {
          var ctx = this.context;
          var p = new Point(this.canvas.width / 2, this.canvas.height / 2);

          if (isFunction(cross)) {
            cross(ctx, p);
          } else {
            Canvas$1.drawCross(this.context, p.x, p.y, 2, '#f00');
          }
        }
      };

      _proto._drawContainerExtent = function _drawContainerExtent() {
        var cascadePitches = this.map.options.cascadePitches;

        var h30 = this.map.height - this.map._getVisualHeight(cascadePitches[0]);

        var h60 = this.map.height - this.map._getVisualHeight(cascadePitches[1]);

        var extent = this.map.getContainerExtent();
        var ctx = this.context;
        ctx.beginPath();
        ctx.moveTo(0, extent.ymin);
        ctx.lineTo(extent.xmax, extent.ymin);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, h30);
        ctx.lineTo(extent.xmax, h30);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, h60);
        ctx.lineTo(extent.xmax, h60);
        ctx.stroke(); // console.log(extent.ymin, h30, h60);
      };

      _proto._drawFog = function _drawFog() {
        var map = this.map;

        if (map.getPitch() <= map.options['maxVisualPitch'] || !map.options['fog']) {
          return;
        }

        var fogThickness = 30;
        var r = map.getDevicePixelRatio();
        var ctx = this.context,
            clipExtent = map.getContainerExtent();
        var top = (map.height - map._getVisualHeight(75)) * r;
        if (top < 0) top = 0;
        var bottom = clipExtent.ymin * r,
            h = Math.ceil(bottom - top),
            color = map.options['fogColor'].join();
        var gradient = ctx.createLinearGradient(0, top, 0, bottom + fogThickness);
        var landscape = 1 - fogThickness / (h + fogThickness);
        gradient.addColorStop(0, "rgba(" + color + ", 0)");
        gradient.addColorStop(0.3, "rgba(" + color + ", 0.3)");
        gradient.addColorStop(landscape, "rgba(" + color + ", 1)");
        gradient.addColorStop(1, "rgba(" + color + ", 0)");
        ctx.beginPath();
        ctx.fillStyle = gradient;
        ctx.fillRect(0, top, Math.ceil(clipExtent.getWidth()) * r, Math.ceil(h + fogThickness));
      };

      _proto._getAllLayerToRender = function _getAllLayerToRender() {
        return this.map._getLayers();
      };

      _proto.clearCanvas = function clearCanvas() {
        if (!this.canvas) {
          return;
        }

        Canvas$1.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
      };

      _proto._updateCanvasSize = function _updateCanvasSize() {
        if (!this.canvas || this._containerIsCanvas) {
          return false;
        }

        var map = this.map,
            mapSize = map.getSize(),
            canvas = this.canvas,
            r = map.getDevicePixelRatio();

        if (mapSize['width'] * r === canvas.width && mapSize['height'] * r === canvas.height) {
          return false;
        } //retina屏支持


        canvas.height = r * mapSize['height'];
        canvas.width = r * mapSize['width'];

        if (canvas.style) {
          canvas.style.width = mapSize['width'] + 'px';
          canvas.style.height = mapSize['height'] + 'px';
        }

        return true;
      };

      _proto.createCanvas = function createCanvas() {
        if (this._containerIsCanvas) {
          this.canvas = this.map._containerDOM;
        } else {
          this.canvas = createEl('canvas');

          this._updateCanvasSize();

          this.map._panels.canvasContainer.appendChild(this.canvas);
        }

        this.context = this.canvas.getContext('2d');
      };

      _proto._checkSize = function _checkSize() {
        if (!this.map || this.map.isInteracting()) {
          return;
        } // refresh map's dom position


        computeDomPosition(this.map._containerDOM);
        this.map.checkSize();
      };

      _proto._setCheckSizeInterval = function _setCheckSizeInterval(interval) {
        var _this4 = this;

        clearInterval(this._resizeInterval);
        this._checkSizeInterval = interval;
        this._resizeInterval = setInterval(function () {
          if (!_this4.map || _this4.map.isRemoved()) {
            //is deleted
            clearInterval(_this4._resizeInterval);
          } else {
            _this4._checkSize();
          }
        }, this._checkSizeInterval);
      };

      _proto._registerEvents = function _registerEvents() {
        var _this5 = this;

        var map = this.map;

        if (map.options['checkSize'] && !IS_NODE && typeof window !== 'undefined') {
          this._setCheckSizeInterval(map.options['checkSizeInterval']);
        }

        if (!Browser$1.mobile) {
          map.on('_mousemove', this._onMapMouseMove, this);
        }

        map.on('_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart', function (param) {
          _this5._eventParam = param;
        });
        map.on('_zooming', function (param) {
          if (!map.getPitch()) {
            _this5._zoomMatrix = param['matrix']['container'];
          }

          _this5._eventParam = param;
        });
        map.on('_zoomend', function (param) {
          _this5._eventParam = param;
          delete _this5._zoomMatrix;
        });
        map.on('_spatialreferencechange', function () {
          _this5._spatialRefChanged = true;
        });

        if (Browser$1.webgl && typeof document !== 'undefined') {
          addDomEvent(document, 'visibilitychange', this._onVisibilitychange, this);
        }
      };

      _proto._onMapMouseMove = function _onMapMouseMove(param) {
        var _this6 = this;

        var map = this.map;

        if (map.isInteracting() || !map.options['hitDetect']) {
          return;
        }

        if (this._hitDetectFrame) {
          cancelAnimFrame(this._hitDetectFrame);
        }

        this._hitDetectFrame = requestAnimFrame(function () {
          _this6.hitDetect(param['containerPoint']);
        });
      };

      _proto._getCanvasLayers = function _getCanvasLayers() {
        return this.map._getLayers(function (layer) {
          return layer.isCanvasRender();
        });
      };

      _proto._onVisibilitychange = function _onVisibilitychange() {
        if (document.visibilityState !== 'visible') {
          return;
        }

        this.setToRedraw();
      };

      return MapCanvasRenderer;
    }(MapRenderer);

    Map$1.registerRenderer('canvas', MapCanvasRenderer);
    Map$1.mergeOptions({
      'fog': false,
      'fogColor': [233, 233, 233]
    });

    /** @namespace renderer */

    var index$6 = /*#__PURE__*/Object.freeze({
        ResourceCache: ResourceCache,
        CanvasRenderer: CanvasRenderer,
        ImageGLRenderable: ImageGLRenderable,
        MapRenderer: MapRenderer,
        MapCanvasRenderer: MapCanvasRenderer,
        Renderable: Renderable,
        ImageLayerCanvasRenderer: ImageLayerCanvasRenderer,
        ImageLayerGLRenderer: ImageLayerGLRenderer,
        TileLayerCanvasRenderer: TileLayerCanvasRenderer,
        TileLayerGLRenderer: TileLayerGLRenderer,
        CanvasTileLayerCanvasRenderer: CanvasRenderer$1,
        CanvasTileLayerGLRenderer: GLRenderer,
        OverlayLayerCanvasRenderer: OverlayLayerRenderer,
        VectorLayerCanvasRenderer: VectorLayerRenderer,
        CanvasLayerRenderer: CanvasLayerRenderer
    });

    var CenterPointRenderer = {
      _getRenderPoints: function _getRenderPoints() {
        return [[this._getCenter2DPoint(this.getMap().getGLZoom())], null];
      }
    };
    /**
     * 获取symbolizer所需的数据
     */

    Marker.include(CenterPointRenderer);
    Ellipse.include(CenterPointRenderer);
    Circle.include(CenterPointRenderer); //----------------------------------------------------

    Sector.include(CenterPointRenderer); //----------------------------------------------------

    Rectangle.include({
      _getRenderPoints: function _getRenderPoints(placement) {
        var map = this.getMap();

        if (placement === 'vertex') {
          var shell = this._trimRing(this.getShell());

          var points = [];

          for (var i = 0, len = shell.length; i < len; i++) {
            points.push(map.coordToPoint(shell[i], map.getGLZoom()));
          }

          return [points, null];
        } else {
          var c = map.coordToPoint(this.getCenter(), map.getGLZoom());
          return [[c], null];
        }
      }
    }); //----------------------------------------------------

    var PolyRenderer = {
      _getRenderPoints: function _getRenderPoints(placement) {
        var map = this.getMap();
        var glZoom = map.getGLZoom();
        var points,
            rotations = null;

        if (placement === 'point') {
          points = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom);

          if (points && points.length > 0 && Array.isArray(points[0])) {
            //anti-meridian
            points = points[0].concat(points[1]);
          }
        } else if (placement === 'vertex') {
          points = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom);
          rotations = [];

          if (points && points.length > 0 && Array.isArray(points[0])) {
            for (var i = 0, l = points.length; i < l; i++) {
              for (var ii = 0, ll = points[i].length; ii < ll; ii++) {
                if (ii === 0) {
                  rotations.push([points[i][ii], points[i][ii + 1]]);
                } else {
                  rotations.push([points[i][ii - 1], points[i][ii]]);
                }
              }
            }

            points = points[0].concat(points[1]);
          } else {
            for (var _i = 0, _l = points.length; _i < _l; _i++) {
              if (_i === 0) {
                rotations.push([points[_i], points[_i + 1]]);
              } else {
                rotations.push([points[_i - 1], points[_i]]);
              }
            }
          }
        } else if (placement === 'line') {
          points = [];
          rotations = [];

          var vertice = this._getPath2DPoints(this._getPrjCoordinates(), false, glZoom),
              isSplitted = vertice.length > 0 && Array.isArray(vertice[0]);

          if (isSplitted) {
            //anti-meridian splitted
            var ring;

            for (var _i2 = 1, _l2 = vertice.length; _i2 < _l2; _i2++) {
              ring = vertice[_i2];

              if (this instanceof Polygon && ring.length > 0 && !ring[0].equals(ring[ring.length - 1])) {
                ring.push(ring[0]);
              }

              for (var _ii = 1, _ll = ring.length; _ii < _ll; _ii++) {
                points.push(ring[_ii].add(ring[_ii - 1])._multi(0.5));
                rotations.push([ring[_ii - 1], ring[_ii]]);
              }
            }
          } else {
            if (this instanceof Polygon && vertice.length > 0 && !vertice[0].equals(vertice[vertice.length - 1])) {
              vertice.push(vertice[0]);
            }

            for (var _i3 = 1, _l3 = vertice.length; _i3 < _l3; _i3++) {
              points.push(vertice[_i3].add(vertice[_i3 - 1])._multi(0.5));
              rotations.push([vertice[_i3 - 1], vertice[_i3]]);
            }
          }
        } else if (placement === 'vertex-first') {
          var coords = this._getPrjCoordinates();

          points = coords.length ? [map._prjToPoint(coords[0], glZoom)] : [];
          rotations = coords.length ? [[map._prjToPoint(coords[0], glZoom), map._prjToPoint(coords[1], glZoom)]] : [];
        } else if (placement === 'vertex-last') {
          var _coords = this._getPrjCoordinates();

          var _l4 = _coords.length;
          points = _l4 ? [map._prjToPoint(_coords[_l4 - 1], glZoom)] : [];
          var current = _l4 - 1,
              previous = _l4 > 1 ? _l4 - 2 : _l4 - 1;
          rotations = _l4 ? [[map._prjToPoint(_coords[previous], glZoom), map._prjToPoint(_coords[current], glZoom)]] : [];
        } else {
          var pcenter = this._getProjection().project(this.getCenter());

          points = [map._prjToPoint(pcenter, glZoom)];
        }

        return [points, rotations];
      }
    };
    LineString.include(PolyRenderer);
    Polygon.include(PolyRenderer);

    Geometry.include({
      _redrawWhenPitch: function _redrawWhenPitch() {
        return false;
      },
      _redrawWhenRotate: function _redrawWhenRotate() {
        return false;
      }
    });
    var el = {
      _redrawWhenPitch: function _redrawWhenPitch() {
        return true;
      },
      _redrawWhenRotate: function _redrawWhenRotate() {
        return this instanceof Ellipse || this instanceof Sector;
      },
      _paintAsPath: function _paintAsPath() {
        var map = this.getMap();

        var altitude = this._getPainter().getAltitude(); // when map is tilting, draw the circle/ellipse as a polygon by vertexes.


        return altitude > 0 || map.getPitch() || this instanceof Ellipse && map.getBearing();
      },
      _getPaintParams: function _getPaintParams() {
        var map = this.getMap();

        if (this._paintAsPath()) {
          return Polygon.prototype._getPaintParams.call(this, true);
        }

        var pcenter = this._getPrjCoordinates();

        var pt = map._prjToPoint(pcenter, map.getGLZoom());

        var size = this._getRenderSize();

        return [pt, size['width'], size['height']];
      },
      _paintOn: function _paintOn() {
        if (this._paintAsPath()) {
          return Canvas$1.polygon.apply(Canvas$1, arguments);
        } else {
          return Canvas$1.ellipse.apply(Canvas$1, arguments);
        }
      },
      _getRenderSize: function _getRenderSize() {
        var map = this.getMap(),
            z = map.getGLZoom();

        var prjExtent = this._getPrjExtent();

        var pmin = map._prjToPoint(prjExtent.getMin(), z),
            pmax = map._prjToPoint(prjExtent.getMax(), z);

        return new Size(Math.abs(pmax.x - pmin.x) / 2, Math.abs(pmax.y - pmin.y) / 2);
      }
    };
    Ellipse.include(el);
    Circle.include(el); //----------------------------------------------------

    Rectangle.include({
      _getPaintParams: function _getPaintParams() {
        var map = this.getMap();
        var pointZoom = map.getGLZoom();

        var shell = this._getPrjShell();

        var points = this._getPath2DPoints(shell, false, pointZoom);

        return [points];
      },
      _paintOn: Canvas$1.polygon
    }); //----------------------------------------------------

    Sector.include(el, {
      _redrawWhenPitch: function _redrawWhenPitch() {
        return true;
      },
      _getPaintParams: function _getPaintParams() {
        if (this._paintAsPath()) {
          return Polygon.prototype._getPaintParams.call(this, true);
        }

        var map = this.getMap();

        var pt = map._prjToPoint(this._getPrjCoordinates(), map.getGLZoom());

        var size = this._getRenderSize();

        return [pt, size['width'], [this.getStartAngle(), this.getEndAngle()]];
      },
      _paintOn: function _paintOn() {
        if (this._paintAsPath()) {
          return Canvas$1.polygon.apply(Canvas$1, arguments);
        } else {
          var r = this.getMap().getBearing();
          var args = arguments;

          if (r) {
            args[3] = args[3].slice(0);
            args[3][0] += r;
            args[3][1] += r;
          }

          return Canvas$1.sector.apply(Canvas$1, args);
        }
      }
    }); //----------------------------------------------------

    Path.include({
      _paintAsPath: function _paintAsPath() {
        return true;
      }
    });
    LineString.include({
      arrowStyles: {
        'classic': [3, 4]
      },
      _getArrowShape: function _getArrowShape(prePoint, point, lineWidth, arrowStyle, tolerance) {
        if (!prePoint || !point || prePoint.equals(point)) {
          return null;
        }

        if (!tolerance) {
          tolerance = 0;
        }

        var width = lineWidth * arrowStyle[0],
            height = lineWidth * arrowStyle[1] + tolerance,
            hw = width / 2 + tolerance;
        var normal;

        if (point.nextCtrlPoint || point.prevCtrlPoint) {
          // use control points to caculate normal if it's a bezier curve
          if (point.prevCtrlPoint) {
            normal = point.sub(new Point(point.prevCtrlPoint));
          } else {
            normal = point.sub(new Point(point.nextCtrlPoint));
          }
        } else {
          normal = point.sub(prePoint);
        }

        normal._unit();

        var p1 = point.sub(normal.multi(height));

        normal._perp();

        var p0 = p1.add(normal.multi(hw));

        normal._multi(-1);

        var p2 = p1.add(normal.multi(hw));
        return [p0, point, p2, p0];
      },
      _getPaintParams: function _getPaintParams() {
        var prjVertexes = this._getPrjCoordinates();

        var points = this._getPath2DPoints(prjVertexes, false, this.getMap().getGLZoom());

        return [points];
      },
      _paintOn: function _paintOn(ctx, points, lineOpacity, fillOpacity, dasharray) {
        if (this.options['smoothness']) {
          Canvas$1.paintSmoothLine(ctx, points, lineOpacity, this.options['smoothness'], false, this._animIdx, this._animTailRatio);
        } else {
          Canvas$1.path(ctx, points, lineOpacity, null, dasharray);
        }

        this._paintArrow(ctx, points, lineOpacity);
      },
      _getArrowPlacement: function _getArrowPlacement() {
        return this.options['arrowPlacement'];
      },
      _getArrowStyle: function _getArrowStyle() {
        var arrowStyle = this.options['arrowStyle'];

        if (arrowStyle) {
          return Array.isArray(arrowStyle) ? arrowStyle : this.arrowStyles[arrowStyle];
        }

        return null;
      },
      _getArrows: function _getArrows(points, lineWidth, tolerance) {
        var arrowStyle = this._getArrowStyle();

        if (!arrowStyle || points.length < 2) {
          return [];
        }

        var isSplitted = points.length > 0 && Array.isArray(points[0]);
        var segments = isSplitted ? points : [points];

        var placement = this._getArrowPlacement();

        var arrows = [];
        var map = this.getMap(),
            first = map.coordToContainerPoint(this.getFirstCoordinate()),
            last = map.coordToContainerPoint(this.getLastCoordinate());

        for (var i = segments.length - 1; i >= 0; i--) {
          if (placement === 'vertex-first' || placement === 'vertex-firstlast' && segments[i][0].closeTo(first, 0.01)) {
            var arrow = this._getArrowShape(segments[i][1], segments[i][0], lineWidth, arrowStyle, tolerance);

            if (arrow) {
              arrows.push(arrow);
            }
          }

          if (placement === 'vertex-last' || placement === 'vertex-firstlast' && segments[i][segments[i].length - 1].closeTo(last, 0.01)) {
            var _arrow = this._getArrowShape(segments[i][segments[i].length - 2], segments[i][segments[i].length - 1], lineWidth, arrowStyle, tolerance);

            if (_arrow) {
              arrows.push(_arrow);
            }
          } else if (placement === 'point') {
            this._getArrowPoints(arrows, segments[i], lineWidth, arrowStyle, tolerance);
          }
        }

        return arrows;
      },
      _getArrowPoints: function _getArrowPoints(arrows, segments, lineWidth, arrowStyle, tolerance) {
        for (var ii = 0, ll = segments.length - 1; ii < ll; ii++) {
          var arrow = this._getArrowShape(segments[ii], segments[ii + 1], lineWidth, arrowStyle, tolerance);

          if (arrow) {
            arrows.push(arrow);
          }
        }
      },
      _paintArrow: function _paintArrow(ctx, points, lineOpacity) {
        var lineWidth = this._getInternalSymbol()['lineWidth'];

        if (!isNumber(lineWidth) || lineWidth < 3) {
          lineWidth = 3;
        }

        var arrows = this._getArrows(points, lineWidth);

        if (!arrows.length) {
          return;
        }

        if (ctx.setLineDash) {
          //remove line dash effect if any
          ctx.setLineDash([]);
        }

        for (var i = arrows.length - 1; i >= 0; i--) {
          ctx.fillStyle = ctx.strokeStyle;
          Canvas$1.polygon(ctx, arrows[i], lineOpacity, lineOpacity);
        }
      }
    });
    Polygon.include({
      _getPaintParams: function _getPaintParams(disableSimplify) {
        var maxZoom = this.getMap().getGLZoom();

        var prjVertexes = this._getPrjShell();

        var points = this._getPath2DPoints(prjVertexes, disableSimplify, maxZoom); //splitted by anti-meridian


        var isSplitted = points.length > 0 && Array.isArray(points[0]);

        if (isSplitted) {
          points = [[points[0]], [points[1]]];
        }

        var prjHoles = this._getPrjHoles();

        var holePoints = [];

        if (prjHoles && prjHoles.length > 0) {
          //outer ring  simplify result;
          var simplified = this._simplified;

          for (var i = 0; i < prjHoles.length; i++) {
            var hole = this._getPath2DPoints(prjHoles[i], disableSimplify, maxZoom);

            if (Array.isArray(hole) && isSplitted) {
              if (Array.isArray(hole[0])) {
                points[0].push(hole[0]);
                points[1].push(hole[1]);
              } else {
                points[0].push(hole);
              }
            } else {
              holePoints.push(hole);
            }
          } // if outer ring  simplify==true , Ignore inner ring  simplify result


          if (simplified) {
            this._simplified = simplified;
          }
        }

        if (!isSplitted) {
          points = [points];
          pushIn(points, holePoints);
        }

        return [points];
      },
      _paintOn: function _paintOn(ctx, points, lineOpacity, fillOpacity, dasharray) {
        Canvas$1.polygon(ctx, points, lineOpacity, fillOpacity, dasharray, this.options['smoothness']);
      }
    });

    Map$1.VERSION = '0.46.0';

    var maptalks = /*#__PURE__*/Object.freeze({
        Util: index$1,
        DomUtil: dom,
        StringUtil: strings,
        MapboxUtil: index,
        Map: Map$1,
        ui: index$4,
        control: index$5,
        renderer: index$6,
        symbolizer: index$3,
        animation: Animation$1,
        Browser: Browser$1,
        Ajax: Ajax,
        Canvas: Canvas$1,
        Promise: Promise$1,
        Class: Class,
        Eventable: Eventable,
        JSONAble: JSONAble,
        Handlerable: Handlerable,
        Handler: Handler$1,
        DragHandler: DragHandler,
        MapTool: MapTool,
        DrawTool: DrawTool,
        AreaTool: AreaTool,
        DistanceTool: DistanceTool,
        SpatialReference: SpatialReference,
        INTERNAL_LAYER_PREFIX: INTERNAL_LAYER_PREFIX,
        GEOMETRY_COLLECTION_TYPES: GEOMETRY_COLLECTION_TYPES,
        GEOJSON_TYPES: GEOJSON_TYPES,
        RESOURCE_PROPERTIES: RESOURCE_PROPERTIES,
        RESOURCE_SIZE_PROPERTIES: RESOURCE_SIZE_PROPERTIES,
        NUMERICAL_PROPERTIES: NUMERICAL_PROPERTIES,
        COLOR_PROPERTIES: COLOR_PROPERTIES,
        DEFAULT_TEXT_SIZE: DEFAULT_TEXT_SIZE,
        projection: projections,
        measurer: index$2,
        Coordinate: Coordinate,
        CRS: CRS,
        Extent: Extent,
        Point: Point,
        PointExtent: PointExtent,
        Size: Size,
        Transformation: Transformation,
        Layer: Layer,
        TileLayer: TileLayer,
        GroupTileLayer: GroupTileLayer,
        WMSTileLayer: WMSTileLayer,
        CanvasTileLayer: CanvasTileLayer,
        ImageLayer: ImageLayer,
        OverlayLayer: OverlayLayer,
        VectorLayer: VectorLayer,
        CanvasLayer: CanvasLayer,
        ParticleLayer: ParticleLayer,
        TileSystem: TileSystem,
        TileConfig: TileConfig,
        ArcCurve: ArcCurve,
        Circle: Circle,
        ConnectorLine: ConnectorLine,
        ArcConnectorLine: ArcConnectorLine,
        CubicBezierCurve: CubicBezierCurve,
        Curve: Curve,
        Ellipse: Ellipse,
        GeoJSON: GeoJSON,
        Geometry: Geometry,
        GeometryCollection: GeometryCollection,
        Label: Label,
        LineString: LineString,
        Marker: Marker,
        MultiLineString: MultiLineString,
        MultiPoint: MultiPoint,
        MultiPolygon: MultiPolygon,
        Polygon: Polygon,
        QuadBezierCurve: QuadBezierCurve,
        Rectangle: Rectangle,
        Sector: Sector,
        TextBox: TextBox,
        TextMarker: TextMarker
    });

    var global$1 = typeof window === 'object' ? window : global$1;
    var Van = global$1.Van || {};
    assign(Van, {
      maptalks: maptalks
    });
    global$1.Van = Van;

    return Van;

}));
