/* version: 1.3.1; hash: 50816ed; buildTime: 5/7/2019, 5:29:17 PM */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = global || self, global.Van = factory());
}(this, function () { 'use strict';

    var forOwn = function forOwn(obj, cb) {
      for (var n in obj) {
        if (obj.hasOwnProperty(n)) {
          if (cb(obj[n], n) === false) {
            return;
          }
        }
      }
    };

    /**
     * Created by Jeffrey on 2018/1/17.
     */

    var assign = Object.assign || function (target) {
      for (var j = 1, len = arguments.length; j < len; j++) {
        forOwn(arguments[j], function (value, key) {
          target[key] = value;
        });
      }

      return target;
    };

    //     Underscore.js 1.9.1
    //     http://underscorejs.org
    //     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    // Baseline setup
    // --------------
    var root = typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global || {}; // Save bytes in the minified (but not gzipped) version:

    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null; // Create quick reference letiables for speed access to core prototypes.

    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.

    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeCreate = Object.create; // Naked function reference for surrogate-prototype-swapping.

    var Ctor = function Ctor() {}; // Create a safe reference to the Underscore object for use below.


    var _ = function _(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    }; // Current version.


    _.VERSION = '1.9.1'; // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.

    var optimizeCb = function optimizeCb(func, context, argCount) {
      if (context === void 0) return func;

      switch (argCount == null ? 3 : argCount) {
        case 1:
          return function (value) {
            return func.call(context, value);
          };
        // The 2-argument case is omitted because we’re not using it.

        case 3:
          return function (value, index, collection) {
            return func.call(context, value, index, collection);
          };

        case 4:
          return function (accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
      }

      return function () {
        return func.apply(context, arguments);
      };
    };

    var builtinIteratee; // An internal function to generate callbacks that can be applied to each
    // element in a collection, returning the desired result — either `identity`,
    // an arbitrary callback, a property matcher, or a property accessor.

    var cb = function cb(value, context, argCount) {
      if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
      if (value == null) return _.identity;
      if (_.isFunction(value)) return optimizeCb(value, context, argCount);
      if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
      return _.property(value);
    }; // External wrapper for our callback generator. Users may customize
    // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    // This abstraction hides the internal-only argCount argument.


    _.iteratee = builtinIteratee = function builtinIteratee(value, context) {
      return cb(value, context, Infinity);
    }; // Some functions take a letiable number of arguments, or a few expected
    // arguments at the beginning and then a letiable number of values to operate
    // on. This helper accumulates all remaining arguments past the function’s
    // argument length (or an explicit `startIndex`), into an array that becomes
    // the last argument. Similar to ES6’s "rest parameter".


    var restArguments = function restArguments(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function () {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;

        for (; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }

        switch (startIndex) {
          case 0:
            return func.call(this, rest);

          case 1:
            return func.call(this, arguments[0], rest);

          case 2:
            return func.call(this, arguments[0], arguments[1], rest);
        }

        var args = Array(startIndex + 1);

        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }

        args[startIndex] = rest;
        return func.apply(this, args);
      };
    }; // An internal function for creating a new object that inherits from another.


    var baseCreate = function baseCreate(prototype) {
      if (!_.isObject(prototype)) return {};
      if (nativeCreate) return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor();
      Ctor.prototype = null;
      return result;
    };

    var shallowProperty = function shallowProperty(key) {
      return function (obj) {
        return obj == null ? void 0 : obj[key];
      };
    };

    var has = function has(obj, path) {
      return obj != null && hasOwnProperty.call(obj, path);
    };

    var deepGet = function deepGet(obj, path) {
      var length = path.length;

      for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
      }

      return length ? obj : void 0;
    }; // Helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object.
    // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094


    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = shallowProperty('length');

    var isArrayLike = function isArrayLike(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    }; // Collection Functions
    // --------------------
    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.


    _.each = _.forEach = function (obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;

      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);

        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }

      return obj;
    }; // Return the results of applying the iteratee to each element.


    _.map = _.collect = function (obj, iteratee, context) {
      iteratee = cb(iteratee, context);

      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);

      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }

      return results;
    }; // Create a reducing function iterating left or right.


    var createReduce = function createReduce(dir) {
      // Wrap code that reassigns argument letiables in a separate function than
      // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
      var reducer = function reducer(obj, iteratee, memo, initial) {
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;

        if (!initial) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }

        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }

        return memo;
      };

      return function (obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
      };
    }; // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.


    _.reduce = _.foldl = _.inject = createReduce(1); // The right-associative version of reduce, also known as `foldr`.

    _.reduceRight = _.foldr = createReduce(-1); // Return the first value which passes a truth test. Aliased as `detect`.

    _.find = _.detect = function (obj, predicate, context) {
      var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
      var key = keyFinder(obj, predicate, context);
      if (key !== void 0 && key !== -1) return obj[key];
    }; // Return all the elements that pass a truth test.
    // Aliased as `select`.


    _.filter = _.select = function (obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);

      _.each(obj, function (value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });

      return results;
    }; // Return all the elements for which a truth test fails.


    _.reject = function (obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    }; // Determine whether all of the elements match a truth test.
    // Aliased as `all`.


    _.every = _.all = function (obj, predicate, context) {
      predicate = cb(predicate, context);

      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;

      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }

      return true;
    }; // Determine if at least one element in the object matches a truth test.
    // Aliased as `any`.


    _.some = _.any = function (obj, predicate, context) {
      predicate = cb(predicate, context);

      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;

      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }

      return false;
    }; // Determine if the array or object contains a given item (using `===`).
    // Aliased as `includes` and `include`.


    _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    }; // Invoke a method (with arguments) on every item in a collection.


    _.invoke = restArguments(function (obj, path, args) {
      var contextPath, func;

      if (_.isFunction(path)) {
        func = path;
      } else if (_.isArray(path)) {
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }

      return _.map(obj, function (context) {
        var method = func;

        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }

          if (context == null) return void 0;
          method = context[path];
        }

        return method == null ? method : method.apply(context, args);
      });
    }); // Convenience version of a common use case of `map`: fetching a property.

    _.pluck = function (obj, key) {
      return _.map(obj, _.property(key));
    }; // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.


    _.where = function (obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    }; // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.


    _.findWhere = function (obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    }; // Return the maximum element (or element-based computation).


    _.max = function (obj, iteratee, context) {
      var result = -Infinity,
          lastComputed = -Infinity,
          value,
          computed;

      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);

        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];

          if (value != null && value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);

        _.each(obj, function (v, index, list) {
          computed = iteratee(v, index, list);

          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }

      return result;
    }; // Return the minimum element (or element-based computation).


    _.min = function (obj, iteratee, context) {
      var result = Infinity,
          lastComputed = Infinity,
          value,
          computed;

      if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);

        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];

          if (value != null && value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);

        _.each(obj, function (v, index, list) {
          computed = iteratee(v, index, list);

          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = v;
            lastComputed = computed;
          }
        });
      }

      return result;
    }; // Shuffle a collection.


    _.shuffle = function (obj) {
      return _.sample(obj, Infinity);
    }; // Sample **n** random values from a collection using the modern version of the
    // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `map`.


    _.sample = function (obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj)) obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }

      var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
      var length = getLength(sample);
      n = Math.max(Math.min(n, length), 0);
      var last = length - 1;

      for (var index = 0; index < n; index++) {
        var rand = _.random(index, last);

        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
      }

      return sample.slice(0, n);
    }; // Sort the object's values by a criterion produced by an iteratee.


    _.sortBy = function (obj, iteratee, context) {
      var index = 0;
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function (value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function (left, right) {
        var a = left.criteria;
        var b = right.criteria;

        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }

        return left.index - right.index;
      }), 'value');
    }; // An internal function used for aggregate "group by" operations.


    var group = function group(behavior, partition) {
      return function (obj, iteratee, context) {
        var result = partition ? [[], []] : {};
        iteratee = cb(iteratee, context);

        _.each(obj, function (value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });

        return result;
      };
    }; // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.


    _.groupBy = group(function (result, value, key) {
      if (has(result, key)) result[key].push(value);else result[key] = [value];
    }); // Indexes the object's values by a criterion, similar to `groupBy`, but for
    // when you know that your index values will be unique.

    _.indexBy = group(function (result, value, key) {
      result[key] = value;
    }); // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.

    _.countBy = group(function (result, value, key) {
      if (has(result, key)) result[key]++;else result[key] = 1;
    });
    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g; // Safely create a real, live array from anything iterable.

    _.toArray = function (obj) {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);

      if (_.isString(obj)) {
        // Keep surrogate pair characters together
        return obj.match(reStrSymbol);
      }

      if (isArrayLike(obj)) return _.map(obj, _.identity);
      return _.values(obj);
    }; // Return the number of elements in an object.


    _.size = function (obj) {
      if (obj == null) return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    }; // Split a collection into two arrays: one whose elements all satisfy the given
    // predicate, and one whose elements all do not satisfy the predicate.


    _.partition = group(function (result, value, pass) {
      result[pass ? 0 : 1].push(value);
    }, true); // Array Functions
    // ---------------
    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.

    _.first = _.head = _.take = function (array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[0];
      return _.initial(array, array.length - n);
    }; // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.


    _.initial = function (array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    }; // Get the last element of an array. Passing **n** will return the last N
    // values in the array.


    _.last = function (array, n, guard) {
      if (array == null || array.length < 1) return n == null ? void 0 : [];
      if (n == null || guard) return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array.


    _.rest = _.tail = _.drop = function (array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    }; // Trim out all falsy values from an array.


    _.compact = function (array) {
      return _.filter(array, Boolean);
    }; // Internal implementation of a recursive `flatten` function.


    var flatten = function flatten(input, shallow, strict, output) {
      output = output || [];
      var idx = output.length;

      for (var i = 0, length = getLength(input); i < length; i++) {
        var value = input[i];

        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          // Flatten current level of array or arguments object.
          if (shallow) {
            var j = 0,
                len = value.length;

            while (j < len) {
              output[idx++] = value[j++];
            }
          } else {
            flatten(value, shallow, strict, output);
            idx = output.length;
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }

      return output;
    }; // Flatten out an array, either recursively (by default), or just one level.


    _.flatten = function (array, shallow) {
      return flatten(array, shallow, false);
    }; // Return a version of the array that does not contain the specified value(s).


    _.without = restArguments(function (array, otherArrays) {
      return _.difference(array, otherArrays);
    }); // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // The faster algorithm will not work with an iteratee if the iteratee
    // is not a one-to-one function, so providing an iteratee will disable
    // the faster algorithm.
    // Aliased as `unique`.

    _.uniq = _.unique = function (array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }

      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];

      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;

        if (isSorted && !iteratee) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }

      return result;
    }; // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.


    _.union = restArguments(function (arrays) {
      return _.uniq(flatten(arrays, true, true));
    }); // Produce an array that contains every item shared between all the
    // passed-in arrays.

    _.intersection = function (array) {
      var result = [];
      var argsLength = arguments.length;

      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item)) continue;
        var j = void 0;

        for (j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item)) break;
        }

        if (j === argsLength) result.push(item);
      }

      return result;
    }; // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.


    _.difference = restArguments(function (array, rest) {
      rest = flatten(rest, true, true);
      return _.filter(array, function (value) {
        return !_.contains(rest, value);
      });
    }); // Complement of _.zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices.

    _.unzip = function (array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }

      return result;
    }; // Zip together multiple lists into a single array -- elements that share
    // an index go together.


    _.zip = restArguments(_.unzip); // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values. Passing by pairs is the reverse of _.pairs.

    _.object = function (list, values) {
      var result = {};

      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }

      return result;
    }; // Generator function to create the findIndex and findLastIndex functions.


    var createPredicateIndexFinder = function createPredicateIndexFinder(dir) {
      return function (array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;

        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }

        return -1;
      };
    }; // Returns the first index on an array-like that passes a predicate test.


    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1); // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.

    _.sortedIndex = function (array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0,
          high = getLength(array);

      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
      }

      return low;
    }; // Generator function to create the indexOf and lastIndexOf functions.


    var createIndexFinder = function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function (array, item, idx) {
        var i = 0,
            length = getLength(array);

        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }

        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }

        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }

        return -1;
      };
    }; // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.


    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex); // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).

    _.range = function (start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }

      if (!step) {
        step = stop < start ? -1 : 1;
      }

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    }; // Chunk a single array into multiple arrays, each containing `count` or fewer
    // items.


    _.chunk = function (array, count) {
      if (count == null || count < 1) return [];
      var result = [];
      var i = 0,
          length = array.length;

      while (i < length) {
        result.push(slice.call(array, i, i += count));
      }

      return result;
    }; // Function (ahem) Functions
    // ------------------
    // Determines whether to execute a function as a constructor
    // or a normal function with the provided arguments.


    var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result)) return result;
      return self;
    }; // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.


    _.bind = restArguments(function (func, context, args) {
      if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
      var bound = restArguments(function (callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    }); // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. _ acts
    // as a placeholder by default, allowing any combination of arguments to be
    // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.

    _.partial = restArguments(function (func, boundArgs) {
      var placeholder = _.partial.placeholder;

      var bound = function bound() {
        var position = 0,
            length = boundArgs.length;
        var args = Array(length);

        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }

        while (position < arguments.length) {
          args.push(arguments[position++]);
        }

        return executeBound(func, bound, this, this, args);
      };

      return bound;
    });
    _.partial.placeholder = _; // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.

    _.bindAll = restArguments(function (obj, keys) {
      keys = flatten(keys, false, false);
      var index = keys.length;
      if (index < 1) throw new Error('bindAll must be passed function names');

      while (index--) {
        var key = keys[index];
        obj[key] = _.bind(obj[key], obj);
      }
    }); // Memoize an expensive function by storing its results.

    _.memoize = function (func, hasher) {
      var memoize = function memoize(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!has(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };

      memoize.cache = {};
      return memoize;
    }; // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.


    _.delay = restArguments(function (func, wait, args) {
      return setTimeout(function () {
        return func.apply(null, args);
      }, wait);
    }); // Defers a function, scheduling it to run after the current call stack has
    // cleared.

    _.defer = _.partial(_.delay, _, 1); // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.

    _.throttle = function (func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options) options = {};

      var later = function later() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function throttled() {
        var now = _.now();

        if (!previous && options.leading === false) previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;

        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }

        return result;
      };

      throttled.cancel = function () {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    }; // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.


    _.debounce = function (func, wait, immediate) {
      var timeout, result;

      var later = function later(context, args) {
        timeout = null;
        if (args) result = func.apply(context, args);
      };

      var debounced = restArguments(function (args) {
        if (timeout) clearTimeout(timeout);

        if (immediate) {
          var callNow = !timeout;
          timeout = setTimeout(later, wait);
          if (callNow) result = func.apply(this, args);
        } else {
          timeout = _.delay(later, wait, this, args);
        }

        return result;
      });

      debounced.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
      };

      return debounced;
    }; // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.


    _.wrap = function (func, wrapper) {
      return _.partial(wrapper, func);
    }; // Returns a negated version of the passed-in predicate.


    _.negate = function (predicate) {
      return function () {
        return !predicate.apply(this, arguments);
      };
    }; // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.


    _.compose = function () {
      var args = arguments;
      var start = args.length - 1;
      return function () {
        var i = start;
        var result = args[start].apply(this, arguments);

        while (i--) {
          result = args[i].call(this, result);
        }

        return result;
      };
    }; // Returns a function that will only be executed on and after the Nth call.


    _.after = function (times, func) {
      return function () {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    }; // Returns a function that will only be executed up to (but not including) the Nth call.


    _.before = function (times, func) {
      var memo;
      return function () {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }

        if (times <= 1) func = null;
        return memo;
      };
    }; // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.


    _.once = _.partial(_.before, 2);
    _.restArguments = restArguments; // Object Functions
    // ----------------
    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.

    var hasEnumBug = !{
      toString: null
    }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    var collectNonEnumProps = function collectNonEnumProps(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = _.isFunction(constructor) && constructor.prototype || ObjProto; // Constructor is a special case.

      var prop = 'constructor';
      if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];

        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    }; // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.


    _.keys = function (obj) {
      if (!_.isObject(obj)) return [];
      if (nativeKeys) return nativeKeys(obj);
      var keys = [];

      for (var key in obj) {
        if (has(obj, key)) keys.push(key);
      } // Ahem, IE < 9.


      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }; // Retrieve all the property names of an object.


    _.allKeys = function (obj) {
      if (!_.isObject(obj)) return [];
      var keys = [];

      for (var key in obj) {
        keys.push(key);
      } // Ahem, IE < 9.


      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }; // Retrieve the values of an object's properties.


    _.values = function (obj) {
      var keys = _.keys(obj);

      var length = keys.length;
      var values = Array(length);

      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }

      return values;
    }; // Returns the results of applying the iteratee to each element of the object.
    // In contrast to _.map it returns an object.


    _.mapObject = function (obj, iteratee, context) {
      iteratee = cb(iteratee, context);

      var keys = _.keys(obj),
          length = keys.length,
          results = {};

      for (var index = 0; index < length; index++) {
        var currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }

      return results;
    }; // Convert an object into a list of `[key, value]` pairs.
    // The opposite of _.object.


    _.pairs = function (obj) {
      var keys = _.keys(obj);

      var length = keys.length;
      var pairs = Array(length);

      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }

      return pairs;
    }; // Invert the keys and values of an object. The values must be serializable.


    _.invert = function (obj) {
      var result = {};

      var keys = _.keys(obj);

      for (var i = 0, length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }

      return result;
    }; // Return a sorted list of the function names available on the object.
    // Aliased as `methods`.


    _.functions = _.methods = function (obj) {
      var names = [];

      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }

      return names.sort();
    }; // An internal function for creating assigner functions.


    var createAssigner = function createAssigner(keysFunc, defaults) {
      return function (obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;

        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;

          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }

        return obj;
      };
    }; // Extend a given object with all the properties in passed-in object(s).


    _.extend = createAssigner(_.allKeys); // Assigns a given object with all the own properties in the passed-in object(s).
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

    _.extendOwn = _.assign = createAssigner(_.keys); // Returns the first key on an object that passes a predicate test.

    _.findKey = function (obj, predicate, context) {
      predicate = cb(predicate, context);

      var keys = _.keys(obj),
          key;

      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    }; // Internal pick helper function to determine if `obj` has key `key`.


    var keyInObj = function keyInObj(value, key, obj) {
      return key in obj;
    }; // Return a copy of the object only containing the whitelisted properties.


    _.pick = restArguments(function (obj, keys) {
      var result = {},
          iteratee = keys[0];
      if (obj == null) return result;

      if (_.isFunction(iteratee)) {
        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
        keys = _.allKeys(obj);
      } else {
        iteratee = keyInObj;
        keys = flatten(keys, false, false);
        obj = Object(obj);
      }

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }

      return result;
    }); // Return a copy of the object without the blacklisted properties.

    _.omit = restArguments(function (obj, keys) {
      var iteratee = keys[0],
          context;

      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
        if (keys.length > 1) context = keys[1];
      } else {
        keys = _.map(flatten(keys, false, false), String);

        iteratee = function iteratee(value, key) {
          return !_.contains(keys, key);
        };
      }

      return _.pick(obj, iteratee, context);
    }); // Fill in a given object with default properties.

    _.defaults = createAssigner(_.allKeys, true); // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.

    _.create = function (prototype, props) {
      var result = baseCreate(prototype);
      if (props) _.extendOwn(result, props);
      return result;
    }; // Create a (shallow-cloned) duplicate of an object.


    _.clone = function (obj) {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    }; // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.


    _.tap = function (obj, interceptor) {
      interceptor(obj);
      return obj;
    }; // Returns whether an object has a given set of `key:value` pairs.


    _.isMatch = function (object, attrs) {
      var keys = _.keys(attrs),
          length = keys.length;

      if (object == null) return !length;
      var obj = Object(object);

      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }

      return true;
    }; // Internal recursive comparison function for `isEqual`.


    var eq, deepEq;

    eq = function eq(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b; // `null` or `undefined` only equal to itself (strict comparison).

      if (a == null || b == null) return false; // `NaN`s are equivalent, but non-reflexive.

      if (a !== a) return b !== b; // Exhaust primitive checks

      var type = typeof a;
      if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
      return deepEq(a, b, aStack, bStack);
    }; // Internal recursive comparison function for `isEqual`.


    deepEq = function deepEq(a, b, aStack, bStack) {
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names.

      var className = toString.call(a);
      if (className !== toString.call(b)) return false;

      switch (className) {
        // Strings, numbers, regular expressions, dates, and booleans are compared by value.
        case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;

        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN.
          if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

          return +a === 0 ? 1 / +a === 1 / b : +a === +b;

        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;

        case '[object Symbol]':
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      }

      var areArrays = className === '[object Array]';

      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.

        var aCtor = a.constructor,
            bCtor = b.constructor;

        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
          return false;
        }
      } // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.


      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;

      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      } // Add the first object to the stack of traversed objects.


      aStack.push(a);
      bStack.push(b); // Recursively compare objects and arrays.

      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var keys = _.keys(a),
            key;

        length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

        if (_.keys(b).length !== length) return false;

        while (length--) {
          // Deep compare each member
          key = keys[length];
          if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
        }
      } // Remove the first object from the stack of traversed objects.


      aStack.pop();
      bStack.pop();
      return true;
    }; // Perform a deep comparison to check if two objects are equal.


    _.isEqual = function (a, b) {
      return eq(a, b);
    }; // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.


    _.isEmpty = function (obj) {
      if (obj == null) return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
      return _.keys(obj).length === 0;
    }; // Is a given value a DOM element?


    _.isElement = function (obj) {
      return !!(obj && obj.nodeType === 1);
    }; // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray


    _.isArray = nativeIsArray || function (obj) {
      return toString.call(obj) === '[object Array]';
    }; // Is a given letiable an object?


    _.isObject = function (obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.


    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function (name) {
      _['is' + name] = function (obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    }); // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.


    if (!_.isArguments(arguments)) {
      _.isArguments = function (obj) {
        return has(obj, 'callee');
      };
    } // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
    // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).


    var nodelist = window.document && window.document.childNodes;

    if (typeof Int8Array != 'object' && typeof nodelist != 'function') {
      _.isFunction = function (obj) {
        return typeof obj == 'function' || false;
      };
    } // Is a given object a finite number?


    _.isFinite = function (obj) {
      return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
    }; // Is the given value `NaN`?


    _.isNaN = function (obj) {
      return _.isNumber(obj) && isNaN(obj);
    }; // Is a given value a boolean?


    _.isBoolean = function (obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    }; // Is a given value equal to null?


    _.isNull = function (obj) {
      return obj === null;
    }; // Is a given letiable undefined?


    _.isUndefined = function (obj) {
      return obj === void 0;
    }; // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).


    _.has = function (obj, path) {
      if (!_.isArray(path)) {
        return has(obj, path);
      }

      var length = path.length;

      for (var i = 0; i < length; i++) {
        var key = path[i];

        if (obj == null || !hasOwnProperty.call(obj, key)) {
          return false;
        }

        obj = obj[key];
      }

      return !!length;
    }; // Utility Functions
    // -----------------
    // Run Underscore.js in *noConflict* mode, returning the `_` letiable to its
    // previous owner. Returns a reference to the Underscore object.


    _.noConflict = function () {
      root._ = previousUnderscore;
      return this;
    }; // Keep the identity function around for default iteratees.


    _.identity = function (value) {
      return value;
    }; // Predicate-generating functions. Often useful outside of Underscore.


    _.constant = function (value) {
      return function () {
        return value;
      };
    };

    _.noop = function () {}; // Creates a function that, when passed an object, will traverse that object’s
    // properties down the given `path`, specified as an array of keys or indexes.


    _.property = function (path) {
      if (!_.isArray(path)) {
        return shallowProperty(path);
      }

      return function (obj) {
        return deepGet(obj, path);
      };
    }; // Generates a function for a given object that returns a given property.


    _.propertyOf = function (obj) {
      if (obj == null) {
        return function () {};
      }

      return function (path) {
        return !_.isArray(path) ? obj[path] : deepGet(obj, path);
      };
    }; // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.


    _.matcher = _.matches = function (attrs) {
      attrs = _.extendOwn({}, attrs);
      return function (obj) {
        return _.isMatch(obj, attrs);
      };
    }; // Run a function **n** times.


    _.times = function (n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);

      for (var i = 0; i < n; i++) {
        accum[i] = iteratee(i);
      }

      return accum;
    }; // Return a random integer between min and max (inclusive).


    _.random = function (min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }

      return min + Math.floor(Math.random() * (max - min + 1));
    }; // A (possibly faster) way to get the current timestamp as an integer.


    _.now = Date.now || function () {
      return new Date().getTime();
    }; // List of HTML entities for escaping.


    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };

    var unescapeMap = _.invert(escapeMap); // Functions for escaping and unescaping strings to/from HTML interpolation.


    var createEscaper = function createEscaper(map) {
      var escaper = function escaper(match) {
        return map[match];
      }; // Regexes for identifying a key that needs to be escaped.


      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function (string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };

    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap); // Traverses the children of `obj` along `path`. If a child is a function, it
    // is invoked with its parent as context. Returns the value of the final
    // child, or `fallback` if any child is undefined.

    _.result = function (obj, path, fallback) {
      if (!_.isArray(path)) path = [path];
      var length = path.length;

      if (!length) {
        return _.isFunction(fallback) ? fallback.call(obj) : fallback;
      }

      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];

        if (prop === void 0) {
          prop = fallback;
          i = length; // Ensure we don't continue iterating.
        }

        obj = _.isFunction(prop) ? prop.call(obj) : prop;
      }

      return obj;
    }; // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.


    var idCounter = 0;

    _.uniqueId = function (prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    }; // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.


    _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    }; // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.

    var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a
    // string literal.

    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      "\u2028": 'u2028',
      "\u2029": 'u2029'
    };
    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    var escapeChar = function escapeChar(match) {
      return '\\' + escapes[match];
    }; // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.


    _.template = function (text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation.

      var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately.

      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        } // Adobe VMs need the match returned to produce the correct offset.


        return match;
      });
      source += "';\n"; // If a letiable is not specified, place data values in local scope.

      if (!settings.letiable) source = 'with(obj||{}){\n' + source + '}\n';
      source = "let __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
      var render;

      try {
        render = new Function(settings.letiable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function template(data) {
        return render.call(this, data, _);
      }; // Provide the compiled source as a convenience for precompilation.


      var argument = settings.letiable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';
      return template;
    }; // Add a "chain" function. Start chaining a wrapped Underscore object.


    _.chain = function (obj) {
      var instance = _(obj);

      instance._chain = true;
      return instance;
    }; // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.
    // Helper function to continue chaining intermediate results.


    var chainResult = function chainResult(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    }; // Add your own custom functions to the Underscore object.


    _.mixin = function (obj) {
      _.each(_.functions(obj), function (name) {
        var func = _[name] = obj[name];

        _.prototype[name] = function () {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_, args));
        };
      });

      return _;
    }; // Add all of the Underscore functions to the wrapper object.


    _.mixin(_); // Add all mutator Array functions to the wrapper.


    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
      var method = ArrayProto[name];

      _.prototype[name] = function () {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
        return chainResult(this, obj);
      };
    }); // Add all accessor Array functions to the wrapper.


    _.each(['concat', 'join', 'slice'], function (name) {
      var method = ArrayProto[name];

      _.prototype[name] = function () {
        return chainResult(this, method.apply(this._wrapped, arguments));
      };
    }); // Extracts the result from a wrapped and chained object.


    _.prototype.value = function () {
      return this._wrapped;
    }; // Provide unwrapping proxy for some methods used in engine operations
    // such as arithmetic and JSON stringification.


    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

    _.prototype.toString = function () {
      return String(this._wrapped);
    };

    /**
     * Created by Jeffrey on 2018/12/4.
     */

    /**
     * reducer 会用value作为action type对比
     * 利用这个可以转一下现在的和以前的
     * 先跑起来再改掉
     *
     * act.module.foo -> Act.bar
     */
    var ActionTypes = {
      init: 'init',
      // fill in data from server
      resize: 'resize',
      scrollByPx: 'scrollByPx',
      eventPos: 'eventPos',
      scrollStart: 'scrollStart',
      scrollEnd: 'scrollEnd',
      syncScroll: 'syncScroll',
      zoomStart: 'zoomStart',
      zoom: 'zoom',
      zoomEnd: 'zoomEnd',
      touchEnd: 'touchEnd',
      tagFilter: 'tagFilter',
      sliderFilter: 'sliderFilter',
      highlight: 'highlight',
      highlightMatchedTarget: 'highlightMatchedTarget',
      unhover: 'unhover',
      mapChangeView: 'mapChangeView',
      plotPanStart: 'plotPanStart',
      plotPanMove: 'plotPanMove',
      plotPanEnd: 'plotPanEnd',
      facetResize: 'facetResize',
      selecting: 'selecting',
      holdSelect: 'holdSelect',
      edgeMoving: 'edgeMoving',
      pieRotate: 'pieRotate',
      selectedRows: 'selectedRows',
      panningCell: 'panningCell'
    };
    var Act = {};

    _.each(ActionTypes, function (v, k) {
      Act[k] = function (payload) {
        return {
          type: k,
          payload: payload
        };
      };
    });

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /** Virtual DOM Node */
    function VNode() {}

    /** Global options
     *	@public
     *	@namespace options {Object}
     */
    var options = {
      /** If `true`, `prop` changes trigger synchronous component updates.
       *	@name syncComponentUpdates
       *	@type Boolean
       *	@default true
       */
      //syncComponentUpdates: true,

      /** Processes all created VNodes.
       *	@param {VNode} vnode	A newly-created VNode to normalize/process
       */
      //vnode(vnode) { }

      /** Hook invoked after a component is mounted. */
      // afterMount(component) { }

      /** Hook invoked after the DOM is updated with a component's latest render. */
      // afterUpdate(component) { }

      /** Hook invoked immediately before a component is unmounted. */
      // beforeUnmount(component) { }
    };

    var stack = [];
    var EMPTY_CHILDREN = [];
    /**
     * JSX/hyperscript reviver.
     * @see http://jasonformat.com/wtf-is-jsx
     * Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
     *
     * Note: this is exported as both `h()` and `createElement()` for compatibility reasons.
     *
     * Creates a VNode (virtual DOM element). A tree of VNodes can be used as a lightweight representation
     * of the structure of a DOM tree. This structure can be realized by recursively comparing it against
     * the current _actual_ DOM structure, and applying only the differences.
     *
     * `h()`/`createElement()` accepts an element name, a list of attributes/props,
     * and optionally children to append to the element.
     *
     * @example The following DOM tree
     *
     * `<div id="foo" name="bar">Hello!</div>`
     *
     * can be constructed using this function as:
     *
     * `h('div', { id: 'foo', name : 'bar' }, 'Hello!');`
     *
     * @param {string} nodeName	An element name. Ex: `div`, `a`, `span`, etc.
     * @param {Object} attributes	Any attributes/props to set on the created element.
     * @param rest			Additional arguments are taken to be children to append. Can be infinitely nested Arrays.
     *
     * @public
     */

    function h(nodeName, attributes) {
      var children = EMPTY_CHILDREN,
          lastSimple,
          child,
          simple,
          i;

      for (i = arguments.length; i-- > 2;) {
        stack.push(arguments[i]);
      }

      if (attributes && attributes.children != null) {
        if (!stack.length) stack.push(attributes.children);
        delete attributes.children;
      }

      while (stack.length) {
        if ((child = stack.pop()) && child.pop !== undefined) {
          for (i = child.length; i--;) {
            stack.push(child[i]);
          }
        } else {
          if (typeof child === 'boolean') child = null;

          if (simple = typeof nodeName !== 'function') {
            if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
          }

          if (simple && lastSimple) {
            children[children.length - 1] += child;
          } else if (children === EMPTY_CHILDREN) {
            children = [child];
          } else {
            children.push(child);
          }

          lastSimple = simple;
        }
      }

      var p = new VNode();
      p.nodeName = nodeName;
      p.children = children;
      p.attributes = attributes == null ? undefined : attributes;
      p.key = attributes == null ? undefined : attributes.key;

      return p;
    }

    /**
     *  Copy all properties from `props` onto `obj`.
     *  @param {Object} obj		Object onto which properties should be copied.
     *  @param {Object} props	Object from which to copy properties.
     *  @returns obj
     *  @private
     */
    function extend(obj, props) {
      for (var i in props) {
        obj[i] = props[i];
      }

      return obj;
    }
    /**
     * Call a function asynchronously, as soon as possible. Makes
     * use of HTML Promise to schedule the callback if available,
     * otherwise falling back to `setTimeout` (mainly for IE<11).
     *
     * @param {Function} callback
     */

    var Promise$1 = typeof window !== 'undefined' && window.Promise;
    var defer = typeof Promise$1 == 'function' ? Promise$1.resolve().then.bind(Promise$1.resolve()) : setTimeout;

    // render modes
    var NO_RENDER = 0;
    var SYNC_RENDER = 1;
    var FORCE_RENDER = 2;
    var ASYNC_RENDER = 3;
    var ATTR_KEY = '__vanattr_';
    var RENDERED = 1; // DOM properties that should NOT have "px" added when numeric
    var TransformNamesMap = {
      position: 1,
      scale: 1,
      origin: 1
    };
    var AnimationNamesMap = {
      position: 1,
      scale: 1,
      rotation: 1,
      origin: 1,
      shape: 1,
      style: 1
    };
    var TransformNames = Object.keys(TransformNamesMap);

    /** Managed queue of dirty components to be re-rendered */

    var items = [];
    function enqueueRender(component) {
      if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
        (defer)(rerender);
      }
    }
    function rerender() {
      var p,
          list = items;
      items = [];

      while (p = list.pop()) {
        if (p._dirty) renderComponent(p);
      }
    }

    /**
     * Created by eason on 2017/8/15.
     */
    // 1.1e-7 -> 8
    var decimalPlacesRegExp = /(?:\d+)(?:\.(\d+))?(?:[eE]-(\d+))?/; // ["0.111e-7", "111", "7"]

    var decimalRegExp = /\.|[eE]-\d+/g; // (1.1e-7 + '').match(/\.|e-\d+/ig) -> [".", "e-7"]

    var PI = Math.PI;

    function isZero(num) {
      return Math.abs(num) < 1e-6;
    }

    function getDecimalPlaces(num) {
      var m = (num + '').match(decimalPlacesRegExp);
      return m ? (m[1] ? m[1].length : 0) + (+m[2] || 0) : 0;
    }

    function getSingleDigitStep(step) {
      return Math.ceil(step);
    }

    function getDoubleDigitStep(step) {
      var remainder = accMod(step, 5);
      return isZero(remainder) ? step : +accAdd(step + 5, -remainder).toFixed();
    }

    function getMoreThanDoubleDigitStep(step) {
      var power = Math.floor(Math.log(step) / Math.LN10);
      var standard = Math.pow(10, power);

      if (isZero(step - Math.pow(10, power))) {
        return step;
      }

      var proportion = accDiv(accMod(step, standard), standard);
      var stepPower = accAdd(step, -accMod(step, standard));
      var remainder = accMul(Math.ceil(proportion * 10) / 10, standard);
      return +accAdd(stepPower, remainder).toFixed();
    }

    function getRemainderPower(step) {
      if (1 <= step && step < 10) {
        return 1;
      } else if (10 <= step && step < 100) {
        return 5;
      } else if (100 <= step) {
        var power = Math.floor(Math.log(step) / Math.LN10) - 1;
        return Math.pow(10, power);
      } else if (0 < step && step < 1) {
        var s = step.toPrecision(3) + '';
        var m = getDecimalPlaces(s);
        var up = isZero(step - s) ? 0 : 1;
        return getRemainderPower(+s.replace(decimalRegExp, '') + up) / Math.pow(10, m);
      }
    }

    function getReadableStep(step) {
      if (1 <= step && step < 10) {
        return getSingleDigitStep(step);
      } else if (10 <= step && step < 100) {
        return getDoubleDigitStep(step);
      } else if (100 <= step) {
        return getMoreThanDoubleDigitStep(step);
      } else if (0 < step && step < 1) {
        var s = step.toPrecision(3) + '';
        var m = getDecimalPlaces(s);
        var up = isZero(step - s) ? 0 : 1;
        return getReadableStep(+s.replace(decimalRegExp, '') + up) / Math.pow(10, m);
      }
    }
    /**
     * 获取具有可读性的标签
     * @param start
     * @param end
     * @param count，count === tickInterval + 1
     * @returns []
     * 可读性文档：https://kms.finedevelop.com/pages/viewpage.action?pageId=45802680
     */


    var getReadableTicks = function getReadableTicks(start, end, count) {
      if (count <= 1 || isZero(end - start)) {
        return [];
      }

      var isReverse = end < start;

      if (isReverse) {
        var _ref = [end, start];
        start = _ref[0];
        end = _ref[1];
      }

      var interval = count - 1;
      var step = getReadableStep(accDiv(accAdd(end, -start), interval));
      var remainderPower = getRemainderPower(step);
      var remainder = accMod(start, remainderPower);
      var offset = start >= 0 ? 0 : remainderPower;
      var readableStart = isZero(remainder) ? start : accAdd(accAdd(start, -remainder), -offset);
      var readableStep = getReadableStep(accDiv(accAdd(end, -readableStart), interval));
      var readableTicks = [];
      var i = 0;

      while (readableTicks.length < count) {
        var tick = accAdd(readableStart, accMul(readableStep, i));
        readableTicks.push(tick);
        i++;
      }

      return isReverse ? readableTicks.reverse() : readableTicks;
    };
    var toRadian = function toRadian(num) {
      return num / 180 * PI;
    };
    var linearTickInterval = function linearTickInterval(minValue, maxValue, m) {
      m = m || 5;
      var span = maxValue - minValue;
      var step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10));
      var err = m / span * step;

      if (err <= 0.15) {
        step *= 10;
      } else if (err <= 0.35) {
        step *= 5;
      } else if (err <= 0.75) {
        step *= 2;
      }

      return step;
    };
    var LABEL_DOMAIN_MAX_RATIO = 1.05;
    /**
     * 计算最优domain时考虑标签不溢出，手动调大domain.max
     * @param min
     * @param max
     * @param tickInterval
     * @returns {*}
     */

    var linearNiceDomainWithLabel = function linearNiceDomainWithLabel(min, max, tickInterval) {
      // 考虑两个方向的扩展
      min *= min < 0 ? LABEL_DOMAIN_MAX_RATIO : 1;
      max *= max > 0 ? LABEL_DOMAIN_MAX_RATIO : 1;
      return linearNiceDomain(min, max, tickInterval);
    };
    var linearNiceDomain = function linearNiceDomain(minValue, maxValue, tickInterval) {
      minValue = accMul(Math.floor(minValue / tickInterval), tickInterval);
      maxValue = accMul(Math.ceil(maxValue / tickInterval), tickInterval);
      return [minValue, maxValue];
    };
    var sum = function sum(array) {
      var sum = 0;

      for (var i = array.length - 1; i >= 0; i--) {
        sum += array[i];
      }

      return sum;
    };
    var minMax = function minMax(array) {
      var min = Number.MAX_VALUE,
          max = -Number.MAX_VALUE;

      for (var i = 0, len = array.length; i < len; i++) {
        min = Math.min(min, array[i]);
        max = Math.max(max, array[i]);
      }

      return [min, max];
    };
    var accAdd = function accAdd(arg1, arg2) {
      if (arg1 % 1 === 0 && arg2 % 1 === 0) {
        return arg1 + arg2;
      }

      var r1 = getDecimalPlaces(arg1);
      var r2 = getDecimalPlaces(arg2);
      var m = Math.pow(10, Math.max(r1, r2));
      return (arg1 * m + arg2 * m) / m;
    };
    var accDiv = function accDiv(arg1, arg2) {
      if (arg1 % 1 === 0 && arg2 % 1 === 0) {
        return arg1 / arg2;
      }

      var s1 = arg1 + '',
          s2 = arg2 + '';
      var m = -getDecimalPlaces(arg1);
      m += getDecimalPlaces(arg2);
      var a = s1.replace(decimalRegExp, '');
      var b = s2.replace(decimalRegExp, '');
      return m > 0 ? a / b * Math.pow(10, m) : a / b / Math.pow(10, -m);
    };
    var accMul = function accMul(arg1, arg2) {
      if (arg1 % 1 === 0 && arg2 % 1 === 0) {
        return arg1 * arg2;
      }

      var s1 = arg1 + '',
          s2 = arg2 + '';
      var m = getDecimalPlaces(arg1);
      m += getDecimalPlaces(arg2);
      return s1.replace(decimalRegExp, '') * s2.replace(decimalRegExp, '') / Math.pow(10, m);
    };
    var accMod = function accMod(arg1, arg2) {
      if (arg1 % 1 === 0 && arg2 % 1 === 0) {
        return arg1 % arg2;
      }

      var s1 = arg1 + '',
          s2 = arg2 + '';
      var m1 = getDecimalPlaces(arg1);
      var m2 = getDecimalPlaces(arg2);
      return s1.replace(decimalRegExp, '') * Math.pow(10, m2) % (s2.replace(decimalRegExp, '') * Math.pow(10, m1)) / Math.pow(10, m1 + m2);
    };
    var toNum = function toNum(num) {
      return isNaN(num) ? 0 : +num;
    };
    /**
     * revised from _.baseClamp
     *
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */

    var clamp = function clamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }

        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }

      return toNum(number);
    };
    /**
     * get percent between two values, no bound check!
     * @param number
     * @param min
     * @param max
     */

    var percent = function percent(number, min, max) {
      return (number - min) / (max - min);
    };
    /**
     * Check if value within [start, end] (including start & end)
     * @param value
     * @param start
     * @param end
     * @returns {boolean}
     */

    var between = function between(value, start, end) {
      return value != null && start <= value && value <= end;
    };
    /**
     * calculate point position under polar axis
     * @param r
     * @param angle
     * @param center
     * @returns {*[]}
     */

    var calcPolarPos = function calcPolarPos(r, angle, center) {
      if (center === void 0) {
        center = [0, 0];
      }

      var _center = center,
          cx = _center[0],
          cy = _center[1];
      return [cx + r * Math.cos(angle), cy + r * Math.sin(angle)];
    };
    var normalRadian = function normalRadian(angle) {
      angle = angle % (Math.PI * 2);
      return angle + (angle < 0 ? Math.PI * 2 : 0);
    };
    /**
     * 计算弧度所在的象限：
     * 0~0.5π: 4,
     * 0.5π~π: 3,
     * π~1.5π: 2,
     * 1.5π~2π: 1
     */

    var calcAngleQuadrant = function calcAngleQuadrant(angle) {
      var pi = Math.PI,
          hfPi = pi / 2,
          opfPi = 1.5 * pi;

      if (angle >= 0 && angle < hfPi) {
        return 4;
      } else if (angle >= hfPi && angle < pi) {
        return 3;
      } else if (angle >= pi && angle < opfPi) {
        return 2;
      } else {
        return 1;
      }
    };
    /**
     * whether value belongs to range. default range is [start, end]
     * @param range
     * @param value
     * @param isCloseToLeft   if false, the range will be (start, end]
     * @param isCloseToRight
     */

    var inRange = function inRange(range, value, isCloseToLeft, isCloseToRight) {
      if (isCloseToLeft === void 0) {
        isCloseToLeft = true;
      }

      if (isCloseToRight === void 0) {
        isCloseToRight = true;
      }

      var isLargeThanMinimum = value > range[0];
      var isLessThanMaximum = value < range[1];

      if (isCloseToLeft) {
        isLargeThanMinimum = isLargeThanMinimum || isZero(value - range[0]);
      }

      if (isCloseToRight) {
        isLessThanMaximum = isLessThanMaximum || isZero(value - range[1]);
      }

      return isLargeThanMinimum && isLessThanMaximum;
    };

    var global$1 = typeof window === 'object' ? window : global$1;
    var DO_NOTHING = function DO_NOTHING() {};
    var TRUE_FUNCTION = function TRUE_FUNCTION() {
      return true;
    };
    var FALSE_FUNCTION = function FALSE_FUNCTION() {
      return false;
    };
    var isArray = 'isArray' in Array ? Array.isArray : function (t) {
      return '[object Array]' === Object.prototype.toString.call(t);
    }; // TODO, remove ES5 Array.prototype method

    var forEach = function forEach(arr, cb) {
      for (var i = 0, len = arr.length; i < len; i++) {
        if (cb(arr[i], i) === false) {
          return;
        }
      }
    };
    var map = function map(arr, f) {
      var newArr = [];

      for (var i = 0, len = arr.length; i < len; i++) {
        newArr.push(f(arr[i], i, arr));
      }

      return newArr;
    };
    var filter = function filter(arr, cb) {
      var newArr = [];

      for (var i = 0, len = arr.length; i < len; i++) {
        if (cb(arr[i])) newArr.push(arr[i]);
      }

      return newArr;
    };
    var reduce = _.reduce;
    var find = function find(arr, cb) {
      for (var i = 0, len = arr.length; i < len; i++) {
        if (cb(arr[i], i, arr)) {
          return arr[i];
        }
      }
    }; // https://gist.github.com/developit/6e518a2ea4f2da03b0a8e4a2f81bc362

    var shallowEqual = function shallowEqual(a, b) {
      for (var key in a) {
        if (a[key] !== b[key]) return false;
      }

      for (var _key in b) {
        if (!(_key in a)) return false;
      }

      return true;
    };
    var wontBind = {
      constructor: true,
      render: true,
      componentWillMount: true,
      componentDidMount: true,
      componentWillReceiveProps: true,
      shouldComponentUpdate: true,
      componentWillUpdate: true,
      componentDidUpdate: true,
      componentWillUnmount: true,
      forceUpdate: true,
      componentDidCatch: true
    }; // todo, test in IE8

    var autoBind = Object.getOwnPropertyNames ? function (self) {
      var proto = self.constructor.prototype;
      map(Object.getOwnPropertyNames(proto), function (k) {
        var v = self[k];

        if (typeof v === 'function' && !wontBind[k]) {
          self[k] = v.bind(self);
        }
      });
    } : function (self) {
      var proto = self.constructor.prototype;
      forOwn(proto, function (v, k) {
        if (typeof v === 'function' && !wontBind[k]) {
          self[k] = v.bind(self);
        }
      });
    };

    var freezeAll = DO_NOTHING;
    function getDomSize(dom) {
      var stl = dom.currentStyle || document.defaultView.getComputedStyle(dom);
      var width = dom.clientWidth || parseInt(stl.width, 10) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10) || 0;
      var height = dom.clientHeight || parseInt(stl.height, 10) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10) || 0;
      return {
        width: width,
        height: height
      };
    }
    function getFormattedText(text, cfg) {
      text += '';

      if (cfg == null || text === '') {
        return text;
      }

      if (text.indexOf('~') >= 0) {
        var _text$split = text.split('~'),
            left = _text$split[0],
            right = _text$split[1];

        return getFormattedText(left, cfg) + "~" + getFormattedText(right, cfg);
      }

      var formatType = cfg.formatType,
          dateFormatType = cfg.dateFormatType,
          group = cfg.group,
          unit = cfg.unit;

      if (formatType === 'date') {
        text = typeof BI !== 'undefined' && BI.Format && BI.Format.formatValueByGroupAndFormatter ? BI.Format.formatValueByGroupAndFormatter(text, group, dateFormatType) : text;
      } else {
        text = typeof BI !== 'undefined' && BI.Format && BI.Format.numberFormat ? BI.Format.numberFormat(text, cfg) : text;
        text += unit;
      }

      return text;
    }
    function mergeShifting(shifting, parentShifting) {
      var x1 = shifting[0],
          y1 = shifting[1];
      var x2 = parentShifting[0],
          y2 = parentShifting[1];
      return [x1 + x2, y1 + y2];
    }
    function oneBasedIndexMap(arr) {
      // `Set` may be more optimal
      return _.reduce(_.uniq(arr), function (obj, v, i) {
        obj[v] = i + 1;
        return obj;
      }, {});
    }
    function fillArray(count, iteratee) {
      var arr = [],
          dynamic = typeof iteratee === 'function';
      var i = 0;

      while (i < count) {
        arr.push(dynamic ? iteratee(i) : iteratee);
        i++;
      }

      return arr;
    }

    var util = /*#__PURE__*/Object.freeze({
        forOwn: forOwn,
        global: global$1,
        DO_NOTHING: DO_NOTHING,
        TRUE_FUNCTION: TRUE_FUNCTION,
        FALSE_FUNCTION: FALSE_FUNCTION,
        isArray: isArray,
        forEach: forEach,
        map: map,
        filter: filter,
        reduce: reduce,
        find: find,
        shallowEqual: shallowEqual,
        autoBind: autoBind,
        freezeAll: freezeAll,
        getDomSize: getDomSize,
        getFormattedText: getFormattedText,
        mergeShifting: mergeShifting,
        oneBasedIndexMap: oneBasedIndexMap,
        fillArray: fillArray,
        getReadableTicks: getReadableTicks
    });

    /**
     * Check if two nodes are equivalent.
     *
     * @param {Node} node			DOM Node to compare
     * @param {VNode} vnode			Virtual DOM node to compare
     * @param {boolean} [hydrating=false]	If true, ignores component constructors when comparing.
     * @private
     */

    function isSameNodeType(node, vnode, hydrating) {
      if (typeof vnode.nodeName === 'string') {
        return isNamedNode(node, vnode.nodeName);
      }

      return hydrating || node._componentConstructor === vnode.nodeName;
    }
    /**
     * Check if an Element has a given nodeName, case-insensitively.
     *
     * @param {Element} node	A DOM Element to inspect the name of.
     * @param {String} nodeName	Unnormalized name to compare against.
     */

    function isNamedNode(node, nodeName) {
      return node.type === nodeName;
    }
    /**
     * Reconstruct Component-style `props` from a VNode.
     * Ensures default/fallback values from `defaultProps`:
     * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
     *
     * @param {VNode} vnode
     * @returns {Object} props
     */

    function getNodeProps(vnode) {
      var props = extend({}, vnode.attributes);
      props.children = vnode.children;
      var defaultProps = vnode.nodeName.defaultProps;

      if (defaultProps !== undefined) {
        for (var i in defaultProps) {
          if (props[i] === undefined) {
            props[i] = defaultProps[i];
          }
        }
      }

      return props;
    }

    /**
     * @module zrender/core/util
     */
    // 用于处理merge时无法遍历Date等对象的问题
    var BUILTIN_OBJECT = {
      '[object Function]': 1,
      '[object RegExp]': 1,
      '[object Date]': 1,
      '[object Error]': 1,
      '[object CanvasGradient]': 1,
      '[object CanvasPattern]': 1,
      // For node-canvas
      '[object Image]': 1,
      '[object Canvas]': 1
    };
    var TYPED_ARRAY = {
      '[object Int8Array]': 1,
      '[object Uint8Array]': 1,
      '[object Uint8ClampedArray]': 1,
      '[object Int16Array]': 1,
      '[object Uint16Array]': 1,
      '[object Int32Array]': 1,
      '[object Uint32Array]': 1,
      '[object Float32Array]': 1,
      '[object Float64Array]': 1
    };
    var objToString = Object.prototype.toString;
    var arrayProto = Array.prototype;
    var nativeForEach = arrayProto.forEach;
    var nativeSlice = arrayProto.slice;
    var nativeMap = arrayProto.map;

    var methods = {};
    function $override(name, fn) {
      // Clear ctx instance for different environment
      if (name === 'createCanvas') {
        _ctx = null;
      }

      methods[name] = fn;
    }
    /**
     * Those data types can be cloned:
     *     Plain object, Array, TypedArray, number, string, null, undefined.
     * Those data types will be assgined using the orginal data:
     *     BUILTIN_OBJECT
     * Instance of user defined class will be cloned to a plain object, without
     * properties in prototype.
     * Other data types is not supported (not sure what will happen).
     *
     * Caution: do not support clone Date, for performance consideration.
     * (There might be a large number of date in `series.data`).
     * So date should not be modified in and out of echarts.
     *
     * @param {*} source
     * @return {*} new
     */

    function clone(source) {
      if (source == null || typeof source !== 'object') {
        return source;
      }

      var result = source;
      var typeStr = objToString.call(source);

      if (typeStr === '[object Array]') {
        if (!isPrimitive(source)) {
          result = [];

          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone(source[i]);
          }
        }
      } else if (TYPED_ARRAY[typeStr]) {
        if (!isPrimitive(source)) {
          var Ctor = source.constructor;

          if (source.constructor.from) {
            result = Ctor.from(source);
          } else {
            result = new Ctor(source.length);

            for (var i = 0, len = source.length; i < len; i++) {
              result[i] = clone(source[i]);
            }
          }
        }
      } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};

        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            result[key] = clone(source[key]);
          }
        }
      }

      return result;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} target
     * @param {*} source
     * @param {boolean} [overwrite=false]
     */

    function merge(target, source, overwrite) {
      // We should escapse that source is string
      // and enter for ... in ...
      if (!isObject(source) || !isObject(target)) {
        return overwrite ? clone(source) : target;
      }

      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var targetProp = target[key];
          var sourceProp = source[key];

          if (isObject(sourceProp) && isObject(targetProp) && !isArray$1(sourceProp) && !isArray$1(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
            // 如果需要递归覆盖，就递归调用merge
            merge(targetProp, sourceProp, overwrite);
          } else if (overwrite || !(key in target)) {
            // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
            // NOTE，在 target[key] 不存在的时候也是直接覆盖
            target[key] = clone(source[key], true);
          }
        }
      }

      return target;
    }
    /**
     * @param {*} target
     * @param {*} source
     * @memberOf module:zrender/core/util
     */

    function extend$1(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }

      return target;
    }
    /**
     * @param {*} target
     * @param {*} source
     * @param {boolean} [overlay=false]
     * @memberOf module:zrender/core/util
     */

    function defaults(target, source, overlay) {
      for (var key in source) {
        if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
          target[key] = source[key];
        }
      }

      return target;
    }
    var createCanvas$1 = function createCanvas() {
      return methods.createCanvas();
    };

    methods.createCanvas = function () {
      return document.createElement('canvas');
    }; // FIXME


    var _ctx;

    function getContext() {
      if (!_ctx) {
        // Use util.createCanvas instead of createCanvas
        // because createCanvas may be overwritten in different environment
        _ctx = createCanvas$1().getContext('2d');
      }

      return _ctx;
    }
    /**
     * 查询数组中元素的index
     * @memberOf module:zrender/core/util
     */

    function indexOf(array, value) {
      if (array) {
        if (array.indexOf) {
          return array.indexOf(value);
        }

        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === value) {
            return i;
          }
        }
      }

      return -1;
    }
    /**
     * 构造类继承关系
     *
     * @memberOf module:zrender/core/util
     * @param {Function} clazz 源类
     * @param {Function} baseClazz 基类
     */

    function inherits(clazz, baseClazz) {
      var clazzPrototype = clazz.prototype;

      function F() {}

      F.prototype = baseClazz.prototype;
      clazz.prototype = new F();

      for (var prop in clazzPrototype) {
        clazz.prototype[prop] = clazzPrototype[prop];
      }

      clazz.prototype.constructor = clazz;
      clazz.superClass = baseClazz;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Object|Function} target
     * @param {Object|Function} sorce
     * @param {boolean} overlay
     */

    function mixin(target, source, overlay) {
      target = 'prototype' in target ? target.prototype : target;
      source = 'prototype' in source ? source.prototype : source;
      defaults(target, source, overlay);
    }
    /**
     * Consider typed array.
     * @param {Array|TypedArray} data
     */

    function isArrayLike$1(data) {
      if (!data) {
        return;
      }

      if (typeof data === 'string') {
        return false;
      }

      return typeof data.length === 'number';
    }
    /**
     * 数组或对象遍历
     * @memberOf module:zrender/core/util
     * @param {Object|Array} obj
     * @param {Function} cb
     * @param {*} [context]
     */

    function each(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
          cb.call(context, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            cb.call(context, obj[key], key, obj);
          }
        }
      }
    }
    /**
     * 数组映射
     * @memberOf module:zrender/core/util
     * @param {Array} obj
     * @param {Function} cb
     * @param {*} [context]
     * @return {Array}
     */

    function map$1(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }

      if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
      } else {
        var result = [];

        for (var i = 0, len = obj.length; i < len; i++) {
          result.push(cb.call(context, obj[i], i, obj));
        }

        return result;
      }
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {Function} func
     * @param {*} context
     * @return {Function}
     */

    function bind(func, context) {
      var args = nativeSlice.call(arguments, 2);
      return function () {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
      };
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isArray$1(value) {
      return objToString.call(value) === '[object Array]';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isFunction(value) {
      return typeof value === 'function';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isString(value) {
      return objToString.call(value) === '[object String]';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type === 'function' || !!value && type === 'object';
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isBuiltInObject(value) {
      return !!BUILTIN_OBJECT[objToString.call(value)];
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {*} value
     * @return {boolean}
     */

    function isDom(value) {
      return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';
    }
    function retrieve2(value0, value1) {
      return value0 != null ? value0 : value1;
    }
    function retrieve3(value0, value1, value2) {
      return value0 != null ? value0 : value1 != null ? value1 : value2;
    }
    /**
     * Normalize css liked array configuration
     * e.g.
     *  3 => [3, 3, 3, 3]
     *  [4, 2] => [4, 2, 4, 2]
     *  [4, 3, 2] => [4, 3, 2, 3]
     * @param {number|Array.<number>} val
     * @return {Array.<number>}
     */

    function normalizeCssArray(val) {
      if (typeof val === 'number') {
        return [val, val, val, val];
      }

      var len = val.length;

      if (len === 2) {
        // vertical | horizontal
        return [val[0], val[1], val[0], val[1]];
      } else if (len === 3) {
        // top | horizontal | bottom
        return [val[0], val[1], val[2], val[1]];
      }

      return val;
    }
    /**
     * @memberOf module:zrender/core/util
     * @param {string} str string to be trimed
     * @return {string} trimed string
     */

    function trim(str) {
      if (str == null) {
        return null;
      } else if (typeof str.trim === 'function') {
        return str.trim();
      } else {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
      }
    }
    var primitiveKey = '__ec_primitive__';
    function isPrimitive(obj) {
      return obj[primitiveKey];
    }

    var SHADOW_PROPS = {
      'shadowBlur': 1,
      'shadowOffsetX': 1,
      'shadowOffsetY': 1,
      'textShadowBlur': 1,
      'textShadowOffsetX': 1,
      'textShadowOffsetY': 1,
      'textBoxShadowBlur': 1,
      'textBoxShadowOffsetX': 1,
      'textBoxShadowOffsetY': 1
    };
    function fixShadow (ctx, propName, value) {
      if (SHADOW_PROPS.hasOwnProperty(propName)) {
        return value *= ctx.dpr;
      }

      return value;
    }

    var STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

    var Style = function Style(opts) {
      this.extendFrom(opts, false);
    };

    function createLinearGradient(ctx, obj, rect) {
      var x = obj.x == null ? 0 : obj.x;
      var x2 = obj.x2 == null ? 1 : obj.x2;
      var y = obj.y == null ? 0 : obj.y;
      var y2 = obj.y2 == null ? 0 : obj.y2;

      if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
      } // Fix NaN when rect is Infinity


      x = isNaN(x) ? 0 : x;
      x2 = isNaN(x2) ? 1 : x2;
      y = isNaN(y) ? 0 : y;
      y2 = isNaN(y2) ? 0 : y2;
      var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
      return canvasGradient;
    }

    function createRadialGradient(ctx, obj, rect) {
      var width = rect.width;
      var height = rect.height;
      var min = Math.min(width, height);
      var x = obj.x == null ? 0.5 : obj.x;
      var y = obj.y == null ? 0.5 : obj.y;
      var r = obj.r == null ? 0.5 : obj.r;

      if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
      }

      var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      return canvasGradient;
    }

    Style.prototype = {
      constructor: Style,

      /**
       * @type {string}
       */
      fill: '#000',

      /**
       * @type {string}
       */
      stroke: null,

      /**
       * @type {number}
       */
      opacity: 1,

      /**
       * @type {number}
       */
      fillOpacity: null,

      /**
       * @type {number}
       */
      strokeOpacity: null,

      /**
       * @type {Array.<number>}
       */
      lineDash: null,

      /**
       * @type {number}
       */
      lineDashOffset: 0,

      /**
       * @type {number}
       */
      shadowBlur: 0,

      /**
       * @type {number}
       */
      shadowOffsetX: 0,

      /**
       * @type {number}
       */
      shadowOffsetY: 0,

      /**
       * @type {number}
       */
      lineWidth: 1,

      /**
       * If stroke ignore scale
       * @type {Boolean}
       */
      strokeNoScale: false,
      // Bounding rect text configuration
      // Not affected by element transform

      /**
       * @type {string}
       */
      text: null,

      /**
       * If `fontSize` or `fontFamily` exists, `font` will be reset by
       * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
       * So do not visit it directly in upper application (like echarts),
       * but use `contain/text#makeFont` instead.
       * @type {string}
       */
      font: null,

      /**
       * The same as font. Use font please.
       * @deprecated
       * @type {string}
       */
      textFont: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontStyle: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontWeight: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * Should be 12 but not '12px'.
       * @type {number}
       */
      fontSize: null,

      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontFamily: null,

      /**
       * Reserved for special functinality, like 'hr'.
       * @type {string}
       */
      textTag: null,

      /**
       * @type {string}
       */
      textFill: '#000',

      /**
       * @type {string}
       */
      textStroke: null,

      /**
       * @type {number}
       */
      textWidth: null,

      /**
       * Only for textBackground.
       * @type {number}
       */
      textHeight: null,

      /**
       * textStroke may be set as some color as a default
       * value in upper applicaion, where the default value
       * of textStrokeWidth should be 0 to make sure that
       * user can choose to do not use text stroke.
       * @type {number}
       */
      textStrokeWidth: 0,

      /**
       * @type {number}
       */
      textLineHeight: null,

      /**
       * 'inside', 'left', 'right', 'top', 'bottom'
       * [x, y]
       * Based on x, y of rect.
       * @type {string|Array.<number>}
       * @default 'inside'
       */
      textPosition: 'inside',

      /**
       * If not specified, use the boundingRect of a `displayable`.
       * @type {Object}
       */
      textRect: null,

      /**
       * [x, y]
       * @type {Array.<number>}
       */
      textOffset: null,

      /**
       * @type {string}
       */
      textAlign: null,

      /**
       * @type {string}
       */
      textVerticalAlign: null,

      /**
       * @type {number}
       */
      textDistance: 5,

      /**
       * @type {string}
       */
      textShadowColor: 'transparent',

      /**
       * @type {number}
       */
      textShadowBlur: 0,

      /**
       * @type {number}
       */
      textShadowOffsetX: 0,

      /**
       * @type {number}
       */
      textShadowOffsetY: 0,

      /**
       * @type {string}
       */
      textBoxShadowColor: 'transparent',

      /**
       * @type {number}
       */
      textBoxShadowBlur: 0,

      /**
       * @type {number}
       */
      textBoxShadowOffsetX: 0,

      /**
       * @type {number}
       */
      textBoxShadowOffsetY: 0,

      /**
       * Whether transform text.
       * Only useful in Path and Image element
       * @type {boolean}
       */
      transformText: false,

      /**
       * Text rotate around position of Path or Image
       * Only useful in Path and Image element and transformText is false.
       */
      textRotation: 0,

      /**
       * Text origin of text rotation, like [10, 40].
       * Based on x, y of rect.
       * Useful in label rotation of circular symbol.
       * By default, this origin is textPosition.
       * Can be 'center'.
       * @type {string|Array.<number>}
       */
      textOrigin: null,

      /**
       * @type {string}
       */
      textBackgroundColor: null,

      /**
       * @type {string}
       */
      textBorderColor: null,

      /**
       * @type {number}
       */
      textBorderWidth: 0,

      /**
       * @type {number}
       */
      textBorderRadius: 0,

      /**
       * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
       * @type {number|Array.<number>}
       */
      textPadding: null,

      /**
       * Text styles for rich text.
       * @type {Object}
       */
      rich: null,

      /**
       * {outerWidth, outerHeight, ellipsis, placeholder}
       * @type {Object}
       */
      truncate: null,

      /**
       * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
       * @type {string}
       */
      blend: null,

      /**
       * @param {CanvasRenderingContext2D} ctx
       */
      bind: function bind(ctx, el, prevEl) {
        var style = this;
        var prevStyle = prevEl && prevEl.style;
        var firstDraw = !prevStyle;

        for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
          var prop = STYLE_COMMON_PROPS[i];
          var styleName = prop[0];

          if (firstDraw || style[styleName] !== prevStyle[styleName]) {
            // FIXME Invalid property value will cause style leak from previous element.
            ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);
          }
        }

        if (firstDraw || style.fill !== prevStyle.fill) {
          ctx.fillStyle = style.fill;
        }

        if (firstDraw || style.stroke !== prevStyle.stroke) {
          ctx.strokeStyle = style.stroke;
        }

        if (firstDraw || style.opacity !== prevStyle.opacity) {
          ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
        }

        if (firstDraw || style.blend !== prevStyle.blend) {
          ctx.globalCompositeOperation = style.blend || 'source-over';
        }

        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
        }
      },
      hasFill: function hasFill() {
        var fill = this.fill;
        return fill != null && fill !== 'none';
      },
      hasStroke: function hasStroke() {
        var stroke = this.stroke;
        return stroke != null && stroke !== 'none' && this.lineWidth > 0;
      },

      /**
       * Extend from other style
       * @param {zrender/graphic/Style} otherStyle
       * @param {boolean} overwrite true: overwrirte any way.
       *                            false: overwrite only when !target.hasOwnProperty
       *                            others: overwrite when property is not null/undefined.
       */
      extendFrom: function extendFrom(otherStyle, overwrite) {
        if (otherStyle) {
          for (var name in otherStyle) {
            if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {
              this[name] = otherStyle[name];
            }
          }
        }
      },

      /**
       * Batch setting style with a given object
       * @param {Object|string} obj
       * @param {*} [obj]
       */
      set: function set(obj, value) {
        if (typeof obj === 'string') {
          this[obj] = value;
        } else {
          this.extendFrom(obj, true);
        }
      },

      /**
       * Clone
       * @return {zrender/graphic/Style} [description]
       */
      clone: function clone() {
        var newStyle = new this.constructor();
        newStyle.extendFrom(this, true);
        return newStyle;
      },
      getGradient: function getGradient(ctx, obj, rect) {
        var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
        var canvasGradient = method(ctx, obj, rect);
        var colorStops = obj.colorStops;

        for (var i = 0; i < colorStops.length; i++) {
          canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
        }

        return canvasGradient;
      }
    };
    var styleProto = Style.prototype;

    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];

      if (!(prop[0] in styleProto)) {
        styleProto[prop[0]] = prop[1];
      }
    } // Provide for others


    Style.getGradient = styleProto.getGradient;

    /**
     * zrender: 生成唯一id
     *
     * @author errorrik (errorrik@gmail.com)
     */
    var idStart = 0x0907;
    function guid () {
      return idStart++;
    }

    /**
     * Event Mixin
     * @module zrender/mixin/Eventful
     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         pissang (https://www.github.com/pissang)
     */
    var arrySlice = Array.prototype.slice;
    /**
     * Event dispatcher.
     *
     * @alias module:zrender/mixin/Eventful
     * @constructor
     * @param {Object} [eventProcessor] The object eventProcessor is the scope when
     *        `eventProcessor.xxx` called.
     * @param {Function} [eventProcessor.normalizeQuery]
     *        param: {string|Object} Raw query.
     *        return: {string|Object} Normalized query.
     * @param {Function} [eventProcessor.filter] Event will be dispatched only
     *        if it returns `true`.
     *        param: {string} eventType
     *        param: {string|Object} query
     *        return: {boolean}
     * @param {Function} [eventProcessor.afterTrigger] Call after all handlers called.
     *        param: {string} eventType
     */

    var Eventful = function Eventful(eventProcessor) {
      this._$handlers = {};
      this._$eventProcessor = eventProcessor;
    };

    Eventful.prototype = {
      constructor: Eventful,

      /**
       * The handler can only be triggered once, then removed.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} context
       */
      one: function one(event, query, handler, context) {
        var _h = this._$handlers;

        if (typeof query === 'function') {
          context = handler;
          handler = query;
          query = null;
        }

        if (!handler || !event) {
          return this;
        }

        query = normalizeQuery(this, query);

        if (!_h[event]) {
          _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
          if (_h[event][i].h === handler) {
            return this;
          }
        }

        _h[event].push({
          h: handler,
          one: true,
          query: query,
          ctx: context || this
        });

        return this;
      },

      /**
       * Bind a handler.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} [context]
       */
      on: function on(event, query, handler, context) {
        var _h = this._$handlers;

        if (typeof query === 'function') {
          context = handler;
          handler = query;
          query = null;
        }

        if (!handler || !event) {
          return this;
        }

        query = normalizeQuery(this, query);

        if (!_h[event]) {
          _h[event] = [];
        }

        for (var i = 0; i < _h[event].length; i++) {
          if (_h[event][i].h === handler) {
            return this;
          }
        }

        _h[event].push({
          h: handler,
          one: false,
          query: query,
          ctx: context || this
        });

        return this;
      },

      /**
       * Whether any handler has bound.
       *
       * @param  {string}  event
       * @return {boolean}
       */
      isSilent: function isSilent(event) {
        var _h = this._$handlers;
        return !_h[event] || !_h[event].length;
      },

      /**
       * Unbind a event.
       *
       * @param {string} event The event name.
       * @param {Function} [handler] The event handler.
       */
      off: function off(event, handler) {
        var _h = this._$handlers;

        if (!event) {
          this._$handlers = {};
          return this;
        }

        if (handler) {
          if (_h[event]) {
            var newList = [];

            for (var i = 0, l = _h[event].length; i < l; i++) {
              if (_h[event][i].h !== handler) {
                newList.push(_h[event][i]);
              }
            }

            _h[event] = newList;
          }

          if (_h[event] && _h[event].length === 0) {
            delete _h[event];
          }
        } else {
          delete _h[event];
        }

        return this;
      },

      /**
       * Dispatch a event.
       *
       * @param {string} type The event name.
       */
      trigger: function trigger(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;

        if (_h) {
          var args = arguments;
          var argLen = args.length;

          if (argLen > 3) {
            args = arrySlice.call(args, 1);
          }

          var len = _h.length;

          for (var i = 0; i < len;) {
            var hItem = _h[i];

            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            } // Optimize advise from backbone


            switch (argLen) {
              case 1:
                hItem.h.call(hItem.ctx);
                break;

              case 2:
                hItem.h.call(hItem.ctx, args[1]);
                break;

              case 3:
                hItem.h.call(hItem.ctx, args[1], args[2]);
                break;

              default:
                // have more than 2 given arguments
                hItem.h.apply(hItem.ctx, args);
                break;
            }

            if (hItem.one) {
              _h.splice(i, 1);

              len--;
            } else {
              i++;
            }
          }
        }

        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      },

      /**
       * Dispatch a event with context, which is specified at the last parameter.
       *
       * @param {string} type The event name.
       */
      triggerWithContext: function triggerWithContext(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;

        if (_h) {
          var args = arguments;
          var argLen = args.length;

          if (argLen > 4) {
            args = arrySlice.call(args, 1, args.length - 1);
          }

          var ctx = args[args.length - 1];
          var len = _h.length;

          for (var i = 0; i < len;) {
            var hItem = _h[i];

            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            } // Optimize advise from backbone


            switch (argLen) {
              case 1:
                hItem.h.call(ctx);
                break;

              case 2:
                hItem.h.call(ctx, args[1]);
                break;

              case 3:
                hItem.h.call(ctx, args[1], args[2]);
                break;

              default:
                // have more than 2 given arguments
                hItem.h.apply(ctx, args);
                break;
            }

            if (hItem.one) {
              _h.splice(i, 1);

              len--;
            } else {
              i++;
            }
          }
        }

        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      }
    };

    function normalizeQuery(host, query) {
      var eventProcessor = host._$eventProcessor;

      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }

      return query;
    } // ----------------------

    /**
     * 3x2矩阵操作类
     * @exports zrender/tool/matrix
     */
    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
    /**
     * Create a identity matrix.
     * @return {Float32Array|Array.<number>}
     */

    function create() {
      var out = new ArrayCtor(6);
      identity(out);
      return out;
    }
    /**
     * 设置矩阵为单位矩阵
     * @param {Float32Array|Array.<number>} out
     */

    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      out[4] = 0;
      out[5] = 0;
      return out;
    }
    /**
     * 复制矩阵
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} m
     */

    function copy(out, m) {
      out[0] = m[0];
      out[1] = m[1];
      out[2] = m[2];
      out[3] = m[3];
      out[4] = m[4];
      out[5] = m[5];
      return out;
    }
    /**
     * 矩阵相乘
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} m1
     * @param {Float32Array|Array.<number>} m2
     */

    function mul(out, m1, m2) {
      // Consider matrix.mul(m, m2, m);
      // where out is the same as m2.
      // So use temp variable to escape error.
      var out0 = m1[0] * m2[0] + m1[2] * m2[1];
      var out1 = m1[1] * m2[0] + m1[3] * m2[1];
      var out2 = m1[0] * m2[2] + m1[2] * m2[3];
      var out3 = m1[1] * m2[2] + m1[3] * m2[3];
      var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
      var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
      out[0] = out0;
      out[1] = out1;
      out[2] = out2;
      out[3] = out3;
      out[4] = out4;
      out[5] = out5;
      return out;
    }
    /**
     * 平移变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {Float32Array|Array.<number>} v
     */

    function translate(out, a, v) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4] + v[0];
      out[5] = a[5] + v[1];
      return out;
    }
    /**
     * 旋转变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {number} rad
     */

    function rotate(out, a, rad) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var st = Math.sin(rad);
      var ct = Math.cos(rad);
      out[0] = aa * ct + ab * st;
      out[1] = -aa * st + ab * ct;
      out[2] = ac * ct + ad * st;
      out[3] = -ac * st + ct * ad;
      out[4] = ct * atx + st * aty;
      out[5] = ct * aty - st * atx;
      return out;
    }
    /**
     * 缩放变换
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     * @param {Float32Array|Array.<number>} v
     */

    function scale(out, a, v) {
      var vx = v[0];
      var vy = v[1];
      out[0] = a[0] * vx;
      out[1] = a[1] * vy;
      out[2] = a[2] * vx;
      out[3] = a[3] * vy;
      out[4] = a[4] * vx;
      out[5] = a[5] * vy;
      return out;
    }
    /**
     * 求逆矩阵
     * @param {Float32Array|Array.<number>} out
     * @param {Float32Array|Array.<number>} a
     */

    function invert(out, a) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var det = aa * ad - ab * ac;

      if (!det) {
        return null;
      }

      det = 1.0 / det;
      out[0] = ad * det;
      out[1] = -ab * det;
      out[2] = -ac * det;
      out[3] = aa * det;
      out[4] = (ac * aty - ad * atx) * det;
      out[5] = (ab * atx - aa * aty) * det;
      return out;
    }

    var ArrayCtor$1 = typeof Float32Array === 'undefined' ? Array : Float32Array;
    /**
     * 创建一个向量
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @return {Vector2}
     */

    function create$1(x, y) {
      var out = new ArrayCtor$1(2);

      if (x == null) {
        x = 0;
      }

      if (y == null) {
        y = 0;
      }

      out[0] = x;
      out[1] = y;
      return out;
    }
    /**
     * 克隆一个向量
     * @param {Vector2} v
     * @return {Vector2}
     */

    function clone$2(v) {
      var out = new ArrayCtor$1(2);
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    /**
     * 向量相加
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */

    function add(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    /**
     * 向量相减
     * @param {Vector2} out
     * @param {Vector2} v1
     * @param {Vector2} v2
     */

    function sub(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    /**
     * 向量长度
     * @param {Vector2} v
     * @return {number}
     */

    function len(v) {
      return Math.sqrt(lenSquare(v));
    }

    /**
     * 向量长度平方
     * @param {Vector2} v
     * @return {number}
     */

    function lenSquare(v) {
      return v[0] * v[0] + v[1] * v[1];
    }
    /**
     * 向量缩放
     * @param {Vector2} out
     * @param {Vector2} v
     * @param {number} s
     */

    function scale$1(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      return out;
    }
    /**
     * 向量归一化
     * @param {Vector2} out
     * @param {Vector2} v
     */

    function normalize(out, v) {
      var d = len(v);

      if (d === 0) {
        out[0] = 0;
        out[1] = 0;
      } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
      }

      return out;
    }
    /**
     * 计算向量间距离
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @return {number}
     */

    function distance(v1, v2) {
      return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    }
    var dist = distance;
    /**
     * 向量距离平方
     * @param {Vector2} v1
     * @param {Vector2} v2
     * @return {number}
     */

    function distanceSquare(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    }
    var distSquare = distanceSquare;
    /**
     * 矩阵左乘向量
     * @param {Vector2} out
     * @param {Vector2} v
     * @param {Vector2} m
     */

    function applyTransform(out, v, m) {
      var x = v[0];
      var y = v[1];
      out[0] = m[0] * x + m[2] * y + m[4];
      out[1] = m[1] * x + m[3] * y + m[5];
      return out;
    }
    /**
     * 求两个向量最小值
     * @param  {Vector2} out
     * @param  {Vector2} v1
     * @param  {Vector2} v2
     */

    function min(out, v1, v2) {
      out[0] = Math.min(v1[0], v2[0]);
      out[1] = Math.min(v1[1], v2[1]);
      return out;
    }
    /**
     * 求两个向量最大值
     * @param  {Vector2} out
     * @param  {Vector2} v1
     * @param  {Vector2} v2
     */

    function max(out, v1, v2) {
      out[0] = Math.max(v1[0], v2[0]);
      out[1] = Math.max(v1[1], v2[1]);
      return out;
    }

    /**
     * 提供变换扩展
     * @module zrender/mixin/Transformable
     * @author pissang (https://www.github.com/pissang)
     */
    var mIdentity = identity;
    var EPSILON = 5e-5;

    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    /**
     * @alias module:zrender/mixin/Transformable
     * @constructor
     */


    var Transformable = function Transformable(opts) {
      opts = opts || {}; // If there are no given position, rotation, scale

      if (!opts.position) {
        /**
         * 平移
         * @type {Array.<number>}
         * @default [0, 0]
         */
        this.position = [0, 0];
      }

      if (opts.rotation == null) {
        /**
         * 旋转
         * @type {Array.<number>}
         * @default 0
         */
        this.rotation = 0;
      }

      if (!opts.scale) {
        /**
         * 缩放
         * @type {Array.<number>}
         * @default [1, 1]
         */
        this.scale = [1, 1];
      }
      /**
       * 旋转和缩放的原点
       * @type {Array.<number>}
       * @default null
       */


      this.origin = this.origin || null;
    };

    var transformableProto = Transformable.prototype;
    transformableProto.transform = null;
    /**
     * 判断是否需要有坐标变换
     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
     */

    transformableProto.needLocalTransform = function () {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
    };

    var scaleTmp = [];

    transformableProto.updateTransform = function () {
      var parent = this.parent;
      var parentHasTransform = parent && parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m = this.transform;

      if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
      }

      m = m || create();

      if (needLocalTransform) {
        this.getLocalTransform(m);
      } else {
        mIdentity(m);
      } // 应用父节点变换


      if (parentHasTransform) {
        if (needLocalTransform) {
          mul(m, parent.transform, m);
        } else {
          copy(m, parent.transform);
        }
      } // 保存这个变换矩阵


      this.transform = m;
      var globalScaleRatio = this.globalScaleRatio;

      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m[0] *= sx;
        m[1] *= sx;
        m[2] *= sy;
        m[3] *= sy;
      }

      this.invTransform = this.invTransform || create();
      invert(this.invTransform, m);
    };

    transformableProto.getLocalTransform = function (m) {
      return Transformable.getLocalTransform(this, m);
    };
    /**
     * 将自己的transform应用到context上
     * @param {CanvasRenderingContext2D} ctx
     */


    transformableProto.setTransform = function (ctx) {
      var m = this.transform;
      var dpr = ctx.dpr || 1;

      if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
      } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };

    transformableProto.restoreTransform = function (ctx) {
      var dpr = ctx.dpr || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };

    var tmpTransform = [];
    var originTransform = create();

    transformableProto.setLocalTransform = function (m) {
      if (!m) {
        // TODO return or set identity?
        return;
      }

      var sx = m[0] * m[0] + m[1] * m[1];
      var sy = m[2] * m[2] + m[3] * m[3];
      var position = this.position;
      var scale$$1 = this.scale;

      if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
      }

      if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
      }

      if (m[0] < 0) {
        sx = -sx;
      }

      if (m[3] < 0) {
        sy = -sy;
      }

      position[0] = m[4];
      position[1] = m[5];
      scale$$1[0] = sx;
      scale$$1[1] = sy;
      this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
    };
    /**
     * 分解`transform`矩阵到`position`, `rotation`, `scale`
     */


    transformableProto.decomposeTransform = function () {
      if (!this.transform) {
        return;
      }

      var parent = this.parent;
      var m = this.transform;

      if (parent && parent.transform) {
        // Get local transform and decompose them to position, scale, rotation
        mul(tmpTransform, parent.invTransform, m);
        m = tmpTransform;
      }

      var origin = this.origin;

      if (origin && (origin[0] || origin[1])) {
        originTransform[4] = origin[0];
        originTransform[5] = origin[1];
        mul(tmpTransform, m, originTransform);
        tmpTransform[4] -= origin[0];
        tmpTransform[5] -= origin[1];
        m = tmpTransform;
      }

      this.setLocalTransform(m);
    };
    /**
     * Get global scale
     * @return {Array.<number>}
     */


    transformableProto.getGlobalScale = function (out) {
      var m = this.transform;
      out = out || [];

      if (!m) {
        out[0] = 1;
        out[1] = 1;
        return out;
      }

      out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
      out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);

      if (m[0] < 0) {
        out[0] = -out[0];
      }

      if (m[3] < 0) {
        out[1] = -out[1];
      }

      return out;
    };
    /**
     * 变换坐标位置到 shape 的局部坐标空间
     * @method
     * @param {number} x
     * @param {number} y
     * @return {Array.<number>}
     */


    transformableProto.transformCoordToLocal = function (x, y) {
      var v2 = [x, y];
      var invTransform = this.invTransform;

      if (invTransform) {
        applyTransform(v2, v2, invTransform);
      }

      return v2;
    };
    /**
     * 变换局部坐标位置到全局坐标空间
     * @method
     * @param {number} x
     * @param {number} y
     * @return {Array.<number>}
     */


    transformableProto.transformCoordToGlobal = function (x, y) {
      var v2 = [x, y];
      var transform = this.transform;

      if (transform) {
        applyTransform(v2, v2, transform);
      }

      return v2;
    };
    /**
     * @static
     * @param {Object} target
     * @param {Array.<number>} target.origin
     * @param {number} target.rotation
     * @param {Array.<number>} target.position
     * @param {Array.<number>} [m]
     */


    Transformable.getLocalTransform = function (target, m) {
      m = m || [];
      mIdentity(m);
      var origin = target.origin;
      var scale$$1 = target.scale || [1, 1];
      var rotation = target.rotation || 0;
      var position = target.position || [0, 0];

      if (origin) {
        // Translate to origin
        m[4] -= origin[0];
        m[5] -= origin[1];
      }

      scale(m, m, scale$$1);

      if (rotation) {
        rotate(m, m, rotation);
      }

      if (origin) {
        // Translate back from origin
        m[4] += origin[0];
        m[5] += origin[1];
      }

      m[4] += position[0];
      m[5] += position[1];
      return m;
    };

    /**
     * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
     * @see http://sole.github.io/tween.js/examples/03_graphs.html
     * @exports zrender/animation/easing
     */
    var easing = {
      /**
      * @param {number} k
      * @return {number}
      */
      linear: function linear(k) {
        return k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticIn: function quadraticIn(k) {
        return k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticOut: function quadraticOut(k) {
        return k * (2 - k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quadraticInOut: function quadraticInOut(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }

        return -0.5 * (--k * (k - 2) - 1);
      },
      // 三次方的缓动（t^3）

      /**
      * @param {number} k
      * @return {number}
      */
      cubicIn: function cubicIn(k) {
        return k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      cubicOut: function cubicOut(k) {
        return --k * k * k + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      cubicInOut: function cubicInOut(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k + 2);
      },
      // 四次方的缓动（t^4）

      /**
      * @param {number} k
      * @return {number}
      */
      quarticIn: function quarticIn(k) {
        return k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quarticOut: function quarticOut(k) {
        return 1 - --k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quarticInOut: function quarticInOut(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }

        return -0.5 * ((k -= 2) * k * k * k - 2);
      },
      // 五次方的缓动（t^5）

      /**
      * @param {number} k
      * @return {number}
      */
      quinticIn: function quinticIn(k) {
        return k * k * k * k * k;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quinticOut: function quinticOut(k) {
        return --k * k * k * k * k + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      quinticInOut: function quinticInOut(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }

        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      },
      // 正弦曲线的缓动（sin(t)）

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalIn: function sinusoidalIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalOut: function sinusoidalOut(k) {
        return Math.sin(k * Math.PI / 2);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalInOut: function sinusoidalInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      },
      // 指数曲线的缓动（2^t）

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialIn: function exponentialIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialOut: function exponentialOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      exponentialInOut: function exponentialInOut(k) {
        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }

        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      },
      // 圆形曲线的缓动（sqrt(1-t^2)）

      /**
      * @param {number} k
      * @return {number}
      */
      circularIn: function circularIn(k) {
        return 1 - Math.sqrt(1 - k * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      circularOut: function circularOut(k) {
        return Math.sqrt(1 - --k * k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      circularInOut: function circularInOut(k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      // 创建类似于弹簧在停止前来回振荡的动画

      /**
      * @param {number} k
      * @return {number}
      */
      elasticIn: function elasticIn(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      },

      /**
      * @param {number} k
      * @return {number}
      */
      elasticOut: function elasticOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      elasticInOut: function elasticInOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;

        if (k === 0) {
          return 0;
        }

        if (k === 1) {
          return 1;
        }

        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }

        if ((k *= 2) < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动

      /**
      * @param {number} k
      * @return {number}
      */
      backIn: function backIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      backOut: function backOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },

      /**
      * @param {number} k
      * @return {number}
      */
      backInOut: function backInOut(k) {
        var s = 1.70158 * 1.525;

        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }

        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      // 创建弹跳效果

      /**
      * @param {number} k
      * @return {number}
      */
      bounceIn: function bounceIn(k) {
        return 1 - easing.bounceOut(1 - k);
      },

      /**
      * @param {number} k
      * @return {number}
      */
      bounceOut: function bounceOut(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      },

      /**
      * @param {number} k
      * @return {number}
      */
      bounceInOut: function bounceInOut(k) {
        if (k < 0.5) {
          return easing.bounceIn(k * 2) * 0.5;
        }

        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
    };

    /**
     * 动画主控制器
     * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
     * @config life(1000) 动画时长
     * @config delay(0) 动画延迟时间
     * @config loop(true)
     * @config gap(0) 循环的间隔时间
     * @config onframe
     * @config easing(optional)
     * @config ondestroy(optional)
     * @config onrestart(optional)
     *
     * TODO pause
     */

    function Clip(options) {
      this._target = options.target; // 生命周期

      this._life = options.life || 1000; // 延时

      this._delay = options.delay || 0; // 开始时间
      // this._startTime = new Date().getTime() + this._delay;// 单位毫秒

      this._initialized = false; // 是否循环

      this.loop = options.loop == null ? false : options.loop;
      this.gap = options.gap || 0;
      this.easing = options.easing || 'Linear';
      this.onframe = options.onframe;
      this.ondestroy = options.ondestroy;
      this.onrestart = options.onrestart;
      this._pausedTime = 0;
      this._paused = false;
    }

    Clip.prototype = {
      constructor: Clip,
      step: function step(globalTime, deltaTime) {
        // Set startTime on first step, or _startTime may has milleseconds different between clips
        // PENDING
        if (!this._initialized) {
          this._startTime = globalTime + this._delay;
          this._initialized = true;
        }

        if (this._paused) {
          this._pausedTime += deltaTime;
          return;
        }

        var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始

        if (percent < 0) {
          return;
        }

        percent = Math.min(percent, 1);
        var easing$$1 = this.easing;
        var easingFunc = typeof easing$$1 === 'string' ? easing[easing$$1] : easing$$1;
        var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
        this.fire('frame', schedule); // 结束

        if (percent === 1) {
          if (this.loop) {
            this.restart(globalTime); // 重新开始周期
            // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件

            return 'restart';
          } // 动画完成将这个控制器标识为待删除
          // 在Animation.update中进行批量删除


          this._needsRemove = true;
          return 'destroy';
        }

        return null;
      },
      restart: function restart(globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;
        this._needsRemove = false;
      },
      fire: function fire(eventType, arg) {
        eventType = 'on' + eventType;

        if (this[eventType]) {
          this[eventType](this._target, arg);
        }
      },
      pause: function pause() {
        this._paused = true;
      },
      resume: function resume() {
        this._paused = false;
      }
    };

    // Simple LRU cache use doubly linked list
    // @module zrender/core/LRU

    /**
     * Simple double linked list. Compared with array, it has O(1) remove operation.
     * @constructor
     */
    var LinkedList = function LinkedList() {
      /**
       * @type {module:zrender/core/LRU~Entry}
       */
      this.head = null;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.tail = null;
      this._len = 0;
    };

    var linkedListProto = LinkedList.prototype;
    /**
     * Insert a new value at the tail
     * @param  {} val
     * @return {module:zrender/core/LRU~Entry}
     */

    linkedListProto.insert = function (val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    /**
     * Insert an entry at the tail
     * @param  {module:zrender/core/LRU~Entry} entry
     */


    linkedListProto.insertEntry = function (entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }

      this._len++;
    };
    /**
     * Remove entry.
     * @param  {module:zrender/core/LRU~Entry} entry
     */


    linkedListProto.remove = function (entry) {
      var prev = entry.prev;
      var next = entry.next;

      if (prev) {
        prev.next = next;
      } else {
        // Is head
        this.head = next;
      }

      if (next) {
        next.prev = prev;
      } else {
        // Is tail
        this.tail = prev;
      }

      entry.next = entry.prev = null;
      this._len--;
    };
    /**
     * @return {number}
     */


    linkedListProto.len = function () {
      return this._len;
    };
    /**
     * Clear list
     */


    linkedListProto.clear = function () {
      this.head = this.tail = null;
      this._len = 0;
    };
    /**
     * @constructor
     * @param {} val
     */


    var Entry = function Entry(val) {
      /**
       * @type {}
       */
      this.value = val;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.next;
      /**
       * @type {module:zrender/core/LRU~Entry}
       */

      this.prev;
    };
    /**
     * LRU Cache
     * @constructor
     * @alias module:zrender/core/LRU
     */


    var LRU = function LRU(maxSize) {
      this._list = new LinkedList();
      this._map = {};
      this._maxSize = maxSize || 10;
      this._lastRemovedEntry = null;
    };

    var LRUProto = LRU.prototype;
    /**
     * @param  {string} key
     * @param  {} value
     * @return {} Removed value
     */

    LRUProto.put = function (key, value) {
      var list = this._list;
      var map = this._map;
      var removed = null;

      if (map[key] == null) {
        var len = list.len(); // Reuse last removed entry

        var entry = this._lastRemovedEntry;

        if (len >= this._maxSize && len > 0) {
          // Remove the least recently used
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }

        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }

        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
      }

      return removed;
    };
    /**
     * @param  {string} key
     * @return {}
     */


    LRUProto.get = function (key) {
      var entry = this._map[key];
      var list = this._list;

      if (entry != null) {
        // Put the latest used entry in the tail
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }

        return entry.value;
      }
    };
    /**
     * Clear the cache
     */


    LRUProto.clear = function () {
      this._list.clear();

      this._map = {};
    };

    var kCSSColorTable = {
      'transparent': [0, 0, 0, 0],
      'aliceblue': [240, 248, 255, 1],
      'antiquewhite': [250, 235, 215, 1],
      'aqua': [0, 255, 255, 1],
      'aquamarine': [127, 255, 212, 1],
      'azure': [240, 255, 255, 1],
      'beige': [245, 245, 220, 1],
      'bisque': [255, 228, 196, 1],
      'black': [0, 0, 0, 1],
      'blanchedalmond': [255, 235, 205, 1],
      'blue': [0, 0, 255, 1],
      'blueviolet': [138, 43, 226, 1],
      'brown': [165, 42, 42, 1],
      'burlywood': [222, 184, 135, 1],
      'cadetblue': [95, 158, 160, 1],
      'chartreuse': [127, 255, 0, 1],
      'chocolate': [210, 105, 30, 1],
      'coral': [255, 127, 80, 1],
      'cornflowerblue': [100, 149, 237, 1],
      'cornsilk': [255, 248, 220, 1],
      'crimson': [220, 20, 60, 1],
      'cyan': [0, 255, 255, 1],
      'darkblue': [0, 0, 139, 1],
      'darkcyan': [0, 139, 139, 1],
      'darkgoldenrod': [184, 134, 11, 1],
      'darkgray': [169, 169, 169, 1],
      'darkgreen': [0, 100, 0, 1],
      'darkgrey': [169, 169, 169, 1],
      'darkkhaki': [189, 183, 107, 1],
      'darkmagenta': [139, 0, 139, 1],
      'darkolivegreen': [85, 107, 47, 1],
      'darkorange': [255, 140, 0, 1],
      'darkorchid': [153, 50, 204, 1],
      'darkred': [139, 0, 0, 1],
      'darksalmon': [233, 150, 122, 1],
      'darkseagreen': [143, 188, 143, 1],
      'darkslateblue': [72, 61, 139, 1],
      'darkslategray': [47, 79, 79, 1],
      'darkslategrey': [47, 79, 79, 1],
      'darkturquoise': [0, 206, 209, 1],
      'darkviolet': [148, 0, 211, 1],
      'deeppink': [255, 20, 147, 1],
      'deepskyblue': [0, 191, 255, 1],
      'dimgray': [105, 105, 105, 1],
      'dimgrey': [105, 105, 105, 1],
      'dodgerblue': [30, 144, 255, 1],
      'firebrick': [178, 34, 34, 1],
      'floralwhite': [255, 250, 240, 1],
      'forestgreen': [34, 139, 34, 1],
      'fuchsia': [255, 0, 255, 1],
      'gainsboro': [220, 220, 220, 1],
      'ghostwhite': [248, 248, 255, 1],
      'gold': [255, 215, 0, 1],
      'goldenrod': [218, 165, 32, 1],
      'gray': [128, 128, 128, 1],
      'green': [0, 128, 0, 1],
      'greenyellow': [173, 255, 47, 1],
      'grey': [128, 128, 128, 1],
      'honeydew': [240, 255, 240, 1],
      'hotpink': [255, 105, 180, 1],
      'indianred': [205, 92, 92, 1],
      'indigo': [75, 0, 130, 1],
      'ivory': [255, 255, 240, 1],
      'khaki': [240, 230, 140, 1],
      'lavender': [230, 230, 250, 1],
      'lavenderblush': [255, 240, 245, 1],
      'lawngreen': [124, 252, 0, 1],
      'lemonchiffon': [255, 250, 205, 1],
      'lightblue': [173, 216, 230, 1],
      'lightcoral': [240, 128, 128, 1],
      'lightcyan': [224, 255, 255, 1],
      'lightgoldenrodyellow': [250, 250, 210, 1],
      'lightgray': [211, 211, 211, 1],
      'lightgreen': [144, 238, 144, 1],
      'lightgrey': [211, 211, 211, 1],
      'lightpink': [255, 182, 193, 1],
      'lightsalmon': [255, 160, 122, 1],
      'lightseagreen': [32, 178, 170, 1],
      'lightskyblue': [135, 206, 250, 1],
      'lightslategray': [119, 136, 153, 1],
      'lightslategrey': [119, 136, 153, 1],
      'lightsteelblue': [176, 196, 222, 1],
      'lightyellow': [255, 255, 224, 1],
      'lime': [0, 255, 0, 1],
      'limegreen': [50, 205, 50, 1],
      'linen': [250, 240, 230, 1],
      'magenta': [255, 0, 255, 1],
      'maroon': [128, 0, 0, 1],
      'mediumaquamarine': [102, 205, 170, 1],
      'mediumblue': [0, 0, 205, 1],
      'mediumorchid': [186, 85, 211, 1],
      'mediumpurple': [147, 112, 219, 1],
      'mediumseagreen': [60, 179, 113, 1],
      'mediumslateblue': [123, 104, 238, 1],
      'mediumspringgreen': [0, 250, 154, 1],
      'mediumturquoise': [72, 209, 204, 1],
      'mediumvioletred': [199, 21, 133, 1],
      'midnightblue': [25, 25, 112, 1],
      'mintcream': [245, 255, 250, 1],
      'mistyrose': [255, 228, 225, 1],
      'moccasin': [255, 228, 181, 1],
      'navajowhite': [255, 222, 173, 1],
      'navy': [0, 0, 128, 1],
      'oldlace': [253, 245, 230, 1],
      'olive': [128, 128, 0, 1],
      'olivedrab': [107, 142, 35, 1],
      'orange': [255, 165, 0, 1],
      'orangered': [255, 69, 0, 1],
      'orchid': [218, 112, 214, 1],
      'palegoldenrod': [238, 232, 170, 1],
      'palegreen': [152, 251, 152, 1],
      'paleturquoise': [175, 238, 238, 1],
      'palevioletred': [219, 112, 147, 1],
      'papayawhip': [255, 239, 213, 1],
      'peachpuff': [255, 218, 185, 1],
      'peru': [205, 133, 63, 1],
      'pink': [255, 192, 203, 1],
      'plum': [221, 160, 221, 1],
      'powderblue': [176, 224, 230, 1],
      'purple': [128, 0, 128, 1],
      'red': [255, 0, 0, 1],
      'rosybrown': [188, 143, 143, 1],
      'royalblue': [65, 105, 225, 1],
      'saddlebrown': [139, 69, 19, 1],
      'salmon': [250, 128, 114, 1],
      'sandybrown': [244, 164, 96, 1],
      'seagreen': [46, 139, 87, 1],
      'seashell': [255, 245, 238, 1],
      'sienna': [160, 82, 45, 1],
      'silver': [192, 192, 192, 1],
      'skyblue': [135, 206, 235, 1],
      'slateblue': [106, 90, 205, 1],
      'slategray': [112, 128, 144, 1],
      'slategrey': [112, 128, 144, 1],
      'snow': [255, 250, 250, 1],
      'springgreen': [0, 255, 127, 1],
      'steelblue': [70, 130, 180, 1],
      'tan': [210, 180, 140, 1],
      'teal': [0, 128, 128, 1],
      'thistle': [216, 191, 216, 1],
      'tomato': [255, 99, 71, 1],
      'turquoise': [64, 224, 208, 1],
      'violet': [238, 130, 238, 1],
      'wheat': [245, 222, 179, 1],
      'white': [255, 255, 255, 1],
      'whitesmoke': [245, 245, 245, 1],
      'yellow': [255, 255, 0, 1],
      'yellowgreen': [154, 205, 50, 1]
    };

    function clampCssByte(i) {
      // Clamp to integer 0 .. 255.
      i = Math.round(i); // Seems to be what Chrome does (vs truncation).

      return i < 0 ? 0 : i > 255 ? 255 : i;
    }

    function clampCssFloat(f) {
      // Clamp to float 0.0 .. 1.0.
      return f < 0 ? 0 : f > 1 ? 1 : f;
    }

    function parseCssInt(str) {
      // int or percentage.
      if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssByte(parseFloat(str) / 100 * 255);
      }

      return clampCssByte(parseInt(str, 10));
    }

    function parseCssFloat(str) {
      // float or percentage.
      if (str.length && str.charAt(str.length - 1) === '%') {
        return clampCssFloat(parseFloat(str) / 100);
      }

      return clampCssFloat(parseFloat(str));
    }

    function cssHueToRgb(m1, m2, h) {
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }

      if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
      }

      if (h * 2 < 1) {
        return m2;
      }

      if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
      }

      return m1;
    }

    function setRgba(out, r, g, b, a) {
      out[0] = r;
      out[1] = g;
      out[2] = b;
      out[3] = a;
      return out;
    }

    function copyRgba(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }

    var colorCache = new LRU(20);
    var lastRemovedArr = null;

    function putToCache(colorStr, rgbaArr) {
      // Reuse removed array
      if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
      }

      lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
    }
    /**
     * @param {string} colorStr
     * @param {Array.<number>} out
     * @return {Array.<number>}
     * @memberOf module:zrender/util/color
     */


    function parse(colorStr, rgbaArr) {
      if (!colorStr) {
        return;
      }

      rgbaArr = rgbaArr || [];
      var cached = colorCache.get(colorStr);

      if (cached) {
        return copyRgba(rgbaArr, cached);
      } // colorStr may be not string


      colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.

      var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

      if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      } // #abc and #abc123 syntax.


      if (str.charAt(0) === '#') {
        if (str.length === 4) {
          var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

          if (!(iv >= 0 && iv <= 0xfff)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return; // Covers NaN.
          }

          setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else if (str.length === 7) {
          var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

          if (!(iv >= 0 && iv <= 0xffffff)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return; // Covers NaN.
          }

          setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        }

        return;
      }

      var op = str.indexOf('(');
      var ep = str.indexOf(')');

      if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1; // To allow case fallthrough.

        switch (fname) {
          case 'rgba':
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            alpha = parseCssFloat(params.pop());
          // jshint ignore:line
          // Fall through.

          case 'rgb':
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          case 'hsla':
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            params[3] = parseCssFloat(params[3]);
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          case 'hsl':
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }

            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;

          default:
            return;
        }
      }

      setRgba(rgbaArr, 0, 0, 0, 1);
      return;
    }
    /**
     * @param {Array.<number>} hsla
     * @param {Array.<number>} rgba
     * @return {Array.<number>} rgba
     */

    function hsla2rgba(hsla, rgba) {
      var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1
      // NOTE(deanm): According to the CSS spec s/l should only be
      // percentages, but we don't bother and let float or percentage.

      var s = parseCssFloat(hsla[1]);
      var l = parseCssFloat(hsla[2]);
      var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var m1 = l * 2 - m2;
      rgba = rgba || [];
      setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);

      if (hsla.length === 4) {
        rgba[3] = hsla[3];
      }

      return rgba;
    }
    /**
     * @param {string} color
     * @param {number=} alpha 0 ~ 1
     * @return {string} Color string in rgba format.
     * @memberOf module:zrender/util/color
     */

    function modifyAlpha(color, alpha) {
      color = parse(color);

      if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, 'rgba');
      }
    }
    /**
     * @param {Array.<number>} arrColor like [12,33,44,0.4]
     * @param {string} type 'rgba', 'hsva', ...
     * @return {string} Result color. (If input illegal, return undefined).
     */

    function stringify(arrColor, type) {
      if (!arrColor || !arrColor.length) {
        return;
      }

      var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];

      if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
        colorStr += ',' + arrColor[3];
      }

      return type + '(' + colorStr + ')';
    }

    /**
     * @module echarts/animation/Animator
     */
    var arraySlice = Array.prototype.slice;

    function defaultGetter(target, key) {
      return target[key];
    }

    function defaultSetter(target, key, value) {
      target[key] = value;
    }
    /**
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} percent
     * @return {number}
     */


    function interpolateNumber(p0, p1, percent) {
      return (p1 - p0) * percent + p0;
    }
    /**
     * @param  {string} p0
     * @param  {string} p1
     * @param  {number} percent
     * @return {string}
     */


    function interpolateString(p0, p1, percent) {
      return percent > 0.5 ? p1 : p0;
    }
    /**
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {number} percent
     * @param  {Array} out
     * @param  {number} arrDim
     */


    function interpolateArray(p0, p1, percent, out, arrDim) {
      var len = p0.length;

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
      } else {
        var len2 = len && p0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
          }
        }
      }
    } // arr0 is source array, arr1 is target array.
    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1


    function fillArr(arr0, arr1, arrDim) {
      var arr0Len = arr0.length;
      var arr1Len = arr1.length;

      if (arr0Len !== arr1Len) {
        // FIXME Not work for TypedArray
        var isPreviousLarger = arr0Len > arr1Len;

        if (isPreviousLarger) {
          // Cut the previous
          arr0.length = arr1Len;
        } else {
          // Fill the previous
          for (var i = arr0Len; i < arr1Len; i++) {
            arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
          }
        }
      } // Handling NaN value


      var len2 = arr0[0] && arr0[0].length;

      for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
          if (isNaN(arr0[i])) {
            arr0[i] = arr1[i];
          }
        } else {
          for (var j = 0; j < len2; j++) {
            if (isNaN(arr0[i][j])) {
              arr0[i][j] = arr1[i][j];
            }
          }
        }
      }
    }
    /**
     * @param  {Array} arr0
     * @param  {Array} arr1
     * @param  {number} arrDim
     * @return {boolean}
     */


    function isArraySame(arr0, arr1, arrDim) {
      if (arr0 === arr1) {
        return true;
      }

      var len = arr0.length;

      if (len !== arr1.length) {
        return false;
      }

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          if (arr0[i] !== arr1[i]) {
            return false;
          }
        }
      } else {
        var len2 = arr0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            if (arr0[i][j] !== arr1[i][j]) {
              return false;
            }
          }
        }
      }

      return true;
    }
    /**
     * Catmull Rom interpolate array
     * @param  {Array} p0
     * @param  {Array} p1
     * @param  {Array} p2
     * @param  {Array} p3
     * @param  {number} t
     * @param  {number} t2
     * @param  {number} t3
     * @param  {Array} out
     * @param  {number} arrDim
     */


    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
      var len = p0.length;

      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
        }
      } else {
        var len2 = p0[0].length;

        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
          }
        }
      }
    }
    /**
     * Catmull Rom interpolate number
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @param  {number} t2
     * @param  {number} t3
     * @return {number}
     */


    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    function cloneValue(value) {
      if (isArrayLike$1(value)) {
        var len = value.length;

        if (isArrayLike$1(value[0])) {
          var ret = [];

          for (var i = 0; i < len; i++) {
            ret.push(arraySlice.call(value[i]));
          }

          return ret;
        }

        return arraySlice.call(value);
      }

      return value;
    }

    function rgba2String(rgba) {
      rgba[0] = Math.floor(rgba[0]);
      rgba[1] = Math.floor(rgba[1]);
      rgba[2] = Math.floor(rgba[2]);
      return 'rgba(' + rgba.join(',') + ')';
    }

    function getArrayDim(keyframes) {
      var lastValue = keyframes[keyframes.length - 1].value;
      return isArrayLike$1(lastValue && lastValue[0]) ? 2 : 1;
    }

    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
      var getter = animator._getter;
      var setter = animator._setter;
      var useSpline = easing === 'spline';
      var trackLen = keyframes.length;

      if (!trackLen) {
        return;
      } // Guess data type


      var firstVal = keyframes[0].value;
      var isValueArray = isArrayLike$1(firstVal);
      var isValueColor = false;
      var isValueString = false; // For vertices morphing

      var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
      var trackMaxTime; // Sort keyframe as ascending

      keyframes.sort(function (a, b) {
        return a.time - b.time;
      });
      trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe

      var kfPercents = []; // Value of each keyframe

      var kfValues = [];
      var prevValue = keyframes[0].value;
      var isAllValueEqual = true;

      for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string

        var value = keyframes[i].value; // Check if value is equal, deep check if value is array

        if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
          isAllValueEqual = false;
        }

        prevValue = value; // Try converting a string to a color array

        if (typeof value === 'string') {
          var colorArray = parse(value);

          if (colorArray) {
            value = colorArray;
            isValueColor = true;
          } else {
            isValueString = true;
          }
        }

        kfValues.push(value);
      }

      if (!forceAnimate && isAllValueEqual) {
        return;
      }

      var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value

      for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
          fillArr(kfValues[i], lastValue, arrDim);
        } else {
          if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
            kfValues[i] = lastValue;
          }
        }
      }

      isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when
      // animation playback is sequency

      var lastFrame = 0;
      var lastFramePercent = 0;
      var start;
      var w;
      var p0;
      var p1;
      var p2;
      var p3;

      if (isValueColor) {
        var rgba = [0, 0, 0, 0];
      }

      var onframe = function onframe(target, percent) {
        // Find the range keyframes
        // kf1-----kf2---------current--------kf3
        // find kf2 and kf3 and do interpolation
        var frame; // In the easing function like elasticOut, percent may less than 0

        if (percent < 0) {
          frame = 0;
        } else if (percent < lastFramePercent) {
          // Start from next key
          // PENDING start from lastFrame ?
          start = Math.min(lastFrame + 1, trackLen - 1);

          for (frame = start; frame >= 0; frame--) {
            if (kfPercents[frame] <= percent) {
              break;
            }
          } // PENDING really need to do this ?


          frame = Math.min(frame, trackLen - 2);
        } else {
          for (frame = lastFrame; frame < trackLen; frame++) {
            if (kfPercents[frame] > percent) {
              break;
            }
          }

          frame = Math.min(frame - 1, trackLen - 2);
        }

        lastFrame = frame;
        lastFramePercent = percent;
        var range = kfPercents[frame + 1] - kfPercents[frame];

        if (range === 0) {
          return;
        } else {
          w = (percent - kfPercents[frame]) / range;
        }

        if (useSpline) {
          p1 = kfValues[frame];
          p0 = kfValues[frame === 0 ? frame : frame - 1];
          p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
          p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];

          if (isValueArray) {
            catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
          } else {
            var value;

            if (isValueColor) {
              value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
              value = rgba2String(rgba);
            } else if (isValueString) {
              // String is step(0.5)
              return interpolateString(p1, p2, w);
            } else {
              value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
            }

            setter(target, propName, value);
          }
        } else {
          if (isValueArray) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
          } else {
            var value;

            if (isValueColor) {
              interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
              value = rgba2String(rgba);
            } else if (isValueString) {
              // String is step(0.5)
              return interpolateString(kfValues[frame], kfValues[frame + 1], w);
            } else {
              value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
            }

            setter(target, propName, value);
          }
        }
      };

      var clip = new Clip({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe: onframe,
        ondestroy: oneTrackDone
      });

      if (easing && easing !== 'spline') {
        clip.easing = easing;
      }

      return clip;
    }
    /**
     * @alias module:zrender/animation/Animator
     * @constructor
     * @param {Object} target
     * @param {boolean} loop
     * @param {Function} getter
     * @param {Function} setter
     */


    var Animator = function Animator(target, loop, getter, setter) {
      this._tracks = {};
      this._target = target;
      this._loop = loop || false;
      this._getter = getter || defaultGetter;
      this._setter = setter || defaultSetter;
      this._clipCount = 0;
      this._delay = 0;
      this._doneList = [];
      this._onframeList = [];
      this._clipList = [];
    };

    Animator.prototype = {
      /**
       * 设置动画关键帧
       * @param  {number} time 关键帧时间，单位是ms
       * @param  {Object} props 关键帧的属性值，key-value表示
       * @return {module:zrender/animation/Animator}
       */
      when: function when(time
      /* ms */
      , props) {
        var tracks = this._tracks;

        for (var propName in props) {
          if (!props.hasOwnProperty(propName)) {
            continue;
          }

          if (!tracks[propName]) {
            tracks[propName] = []; // Invalid value

            var value = this._getter(this._target, propName);

            if (value == null) {
              // zrLog('Invalid property ' + propName);
              continue;
            } // If time is 0
            //  Then props is given initialize value
            // Else
            //  Initialize value from current prop value


            if (time !== 0) {
              tracks[propName].push({
                time: 0,
                value: cloneValue(value)
              });
            }
          }

          tracks[propName].push({
            time: time,
            value: props[propName]
          });
        }

        return this;
      },

      /**
       * 添加动画每一帧的回调函数
       * @param  {Function} callback
       * @return {module:zrender/animation/Animator}
       */
      during: function during(callback) {
        this._onframeList.push(callback);

        return this;
      },
      pause: function pause() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].pause();
        }

        this._paused = true;
      },
      resume: function resume() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].resume();
        }

        this._paused = false;
      },
      isPaused: function isPaused() {
        return !!this._paused;
      },
      _doneCallback: function _doneCallback() {
        // Clear all tracks
        this._tracks = {}; // Clear all clips

        this._clipList.length = 0;
        var doneList = this._doneList;
        var len = doneList.length;

        for (var i = 0; i < len; i++) {
          doneList[i].call(this);
        }
      },

      /**
       * 开始执行动画
       * @param  {string|Function} [easing]
       *         动画缓动函数，详见{@link module:zrender/animation/easing}
       * @param  {boolean} forceAnimate
       * @return {module:zrender/animation/Animator}
       */
      start: function start(easing, forceAnimate) {
        var self = this;
        var clipCount = 0;

        var oneTrackDone = function oneTrackDone() {
          clipCount--;

          if (!clipCount) {
            self._doneCallback();
          }
        };

        var lastClip;

        for (var propName in this._tracks) {
          if (!this._tracks.hasOwnProperty(propName)) {
            continue;
          }

          var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);

          if (clip) {
            this._clipList.push(clip);

            clipCount++; // If start after added to animation

            if (this.animation) {
              this.animation.addClip(clip);
            }

            lastClip = clip;
          }
        } // Add during callback on the last clip


        if (lastClip) {
          var oldOnFrame = lastClip.onframe;

          lastClip.onframe = function (target, percent) {
            oldOnFrame(target, percent);

            for (var i = 0; i < self._onframeList.length; i++) {
              self._onframeList[i](target, percent);
            }
          };
        } // This optimization will help the case that in the upper application
        // the view may be refreshed frequently, where animation will be
        // called repeatly but nothing changed.


        if (!clipCount) {
          this._doneCallback();
        }

        return this;
      },

      /**
       * 停止动画
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stop: function stop(forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;

        for (var i = 0; i < clipList.length; i++) {
          var clip = clipList[i];

          if (forwardToLast) {
            // Move to last frame before stop
            clip.onframe(this._target, 1);
          }

          animation && animation.removeClip(clip);
        }

        clipList.length = 0;
      },

      /**
       * 设置动画延迟开始的时间
       * @param  {number} time 单位ms
       * @return {module:zrender/animation/Animator}
       */
      delay: function delay(time) {
        this._delay = time;
        return this;
      },

      /**
       * 添加动画结束的回调
       * @param  {Function} cb
       * @return {module:zrender/animation/Animator}
       */
      done: function done(cb) {
        if (cb) {
          this._doneList.push(cb);
        }

        return this;
      },

      /**
       * @return {Array.<module:zrender/animation/Clip>}
       */
      getClips: function getClips() {
        return this._clipList;
      }
    };

    var dpr = 1; // If in browser environment

    if (typeof window !== 'undefined') {
      dpr = Math.max(window.devicePixelRatio || 1, 1);
    }

    var devicePixelRatio = dpr;

    var log = function log() {};

    var log$1 = log;

    /**
     * @alias modue:zrender/mixin/Animatable
     * @constructor
     */

    var Animatable = function Animatable() {
      /**
       * @type {Array.<module:zrender/animation/Animator>}
       * @readOnly
       */
      this.animators = [];
    };

    Animatable.prototype = {
      constructor: Animatable,

      /**
       * 动画
       *
       * @param {string} path The path to fetch value from object, like 'a.b.c'.
       * @param {boolean} [loop] Whether to loop animation.
       * @return {module:zrender/animation/Animator}
       * @example:
       *     el.animate('style', false)
       *         .when(1000, {x: 10} )
       *         .done(function(){ // Animation done })
       *         .start()
       */
      animate: function animate(path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;

        if (path) {
          var pathSplitted = path.split('.');
          var prop = el; // If animating shape

          animatingShape = pathSplitted[0] === 'shape';

          for (var i = 0, l = pathSplitted.length; i < l; i++) {
            if (!prop) {
              continue;
            }

            prop = prop[pathSplitted[i]];
          }

          if (prop) {
            target = prop;
          }
        } else {
          target = el;
        }

        if (!target) {
          log$1('Property "' + path + '" is not existed in element ' + el.id);
          return;
        }

        var animators = el.animators;
        var animator = new Animator(target, loop);
        animator.during(function (target) {
          el.dirty(animatingShape);
        }).done(function () {
          // FIXME Animator will not be removed if use `Animator#stop` to stop animation
          animators.splice(indexOf(animators, animator), 1);
        });
        animators.push(animator); // If animate after added to the zrender

        if (zr) {
          zr.animation.addAnimator(animator);
        }

        return animator;
      },

      /**
       * 停止动画
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stopAnimation: function stopAnimation(forwardToLast) {
        var animators = this.animators;
        var len = animators.length;

        for (var i = 0; i < len; i++) {
          animators[i].stop(forwardToLast);
        }

        animators.length = 0;
        return this;
      },

      /**
       * Caution: this method will stop previous animation.
       * So do not use this method to one element twice before
       * animation starts, unless you know what you are doing.
       * @param {Object} target
       * @param {number} [time=500] Time in ms
       * @param {string} [easing='linear']
       * @param {number} [delay=0]
       * @param {Function} [callback]
       * @param {Function} [forceAnimate] Prevent stop animation and callback
       *        immediently when target values are the same as current values.
       *
       * @example
       *  // Animate position
       *  el.animateTo({
       *      position: [10, 10]
       *  }, function () { // done })
       *
       *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
       *  el.animateTo({
       *      shape: {
       *          width: 500
       *      },
       *      style: {
       *          fill: 'red'
       *      }
       *      position: [10, 10]
       *  }, 100, 100, 'cubicOut', function () { // done })
       */
      // TODO Return animation key
      animateTo: function animateTo(target, time, delay, easing, callback, forceAnimate) {
        _animateTo(this, target, time, delay, easing, callback, forceAnimate);
      },

      /**
       * Animate from the target state to current state.
       * The params and the return value are the same as `this.animateTo`.
       */
      animateFrom: function animateFrom(target, time, delay, easing, callback, forceAnimate) {
        _animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
      }
    };

    function _animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
      // animateTo(target, time, easing, callback);
      if (isString(delay)) {
        callback = easing;
        easing = delay;
        delay = 0;
      } // animateTo(target, time, delay, callback);
      else if (isFunction(easing)) {
          callback = easing;
          easing = 'linear';
          delay = 0;
        } // animateTo(target, time, callback);
        else if (isFunction(delay)) {
            callback = delay;
            delay = 0;
          } // animateTo(target, callback)
          else if (isFunction(time)) {
              callback = time;
              time = 500;
            } // animateTo(target)
            else if (!time) {
                time = 500;
              } // Stop all previous animations


      animatable.stopAnimation();
      animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start
      // if there is nothing to animate

      var animators = animatable.animators.slice();
      var count = animators.length;

      function done() {
        count--;

        if (!count) {
          callback && callback();
        }
      } // No animators. This should be checked before animators[i].start(),
      // because 'done' may be executed immediately if no need to animate.


      if (!count) {
        callback && callback();
      } // Start after all animators created
      // Incase any animator is done immediately when all animation properties are not changed


      for (var i = 0; i < animators.length; i++) {
        animators[i].done(done).start(easing, forceAnimate);
      }
    }
    /**
     * @param {string} path=''
     * @param {Object} source=animatable
     * @param {Object} target
     * @param {number} [time=500]
     * @param {number} [delay=0]
     * @param {boolean} [reverse] If `true`, animate
     *        from the `target` to current state.
     *
     * @example
     *  // Animate position
     *  el._animateToShallow({
     *      position: [10, 10]
     *  })
     *
     *  // Animate shape, style and position in 100ms, delayed 100ms
     *  el._animateToShallow({
     *      shape: {
     *          width: 500
     *      },
     *      style: {
     *          fill: 'red'
     *      }
     *      position: [10, 10]
     *  }, 100, 100)
     */


    function animateToShallow(animatable, path, source, target, time, delay, reverse) {
      var objShallow = {};
      var propertyCount = 0;

      for (var name in target) {
        if (!target.hasOwnProperty(name)) {
          continue;
        }

        if (source[name] != null) {
          if (isObject(target[name]) && !isArrayLike$1(target[name])) {
            animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);
          } else {
            if (reverse) {
              objShallow[name] = source[name];
              setAttrByPath(animatable, path, name, target[name]);
            } else {
              objShallow[name] = target[name];
            }

            propertyCount++;
          }
        } else if (target[name] != null && !reverse) {
          setAttrByPath(animatable, path, name, target[name]);
        }
      }

      if (propertyCount > 0) {
        animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
      }
    }

    function setAttrByPath(el, path, name, value) {
      // Attr directly if not has property
      // FIXME, if some property not needed for element ?
      if (!path) {
        el.attr(name, value);
      } else {
        // Only support set shape or style
        var props = {};
        props[path] = {};
        props[path][name] = value;
        el.attr(props);
      }
    }

    /**
     * @alias module:zrender/Element
     * @constructor
     * @extends {module:zrender/mixin/Animatable}
     * @extends {module:zrender/mixin/Transformable}
     * @extends {module:zrender/mixin/Eventful}
     */

    var Element = function Element(opts) {
      // jshint ignore:line
      Transformable.call(this, opts);
      Eventful.call(this, opts);
      Animatable.call(this, opts);
      /**
       * 画布元素ID
       * @type {string}
       */

      this.id = opts.id || guid();
    };

    Element.prototype = {
      /**
       * 元素类型
       * Element type
       * @type {string}
       */
      type: 'element',

      /**
       * 元素名字
       * Element name
       * @type {string}
       */
      name: '',

      /**
       * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
       * ZRender instance will be assigned when element is associated with zrender
       * @name module:/zrender/Element#__zr
       * @type {module:zrender/ZRender}
       */
      __zr: null,

      /**
       * 图形是否忽略，为true时忽略图形的绘制以及事件触发
       * If ignore drawing and events of the element object
       * @name module:/zrender/Element#ignore
       * @type {boolean}
       * @default false
       */
      ignore: false,

      /**
       * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
       * 该路径会继承被裁减对象的变换
       * @type {module:zrender/graphic/Path}
       * @see http://www.w3.org/TR/2dcontext/#clipping-region
       * @readOnly
       */
      clipPath: null,

      /**
       * 是否是 Group
       * @type {boolean}
       */
      isGroup: false,

      /**
       * Drift element
       * @param  {number} dx dx on the global space
       * @param  {number} dy dy on the global space
       */
      drift: function drift(dx, dy) {
        switch (this.draggable) {
          case 'horizontal':
            dy = 0;
            break;

          case 'vertical':
            dx = 0;
            break;
        }

        var m = this.transform;

        if (!m) {
          m = this.transform = [1, 0, 0, 1, 0, 0];
        }

        m[4] += dx;
        m[5] += dy;
        this.decomposeTransform();
        this.dirty(false);
      },

      /**
       * Hook before update
       */
      beforeUpdate: function beforeUpdate() {},

      /**
       * Hook after update
       */
      afterUpdate: function afterUpdate() {},

      /**
       * Update each frame
       */
      update: function update() {
        this.updateTransform();
      },

      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function traverse(cb, context) {},

      /**
       * @protected
       */
      attrKV: function attrKV(key, value) {
        if (key === 'position' || key === 'scale' || key === 'origin') {
          // Copy the array
          if (value) {
            var target = this[key];

            if (!target) {
              target = this[key] = [];
            }

            target[0] = value[0];
            target[1] = value[1];
          }
        } else {
          this[key] = value;
        }
      },

      /**
       * Hide the element
       */
      hide: function hide() {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
      },

      /**
       * Show the element
       */
      show: function show() {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
      },

      /**
       * @param {string|Object} key
       * @param {*} value
       */
      attr: function attr(key, value) {
        if (typeof key === 'string') {
          this.attrKV(key, value);
        } else if (isObject(key)) {
          for (var name in key) {
            if (key.hasOwnProperty(name)) {
              this.attrKV(name, key[name]);
            }
          }
        }

        this.dirty(false);
        return this;
      },

      /**
       * @param {module:zrender/graphic/Path} clipPath
       */
      setClipPath: function setClipPath(clipPath) {
        var zr = this.__zr;

        if (zr) {
          clipPath.addSelfToZr(zr);
        } // Remove previous clip path


        if (this.clipPath && this.clipPath !== clipPath) {
          this.removeClipPath();
        }

        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;
        this.dirty(false);
      },

      /**
       */
      removeClipPath: function removeClipPath() {
        var clipPath = this.clipPath;

        if (clipPath) {
          if (clipPath.__zr) {
            clipPath.removeSelfFromZr(clipPath.__zr);
          }

          clipPath.__zr = null;
          clipPath.__clipTarget = null;
          this.clipPath = null;
          this.dirty(false);
        }
      },

      /**
       * Add self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      addSelfToZr: function addSelfToZr(zr) {
        this.__zr = zr; // 添加动画

        var animators = this.animators;

        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.addAnimator(animators[i]);
          }
        }

        if (this.clipPath) {
          this.clipPath.addSelfToZr(zr);
        }
      },

      /**
       * Remove self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      removeSelfFromZr: function removeSelfFromZr(zr) {
        this.__zr = null; // 移除动画

        var animators = this.animators;

        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.removeAnimator(animators[i]);
          }
        }

        if (this.clipPath) {
          this.clipPath.removeSelfFromZr(zr);
        }
      }
    };
    mixin(Element, Animatable);
    mixin(Element, Transformable);
    mixin(Element, Eventful);

    /**
     * @module echarts/core/BoundingRect
     */
    var v2ApplyTransform = applyTransform;
    var mathMin = Math.min;
    var mathMax = Math.max;
    /**
     * @alias module:echarts/core/BoundingRect
     */

    function BoundingRect(x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }

      if (height < 0) {
        y = y + height;
        height = -height;
      }
      /**
       * @type {number}
       */


      this.x = x;
      /**
       * @type {number}
       */

      this.y = y;
      /**
       * @type {number}
       */

      this.width = width;
      /**
       * @type {number}
       */

      this.height = height;
    }

    BoundingRect.prototype = {
      constructor: BoundingRect,

      /**
       * @param {module:echarts/core/BoundingRect} other
       */
      union: function union(other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);
        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
        this.x = x;
        this.y = y;
      },

      /**
       * @param {Array.<number>} m
       * @methods
       */
      applyTransform: function () {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function (m) {
          // In case usage like this
          // el.getBoundingRect().applyTransform(el.transform)
          // And element has no transform
          if (!m) {
            return;
          }

          lt[0] = lb[0] = this.x;
          lt[1] = rt[1] = this.y;
          rb[0] = rt[0] = this.x + this.width;
          rb[1] = lb[1] = this.y + this.height;
          v2ApplyTransform(lt, lt, m);
          v2ApplyTransform(rb, rb, m);
          v2ApplyTransform(lb, lb, m);
          v2ApplyTransform(rt, rt, m);
          this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
          this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
          var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
          var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
          this.width = maxX - this.x;
          this.height = maxY - this.y;
        };
      }(),

      /**
       * Calculate matrix of transforming from self to target rect
       * @param  {module:zrender/core/BoundingRect} b
       * @return {Array.<number>}
       */
      calculateTransform: function calculateTransform(b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;
        var m = create(); // 矩阵右乘

        translate(m, m, [-a.x, -a.y]);
        scale(m, m, [sx, sy]);
        translate(m, m, [b.x, b.y]);
        return m;
      },

      /**
       * @param {(module:echarts/core/BoundingRect|Object)} b
       * @return {boolean}
       */
      intersect: function intersect(b) {
        if (!b) {
          return false;
        }

        if (!(b instanceof BoundingRect)) {
          // Normalize negative width/height.
          b = BoundingRect.create(b);
        }

        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;
        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;
        return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      },
      contain: function contain(x, y) {
        var rect = this;
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
      },

      /**
       * @return {module:echarts/core/BoundingRect}
       */
      clone: function clone() {
        return new BoundingRect(this.x, this.y, this.width, this.height);
      },

      /**
       * Copy from another rect
       */
      copy: function copy$$1(other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
      },
      plain: function plain() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    };
    /**
     * @param {Object|module:zrender/core/BoundingRect} rect
     * @param {number} rect.x
     * @param {number} rect.y
     * @param {number} rect.width
     * @param {number} rect.height
     * @return {module:zrender/core/BoundingRect}
     */

    BoundingRect.create = function (rect) {
      return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
    };

    var globalImageCache = new LRU(50);
    /**
     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
     */

    function findExistImage(newImageOrSrc) {
      if (typeof newImageOrSrc === 'string') {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
      } else {
        return newImageOrSrc;
      }
    }
    /**
     * Caution: User should cache loaded images, but not just count on LRU.
     * Consider if required images more than LRU size, will dead loop occur?
     *
     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc
     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.
     * @param {module:zrender/Element} [hostEl] For calling `dirty`.
     * @param {Function} [cb] params: (image, cbPayload)
     * @param {Object} [cbPayload] Payload on cb calling.
     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image
     */

    function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
      if (!newImageOrSrc) {
        return image;
      } else if (typeof newImageOrSrc === 'string') {
        // Image should not be loaded repeatly.
        if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
          return image;
        } // Only when there is no existent image or existent image src
        // is different, this method is responsible for load.


        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        var pendingWrap = {
          hostEl: hostEl,
          cb: cb,
          cbPayload: cbPayload
        };

        if (cachedImgObj) {
          image = cachedImgObj.image;
          !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        } else {
          image = new Image();
          image.onload = image.onerror = imageOnLoad;
          globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
            image: image,
            pending: [pendingWrap]
          });
          image.src = image.__zrImageSrc = newImageOrSrc;
        }

        return image;
      } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas
      else {
          return newImageOrSrc;
        }
    }

    function imageOnLoad() {
      var cachedImgObj = this.__cachedImgObj;
      this.onload = this.onerror = this.__cachedImgObj = null;

      for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
      }

      cachedImgObj.pending.length = 0;
    }

    function isImageReady(image) {
      return image && image.width && image.height;
    }

    var textWidthCache = {};
    var textWidthCacheCounter = 0;
    var TEXT_CACHE_MAX = 5000;
    var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
    var DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.

    var methods$1 = {};
    function $override$1(name, fn) {
      methods$1[name] = fn;
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @return {number} width
     */

    function getWidth(text, font) {
      font = font || DEFAULT_FONT;
      var key = text + ':' + font;

      if (textWidthCache[key]) {
        return textWidthCache[key];
      }

      var textLines = (text + '').split('\n');
      var width = 0;

      for (var i = 0, l = textLines.length; i < l; i++) {
        // textContain.measureText may be overrided in SVG or VML
        width = Math.max(measureText(textLines[i], font).width, width);
      }

      if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
      }

      textWidthCacheCounter++;
      textWidthCache[key] = width;
      return width;
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @param {string} [textAlign='left']
     * @param {string} [textVerticalAlign='top']
     * @param {Array.<number>} [textPadding]
     * @param {Object} [rich]
     * @param {Object} [truncate]
     * @return {Object} {x, y, width, height, lineHeight}
     */

    function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
      return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);
    }

    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {
      var contentBlock = parsePlainText(text, font, textPadding, truncate);
      var outerWidth = getWidth(text, font);

      if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
      }

      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      var rect = new BoundingRect(x, y, outerWidth, outerHeight);
      rect.lineHeight = contentBlock.lineHeight;
      return rect;
    }

    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {
      var contentBlock = parseRichText(text, {
        rich: rich,
        truncate: truncate,
        font: font,
        textAlign: textAlign,
        textPadding: textPadding
      });
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      return new BoundingRect(x, y, outerWidth, outerHeight);
    }
    /**
     * @public
     * @param {number} x
     * @param {number} width
     * @param {string} [textAlign='left']
     * @return {number} Adjusted x.
     */


    function adjustTextX(x, width, textAlign) {
      // FIXME Right to left language
      if (textAlign === 'right') {
        x -= width;
      } else if (textAlign === 'center') {
        x -= width / 2;
      }

      return x;
    }
    /**
     * @public
     * @param {number} y
     * @param {number} height
     * @param {string} [textVerticalAlign='top']
     * @return {number} Adjusted y.
     */

    function adjustTextY(y, height, textVerticalAlign) {
      if (textVerticalAlign === 'middle') {
        y -= height / 2;
      } else if (textVerticalAlign === 'bottom') {
        y -= height;
      }

      return y;
    }
    /**
     * @public
     * @param {stirng} textPosition
     * @param {Object} rect {x, y, width, height}
     * @param {number} distance
     * @return {Object} {x, y, textAlign, textVerticalAlign}
     */

    function adjustTextPositionOnRect(textPosition, rect, distance) {
      var x = rect.x;
      var y = rect.y;
      var height = rect.height;
      var width = rect.width;
      var halfHeight = height / 2;
      var textAlign = 'left';
      var textVerticalAlign = 'top';

      switch (textPosition) {
        case 'left':
          x -= distance;
          y += halfHeight;
          textAlign = 'right';
          textVerticalAlign = 'middle';
          break;

        case 'right':
          x += distance + width;
          y += halfHeight;
          textVerticalAlign = 'middle';
          break;

        case 'top':
          x += width / 2;
          y -= distance;
          textAlign = 'center';
          textVerticalAlign = 'bottom';
          break;

        case 'bottom':
          x += width / 2;
          y += height + distance;
          textAlign = 'center';
          break;

        case 'inside':
          x += width / 2;
          y += halfHeight;
          textAlign = 'center';
          textVerticalAlign = 'middle';
          break;

        case 'insideLeft':
          x += distance;
          y += halfHeight;
          textVerticalAlign = 'middle';
          break;

        case 'insideRight':
          x += width - distance;
          y += halfHeight;
          textAlign = 'right';
          textVerticalAlign = 'middle';
          break;

        case 'insideTop':
          x += width / 2;
          y += distance;
          textAlign = 'center';
          break;

        case 'insideBottom':
          x += width / 2;
          y += height - distance;
          textAlign = 'center';
          textVerticalAlign = 'bottom';
          break;

        case 'insideTopLeft':
          x += distance;
          y += distance;
          break;

        case 'insideTopRight':
          x += width - distance;
          y += distance;
          textAlign = 'right';
          break;

        case 'insideBottomLeft':
          x += distance;
          y += height - distance;
          textVerticalAlign = 'bottom';
          break;

        case 'insideBottomRight':
          x += width - distance;
          y += height - distance;
          textAlign = 'right';
          textVerticalAlign = 'bottom';
          break;
      }

      return {
        x: x,
        y: y,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
      };
    }
    /**
     * Show ellipsis if overflow.
     *
     * @public
     * @param  {string} text
     * @param  {string} containerWidth
     * @param  {string} font
     * @param  {number} [ellipsis='...']
     * @param  {Object} [options]
     * @param  {number} [options.maxIterations=3]
     * @param  {number} [options.minChar=0] If truncate result are less
     *                  then minChar, ellipsis will not show, which is
     *                  better for user hint in some cases.
     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
     * @return {string}
     */

    function truncateText(text, containerWidth, font, ellipsis, options) {
      if (!containerWidth) {
        return '';
      }

      var textLines = (text + '').split('\n');
      options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME
      // It is not appropriate that every line has '...' when truncate multiple lines.

      for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
      }

      return textLines.join('\n');
    }

    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
      options = extend$1({}, options);
      options.font = font;
      var ellipsis = retrieve2(ellipsis, '...');
      options.maxIterations = retrieve2(options.maxIterations, 2);
      var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME
      // Other languages?

      options.cnCharWidth = getWidth('国', font); // FIXME
      // Consider proportional font?

      var ascCharWidth = options.ascCharWidth = getWidth('a', font);
      options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
      // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.

      var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.

      for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
      }

      var ellipsisWidth = getWidth(ellipsis, font);

      if (ellipsisWidth > contentWidth) {
        ellipsis = '';
        ellipsisWidth = 0;
      }

      contentWidth = containerWidth - ellipsisWidth;
      options.ellipsis = ellipsis;
      options.ellipsisWidth = ellipsisWidth;
      options.contentWidth = contentWidth;
      options.containerWidth = containerWidth;
      return options;
    }

    function truncateSingleLine(textLine, options) {
      var containerWidth = options.containerWidth;
      var font = options.font;
      var contentWidth = options.contentWidth;

      if (!containerWidth) {
        return '';
      }

      var lineWidth = getWidth(textLine, font);

      if (lineWidth <= containerWidth) {
        return textLine;
      }

      for (var j = 0;; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
          textLine += options.ellipsis;
          break;
        }

        var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
      }

      if (textLine === '') {
        textLine = options.placeholder;
      }

      return textLine;
    }

    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
      var width = 0;
      var i = 0;

      for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
      }

      return i;
    }
    /**
     * @public
     * @param {string} font
     * @return {number} line height
     */


    function getLineHeight(font) {
      // FIXME A rough approach.
      return getWidth('国', font);
    }
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @return {Object} width
     */

    function measureText(text, font) {
      return methods$1.measureText(text, font);
    } // Avoid assign to an exported variable, for transforming to cjs.

    methods$1.measureText = function (text, font) {
      var ctx = getContext();
      ctx.font = font || DEFAULT_FONT;
      return ctx.measureText(text);
    };
    /**
     * @public
     * @param {string} text
     * @param {string} font
     * @param {Object} [truncate]
     * @return {Object} block: {lineHeight, lines, height, outerHeight}
     *  Notice: for performance, do not calculate outerWidth util needed.
     */


    function parsePlainText(text, font, padding, truncate) {
      text != null && (text += '');
      var lineHeight = getLineHeight(font);
      var lines = text ? text.split('\n') : [];
      var height = lines.length * lineHeight;
      var outerHeight = height;

      if (padding) {
        outerHeight += padding[0] + padding[2];
      }

      if (text && truncate) {
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;

        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
          text = '';
          lines = [];
        } else if (truncOuterWidth != null) {
          var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
            minChar: truncate.minChar,
            placeholder: truncate.placeholder
          }); // FIXME
          // It is not appropriate that every line has '...' when truncate multiple lines.

          for (var i = 0, len = lines.length; i < len; i++) {
            lines[i] = truncateSingleLine(lines[i], options);
          }
        }
      }

      return {
        lines: lines,
        height: height,
        outerHeight: outerHeight,
        lineHeight: lineHeight
      };
    }
    /**
     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'
     * Also consider 'bbbb{a|xxx\nzzz}xxxx\naaaa'.
     *
     * @public
     * @param {string} text
     * @param {Object} style
     * @return {Object} block
     * {
     *      width,
     *      height,
     *      lines: [{
     *          lineHeight,
     *          width,
     *          tokens: [[{
     *              styleName,
     *              text,
     *              width,      // include textPadding
     *              height,     // include textPadding
     *              textWidth, // pure text width
     *              textHeight, // pure text height
     *              lineHeihgt,
     *              font,
     *              textAlign,
     *              textVerticalAlign
     *          }], [...], ...]
     *      }, ...]
     * }
     * If styleName is undefined, it is plain text.
     */

    function parseRichText(text, style) {
      var contentBlock = {
        lines: [],
        width: 0,
        height: 0
      };
      text != null && (text += '');

      if (!text) {
        return contentBlock;
      }

      var lastIndex = STYLE_REG.lastIndex = 0;
      var result;

      while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;

        if (matchedIndex > lastIndex) {
          pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }

        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
      }

      if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
      }

      var lines = contentBlock.lines;
      var contentHeight = 0;
      var contentWidth = 0; // For `textWidth: 100%`

      var pendingList = [];
      var stlPadding = style.textPadding;
      var truncate = style.truncate;
      var truncateWidth = truncate && truncate.outerWidth;
      var truncateHeight = truncate && truncate.outerHeight;

      if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
      } // Calculate layout info of tokens.


      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;

        for (var j = 0; j < line.tokens.length; j++) {
          var token = line.tokens[j];
          var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.

          var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.

          var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.

          var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified
          // as box height of the block.
          tokenStyle.textHeight, getLineHeight(font));
          textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
          token.height = tokenHeight;
          token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
          token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
          token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';

          if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
            return {
              lines: [],
              width: 0,
              height: 0
            };
          }

          token.textWidth = getWidth(token.text, font);
          var tokenWidth = tokenStyle.textWidth;
          var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate
          // line when box width is needed to be auto.

          if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {
            token.percentWidth = tokenWidth;
            pendingList.push(token);
            tokenWidth = 0; // Do not truncate in this case, because there is no user case
            // and it is too complicated.
          } else {
            if (tokenWidthNotSpecified) {
              tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling
              // `getBoundingRect()` will not get correct result.

              var textBackgroundColor = tokenStyle.textBackgroundColor;
              var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:
              // (1) If image is not loaded, it will be loaded at render phase and call
              // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded
              // image, and then the right size will be calculated here at the next tick.
              // See `graphic/helper/text.js`.
              // (2) If image loaded, and `textBackgroundColor.image` is image src string,
              // use `imageHelper.findExistImage` to find cached image.
              // `imageHelper.findExistImage` will always be called here before
              // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`
              // which ensures that image will not be rendered before correct size calcualted.

              if (bgImg) {
                bgImg = findExistImage(bgImg);

                if (isImageReady(bgImg)) {
                  tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                }
              }
            }

            var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
            tokenWidth += paddingW;
            var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;

            if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
              if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                token.text = '';
                token.textWidth = tokenWidth = 0;
              } else {
                token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                  minChar: truncate.minChar
                });
                token.textWidth = getWidth(token.text, font);
                tokenWidth = token.textWidth + paddingW;
              }
            }
          }

          lineWidth += token.width = tokenWidth;
          tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }

        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
      }

      contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
      contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);

      if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
      }

      for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.

        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
      }

      return contentBlock;
    }

    function pushTokens(block, str, styleName) {
      var isEmptyStr = str === '';
      var strs = str.split('\n');
      var lines = block.lines;

      for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
          styleName: styleName,
          text: text,
          isLineHolder: !text && !isEmptyStr
        }; // The first token should be appended to the last line.

        if (!i) {
          var tokens = (lines[lines.length - 1] || (lines[0] = {
            tokens: []
          })).tokens; // Consider cases:
          // (1) ''.split('\n') => ['', '\n', ''], the '' at the first item
          // (which is a placeholder) should be replaced by new token.
          // (2) A image backage, where token likes {a|}.
          // (3) A redundant '' will affect textAlign in line.
          // (4) tokens with the same tplName should not be merged, because
          // they should be displayed in different box (with border and padding).

          var tokensLen = tokens.length;
          tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the "lineHolder" or
          // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
          (text || !tokensLen || isEmptyStr) && tokens.push(token);
        } // Other tokens always start a new line.
        else {
            // If there is '', insert it as a placeholder.
            lines.push({
              tokens: [token]
            });
          }
      }
    }

    function makeFont(style) {
      // FIXME in node-canvas fontWeight is before fontStyle
      // Use `fontSize` `fontFamily` to check whether font properties are defined.
      var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.
      style.fontFamily || 'sans-serif'].join(' ');
      return font && trim(font) || style.textFont || style.font;
    }

    function buildPath(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      var r = shape.r;
      var r1;
      var r2;
      var r3;
      var r4; // Convert width and height to positive for better borderRadius

      if (width < 0) {
        x = x + width;
        width = -width;
      }

      if (height < 0) {
        y = y + height;
        height = -height;
      }

      if (typeof r === 'number') {
        r1 = r2 = r3 = r4 = r;
      } else if (r instanceof Array) {
        if (r.length === 1) {
          r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
          r1 = r3 = r[0];
          r2 = r4 = r[1];
        } else if (r.length === 3) {
          r1 = r[0];
          r2 = r4 = r[1];
          r3 = r[2];
        } else {
          r1 = r[0];
          r2 = r[1];
          r3 = r[2];
          r4 = r[3];
        }
      } else {
        r1 = r2 = r3 = r4 = 0;
      }

      var total;

      if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
      }

      if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
      }

      if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
      }

      if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
      }

      ctx.moveTo(x + r1, y);
      ctx.lineTo(x + width - r2, y);
      r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      ctx.lineTo(x + width, y + height - r3);
      r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      ctx.lineTo(x + r4, y + height);
      r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      ctx.lineTo(x, y + r1);
      r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
    }

    var VALID_TEXT_ALIGN = {
      left: 1,
      right: 1,
      center: 1
    };
    var VALID_TEXT_VERTICAL_ALIGN = {
      top: 1,
      bottom: 1,
      middle: 1
    }; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,
    // the default value of shadowColor is `'transparent'`.

    var SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];
    /**
     * @param {module:zrender/graphic/Style} style
     * @return {module:zrender/graphic/Style} The input style.
     */

    function normalizeTextStyle(style) {
      normalizeStyle(style);
      each(style.rich, normalizeStyle);
      return style;
    }

    function normalizeStyle(style) {
      if (style) {
        style.font = makeFont(style);
        var textAlign = style.textAlign;
        textAlign === 'middle' && (textAlign = 'center');
        style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.

        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === 'center' && (textVerticalAlign = 'middle');
        style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';
        var textPadding = style.textPadding;

        if (textPadding) {
          style.textPadding = normalizeCssArray(style.textPadding);
        }
      }
    }
    /**
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} text
     * @param {module:zrender/graphic/Style} style
     * @param {Object|boolean} [rect] {x, y, width, height}
     *                  If set false, rect text is not used.
     * @param {Element} [prevEl] For ctx prop cache.
     */


    function renderText(hostEl, ctx, text, style, rect, prevEl) {
      style.rich ? renderRichText(hostEl, ctx, text, style, rect) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
    } // Avoid setting to ctx according to prevEl if possible for
    // performance in scenarios of large amount text.

    function renderPlainText(hostEl, ctx, text, style, rect, prevEl) {

      var prevStyle = prevEl && prevEl.style;
      var checkCache = prevStyle && prevEl.type === 'text' && !prevStyle.rich;
      var styleFont = style.font || DEFAULT_FONT;

      if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {
        ctx.font = styleFont;
      } // Use the final font from context-2d, because the final
      // font might not be the style.font when it is illegal.
      // But get `ctx.font` might be time consuming.


      var computedFont = hostEl.__computedFont;

      if (hostEl.__styleFont !== styleFont) {
        hostEl.__styleFont = styleFont;
        computedFont = hostEl.__computedFont = ctx.font;
      }

      var textPadding = style.textPadding;
      var contentBlock = hostEl.__textCotentBlock;

      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = parsePlainText(text, computedFont, textPadding, style.truncate);
      }

      var outerHeight = contentBlock.outerHeight;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var boxPos = getBoxPosition(outerHeight, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign || 'left';
      var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxY = adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;
      var needDrawBg = needDrawBackground(style);

      if (needDrawBg || textPadding) {
        // Consider performance, do not call getTextWidth util necessary.
        var textWidth = getWidth(text, computedFont);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = adjustTextX(baseX, outerWidth, textAlign);
        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

        if (textPadding) {
          textX = getTextXForPadding(baseX, textAlign, textPadding);
          textY += textPadding[0];
        }
      } // Always set textAlign and textBase line, because it is difficute to calculate
      // textAlign from prevEl, and we dont sure whether textAlign will be reset if
      // font set happened.


      ctx.textAlign = textAlign; // Force baseline to be "middle". Otherwise, if using "top", the
      // text will offset downward a little bit in font "Microsoft YaHei".

      ctx.textBaseline = 'middle'; // Set text opacity

      ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.

      for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
        var propItem = SHADOW_STYLE_COMMON_PROPS[i];
        var styleProp = propItem[0];
        var ctxProp = propItem[1];
        var val = style[styleProp];

        if (!checkCache || val !== prevStyle[styleProp]) {
          ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
        }
      } // `textBaseline` is set as 'middle'.


      textY += lineHeight / 2;
      var textStrokeWidth = style.textStrokeWidth;
      var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
      var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
      var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
      var textStroke = getStroke(style.textStroke, textStrokeWidth);
      var textFill = getFill(style.textFill);

      if (textStroke) {
        if (strokeWidthChanged) {
          ctx.lineWidth = textStrokeWidth;
        }

        if (strokeChanged) {
          ctx.strokeStyle = textStroke;
        }
      }

      if (textFill) {
        if (!checkCache || style.textFill !== prevStyle.textFill || prevStyle.textBackgroundColor) {
          ctx.fillStyle = textFill;
        }
      }

      if (!checkCache || style.opacity !== prevStyle.opacity) {
        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
      } // Optimize simply, in most cases only one line exists.


      if (textLines.length === 1) {
        // Fill after stroke so the outline will not cover the main part.
        textStroke && ctx.strokeText(textLines[0], textX, textY);
        textFill && ctx.fillText(textLines[0], textX, textY);
      } else {
        for (var i = 0; i < textLines.length; i++) {
          // Fill after stroke so the outline will not cover the main part.
          textStroke && ctx.strokeText(textLines[i], textX, textY);
          textFill && ctx.fillText(textLines[i], textX, textY);
          textY += lineHeight;
        }
      }
    }

    function renderRichText(hostEl, ctx, text, style, rect) {
      var contentBlock = hostEl.__textCotentBlock;

      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = parseRichText(text, style);
      }

      drawRichText(hostEl, ctx, contentBlock, style, rect);
    }

    function drawRichText(hostEl, ctx, contentBlock, style, rect) {
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.textPadding;
      var boxPos = getBoxPosition(outerHeight, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign;
      var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.

      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, textVerticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;

      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }

      var xRight = xLeft + contentWidth;
      needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);

      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;

        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');
          usedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }

        while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');
          usedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        } // The other tokens are placed as textAlign 'center' if there is enough space.


        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;

        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.

          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');
          lineXLeft += token.width;
          leftIndex++;
        }

        lineTop += lineHeight;
      }
    }

    function applyTextRotation(ctx, style, rect, x, y) {
      // textRotation only apply in RectText.
      if (rect && style.textRotation) {
        var origin = style.textOrigin;

        if (origin === 'center') {
          x = rect.width / 2 + rect.x;
          y = rect.height / 2 + rect.y;
        } else if (origin) {
          x = origin[0] + rect.x;
          y = origin[1] + rect.y;
        }

        ctx.translate(x, y); // Positive: anticlockwise

        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
      }
    }

    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of
      // the bias of "Microsoft YaHei".

      var textVerticalAlign = token.textVerticalAlign;
      var y = lineTop + lineHeight / 2;

      if (textVerticalAlign === 'top') {
        y = lineTop + token.height / 2;
      } else if (textVerticalAlign === 'bottom') {
        y = lineTop + lineHeight - token.height / 2;
      }

      !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var textPadding = token.textPadding;

      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
      }

      setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
      setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');
      setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
      setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
      setCtx(ctx, 'globalAlpha', retrieve3(tokenStyle.opacity, style.opacity, 1));
      setCtx(ctx, 'textAlign', textAlign); // Force baseline to be "middle". Otherwise, if using "top", the
      // text will offset downward a little bit in font "Microsoft YaHei".

      setCtx(ctx, 'textBaseline', 'middle');
      setCtx(ctx, 'font', token.font || DEFAULT_FONT);
      var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
      var textFill = getFill(tokenStyle.textFill || style.textFill);
      var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.

      if (textStroke) {
        setCtx(ctx, 'lineWidth', textStrokeWidth);
        setCtx(ctx, 'strokeStyle', textStroke);
        ctx.strokeText(token.text, x, y);
      }

      if (textFill) {
        setCtx(ctx, 'fillStyle', textFill);
        ctx.fillText(token.text, x, y);
      }
    }

    function needDrawBackground(style) {
      return style.textBackgroundColor || style.textBorderWidth && style.textBorderColor;
    } // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}
    // shape: {x, y, width, height}


    function drawBackground(hostEl, ctx, style, x, y, width, height) {
      var textBackgroundColor = style.textBackgroundColor;
      var textBorderWidth = style.textBorderWidth;
      var textBorderColor = style.textBorderColor;
      var isPlainBg = isString(textBackgroundColor);
      setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);
      setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');
      setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);
      setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);

      if (isPlainBg || textBorderWidth && textBorderColor) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;

        if (!textBorderRadius) {
          ctx.rect(x, y, width, height);
        } else {
          buildPath(ctx, {
            x: x,
            y: y,
            width: width,
            height: height,
            r: textBorderRadius
          });
        }

        ctx.closePath();
      }

      if (isPlainBg) {
        setCtx(ctx, 'fillStyle', textBackgroundColor);

        if (style.fillOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.fillOpacity * style.opacity;
          ctx.fill();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.fill();
        }
      } else if (isObject(textBackgroundColor)) {
        var image = textBackgroundColor.image;
        image = createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);

        if (image && isImageReady(image)) {
          ctx.drawImage(image, x, y, width, height);
        }
      }

      if (textBorderWidth && textBorderColor) {
        setCtx(ctx, 'lineWidth', textBorderWidth);
        setCtx(ctx, 'strokeStyle', textBorderColor);

        if (style.strokeOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.strokeOpacity * style.opacity;
          ctx.stroke();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.stroke();
        }
      }
    }

    function onBgImageLoaded(image, textBackgroundColor) {
      // Replace image, so that `contain/text.js#parseRichText`
      // will get correct result in next tick.
      textBackgroundColor.image = image;
    }

    function getBoxPosition(blockHeiht, style, rect) {
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.textAlign;
      var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord

      if (rect) {
        var textPosition = style.textPosition;

        if (textPosition instanceof Array) {
          // Percent
          baseX = rect.x + parsePercent(textPosition[0], rect.width);
          baseY = rect.y + parsePercent(textPosition[1], rect.height);
        } else {
          var res = adjustTextPositionOnRect(textPosition, rect, style.textDistance);
          baseX = res.x;
          baseY = res.y; // Default align and baseline when has textPosition

          textAlign = textAlign || res.textAlign;
          textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        } // textOffset is only support in RectText, otherwise
        // we have to adjust boundingRect for textOffset.


        var textOffset = style.textOffset;

        if (textOffset) {
          baseX += textOffset[0];
          baseY += textOffset[1];
        }
      }

      return {
        baseX: baseX,
        baseY: baseY,
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
      };
    }

    function setCtx(ctx, prop, value) {
      ctx[prop] = fixShadow(ctx, prop, value);
      return ctx[prop];
    }
    /**
     * @param {string} [stroke] If specified, do not check style.textStroke.
     * @param {string} [lineWidth] If specified, do not check style.textStroke.
     * @param {number} style
     */


    function getStroke(stroke, lineWidth) {
      return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?
      : stroke.image || stroke.colorStops ? '#000' : stroke;
    }
    function getFill(fill) {
      return fill == null || fill === 'none' ? null // TODO pattern and gradient?
      : fill.image || fill.colorStops ? '#000' : fill;
    }

    function parsePercent(value, maxValue) {
      if (typeof value === 'string') {
        if (value.lastIndexOf('%') >= 0) {
          return parseFloat(value) / 100 * maxValue;
        }

        return parseFloat(value);
      }

      return value;
    }

    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    /**
     * @param {string} text
     * @param {module:zrender/Style} style
     * @return {boolean}
     */


    function needDrawText(text, style) {
      return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
    }

    /**
     * Mixin for drawing text in a element bounding rect
     * @module zrender/mixin/RectText
     */
    var tmpRect = new BoundingRect();

    var RectText = function RectText() {};

    RectText.prototype = {
      constructor: RectText,

      /**
       * Draw text in a rect with specified position.
       * @param  {CanvasRenderingContext2D} ctx
       * @param  {Object} rect Displayable rect
       */
      drawRectText: function drawRectText(ctx, rect) {
        var style = this.style;
        rect = style.textRect || rect; // Optimize, avoid normalize every time.

        this.__dirty && normalizeTextStyle(style, true);
        var text = style.text; // Convert to string

        text != null && (text += '');

        if (!needDrawText(text, style)) {
          return;
        } // FIXME
        // Do not provide prevEl to `textHelper.renderText` for ctx prop cache,
        // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect
        // text propably break the cache for its host elements.


        ctx.save(); // Transform rect to view space

        var transform = this.transform;

        if (!style.transformText) {
          if (transform) {
            tmpRect.copy(rect);
            tmpRect.applyTransform(transform);
            rect = tmpRect;
          }
        } else {
          this.setTransform(ctx);
        } // transformText and textRotation can not be used at the same time.


        renderText(this, ctx, text, style, rect);
        ctx.restore();
      }
    };

    /**
     * 可绘制的图形基类
     * Base class of all displayable graphic objects
     * @module zrender/graphic/Displayable
     */
    /**
     * @alias module:zrender/graphic/Displayable
     * @extends module:zrender/Element
     * @extends module:zrender/graphic/mixin/RectText
     */

    function Displayable(opts) {
      opts = opts || {};
      Element.call(this, opts); // Extend properties

      for (var name in opts) {
        if (opts.hasOwnProperty(name) && name !== 'style') {
          this[name] = opts[name];
        }
      }
      /**
       * @type {module:zrender/graphic/Style}
       */


      this.style = new Style(opts.style, this);
      this._rect = null; // Shapes for cascade clipping.

      this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted
      // Stateful.call(this, opts);
    }

    Displayable.prototype = {
      constructor: Displayable,
      type: 'displayable',

      /**
       * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
       * Dirty flag. From which painter will determine if this displayable object needs brush
       * @name module:zrender/graphic/Displayable#__dirty
       * @type {boolean}
       */
      __dirty: true,

      /**
       * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
       * If ignore drawing of the displayable object. Mouse event will still be triggered
       * @name module:/zrender/graphic/Displayable#invisible
       * @type {boolean}
       * @default false
       */
      invisible: false,

      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z: 0,

      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z2: 0,

      /**
       * z层level，决定绘画在哪层canvas中
       * @name module:/zrender/graphic/Displayable#zlevel
       * @type {number}
       * @default 0
       */
      zlevel: 0,

      /**
       * 是否可拖拽
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      draggable: false,

      /**
       * 是否正在拖拽
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      dragging: false,

      /**
       * 是否相应鼠标事件
       * @name module:/zrender/graphic/Displayable#silent
       * @type {boolean}
       * @default false
       */
      silent: false,

      /**
       * If enable culling
       * @type {boolean}
       * @default false
       */
      culling: false,

      /**
       * Mouse cursor when hovered
       * @name module:/zrender/graphic/Displayable#cursor
       * @type {string}
       */
      cursor: 'pointer',

      /**
       * If hover area is bounding rect
       * @name module:/zrender/graphic/Displayable#rectHover
       * @type {string}
       */
      rectHover: false,

      /**
       * Render the element progressively when the value >= 0,
       * usefull for large data.
       * @type {boolean}
       */
      progressive: false,

      /**
       * @type {boolean}
       */
      incremental: false,

      /**
       * Scale ratio for global scale.
       * @type {boolean}
       */
      globalScaleRatio: 1,
      beforeBrush: function beforeBrush(ctx) {},
      afterBrush: function afterBrush(ctx) {},

      /**
       * 图形绘制方法
       * @param {CanvasRenderingContext2D} ctx
       */
      // Interface
      brush: function brush(ctx, prevEl) {},

      /**
       * 获取最小包围盒
       * @return {module:zrender/core/BoundingRect}
       */
      // Interface
      getBoundingRect: function getBoundingRect() {},

      /**
       * 判断坐标 x, y 是否在图形上
       * If displayable element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      contain: function contain(x, y) {
        return this.rectContain(x, y);
      },

      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function traverse(cb, context) {
        cb.call(context, this);
      },

      /**
       * 判断坐标 x, y 是否在图形的包围盒上
       * If bounding rect of element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      rectContain: function rectContain(x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
      },

      /**
       * 标记图形元素为脏，并且在下一帧重绘
       * Mark displayable element dirty and refresh next frame
       */
      dirty: function dirty() {
        this.__dirty = this.__dirtyText = true;
        this._rect = null;
        this.__zr && this.__zr.refresh();
      },

      /**
       * 图形是否会触发事件
       * If displayable object binded any event
       * @return {boolean}
       */
      // TODO, 通过 bind 绑定的事件
      // isSilent: function () {
      //     return !(
      //         this.hoverable || this.draggable
      //         || this.onmousemove || this.onmouseover || this.onmouseout
      //         || this.onmousedown || this.onmouseup || this.onclick
      //         || this.ondragenter || this.ondragover || this.ondragleave
      //         || this.ondrop
      //     );
      // },

      /**
       * Alias for animate('style')
       * @param {boolean} loop
       */
      animateStyle: function animateStyle(loop) {
        return this.animate('style', loop);
      },
      attrKV: function attrKV(key, value) {
        if (key !== 'style') {
          Element.prototype.attrKV.call(this, key, value);
        } else {
          this.style.set(value);
        }
      },

      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setStyle: function setStyle(key, value) {
        this.style.set(key, value);
        this.dirty(false);
        return this;
      },

      /**
       * Use given style object
       * @param  {Object} obj
       */
      useStyle: function useStyle(obj) {
        this.style = new Style(obj, this);
        this.dirty(false);
        return this;
      }
    };
    inherits(Displayable, Element);
    mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);

    /**
     * 曲线辅助模块
     * @module zrender/core/curve
     * @author pissang(https://www.github.com/pissang)
     */
    var mathPow = Math.pow;
    var mathSqrt = Math.sqrt;
    var EPSILON$1 = 1e-8;
    var EPSILON_NUMERIC = 1e-4;
    var THREE_SQRT = mathSqrt(3);
    var ONE_THIRD = 1 / 3; // 临时变量

    var _v0 = create$1();

    var _v1 = create$1();

    var _v2 = create$1();

    function isAroundZero(val) {
      return val > -EPSILON$1 && val < EPSILON$1;
    }

    function isNotAroundZero$1(val) {
      return val > EPSILON$1 || val < -EPSILON$1;
    }
    /**
     * 计算三次贝塞尔值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */


    function cubicAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    /**
     * 计算三次贝塞尔导数值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @return {number}
     */

    function cubicDerivativeAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    /**
     * 计算三次贝塞尔方程根，使用盛金公式
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} val
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */

    function cubicRootAt(p0, p1, p2, p3, val, roots) {
      // Evaluate roots of cubic functions
      var a = p3 + 3 * (p1 - p2) - p0;
      var b = 3 * (p2 - p1 * 2 + p0);
      var c = 3 * (p1 - p0);
      var d = p0 - val;
      var A = b * b - 3 * a * c;
      var B = b * c - 9 * a * d;
      var C = c * c - 3 * b * d;
      var n = 0;

      if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
          roots[0] = 0;
        } else {
          var t1 = -c / b; //t1, t2, t3, b is not zero

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = B * B - 4 * A * C;

        if (isAroundZero(disc)) {
          var K = B / A;
          var t1 = -b / a + K; // t1, a is not zero

          var t2 = -K / 2; // t2, t3

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var Y1 = A * b + 1.5 * a * (-B + discSqrt);
          var Y2 = A * b + 1.5 * a * (-B - discSqrt);

          if (Y1 < 0) {
            Y1 = -mathPow(-Y1, ONE_THIRD);
          } else {
            Y1 = mathPow(Y1, ONE_THIRD);
          }

          if (Y2 < 0) {
            Y2 = -mathPow(-Y2, ONE_THIRD);
          } else {
            Y2 = mathPow(Y2, ONE_THIRD);
          }

          var t1 = (-b - (Y1 + Y2)) / (3 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else {
          var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
          var theta = Math.acos(T) / 3;
          var ASqrt = mathSqrt(A);
          var tmp = Math.cos(theta);
          var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
          var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
          var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }

          if (t3 >= 0 && t3 <= 1) {
            roots[n++] = t3;
          }
        }
      }

      return n;
    }
    /**
     * 计算三次贝塞尔方程极限值的位置
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {Array.<number>} extrema
     * @return {number} 有效数目
     */

    function cubicExtrema(p0, p1, p2, p3, extrema) {
      var b = 6 * p2 - 12 * p1 + 6 * p0;
      var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
      var c = 3 * p1 - 3 * p0;
      var n = 0;

      if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
          var t1 = -c / b;

          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;

        if (isAroundZero(disc)) {
          extrema[0] = -b / (2 * a);
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            extrema[n++] = t2;
          }
        }
      }

      return n;
    }
    /**
     * 细分三次贝塞尔曲线
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} p3
     * @param  {number} t
     * @param  {Array.<number>} out
     */

    function cubicSubdivide(p0, p1, p2, p3, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p23 = (p3 - p2) * t + p2;
      var p012 = (p12 - p01) * t + p01;
      var p123 = (p23 - p12) * t + p12;
      var p0123 = (p123 - p012) * t + p012; // Seg0

      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p0123; // Seg1

      out[4] = p0123;
      out[5] = p123;
      out[6] = p23;
      out[7] = p3;
    }
    /**
     * 投射点到三次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} [out] 投射点
     * @return {number}
     */

    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
      // http://pomax.github.io/bezierinfo/#projections
      var t;
      var interval = 0.005;
      var d = Infinity;
      var prev;
      var next;
      var d1;
      var d2;
      _v0[0] = x;
      _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
      // PENDING

      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = distSquare(_v0, _v1);

        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }

      d = Infinity; // At most 32 iteration

      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }

        prev = t - interval;
        next = t + interval; // t - interval

        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = distSquare(_v1, _v0);

        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          // t + interval
          _v2[0] = cubicAt(x0, x1, x2, x3, next);
          _v2[1] = cubicAt(y0, y1, y2, y3, next);
          d2 = distSquare(_v2, _v0);

          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      } // t


      if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
      } // console.log(interval, i);


      return mathSqrt(d);
    }
    /**
     * 计算二次方贝塞尔值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */

    function quadraticAt(p0, p1, p2, t) {
      var onet = 1 - t;
      return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    /**
     * 计算二次方贝塞尔导数值
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @return {number}
     */

    function quadraticDerivativeAt(p0, p1, p2, t) {
      return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    /**
     * 计算二次方贝塞尔方程根
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @param  {Array.<number>} roots
     * @return {number} 有效根数目
     */

    function quadraticRootAt(p0, p1, p2, val, roots) {
      var a = p0 - 2 * p1 + p2;
      var b = 2 * (p1 - p0);
      var c = p0 - val;
      var n = 0;

      if (isAroundZero(a)) {
        if (isNotAroundZero$1(b)) {
          var t1 = -c / b;

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;

        if (isAroundZero(disc)) {
          var t1 = -b / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);

          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }

          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        }
      }

      return n;
    }
    /**
     * 计算二次贝塞尔方程极限值
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @return {number}
     */

    function quadraticExtremum(p0, p1, p2) {
      var divider = p0 + p2 - 2 * p1;

      if (divider === 0) {
        // p1 is center of p0 and p2
        return 0.5;
      } else {
        return (p0 - p1) / divider;
      }
    }
    /**
     * 细分二次贝塞尔曲线
     * @memberOf module:zrender/core/curve
     * @param  {number} p0
     * @param  {number} p1
     * @param  {number} p2
     * @param  {number} t
     * @param  {Array.<number>} out
     */

    function quadraticSubdivide(p0, p1, p2, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p012 = (p12 - p01) * t + p01; // Seg0

      out[0] = p0;
      out[1] = p01;
      out[2] = p012; // Seg1

      out[3] = p012;
      out[4] = p12;
      out[5] = p2;
    }
    /**
     * 投射点到二次贝塞尔曲线上，返回投射距离。
     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} out 投射点
     * @return {number}
     */

    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
      // http://pomax.github.io/bezierinfo/#projections
      var t;
      var interval = 0.005;
      var d = Infinity;
      _v0[0] = x;
      _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值
      // PENDING

      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = distSquare(_v0, _v1);

        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }

      d = Infinity; // At most 32 iteration

      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }

        var prev = t - interval;
        var next = t + interval; // t - interval

        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        var d1 = distSquare(_v1, _v0);

        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          // t + interval
          _v2[0] = quadraticAt(x0, x1, x2, next);
          _v2[1] = quadraticAt(y0, y1, y2, next);
          var d2 = distSquare(_v2, _v0);

          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      } // t


      if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
      } // console.log(interval, i);


      return mathSqrt(d);
    }

    /**
     * @author Yi Shen(https://github.com/pissang)
     */
    var mathMin$1 = Math.min;
    var mathMax$1 = Math.max;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI2 = Math.PI * 2;
    var start = create$1();
    var end = create$1();
    var extremity = create$1();
    /**
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */

    function fromLine(x0, y0, x1, y1, min$$1, max$$1) {
      min$$1[0] = mathMin$1(x0, x1);
      min$$1[1] = mathMin$1(y0, y1);
      max$$1[0] = mathMax$1(x0, x1);
      max$$1[1] = mathMax$1(y0, y1);
    }
    var xDim = [];
    var yDim = [];
    /**
     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {number} x3
     * @param {number} y3
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */

    function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min$$1, max$$1) {
      var cubicExtrema$$1 = cubicExtrema;
      var cubicAt$$1 = cubicAt;
      var i;
      var n = cubicExtrema$$1(x0, x1, x2, x3, xDim);
      min$$1[0] = Infinity;
      min$$1[1] = Infinity;
      max$$1[0] = -Infinity;
      max$$1[1] = -Infinity;

      for (i = 0; i < n; i++) {
        var x = cubicAt$$1(x0, x1, x2, x3, xDim[i]);
        min$$1[0] = mathMin$1(x, min$$1[0]);
        max$$1[0] = mathMax$1(x, max$$1[0]);
      }

      n = cubicExtrema$$1(y0, y1, y2, y3, yDim);

      for (i = 0; i < n; i++) {
        var y = cubicAt$$1(y0, y1, y2, y3, yDim[i]);
        min$$1[1] = mathMin$1(y, min$$1[1]);
        max$$1[1] = mathMax$1(y, max$$1[1]);
      }

      min$$1[0] = mathMin$1(x0, min$$1[0]);
      max$$1[0] = mathMax$1(x0, max$$1[0]);
      min$$1[0] = mathMin$1(x3, min$$1[0]);
      max$$1[0] = mathMax$1(x3, max$$1[0]);
      min$$1[1] = mathMin$1(y0, min$$1[1]);
      max$$1[1] = mathMax$1(y0, max$$1[1]);
      min$$1[1] = mathMin$1(y3, min$$1[1]);
      max$$1[1] = mathMax$1(y3, max$$1[1]);
    }
    /**
     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
     * @memberOf module:zrender/core/bbox
     * @param {number} x0
     * @param {number} y0
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */

    function fromQuadratic(x0, y0, x1, y1, x2, y2, min$$1, max$$1) {
      var quadraticExtremum$$1 = quadraticExtremum;
      var quadraticAt$$1 = quadraticAt; // Find extremities, where derivative in x dim or y dim is zero

      var tx = mathMax$1(mathMin$1(quadraticExtremum$$1(x0, x1, x2), 1), 0);
      var ty = mathMax$1(mathMin$1(quadraticExtremum$$1(y0, y1, y2), 1), 0);
      var x = quadraticAt$$1(x0, x1, x2, tx);
      var y = quadraticAt$$1(y0, y1, y2, ty);
      min$$1[0] = mathMin$1(x0, x2, x);
      min$$1[1] = mathMin$1(y0, y2, y);
      max$$1[0] = mathMax$1(x0, x2, x);
      max$$1[1] = mathMax$1(y0, y2, y);
    }
    /**
     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
     * @method
     * @memberOf module:zrender/core/bbox
     * @param {number} x
     * @param {number} y
     * @param {number} rx
     * @param {number} ry
     * @param {number} startAngle
     * @param {number} endAngle
     * @param {number} anticlockwise
     * @param {Array.<number>} min
     * @param {Array.<number>} max
     */

    function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min$$1, max$$1) {
      var vec2Min = min;
      var vec2Max = max;
      var diff = Math.abs(startAngle - endAngle);

      if (diff % PI2 < 1e-4 && diff > 1e-4) {
        // Is a circle
        min$$1[0] = x - rx;
        min$$1[1] = y - ry;
        max$$1[0] = x + rx;
        max$$1[1] = y + ry;
        return;
      }

      start[0] = mathCos(startAngle) * rx + x;
      start[1] = mathSin(startAngle) * ry + y;
      end[0] = mathCos(endAngle) * rx + x;
      end[1] = mathSin(endAngle) * ry + y;
      vec2Min(min$$1, start, end);
      vec2Max(max$$1, start, end); // Thresh to [0, Math.PI * 2]

      startAngle = startAngle % PI2;

      if (startAngle < 0) {
        startAngle = startAngle + PI2;
      }

      endAngle = endAngle % PI2;

      if (endAngle < 0) {
        endAngle = endAngle + PI2;
      }

      if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
      } else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
      }

      if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
      } // var number = 0;
      // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;


      for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
          extremity[0] = mathCos(angle) * rx + x;
          extremity[1] = mathSin(angle) * ry + y;
          vec2Min(min$$1, extremity, min$$1);
          vec2Max(max$$1, extremity, max$$1);
        }
      }
    }

    /**
     * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
     * 可以用于 isInsidePath 判断以及获取boundingRect
     *
     * @module zrender/core/PathProxy
     * @author Yi Shen (http://www.github.com/pissang)
     */
    var CMD = {
      M: 1,
      L: 2,
      C: 3,
      Q: 4,
      A: 5,
      Z: 6,
      // Rect
      R: 7
    }; // var CMD_MEM_SIZE = {
    //     M: 3,
    //     L: 3,
    //     C: 7,
    //     Q: 5,
    //     A: 9,
    //     R: 5,
    //     Z: 1
    // };

    var min$1 = [];
    var max$1 = [];
    var min2 = [];
    var max2 = [];
    var mathMin$2 = Math.min;
    var mathMax$2 = Math.max;
    var mathCos$1 = Math.cos;
    var mathSin$1 = Math.sin;
    var mathSqrt$1 = Math.sqrt;
    var mathAbs = Math.abs;
    var hasTypedArray = typeof Float32Array !== 'undefined';
    /**
     * @alias module:zrender/core/PathProxy
     * @constructor
     */

    var PathProxy = function PathProxy(notSaveData) {
      this._saveData = !(notSaveData || false);

      if (this._saveData) {
        /**
         * Path data. Stored as flat array
         * @type {Array.<Object>}
         */
        this.data = [];
      }

      this._ctx = null;
    };
    /**
     * 快速计算Path包围盒（并不是最小包围盒）
     * @return {Object}
     */


    PathProxy.prototype = {
      constructor: PathProxy,
      _xi: 0,
      _yi: 0,
      _x0: 0,
      _y0: 0,
      // Unit x, Unit y. Provide for avoiding drawing that too short line segment
      _ux: 0,
      _uy: 0,
      _len: 0,
      _lineDash: null,
      _dashOffset: 0,
      _dashIdx: 0,
      _dashSum: 0,

      /**
       * @readOnly
       */
      setScale: function setScale(sx, sy) {
        this._ux = mathAbs(1 / devicePixelRatio / sx) || 0;
        this._uy = mathAbs(1 / devicePixelRatio / sy) || 0;
      },
      getContext: function getContext() {
        return this._ctx;
      },

      /**
       * @param  {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      beginPath: function beginPath(ctx) {
        this._ctx = ctx;
        ctx && ctx.beginPath();
        ctx && (this.dpr = ctx.dpr); // Reset

        if (this._saveData) {
          this._len = 0;
        }

        if (this._lineDash) {
          this._lineDash = null;
          this._dashOffset = 0;
        }

        return this;
      },

      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      moveTo: function moveTo(x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
        // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
        // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
        // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持

        this._x0 = x;
        this._y0 = y;
        this._xi = x;
        this._yi = y;
        return this;
      },

      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      lineTo: function lineTo(x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment
        || this._len < 5;
        this.addData(CMD.L, x, y);

        if (this._ctx && exceedUnit) {
          this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
        }

        if (exceedUnit) {
          this._xi = x;
          this._yi = y;
        }

        return this;
      },

      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @param  {number} x3
       * @param  {number} y3
       * @return {module:zrender/core/PathProxy}
       */
      bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);

        if (this._ctx) {
          this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }

        this._xi = x3;
        this._yi = y3;
        return this;
      },

      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @return {module:zrender/core/PathProxy}
       */
      quadraticCurveTo: function quadraticCurveTo(x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);

        if (this._ctx) {
          this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }

        this._xi = x2;
        this._yi = y2;
        return this;
      },

      /**
       * @param  {number} cx
       * @param  {number} cy
       * @param  {number} r
       * @param  {number} startAngle
       * @param  {number} endAngle
       * @param  {boolean} anticlockwise
       * @return {module:zrender/core/PathProxy}
       */
      arc: function arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        this._xi = mathCos$1(endAngle) * r + cx;
        this._yi = mathSin$1(endAngle) * r + cy;
        return this;
      },
      // TODO
      arcTo: function arcTo(x1, y1, x2, y2, radius) {
        if (this._ctx) {
          this._ctx.arcTo(x1, y1, x2, y2, radius);
        }

        return this;
      },
      // TODO
      rect: function rect(x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
      },

      /**
       * @return {module:zrender/core/PathProxy}
       */
      closePath: function closePath() {
        this.addData(CMD.Z);
        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;

        if (ctx) {
          this._needsDash() && this._dashedLineTo(x0, y0);
          ctx.closePath();
        }

        this._xi = x0;
        this._yi = y0;
        return this;
      },

      /**
       * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
       * stroke 同样
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      fill: function fill(ctx) {
        ctx && ctx.fill();
        this.toStatic();
      },

      /**
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      stroke: function stroke(ctx) {
        ctx && ctx.stroke();
        this.toStatic();
      },

      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDash: function setLineDash(lineDash) {
        if (lineDash instanceof Array) {
          this._lineDash = lineDash;
          this._dashIdx = 0;
          var lineDashSum = 0;

          for (var i = 0; i < lineDash.length; i++) {
            lineDashSum += lineDash[i];
          }

          this._dashSum = lineDashSum;
        }

        return this;
      },

      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDashOffset: function setLineDashOffset(offset) {
        this._dashOffset = offset;
        return this;
      },

      /**
       *
       * @return {boolean}
       */
      len: function len$$1() {
        return this._len;
      },

      /**
       * 直接设置 Path 数据
       */
      setData: function setData(data) {
        var len$$1 = data.length;

        if (!(this.data && this.data.length === len$$1) && hasTypedArray) {
          this.data = new Float32Array(len$$1);
        }

        for (var i = 0; i < len$$1; i++) {
          this.data[i] = data[i];
        }

        this._len = len$$1;
      },

      /**
       * 添加子路径
       * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
       */
      appendPath: function appendPath(path) {
        if (!(path instanceof Array)) {
          path = [path];
        }

        var len$$1 = path.length;
        var appendSize = 0;
        var offset = this._len;

        for (var i = 0; i < len$$1; i++) {
          appendSize += path[i].len();
        }

        if (hasTypedArray && this.data instanceof Float32Array) {
          this.data = new Float32Array(offset + appendSize);
        }

        for (var i = 0; i < len$$1; i++) {
          var appendPathData = path[i].data;

          for (var k = 0; k < appendPathData.length; k++) {
            this.data[offset++] = appendPathData[k];
          }
        }

        this._len = offset;
      },

      /**
       * 填充 Path 数据。
       * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
       */
      addData: function addData(cmd) {
        if (!this._saveData) {
          return;
        }

        var data = this.data;

        if (this._len + arguments.length > data.length) {
          // 因为之前的数组已经转换成静态的 Float32Array
          // 所以不够用时需要扩展一个新的动态数组
          this._expandData();

          data = this.data;
        }

        for (var i = 0; i < arguments.length; i++) {
          data[this._len++] = arguments[i];
        }

        this._prevCmd = cmd;
      },
      _expandData: function _expandData() {
        // Only if data is Float32Array
        if (!(this.data instanceof Array)) {
          var newData = [];

          for (var i = 0; i < this._len; i++) {
            newData[i] = this.data[i];
          }

          this.data = newData;
        }
      },

      /**
       * If needs js implemented dashed line
       * @return {boolean}
       * @private
       */
      _needsDash: function _needsDash() {
        return this._lineDash;
      },
      _dashedLineTo: function _dashedLineTo(x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist$$1 = mathSqrt$1(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist$$1;
        dy /= dist$$1;

        if (offset < 0) {
          // Convert to positive offset
          offset = dashSum + offset;
        }

        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;

        while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
          idx = this._dashIdx;
          dash = lineDash[idx];
          x += dx * dash;
          y += dy * dash;
          this._dashIdx = (idx + 1) % nDash; // Skip positive offset

          if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
            continue;
          }

          ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin$2(x, x1) : mathMax$2(x, x1), dy >= 0 ? mathMin$2(y, y1) : mathMax$2(y, y1));
        } // Offset for next lineTo


        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
      },
      // Not accurate dashed line to
      _dashedBezierTo: function _dashedBezierTo(x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt$$1 = cubicAt;
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;
        var x;
        var y;
        var tmpLen = 0;

        if (offset < 0) {
          // Convert to positive offset
          offset = dashSum + offset;
        }

        offset %= dashSum; // Bezier approx length

        for (t = 0; t < 1; t += 0.1) {
          dx = cubicAt$$1(x0, x1, x2, x3, t + 0.1) - cubicAt$$1(x0, x1, x2, x3, t);
          dy = cubicAt$$1(y0, y1, y2, y3, t + 0.1) - cubicAt$$1(y0, y1, y2, y3, t);
          bezierLen += mathSqrt$1(dx * dx + dy * dy);
        } // Find idx after add offset


        for (; idx < nDash; idx++) {
          tmpLen += lineDash[idx];

          if (tmpLen > offset) {
            break;
          }
        }

        t = (tmpLen - offset) / bezierLen;

        while (t <= 1) {
          x = cubicAt$$1(x0, x1, x2, x3, t);
          y = cubicAt$$1(y0, y1, y2, y3, t); // Use line to approximate dashed bezier
          // Bad result if dash is long

          idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          t += lineDash[idx] / bezierLen;
          idx = (idx + 1) % nDash;
        } // Finish the last segment and calculate the new offset


        idx % 2 !== 0 && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);
      },
      _dashedQuadraticTo: function _dashedQuadraticTo(x1, y1, x2, y2) {
        // Convert quadratic to cubic using degree elevation
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;

        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
      },

      /**
       * 转成静态的 Float32Array 减少堆内存占用
       * Convert dynamic array to static Float32Array
       */
      toStatic: function toStatic() {
        var data = this.data;

        if (data instanceof Array) {
          data.length = this._len;

          if (hasTypedArray) {
            this.data = new Float32Array(data);
          }
        }
      },

      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function getBoundingRect() {
        min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;

        for (var i = 0; i < data.length;) {
          var cmd = data[i++];

          if (i === 1) {
            // 如果第一个命令是 L, C, Q
            // 则 previous point 同绘制命令的第一个 point
            //
            // 第一个命令为 Arc 的情况下会在后面特殊处理
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
          }

          switch (cmd) {
            case CMD.M:
              // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
              // 在 closePath 的时候使用
              x0 = data[i++];
              y0 = data[i++];
              xi = x0;
              yi = y0;
              min2[0] = x0;
              min2[1] = y0;
              max2[0] = x0;
              max2[1] = y0;
              break;

            case CMD.L:
              fromLine(xi, yi, data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.C:
              fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.Q:
              fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;

            case CMD.A:
              // TODO Arc 判断的开销比较大
              var cx = data[i++];
              var cy = data[i++];
              var rx = data[i++];
              var ry = data[i++];
              var startAngle = data[i++];
              var endAngle = data[i++] + startAngle; // TODO Arc 旋转

              i += 1;
              var anticlockwise = 1 - data[i++];

              if (i === 1) {
                // 直接使用 arc 命令
                // 第一个命令起点还未定义
                x0 = mathCos$1(startAngle) * rx + cx;
                y0 = mathSin$1(startAngle) * ry + cy;
              }

              fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
              xi = mathCos$1(endAngle) * rx + cx;
              yi = mathSin$1(endAngle) * ry + cy;
              break;

            case CMD.R:
              x0 = xi = data[i++];
              y0 = yi = data[i++];
              var width = data[i++];
              var height = data[i++]; // Use fromLine

              fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
              break;

            case CMD.Z:
              xi = x0;
              yi = y0;
              break;
          } // Union


          min(min$1, min$1, min2);
          max(max$1, max$1, max2);
        } // No data


        if (i === 0) {
          min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;
        }

        return new BoundingRect(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);
      },

      /**
       * Rebuild path from current data
       * Rebuild path will not consider javascript implemented line dash.
       * @param {CanvasRenderingContext2D} ctx
       */
      rebuildPath: function rebuildPath(ctx) {
        var d = this.data;
        var x0, y0;
        var xi, yi;
        var x, y;
        var ux = this._ux;
        var uy = this._uy;
        var len$$1 = this._len;

        for (var i = 0; i < len$$1;) {
          var cmd = d[i++];

          if (i === 1) {
            // 如果第一个命令是 L, C, Q
            // 则 previous point 同绘制命令的第一个 point
            //
            // 第一个命令为 Arc 的情况下会在后面特殊处理
            xi = d[i];
            yi = d[i + 1];
            x0 = xi;
            y0 = yi;
          }

          switch (cmd) {
            case CMD.M:
              x0 = xi = d[i++];
              y0 = yi = d[i++];
              ctx.moveTo(xi, yi);
              break;

            case CMD.L:
              x = d[i++];
              y = d[i++]; // Not draw too small seg between

              if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len$$1 - 1) {
                ctx.lineTo(x, y);
                xi = x;
                yi = y;
              }

              break;

            case CMD.C:
              ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;

            case CMD.Q:
              ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;

            case CMD.A:
              var cx = d[i++];
              var cy = d[i++];
              var rx = d[i++];
              var ry = d[i++];
              var theta = d[i++];
              var dTheta = d[i++];
              var psi = d[i++];
              var fs = d[i++];
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              var isEllipse = Math.abs(rx - ry) > 1e-3;
              var endAngle = theta + dTheta;

              if (isEllipse) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              } else {
                ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
              }

              if (i === 1) {
                // 直接使用 arc 命令
                // 第一个命令起点还未定义
                x0 = mathCos$1(theta) * rx + cx;
                y0 = mathSin$1(theta) * ry + cy;
              }

              xi = mathCos$1(endAngle) * rx + cx;
              yi = mathSin$1(endAngle) * ry + cy;
              break;

            case CMD.R:
              x0 = xi = d[i];
              y0 = yi = d[i + 1];
              ctx.rect(d[i++], d[i++], d[i++], d[i++]);
              break;

            case CMD.Z:
              ctx.closePath();
              xi = x0;
              yi = y0;
          }
        }
      }
    };
    PathProxy.CMD = CMD;

    /**
     * 线段包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */
    function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth;
      var _a = 0;
      var _b = x0; // Quick reject

      if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
      }

      if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      } else {
        return Math.abs(x - x0) <= _l / 2;
      }

      var tmp = _a * x - y + _b;

      var _s = tmp * tmp / (_a * _a + 1);

      return _s <= _l / 2 * _l / 2;
    }

    /**
     * 三次贝塞尔曲线描边包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  x2
     * @param  {number}  y2
     * @param  {number}  x3
     * @param  {number}  y3
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */

    function containStroke$1(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth; // Quick reject

      if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
        return false;
      }

      var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
    }

    /**
     * 二次贝塞尔曲线描边包含判断
     * @param  {number}  x0
     * @param  {number}  y0
     * @param  {number}  x1
     * @param  {number}  y1
     * @param  {number}  x2
     * @param  {number}  y2
     * @param  {number}  lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {boolean}
     */

    function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth; // Quick reject

      if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
        return false;
      }

      var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
    }

    var PI2$1 = Math.PI * 2;
    function normalizeRadian(angle) {
      angle %= PI2$1;

      if (angle < 0) {
        angle += PI2$1;
      }

      return angle;
    }

    var PI2$2 = Math.PI * 2;
    /**
     * 圆弧描边包含判断
     * @param  {number}  cx
     * @param  {number}  cy
     * @param  {number}  r
     * @param  {number}  startAngle
     * @param  {number}  endAngle
     * @param  {boolean}  anticlockwise
     * @param  {number} lineWidth
     * @param  {number}  x
     * @param  {number}  y
     * @return {Boolean}
     */

    function containStroke$3(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }

      var _l = lineWidth;
      x -= cx;
      y -= cy;
      var d = Math.sqrt(x * x + y * y);

      if (d - _l > r || d + _l < r) {
        return false;
      }

      if (Math.abs(startAngle - endAngle) % PI2$2 < 1e-4) {
        // Is a circle
        return true;
      }

      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }

      if (startAngle > endAngle) {
        endAngle += PI2$2;
      }

      var angle = Math.atan2(y, x);

      if (angle < 0) {
        angle += PI2$2;
      }

      return angle >= startAngle && angle <= endAngle || angle + PI2$2 >= startAngle && angle + PI2$2 <= endAngle;
    }

    function windingLine(x0, y0, x1, y1, x, y) {
      if (y > y0 && y > y1 || y < y0 && y < y1) {
        return 0;
      } // Ignore horizontal line


      if (y1 === y0) {
        return 0;
      }

      var dir = y1 < y0 ? 1 : -1;
      var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon

      if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
      }

      var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as "contain".

      return x_ === x ? Infinity : x_ > x ? dir : 0;
    }

    var CMD$1 = PathProxy.CMD;
    var PI2$3 = Math.PI * 2;
    var EPSILON$2 = 1e-4;

    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON$2;
    } // 临时数组


    var roots = [-1, -1, -1];
    var extrema = [-1, -1];

    function swapExtrema() {
      var tmp = extrema[0];
      extrema[0] = extrema[1];
      extrema[1] = tmp;
    }

    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
      // Quick reject
      if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
        return 0;
      }

      var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);

      if (nRoots === 0) {
        return 0;
      } else {
        var w = 0;
        var nExtrema = -1;
        var y0_;
        var y1_;

        for (var i = 0; i < nRoots; i++) {
          var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon

          var unit = t === 0 || t === 1 ? 0.5 : 1;
          var x_ = cubicAt(x0, x1, x2, x3, t);

          if (x_ < x) {
            // Quick reject
            continue;
          }

          if (nExtrema < 0) {
            nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);

            if (extrema[1] < extrema[0] && nExtrema > 1) {
              swapExtrema();
            }

            y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);

            if (nExtrema > 1) {
              y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
            }
          }

          if (nExtrema === 2) {
            // 分成三段单调函数
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else if (t < extrema[1]) {
              w += y1_ < y0_ ? unit : -unit;
            } else {
              w += y3 < y1_ ? unit : -unit;
            }
          } else {
            // 分成两段单调函数
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else {
              w += y3 < y0_ ? unit : -unit;
            }
          }
        }

        return w;
      }
    }

    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
      // Quick reject
      if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
        return 0;
      }

      var nRoots = quadraticRootAt(y0, y1, y2, y, roots);

      if (nRoots === 0) {
        return 0;
      } else {
        var t = quadraticExtremum(y0, y1, y2);

        if (t >= 0 && t <= 1) {
          var w = 0;
          var y_ = quadraticAt(y0, y1, y2, t);

          for (var i = 0; i < nRoots; i++) {
            // Remove one endpoint.
            var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
            var x_ = quadraticAt(x0, x1, x2, roots[i]);

            if (x_ < x) {
              // Quick reject
              continue;
            }

            if (roots[i] < t) {
              w += y_ < y0 ? unit : -unit;
            } else {
              w += y2 < y_ ? unit : -unit;
            }
          }

          return w;
        } else {
          // Remove one endpoint.
          var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
          var x_ = quadraticAt(x0, x1, x2, roots[0]);

          if (x_ < x) {
            // Quick reject
            return 0;
          }

          return y2 < y0 ? unit : -unit;
        }
      }
    } // TODO
    // Arc 旋转


    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
      y -= cy;

      if (y > r || y < -r) {
        return 0;
      }

      var tmp = Math.sqrt(r * r - y * y);
      roots[0] = -tmp;
      roots[1] = tmp;
      var diff = Math.abs(startAngle - endAngle);

      if (diff < 1e-4) {
        return 0;
      }

      if (diff % PI2$3 < 1e-4) {
        // Is a circle
        startAngle = 0;
        endAngle = PI2$3;
        var dir = anticlockwise ? 1 : -1;

        if (x >= roots[0] + cx && x <= roots[1] + cx) {
          return dir;
        } else {
          return 0;
        }
      }

      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }

      if (startAngle > endAngle) {
        endAngle += PI2$3;
      }

      var w = 0;

      for (var i = 0; i < 2; i++) {
        var x_ = roots[i];

        if (x_ + cx > x) {
          var angle = Math.atan2(y, x_);
          var dir = anticlockwise ? 1 : -1;

          if (angle < 0) {
            angle = PI2$3 + angle;
          }

          if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
            if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
              dir = -dir;
            }

            w += dir;
          }
        }
      }

      return w;
    }

    function containPath(data, lineWidth, isStroke, x, y) {
      var w = 0;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;

      for (var i = 0; i < data.length;) {
        var cmd = data[i++]; // Begin a new subpath

        if (cmd === CMD$1.M && i > 1) {
          // Close previous subpath
          if (!isStroke) {
            w += windingLine(xi, yi, x0, y0, x, y);
          } // 如果被任何一个 subpath 包含
          // if (w !== 0) {
          //     return true;
          // }

        }

        if (i === 1) {
          // 如果第一个命令是 L, C, Q
          // 则 previous point 同绘制命令的第一个 point
          //
          // 第一个命令为 Arc 的情况下会在后面特殊处理
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }

        switch (cmd) {
          case CMD$1.M:
            // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
            // 在 closePath 的时候使用
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            break;

          case CMD$1.L:
            if (isStroke) {
              if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
              w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.C:
            if (isStroke) {
              if (containStroke$1(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.Q:
            if (isStroke) {
              if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }

            xi = data[i++];
            yi = data[i++];
            break;

          case CMD$1.A:
            // TODO Arc 判断的开销比较大
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++]; // TODO Arc 旋转

            i += 1;
            var anticlockwise = 1 - data[i++];
            var x1 = Math.cos(theta) * rx + cx;
            var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令

            if (i > 1) {
              w += windingLine(xi, yi, x1, y1, x, y);
            } else {
              // 第一个命令起点还未定义
              x0 = x1;
              y0 = y1;
            } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放


            var _x = (x - cx) * ry / rx + cx;

            if (isStroke) {
              if (containStroke$3(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                return true;
              }
            } else {
              w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
            }

            xi = Math.cos(theta + dTheta) * rx + cx;
            yi = Math.sin(theta + dTheta) * ry + cy;
            break;

          case CMD$1.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            var x1 = x0 + width;
            var y1 = y0 + height;

            if (isStroke) {
              if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              // FIXME Clockwise ?
              w += windingLine(x1, y0, x1, y1, x, y);
              w += windingLine(x0, y1, x0, y0, x, y);
            }

            break;

          case CMD$1.Z:
            if (isStroke) {
              if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              // Close a subpath
              w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含
              // FIXME subpaths may overlap
              // if (w !== 0) {
              //     return true;
              // }
            }

            xi = x0;
            yi = y0;
            break;
        }
      }

      if (!isStroke && !isAroundEqual(yi, y0)) {
        w += windingLine(xi, yi, x0, y0, x, y) || 0;
      }

      return w !== 0;
    }

    function contain(pathData, x, y) {
      return containPath(pathData, 0, false, x, y);
    }
    function containStroke$4(pathData, lineWidth, x, y) {
      return containPath(pathData, lineWidth, true, x, y);
    }

    var Pattern = function Pattern(image, repeat) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {image: ...}`, where this constructor will not be called.
      this.image = image;
      this.repeat = repeat; // Can be cloned

      this.type = 'pattern';
    };

    Pattern.prototype.getCanvasPattern = function (ctx) {
      return ctx.createPattern(this.image, this.repeat || 'repeat');
    };

    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
    var abs = Math.abs;
    var pathProxyForDraw = new PathProxy(true);
    /**
     * @alias module:zrender/graphic/Path
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */

    function Path(opts) {
      Displayable.call(this, opts);
      /**
       * @type {module:zrender/core/PathProxy}
       * @readOnly
       */

      this.path = null;
    }

    Path.prototype = {
      constructor: Path,
      type: 'path',
      __dirtyPath: true,
      strokeContainThreshold: 5,
      brush: function brush(ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;
        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);

        if (this.__dirty) {
          var rect; // Update gradient because bounding rect may changed

          if (hasFillGradient) {
            rect = rect || this.getBoundingRect();
            this._fillGradient = style.getGradient(ctx, fill, rect);
          }

          if (hasStrokeGradient) {
            rect = rect || this.getBoundingRect();
            this._strokeGradient = style.getGradient(ctx, stroke, rect);
          }
        } // Use the gradient or pattern


        if (hasFillGradient) {
          // PENDING If may have affect the state
          ctx.fillStyle = this._fillGradient;
        } else if (hasFillPattern) {
          ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }

        if (hasStrokeGradient) {
          ctx.strokeStyle = this._strokeGradient;
        } else if (hasStrokePattern) {
          ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }

        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;
        var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy

        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1]); // Proxy context
        // Rebuild path in following 2 cases
        // 1. Path is dirty
        // 2. Path needs javascript implemented lineDash stroking.
        //    In this case, lineDash information will not be saved in PathProxy

        if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
          path.beginPath(ctx); // Setting line dash before build path

          if (lineDash && !ctxLineDash) {
            path.setLineDash(lineDash);
            path.setLineDashOffset(lineDashOffset);
          }

          this.buildPath(path, this.shape, false); // Clear path dirty flag

          if (this.path) {
            this.__dirtyPath = false;
          }
        } else {
          // Replay path building
          ctx.beginPath();
          this.path.rebuildPath(ctx);
        }

        if (hasFill) {
          if (style.fillOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.fillOpacity * style.opacity;
            path.fill(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.fill(ctx);
          }
        }

        if (lineDash && ctxLineDash) {
          ctx.setLineDash(lineDash);
          ctx.lineDashOffset = lineDashOffset;
        }

        if (hasStroke) {
          if (style.strokeOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.strokeOpacity * style.opacity;
            path.stroke(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.stroke(ctx);
          }
        }

        if (lineDash && ctxLineDash) {
          // PENDING
          // Remove lineDash
          ctx.setLineDash([]);
        } // Draw rect text


        if (style.text != null) {
          // Only restore transform when needs draw text.
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
      // Like in circle
      buildPath: function buildPath(ctx, shapeCfg, inBundle) {},
      createPathProxy: function createPathProxy() {
        this.path = new PathProxy();
      },
      getBoundingRect: function getBoundingRect() {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;

        if (needsUpdateRect) {
          var path = this.path;

          if (!path) {
            // Create path on demand.
            path = this.path = new PathProxy();
          }

          if (this.__dirtyPath) {
            path.beginPath();
            this.buildPath(path, this.shape, false);
          }

          rect = path.getBoundingRect();
        }

        this._rect = rect;

        if (style.hasStroke()) {
          // Needs update rect with stroke lineWidth when
          // 1. Element changes scale or lineWidth
          // 2. Shape is changed
          var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());

          if (this.__dirty || needsUpdateRect) {
            rectWithStroke.copy(rect); // FIXME Must after updateTransform

            var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical

            var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill

            if (!style.hasFill()) {
              w = Math.max(w, this.strokeContainThreshold || 4);
            } // Consider line width
            // Line scale can't be 0;


            if (lineScale > 1e-10) {
              rectWithStroke.width += w / lineScale;
              rectWithStroke.height += w / lineScale;
              rectWithStroke.x -= w / lineScale / 2;
              rectWithStroke.y -= w / lineScale / 2;
            }
          } // Return rect with stroke


          return rectWithStroke;
        }

        return rect;
      },
      contain: function contain$$1(x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];

        if (rect.contain(x, y)) {
          var pathData = this.path.data;

          if (style.hasStroke()) {
            var lineWidth = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;

            if (lineScale > 1e-10) {
              // Only add extra hover lineWidth when there are no fill
              if (!style.hasFill()) {
                lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
              }

              if (containStroke$4(pathData, lineWidth / lineScale, x, y)) {
                return true;
              }
            }
          }

          if (style.hasFill()) {
            return contain(pathData, x, y);
          }
        }

        return false;
      },

      /**
       * @param  {boolean} dirtyPath
       */
      dirty: function dirty(dirtyPath) {
        if (dirtyPath == null) {
          dirtyPath = true;
        } // Only mark dirty, not mark clean


        if (dirtyPath) {
          this.__dirtyPath = dirtyPath;
          this._rect = null;
        }

        this.__dirty = this.__dirtyText = true;
        this.__zr && this.__zr.refresh(); // Used as a clipping path

        if (this.__clipTarget) {
          this.__clipTarget.dirty();
        }
      },

      /**
       * Alias for animate('shape')
       * @param {boolean} loop
       */
      animateShape: function animateShape(loop) {
        return this.animate('shape', loop);
      },
      // Overwrite attrKV
      attrKV: function attrKV(key, value) {
        // FIXME
        if (key === 'shape') {
          this.setShape(value);
          this.__dirtyPath = true;
          this._rect = null;
        } else {
          Displayable.prototype.attrKV.call(this, key, value);
        }
      },

      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setShape: function setShape(key, value) {
        var shape = this.shape; // Path from string may not have shape

        if (shape) {
          if (isObject(key)) {
            for (var name in key) {
              if (key.hasOwnProperty(name)) {
                shape[name] = key[name];
              }
            }
          } else {
            shape[key] = value;
          }

          this.dirty(true);
        }

        return this;
      },
      getLineScale: function getLineScale() {
        var m = this.transform; // Get the line scale.
        // Determinant of `m` means how much the area is enlarged by the
        // transformation. So its square root can be used as a scale factor
        // for width.

        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
      }
    };
    /**
     * 扩展一个 Path element, 比如星形，圆等。
     * Extend a path element
     * @param {Object} props
     * @param {string} props.type Path type
     * @param {Function} props.init Initialize
     * @param {Function} props.buildPath Overwrite buildPath method
     * @param {Object} [props.style] Extended default style config
     * @param {Object} [props.shape] Extended default shape config
     */

    Path.extend = function (defaults$$1) {
      var Sub = function Sub(opts) {
        Path.call(this, opts);

        if (defaults$$1.style) {
          // Extend default style
          this.style.extendFrom(defaults$$1.style, false);
        } // Extend default shape


        var defaultShape = defaults$$1.shape;

        if (defaultShape) {
          this.shape = this.shape || {};
          var thisShape = this.shape;

          for (var name in defaultShape) {
            if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
              thisShape[name] = defaultShape[name];
            }
          }
        }

        defaults$$1.init && defaults$$1.init.call(this, opts);
      };

      inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象

      for (var name in defaults$$1) {
        // Extending prototype values and methods
        if (name !== 'style' && name !== 'shape') {
          Sub.prototype[name] = defaults$$1[name];
        }
      }

      return Sub;
    };

    inherits(Path, Displayable);

    /**
     * 圆形
     * @module zrender/shape/Circle
     */
    var Circle = Path.extend({
      type: 'circle',
      shape: {
        cx: 0,
        cy: 0,
        r: 0
      },
      buildPath: function buildPath(ctx, shape, inBundle) {
        // Better stroking in ShapeBundle
        // Always do it may have performence issue ( fill may be 2x more cost)
        if (inBundle) {
          ctx.moveTo(shape.cx + shape.r, shape.cy);
        } // else {
        //     if (ctx.allocate && !ctx.data.length) {
        //         ctx.allocate(ctx.CMD_MEM_SIZE.A);
        //     }
        // }
        // Better stroking in ShapeBundle
        // ctx.moveTo(shape.cx + shape.r, shape.cy);


        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
      }
    });

    /**
     * @alias zrender/graphic/Text
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */

    var Text = function Text(opts) {
      // jshint ignore:line
      Displayable.call(this, opts);
    };

    Text.prototype = {
      constructor: Text,
      type: 'text',
      brush: function brush(ctx, prevEl) {
        var style = this.style; // Optimize, avoid normalize every time.

        this.__dirty && normalizeTextStyle(style, true); // Use props with prefix 'text'.

        style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
        var text = style.text; // Convert to string

        text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job
        // is in textHelper.renderText, and performance of text render should
        // be considered.
        // style.bind(ctx, this, prevEl);

        if (!needDrawText(text, style)) {
          // KeepPrevEl, because the current el.style is not applied
          // and should not be used as cache.
          return true;
        }

        this.setTransform(ctx);
        renderText(this, ctx, text, style, null, prevEl);
        this.restoreTransform(ctx);
      },
      getBoundingRect: function getBoundingRect$$1() {
        var style = this.style; // Optimize, avoid normalize every time.

        this.__dirty && normalizeTextStyle(style, true);

        if (!this._rect) {
          var text = style.text;
          text != null ? text += '' : text = '';
          var rect = getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich);
          rect.x += style.x || 0;
          rect.y += style.y || 0;

          if (getStroke(style.textStroke, style.textStrokeWidth)) {
            var w = style.textStrokeWidth;
            rect.x -= w / 2;
            rect.y -= w / 2;
            rect.width += w;
            rect.height += w;
          }

          this._rect = rect;
        }

        return this._rect;
      }
    };
    inherits(Text, Displayable);

    var CMD$2 = PathProxy.CMD;
    var points = [[], [], []];
    var mathSqrt$2 = Math.sqrt;
    var mathAtan2 = Math.atan2;
    function transformPath (path, m) {
      var data = path.data;
      var cmd;
      var nPoint;
      var i;
      var j;
      var k;
      var p;
      var M = CMD$2.M;
      var C = CMD$2.C;
      var L = CMD$2.L;
      var R = CMD$2.R;
      var A = CMD$2.A;
      var Q = CMD$2.Q;

      for (i = 0, j = 0; i < data.length;) {
        cmd = data[i++];
        j = i;
        nPoint = 0;

        switch (cmd) {
          case M:
            nPoint = 1;
            break;

          case L:
            nPoint = 1;
            break;

          case C:
            nPoint = 3;
            break;

          case Q:
            nPoint = 2;
            break;

          case A:
            var x = m[4];
            var y = m[5];
            var sx = mathSqrt$2(m[0] * m[0] + m[1] * m[1]);
            var sy = mathSqrt$2(m[2] * m[2] + m[3] * m[3]);
            var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx

            data[i] *= sx;
            data[i++] += x; // cy

            data[i] *= sy;
            data[i++] += y; // Scale rx and ry
            // FIXME Assume psi is 0 here

            data[i++] *= sx;
            data[i++] *= sy; // Start angle

            data[i++] += angle; // end angle

            data[i++] += angle; // FIXME psi

            i += 2;
            j = i;
            break;

          case R:
            // x0, y0
            p[0] = data[i++];
            p[1] = data[i++];
            applyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1]; // x1, y1

            p[0] += data[i++];
            p[1] += data[i++];
            applyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
        }

        for (k = 0; k < nPoint; k++) {
          var p = points[k];
          p[0] = data[i++];
          p[1] = data[i++];
          applyTransform(p, p, m); // Write back

          data[j++] = p[0];
          data[j++] = p[1];
        }
      }
    }

    // var cc = [
    //     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
    //     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
    // ];

    var mathSqrt$3 = Math.sqrt;
    var mathSin$2 = Math.sin;
    var mathCos$2 = Math.cos;
    var PI$1 = Math.PI;

    var vMag = function vMag(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };

    var vRatio = function vRatio(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };

    var vAngle = function vAngle(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };

    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
      var psi = psiDeg * (PI$1 / 180.0);
      var xp = mathCos$2(psi) * (x1 - x2) / 2.0 + mathSin$2(psi) * (y1 - y2) / 2.0;
      var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2.0 + mathCos$2(psi) * (y1 - y2) / 2.0;
      var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

      if (lambda > 1) {
        rx *= mathSqrt$3(lambda);
        ry *= mathSqrt$3(lambda);
      }

      var f = (fa === fs ? -1 : 1) * mathSqrt$3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
      var cxp = f * rx * yp / ry;
      var cyp = f * -ry * xp / rx;
      var cx = (x1 + x2) / 2.0 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
      var cy = (y1 + y2) / 2.0 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
      var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
      var u = [(xp - cxp) / rx, (yp - cyp) / ry];
      var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
      var dTheta = vAngle(u, v);

      if (vRatio(u, v) <= -1) {
        dTheta = PI$1;
      }

      if (vRatio(u, v) >= 1) {
        dTheta = 0;
      }

      if (fs === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * PI$1;
      }

      if (fs === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * PI$1;
      }

      path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
    }

    var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:
    // (1) delimiter can be comma or space, where continuous commas
    // or spaces should be seen as one comma.
    // (2) value can be like:
    // '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',
    // 'l-.5E1,54', '121-23-44-11' (no delimiter)

    var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\s,]+/;

    function createPathProxyFromString(data) {
      if (!data) {
        return new PathProxy();
      } // var data = data.replace(/-/g, ' -')
      //     .replace(/  /g, ' ')
      //     .replace(/ /g, ',')
      //     .replace(/,,/g, ',');
      // var n;
      // create pipes so that we can split the data
      // for (n = 0; n < cc.length; n++) {
      //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
      // }
      // data = data.replace(/-/g, ',-');
      // create array
      // var arr = cs.split('|');
      // init context point


      var cpx = 0;
      var cpy = 0;
      var subpathX = cpx;
      var subpathY = cpy;
      var prevCmd;
      var path = new PathProxy();
      var CMD = PathProxy.CMD; // commandReg.lastIndex = 0;
      // var cmdResult;
      // while ((cmdResult = commandReg.exec(data)) != null) {
      //     var cmdStr = cmdResult[1];
      //     var cmdContent = cmdResult[2];

      var cmdList = data.match(commandReg);

      for (var l = 0; l < cmdList.length; l++) {
        var cmdText = cmdList[l];
        var cmdStr = cmdText.charAt(0);
        var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.
        // var p = cmdContent.split(valueSplitReg);
        // var pLen = 0;
        // for (var i = 0; i < p.length; i++) {
        //     // '' and other invalid str => NaN
        //     var val = parseFloat(p[i]);
        //     !isNaN(val) && (p[pLen++] = val);
        // }

        var p = cmdText.match(numberReg) || [];
        var pLen = p.length;

        for (var i = 0; i < pLen; i++) {
          p[i] = parseFloat(p[i]);
        }

        var off = 0;

        while (off < pLen) {
          var ctlPtx;
          var ctlPty;
          var rx;
          var ry;
          var psi;
          var fa;
          var fs;
          var x1 = cpx;
          var y1 = cpy; // convert l, H, h, V, and v to L

          switch (cmdStr) {
            case 'l':
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'L':
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'm':
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = 'l';
              break;

            case 'M':
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = 'L';
              break;

            case 'h':
              cpx += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'H':
              cpx = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'v':
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'V':
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;

            case 'C':
              cmd = CMD.C;
              path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
              cpx = p[off - 2];
              cpy = p[off - 1];
              break;

            case 'c':
              cmd = CMD.C;
              path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
              cpx += p[off - 2];
              cpy += p[off - 1];
              break;

            case 'S':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cmd = CMD.C;
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;

            case 's':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cmd = CMD.C;
              x1 = cpx + p[off++];
              y1 = cpy + p[off++];
              cpx += p[off++];
              cpy += p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;

            case 'Q':
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;

            case 'q':
              x1 = p[off++] + cpx;
              y1 = p[off++] + cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;

            case 'T':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;

            case 't':
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;

              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }

              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;

            case 'A':
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;

            case 'a':
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
          }
        }

        if (cmdStr === 'z' || cmdStr === 'Z') {
          cmd = CMD.Z;
          path.addData(cmd); // z may be in the middle of the path.

          cpx = subpathX;
          cpy = subpathY;
        }

        prevCmd = cmd;
      }

      path.toStatic();
      return path;
    } // TODO Optimize double memory cost problem

    /**
     * Catmull-Rom spline 插值折线
     * @module zrender/shape/util/smoothSpline
     * @author pissang (https://www.github.com/pissang)
     *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         errorrik (errorrik@gmail.com)
     */
    /**
     * @inner
     */

    function interpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    /**
     * @alias module:zrender/shape/util/smoothSpline
     * @param {Array} points 线段顶点数组
     * @param {boolean} isLoop
     * @return {Array}
     */


    function smoothSpline (points, isLoop) {
      var len$$1 = points.length;
      var ret = [];
      var distance$$1 = 0;

      for (var i = 1; i < len$$1; i++) {
        distance$$1 += distance(points[i - 1], points[i]);
      }

      var segs = distance$$1 / 2;
      segs = segs < len$$1 ? len$$1 : segs;

      for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len$$1 : len$$1 - 1);
        var idx = Math.floor(pos);
        var w = pos - idx;
        var p0;
        var p1 = points[idx % len$$1];
        var p2;
        var p3;

        if (!isLoop) {
          p0 = points[idx === 0 ? idx : idx - 1];
          p2 = points[idx > len$$1 - 2 ? len$$1 - 1 : idx + 1];
          p3 = points[idx > len$$1 - 3 ? len$$1 - 1 : idx + 2];
        } else {
          p0 = points[(idx - 1 + len$$1) % len$$1];
          p2 = points[(idx + 1) % len$$1];
          p3 = points[(idx + 2) % len$$1];
        }

        var w2 = w * w;
        var w3 = w * w2;
        ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
      }

      return ret;
    }

    /**
     * 贝塞尔平滑曲线
     * @module zrender/shape/util/smoothBezier
     * @author pissang (https://www.github.com/pissang)
     *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
     *         errorrik (errorrik@gmail.com)
     */
    /**
     * 贝塞尔平滑曲线
     * @alias module:zrender/shape/util/smoothBezier
     * @param {Array} points 线段顶点数组
     * @param {number} smooth 平滑等级, 0-1
     * @param {boolean} isLoop
     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
     *                           整个折线的包围盒做一个并集用来约束控制点。
     * @param {Array} 计算出来的控制点数组
     */

    function smoothBezier (points, smooth, isLoop, constraint) {
      var cps = [];
      var v = [];
      var v1 = [];
      var v2 = [];
      var prevPoint;
      var nextPoint;
      var min$$1;
      var max$$1;

      if (constraint) {
        min$$1 = [Infinity, Infinity];
        max$$1 = [-Infinity, -Infinity];

        for (var i = 0, len$$1 = points.length; i < len$$1; i++) {
          min(min$$1, min$$1, points[i]);
          max(max$$1, max$$1, points[i]);
        } // 与指定的包围盒做并集


        min(min$$1, min$$1, constraint[0]);
        max(max$$1, max$$1, constraint[1]);
      }

      for (var i = 0, len$$1 = points.length; i < len$$1; i++) {
        var point = points[i];

        if (isLoop) {
          prevPoint = points[i ? i - 1 : len$$1 - 1];
          nextPoint = points[(i + 1) % len$$1];
        } else {
          if (i === 0 || i === len$$1 - 1) {
            cps.push(clone$2(points[i]));
            continue;
          } else {
            prevPoint = points[i - 1];
            nextPoint = points[i + 1];
          }
        }

        sub(v, nextPoint, prevPoint); // use degree to scale the handle length

        scale$1(v, v, smooth);
        var d0 = distance(point, prevPoint);
        var d1 = distance(point, nextPoint);
        var sum = d0 + d1;

        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }

        scale$1(v1, v, -d0);
        scale$1(v2, v, d1);
        var cp0 = add([], point, v1);
        var cp1 = add([], point, v2);

        if (constraint) {
          max(cp0, cp0, min$$1);
          min(cp0, cp0, max$$1);
          max(cp1, cp1, min$$1);
          min(cp1, cp1, max$$1);
        }

        cps.push(cp0);
        cps.push(cp1);
      }

      if (isLoop) {
        cps.push(cps.shift());
      }

      return cps;
    }

    function buildPath$1(ctx, shape, closePath) {
      var points = shape.points;
      var smooth = shape.smooth;

      if (points && points.length >= 2) {
        if (smooth && smooth !== 'spline') {
          var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
          ctx.moveTo(points[0][0], points[0][1]);
          var len = points.length;

          for (var i = 0; i < (closePath ? len : len - 1); i++) {
            var cp1 = controlPoints[i * 2];
            var cp2 = controlPoints[i * 2 + 1];
            var p = points[(i + 1) % len];
            ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
          }
        } else {
          if (smooth === 'spline') {
            points = smoothSpline(points, closePath);
          }

          ctx.moveTo(points[0][0], points[0][1]);

          for (var i = 1, l = points.length; i < l; i++) {
            ctx.lineTo(points[i][0], points[i][1]);
          }
        }

        closePath && ctx.closePath();
      }
    }

    /**
     * 多边形
     * @module zrender/shape/Polygon
     */
    var Polygon = Path.extend({
      type: 'polygon',
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      buildPath: function buildPath(ctx, shape) {
        buildPath$1(ctx, shape, true);
      }
    });

    /**
     * @module zrender/graphic/shape/Polyline
     */
    var Polyline = Path.extend({
      type: 'polyline',
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        buildPath$1(ctx, shape, false);
      }
    });

    /**
     * 直线
     * @module zrender/graphic/shape/Line
     */
    var Line = Path.extend({
      type: 'line',
      shape: {
        // Start point
        x1: 0,
        y1: 0,
        // End point
        x2: 0,
        y2: 0,
        percent: 1
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var percent = shape.percent;

        if (percent === 0) {
          return;
        }

        ctx.moveTo(x1, y1);

        if (percent < 1) {
          x2 = x1 * (1 - percent) + x2 * percent;
          y2 = y1 * (1 - percent) + y2 * percent;
        }

        ctx.lineTo(x2, y2);
      },

      /**
       * Get point at percent
       * @param  {number} percent
       * @return {Array.<number>}
       */
      pointAt: function pointAt(p) {
        var shape = this.shape;
        return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
      }
    });

    /**
     * n角星（n>3）
     * @module zrender/graphic/shape/Star
     */
    var PI$2 = Math.PI;
    var cos = Math.cos;
    var sin = Math.sin;
    var Star = Path.extend({
      type: 'star',
      shape: {
        cx: 0,
        cy: 0,
        n: 3,
        r0: null,
        r: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var n = shape.n;

        if (!n || n < 2) {
          return;
        }

        var x = shape.cx;
        var y = shape.cy;
        var r = shape.r;
        var r0 = shape.r0; // 如果未指定内部顶点外接圆半径，则自动计算

        if (r0 == null) {
          r0 = n > 4 // 相隔的外部顶点的连线的交点，
          // 被取为内部交点，以此计算r0
          ? r * cos(2 * PI$2 / n) / cos(PI$2 / n) // 二三四角星的特殊处理
          : r / 3;
        }

        var dStep = PI$2 / n;
        var deg = -PI$2 / 2;
        var xStart = x + r * cos(deg);
        var yStart = y + r * sin(deg);
        deg += dStep; // 记录边界点，用于判断inside

        ctx.moveTo(xStart, yStart);

        for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
          ri = i % 2 === 0 ? r0 : r;
          ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
          deg += dStep;
        }

        ctx.closePath();
      }
    });

    /**
     * 圆弧
     * @module zrender/graphic/shape/Arc
     */
    var Arc = Path.extend({
      type: 'arc',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      }
    });

    /**
     * 心形
     * @module zrender/graphic/shape/Heart
     */
    var Heart = Path.extend({
      type: 'heart',
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.width;
        var b = shape.height;
        ctx.moveTo(x, y);
        ctx.bezierCurveTo(x + a / 2, y - b * 2 / 3, x + a * 2, y + b / 3, x, y + b);
        ctx.bezierCurveTo(x - a * 2, y + b / 3, x - a / 2, y - b * 2 / 3, x, y);
      }
    });

    /**
     * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
     * @module zrender/graphic/Group
     * @example
     *     var Group = require('zrender/container/Group');
     *     var Circle = require('zrender/graphic/shape/Circle');
     *     var g = new Group();
     *     g.position[0] = 100;
     *     g.position[1] = 100;
     *     g.add(new Circle({
     *         style: {
     *             x: 100,
     *             y: 100,
     *             r: 20,
     *         }
     *     }));
     *     zr.add(g);
     */
    /**
     * @alias module:zrender/graphic/Group
     * @constructor
     * @extends module:zrender/mixin/Transformable
     * @extends module:zrender/mixin/Eventful
     */

    var Group = function Group(opts) {
      opts = opts || {};
      Element.call(this, opts);

      for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
          this[key] = opts[key];
        }
      }

      this._children = [];
      this.__storage = null;
      this.__dirty = true;
    };

    Group.prototype = {
      constructor: Group,
      isGroup: true,

      /**
       * @type {string}
       */
      type: 'group',

      /**
       * 所有子孙元素是否响应鼠标事件
       * @name module:/zrender/container/Group#silent
       * @type {boolean}
       * @default false
       */
      silent: false,

      /**
       * @return {Array.<module:zrender/Element>}
       */
      children: function children() {
        return this._children.slice();
      },

      /**
       * 获取指定 index 的儿子节点
       * @param  {number} idx
       * @return {module:zrender/Element}
       */
      childAt: function childAt(idx) {
        return this._children[idx];
      },

      /**
       * 获取指定名字的儿子节点
       * @param  {string} name
       * @return {module:zrender/Element}
       */
      childOfName: function childOfName(name) {
        var children = this._children;

        for (var i = 0; i < children.length; i++) {
          if (children[i].name === name) {
            return children[i];
          }
        }
      },

      /**
       * @return {number}
       */
      childCount: function childCount() {
        return this._children.length;
      },

      /**
       * 添加子节点到最后
       * @param {module:zrender/Element} child
       */
      add: function add(child) {
        if (child && child !== this && child.parent !== this) {
          this._children.push(child);

          this._doAdd(child);
        }

        return this;
      },

      /**
       * 添加子节点在 nextSibling 之前
       * @param {module:zrender/Element} child
       * @param {module:zrender/Element} nextSibling
       */
      addBefore: function addBefore(child, nextSibling) {
        if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
          var children = this._children;
          var idx = children.indexOf(nextSibling);

          if (idx >= 0) {
            children.splice(idx, 0, child);

            this._doAdd(child);
          }
        }

        return this;
      },
      _doAdd: function _doAdd(child) {
        if (child.parent) {
          child.parent.remove(child);
        }

        child.parent = this;
        var storage = this.__storage;
        var zr = this.__zr;

        if (storage && storage !== child.__storage) {
          storage.addToStorage(child);

          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }

        zr && zr.refresh();
      },

      /**
       * 移除子节点
       * @param {module:zrender/Element} child
       */
      remove: function remove(child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;
        var idx = indexOf(children, child);

        if (idx < 0) {
          return this;
        }

        children.splice(idx, 1);
        child.parent = null;

        if (storage) {
          storage.delFromStorage(child);

          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }

        zr && zr.refresh();
        return this;
      },

      /**
       * 移除所有子节点
       */
      removeAll: function removeAll() {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;

        for (i = 0; i < children.length; i++) {
          child = children[i];

          if (storage) {
            storage.delFromStorage(child);

            if (child instanceof Group) {
              child.delChildrenFromStorage(storage);
            }
          }

          child.parent = null;
        }

        children.length = 0;
        return this;
      },

      /**
       * 遍历所有子节点
       * @param  {Function} cb
       * @param  {}   context
       */
      eachChild: function eachChild(cb, context) {
        var children = this._children;

        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          cb.call(context, child, i);
        }

        return this;
      },

      /**
       * 深度优先遍历所有子孙节点
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function traverse(cb, context) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          cb.call(context, child);

          if (child.type === 'group') {
            child.traverse(cb, context);
          }
        }

        return this;
      },
      addChildrenToStorage: function addChildrenToStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.addToStorage(child);

          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
      },
      delChildrenFromStorage: function delChildrenFromStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.delFromStorage(child);

          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
      },
      dirty: function dirty() {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
      },

      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function getBoundingRect(includeChildren) {
        // TODO Caching
        var rect = null;
        var tmpRect = new BoundingRect(0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];

        for (var i = 0; i < children.length; i++) {
          var child = children[i];

          if (child.ignore || child.invisible) {
            continue;
          }

          var childRect = child.getBoundingRect();
          var transform = child.getLocalTransform(tmpMat); // TODO
          // The boundingRect cacluated by transforming original
          // rect may be bigger than the actual bundingRect when rotation
          // is used. (Consider a circle rotated aginst its center, where
          // the actual boundingRect should be the same as that not be
          // rotated.) But we can not find better approach to calculate
          // actual boundingRect yet, considering performance.

          if (transform) {
            tmpRect.copy(childRect);
            tmpRect.applyTransform(transform);
            rect = rect || tmpRect.clone();
            rect.union(tmpRect);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }

        return rect || tmpRect;
      }
    };
    inherits(Group, Element);

    /**
     * @alias zrender/graphic/Image
     * @extends module:zrender/graphic/Displayable
     * @constructor
     * @param {Object} opts
     */

    function ZImage(opts) {
      Displayable.call(this, opts);
    }

    ZImage.prototype = {
      constructor: ZImage,
      type: 'image',
      brush: function brush(ctx, prevEl) {
        var style = this.style;
        var src = style.image; // Must bind each time

        style.bind(ctx, this, prevEl);
        var image = this._image = createOrUpdateImage(src, this._image, this, this.onload);

        if (!image || !isImageReady(image)) {
          return;
        } // 图片已经加载完成
        // if (image.nodeName.toUpperCase() == 'IMG') {
        //     if (!image.complete) {
        //         return;
        //     }
        // }
        // Else is canvas


        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image.width / image.height;

        if (width == null && height != null) {
          // Keep image/height ratio
          width = height * aspect;
        } else if (height == null && width != null) {
          height = width / aspect;
        } else if (width == null && height == null) {
          width = image.width;
          height = image.height;
        } // 设置transform


        this.setTransform(ctx);

        if (style.sWidth && style.sHeight) {
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
          var sx = style.sx;
          var sy = style.sy;
          var sWidth = width - sx;
          var sHeight = height - sy;
          ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
          ctx.drawImage(image, x, y, width, height);
        } // Draw rect text


        if (style.text != null) {
          // Only restore transform when needs draw text.
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      getBoundingRect: function getBoundingRect() {
        var style = this.style;

        if (!this._rect) {
          this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
        }

        return this._rect;
      }
    };
    inherits(ZImage, Displayable);

    /**
     * echarts设备环境识别
     *
     * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
     * @author firede[firede@firede.us]
     * @desc thanks zepto.
     */
    var env = {};

    if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
      // In Weixin Application
      env = {
        browser: {},
        os: {},
        node: false,
        wxa: true,
        // Weixin Application
        canvasSupported: true,
        svgSupported: false,
        touchEventsSupported: true,
        domSupported: false
      };
    } else if (typeof document === 'undefined' && typeof self !== 'undefined') {
      // In worker
      env = {
        browser: {},
        os: {},
        node: false,
        worker: true,
        canvasSupported: true,
        domSupported: false
      };
    } else if (typeof navigator === 'undefined') {
      // In node
      env = {
        browser: {},
        os: {},
        node: true,
        worker: false,
        // Assume canvas is supported
        canvasSupported: true,
        svgSupported: true,
        domSupported: false
      };
    } else {
      env = detect(navigator.userAgent);
    }

    var env$1 = env; // Zepto.js
    // (c) 2010-2013 Thomas Fuchs
    // Zepto.js may be freely distributed under the MIT license.

    function detect(ua) {
      var os = {};
      var browser = {}; // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
      // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
      // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
      // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
      // var touchpad = webos && ua.match(/TouchPad/);
      // var kindle = ua.match(/Kindle\/([\d.]+)/);
      // var silk = ua.match(/Silk\/([\d._]+)/);
      // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
      // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
      // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
      // var playbook = ua.match(/PlayBook/);
      // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);

      var firefox = ua.match(/Firefox\/([\d.]+)/); // var safari = webkit && ua.match(/Mobile\//) && !chrome;
      // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

      var ie = ua.match(/MSIE\s([\d.]+)/) // IE 11 Trident/7.0; rv:11.0
      || ua.match(/Trident\/.+?rv:(([\d.]+))/);
      var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

      var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:
      // - discern (more) between multiple browsers on android
      // - decide if kindle fire in silk mode is android or not
      // - Firefox on Android doesn't specify the Android version
      // - possibly devide in os, device and browser hashes
      // if (browser.webkit = !!webkit) browser.version = webkit[1];
      // if (android) os.android = true, os.version = android[2];
      // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
      // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
      // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
      // if (webos) os.webos = true, os.version = webos[2];
      // if (touchpad) os.touchpad = true;
      // if (blackberry) os.blackberry = true, os.version = blackberry[2];
      // if (bb10) os.bb10 = true, os.version = bb10[2];
      // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
      // if (playbook) browser.playbook = true;
      // if (kindle) os.kindle = true, os.version = kindle[1];
      // if (silk) browser.silk = true, browser.version = silk[1];
      // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
      // if (chrome) browser.chrome = true, browser.version = chrome[1];

      if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
      } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
      // if (webview) browser.webview = true;


      if (ie) {
        browser.ie = true;
        browser.version = ie[1];
      }

      if (edge) {
        browser.edge = true;
        browser.version = edge[1];
      } // It is difficult to detect WeChat in Win Phone precisely, because ua can
      // not be set on win phone. So we do not consider Win Phone.


      if (weChat) {
        browser.weChat = true;
      } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
      //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
      // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
      //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
      //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));


      return {
        browser: browser,
        os: os,
        node: false,
        // 原生canvas支持，改极端点了
        // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
        canvasSupported: !!document.createElement('canvas').getContext,
        svgSupported: typeof SVGRect !== 'undefined',
        // works on most browsers
        // IE10/11 does not support touch event, and MS Edge supports them but not by
        // default, so we dont check navigator.maxTouchPoints for them here.
        touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
        // <http://caniuse.com/#search=pointer%20event>.
        pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer
        // events currently. So we dont use that on other browsers unless tested sufficiently.
        // Although IE 10 supports pointer event, it use old style and is different from the
        // standard. So we exclude that. (IE 10 is hardly used on touch device)
        && (browser.edge || browser.ie && browser.version >= 11),
        // passiveSupported: detectPassiveSupport()
        domSupported: typeof document !== 'undefined'
      };
    } // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
    // function detectPassiveSupport() {
    //     // Test via a getter in the options object to see if the passive property is accessed
    //     var supportsPassive = false;
    //     try {
    //         var opts = Object.defineProperty({}, 'passive', {
    //             get: function() {
    //                 supportsPassive = true;
    //             }
    //         });
    //         window.addEventListener('testPassive', function() {}, opts);
    //     } catch (e) {
    //     }
    //     return supportsPassive;
    // }

    // where exception "unexpected call to method or property access"
    // might be thrown when calling ctx.fill or ctx.stroke after a path
    // whose area size is zero is drawn and ctx.clip() is called and
    // shadowBlur is set. See #4572, #3112, #5777.
    // (e.g.,
    //  ctx.moveTo(10, 10);
    //  ctx.lineTo(20, 10);
    //  ctx.closePath();
    //  ctx.clip();
    //  ctx.shadowBlur = 10;
    //  ...
    //  ctx.fill();
    // )

    var shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];
    function fixClipWithShadow (orignalBrush) {
      // version string can be: '11.0'
      return env$1.browser.ie && env$1.browser.version >= 11 ? function () {
        var clipPaths = this.__clipPaths;
        var style = this.style;
        var modified;

        if (clipPaths) {
          for (var i = 0; i < clipPaths.length; i++) {
            var clipPath = clipPaths[i];
            var shape = clipPath && clipPath.shape;
            var type = clipPath && clipPath.type;

            if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {
              for (var j = 0; j < shadowTemp.length; j++) {
                // It is save to put shadowTemp static, because shadowTemp
                // will be all modified each item brush called.
                shadowTemp[j][2] = style[shadowTemp[j][0]];
                style[shadowTemp[j][0]] = shadowTemp[j][1];
              }

              modified = true;
              break;
            }
          }
        }

        orignalBrush.apply(this, arguments);

        if (modified) {
          for (var j = 0; j < shadowTemp.length; j++) {
            style[shadowTemp[j][0]] = shadowTemp[j][2];
          }
        }
      } : orignalBrush;
    }

    /**
     * ZRender提供的rect支持的圆角，类似于css中的border-radius.
     * 但是5.0中的则需要像SVG的rect一样支持rx和ry，这边重写一个新的rect
     */

    var Rect = Path.extend({
      type: 'rect',
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        r: 0
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function buildPath(ctx, _ref) {
        var x = _ref.x,
            y = _ref.y,
            width = _ref.width,
            height = _ref.height,
            r = _ref.r;

        if (!r) {
          ctx.rect(x, y, width, height);
        } else {
          var min = Math.min;
          var w = width,
              hw = w / 2,
              h = height,
              hh = h / 2;
          var wr = min(hw, r),
              hr = min(hh, r);
          var left = x,
              right = x + w,
              top = y,
              bottom = y + h;
          var x1 = left + wr,
              x2 = right - wr,
              y1 = top + hr,
              y2 = bottom - hr;
          ctx.moveTo(x2, top);
          ctx.quadraticCurveTo(right, top, right, y1);
          ctx.lineTo(right, y2);
          ctx.quadraticCurveTo(right, bottom, x2, bottom);
          ctx.lineTo(x1, bottom);
          ctx.quadraticCurveTo(left, bottom, left, y2);
          ctx.lineTo(left, y1);
          ctx.quadraticCurveTo(left, top, x1, top);
          ctx.lineTo(x2, top);
        }
      }
    });

    var Sector = Path.extend({
      type: 'sector',
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var cos = Math.cos,
            sin = Math.sin;
        var c1 = cos(startAngle),
            c2 = cos(endAngle),
            s1 = sin(startAngle),
            s2 = sin(endAngle); // hollow circle

        if (Math.abs(startAngle - endAngle) >= Math.PI * 2) {
          ctx.moveTo(c1 * r + x, s1 * r + y);
          ctx.arc(x, y, r, startAngle, endAngle, !clockwise);

          if (r0 !== 0) {
            ctx.moveTo(c2 * r0 + x, s2 * r0 + y);
            ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
          }
        } else {
          ctx.moveTo(c1 * r0 + x, s1 * r0 + y);
          ctx.lineTo(c1 * r + x, s1 * r + y);
          ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
          ctx.lineTo(c2 * r0 + x, s2 * r0 + y);
          r0 !== 0 && ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }

        ctx.closePath();
      }
    });

    // [100, ) e.g. Legend
    var StaticLayerZ = 100; // [0, 99]
    var HoverLayerZ = 10;
    var NormalLayerZ = 0;
    var RegionLineLayerZ = 15; // 数据挖掘的预测区间线

    var LabelLayerZ = 20; // 标签

    var AnnotationZ = 30; // 注释
    // 轴线

    var AxisLineZ = 50;
    var PanningLineZ = 100; // ZLevel
    var GuideZLevel = 30;
    var TooltipZLevel = 50;
    var EffectLineZLevel = 25; // -1
    // a special case for Pillar's shadow
    // for css selector `canvas[data-zr-dom-id="zr_-1"]`

    var ShadowLayerZ = -1;
    var GridLineZ = -10; // [-201, -101]
    // for map animation

    var MirrorSize = 200;
    var GetMirrorLayerZ = function GetMirrorLayerZ(z) {
      return z - MirrorSize;
    };

    /**
     * Created by eason on 15/6/24.
     */
    //
    //Copyright (c) 2014 Ga?tan Renaudeau
    //
    //Permission is hereby granted, free of charge, to any person
    //obtaining a copy of this software and associated documentation
    //files (the "Software"), to deal in the Software without
    //restriction, including without limitation the rights to use,
    //    copy, modify, merge, publish, distribute, sublicense, and/or sell
    //copies of the Software, and to permit persons to whom the
    //Software is furnished to do so, subject to the following
    //conditions:
    //
    //    The above copyright notice and this permission notice shall be
    //included in all copies or substantial portions of the Software.
    //
    //    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    //    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    //OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    //NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    //HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    //    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    //FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    //OTHER DEALINGS IN THE SOFTWARE.
    var global$2 = window; // These values are established by empiricism with tests (tradeoff: performance VS precision)

    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
    var float32ArraySupported = 'Float32Array' in global$2;

    function A(aA1, aA2) {
      return 1.0 - 3.0 * aA2 + 3.0 * aA1;
    }

    function B(aA1, aA2) {
      return 3.0 * aA2 - 6.0 * aA1;
    }

    function C(aA1) {
      return 3.0 * aA1;
    } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


    function getSlope(aT, aA1, aA2) {
      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
    }

    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX,
          currentT,
          i = 0;

      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;

        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

      return currentT;
    }

    function BezierEasing(mX1, mY1, mX2, mY2) {
      // Validate arguments
      if (arguments.length !== 4) {
        throw new Error('BezierEasing requires 4 arguments.');
      }

      for (var i = 0; i < 4; ++i) {
        if (typeof arguments[i] !== 'number' || isNaN(arguments[i]) || !isFinite(arguments[i])) {
          throw new Error('BezierEasing arguments should be integers.');
        }
      }

      if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {
        throw new Error('BezierEasing x values must be in [0, 1] range.');
      }

      var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : [];

      function newtonRaphsonIterate(aX, aGuessT) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);

          if (currentSlope === 0.0) {
            return aGuessT;
          }

          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }

        return aGuessT;
      }

      function calcSampleValues() {
        for (var i = 0; i < kSplineTableSize; ++i) {
          mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
        }
      }

      function getTForX(aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample != lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }

        --currentSample; // Interpolate to provide an initial guess for t

        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);

        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }

      var _precomputed = false;

      function precompute() {
        _precomputed = true;

        if (mX1 != mY1 || mX2 != mY2) {
          calcSampleValues();
        }
      }

      var f = function f(aX) {
        if (!_precomputed) {
          precompute();
        }

        if (mX1 === mY1 && mX2 === mY2) {
          return aX;
        } // linear
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.


        if (aX === 0) {
          return 0;
        }

        if (1 - aX < 0.001) {
          return 1;
        }

        return calcBezier(getTForX(aX), mY1, mY2);
      };

      f.getControlPoints = function () {
        return [{
          x: mX1,
          y: mY1
        }, {
          x: mX2,
          y: mY2
        }];
      };

      var args = [mX1, mY1, mX2, mY2];
      var str = 'BezierEasing(' + args + ')';

      f.toString = function () {
        return str;
      }; //var css = "cubic-bezier("+args+")";
      //f.toCSS = function () {?return css; };


      return f;
    } // CSS mapping


    BezierEasing.css = {
      ease: BezierEasing(0.25, 0.1, 0.25, 1.0),
      linear: BezierEasing(0.0, 0.0, 1.0, 1.0),
      'ease-in': BezierEasing(0.42, 0.0, 1.0, 1.0),
      'ease-out': BezierEasing(0.0, 0.0, 0.58, 1.0),
      'ease-in-out': BezierEasing(0.42, 0.0, 0.58, 1.0),
      swing: BezierEasing(0.02, 0.01, 0.47, 1.0),
      'ease-in-back': BezierEasing(0.6, -0.28, 0.735, 0.045),
      'ease-out-back': BezierEasing(0.175, 0.885, 0.32, 1.275),
      'ease-in-quart': BezierEasing(0.895, 0.03, 0.685, 0.22),
      'ease-out-quart': BezierEasing(0.165, 0.84, 0.44, 1),
      'ease-in-quint': BezierEasing(0.755, 0.05, 0.855, 0.06),
      'ease-out-quint': BezierEasing(0.23, 1, 0.32, 1),
      'ease-in-quad': BezierEasing(0.55, 0.085, 0.68, 0.53),
      'ease-out-quad': BezierEasing(0.25, 0.46, 0.45, 0.94),
      'ease-in-out-quad': BezierEasing(0.455, 0.03, 0.515, 0.955),
      'ease-out-cubic': BezierEasing(0.215, 0.61, 0.355, 1)
    };

    var css = BezierEasing.css;
    var Ease = {
      Swing: css.swing,
      Ease: css.ease,
      Linear: css.linear,
      A: BezierEasing(0.18, 0.89, 0.32, 1.6),
      B: BezierEasing(0.02, 0.01, 0.47, 1),
      Default: css.ease,
      EaseOutCubic: easing.cubicOut,
      EaseOutBounce: easing.bounceOut,
      EaseInQuint: easing.quinticIn,
      EaseOutQuint: easing.quinticOut,
      EaseInBack: easing.backIn,
      EaseOutRevise: BezierEasing(0, 0, 0.16, 1.03),
      EaseOutBack: easing.backOut,
      EaseInOutExpo: easing.exponentialInOut,
      // for line marker animation
      EaseOutBackAcute: BezierEasing(0.35, 0.81, 0.21, 2),
      EaseOutQuart: css['ease-out-quart'],
      EaseOutQuad: css['ease-out-quad'],
      EaseIntQuad: css['ease-in-quad']
    };

    var DEFAULT_MIN_ZOOM = 0;
    var DEFAULT_MAX_ZOOM = 18;
    var DEFAULT_ZOOM = 5;
    var DEFAULT_LINE_HEIGHT = 0.5;
    var DEFAULT_LEGEND_ICON_COLOR = '#63b2ee';
    var DEFAULT_PADDING = 3;
    var MAX_TICK_COUNT = 9;
    var THUMB_SIZE = 12;
    var Timing_Prediction = {
      Color: '#9D9D9D',
      Fake_Opacity: 0.5
    };
    var Axis = {
      PADDING: 3,
      Stroke: '#d0d0d0'
    };
    var Fade = {
      Color: 'rgba(170, 174, 184, 0.15)',
      Opacity: 0.15,
      Fill: '#a9aeb8',
      Timing: {
        duration: 250,
        ease: Ease.Default
      }
    };
    var AxisLineStyle = {
      enabled: false,
      color: '#d0d0d0',
      width: 1,
      type: 'solid'
    };
    var RESIZE_LINE_COLOR = '#647185';
    var EAST = 180;
    var WEST = -180;
    var NORTH = 90;
    var SOUTH = -90;
    var BIG_DATA_LIMIT = 3000;
    var DASHED_ARRAY = [8, 4];

    var _MappingAesTypes;

    var AttrKeys = {
      // base
      ID: 'id',
      // attrKey
      COLOR: 'color',
      SIZE: 'size',
      PIE_ANGLE: 'pieAngle',
      POINTER: 'pointer',
      TARGET: 'target',
      SYMBOL: 'symbol',
      GRANULARITY: 'granularity',
      ANGLE: 'angle',
      RADIUS: 'radius',
      // position
      X: 'x',
      Y: 'y',
      Y0: 'y0',
      LAT: 'lat',
      LNG: 'lng',
      RINGS: 'rings',
      // timing series prediction
      FAKE: 'fake',
      UPPER: 'upper',
      LOWER: 'lower',
      // condition related
      EFFECT: 'effect',
      ANNOTATION: 'annotation',
      IMAGE_FILL: 'imageFill',
      FADE: 'fade',
      VANISH: 'vanish'
    };
    var Direction = {
      TOP: 'top',
      LEFT: 'left',
      RIGHT: 'right',
      BOTTOM: 'bottom',
      SEPARATOR: '-',
      LEFT_TOP: 'left-top',
      LEFT_BOTTOM: 'left-bottom',
      RIGHT_TOP: 'right-top',
      RIGHT_BOTTOM: 'right-bottom'
    };
    var ChartLibrary = {
      INTERVAL: 'interval',
      PIE: 'pie',
      MULTI_PIE: 'multiPie',
      POINT: 'point',
      FORCE_POINT: 'forcePoint',
      SQUARE: 'square',
      TREE_MAP: 'treeMap',
      TEXT: 'text',
      WORD_CLOUD: 'wordCloud',
      LINE: 'line',
      AREA: 'area',
      LINE_RADAR: 'lineRadar',
      FUNNEL: 'funnel',
      HEAT_MAP: 'heatmap',
      POINTER_GAUGE: 'pointerGauge',
      SLOT_GAUGE: 'slotGauge',
      THERMOMETER_GAUGE: 'thermometerGauge',
      RING_GAUGE: 'ringGauge',
      AREA_MAP: 'areaMap'
    };
    var ColorStyle = {
      NORMAL: 'normal',
      CONTINUOUS: 'continuous',
      STEP: 'step'
    };
    var LineStyle = {
      NORMAL: 'normal',
      STEP: 'step',
      CURVE: 'curve'
    };
    var AesTypes = {
      POINTERS: 'pointers',
      TARGET: 'target',
      COLOR: 'color',
      HEAT_COLOR: 'heatColor',
      SIZE: 'size',
      PIE_ANGLE: 'pieAngle',
      SYMBOL: 'symbol',
      LINE_CONNECT: 'lineConnect',
      TEXT: 'text',
      LABEL: 'label',
      TOOLTIP: 'tooltip',
      GRANULARITY: 'granularity'
    };
    var STAGES = {
      NORMAL: 1,
      // init or canceled
      INTERACTING: 2,
      // no effect or other expensive rendering when interacting
      SELECT: 4,
      // touchMove to find target
      EDGE_MOVE: 8,
      // when selecting, move to the axis area will trigger scroll
      SCROLL: 16,
      // move plot view
      ZOOM: 32,
      BOX_SELECT: 64 // mouse box select

    };
    STAGES.SELECTING = STAGES.SELECT | STAGES.INTERACTING;
    STAGES.SCROLLING = STAGES.SCROLL | STAGES.INTERACTING;
    STAGES.ZOOMING = STAGES.ZOOM | STAGES.INTERACTING;
    STAGES.BOX_SELECTING = STAGES.BOX_SELECT | STAGES.INTERACTING;
    STAGES.EDGE_MOVING = STAGES.SELECTING | STAGES.EDGE_MOVE;
    STAGES.SCROLL_VISIBLE = STAGES.INTERACTING | STAGES.SCROLL | STAGES.ZOOM | STAGES.EDGE_MOVE;
    var MappingAesTypes = (_MappingAesTypes = {}, _MappingAesTypes[AesTypes.SIZE] = true, _MappingAesTypes[AesTypes.COLOR] = true, _MappingAesTypes[AesTypes.HEAT_COLOR] = true, _MappingAesTypes[AesTypes.PIE_ANGLE] = true, _MappingAesTypes[AesTypes.SYMBOL] = true, _MappingAesTypes[AesTypes.POINTERS] = true, _MappingAesTypes[AesTypes.TARGET] = true, _MappingAesTypes);
    var LegendAesTypes = [AesTypes.COLOR, AesTypes.HEAT_COLOR, AesTypes.SYMBOL, AesTypes.SIZE];
    var DataLabel = {
      HIDE: 'hide',
      EXTREME: 'extreme',
      INSIDE: 'inside',
      CENTER: 'center',
      OUTSIDE: 'outside',
      TOP: 'top',
      BOTTOM: 'bottom',
      HOVER_TRANS: 3,
      HOVER_SCALE: [1.1, 1.1]
    };
    var FieldType = {
      DIMENSION: 'DIMENSION',
      MEASURE: 'MEASURE',
      ATTR: 'ATTR'
    };
    var SpecialMode = {
      SINGLE_PIE: 'singlePie',
      KPI: 'kpi'
    };

    // the app process
    var INIT = 'INIT';
    var HIDE = 'HIDE';
    var SHOW = 'SHOW'; // data update

    var ENTER = 'ENTER';
    var UPDATE = 'UPDATE';
    var LEAVE = 'LEAVE'; // element condition

    var FADE = 'FADE';
    var HOVER = 'HOVER';
    var LAT = 'lat';
    var LNG = 'lng';
    var ANNOTATION = 'annotation';
    var IMAGE_FILL = 'imageFill';
    var EFFECT_SUFFIX = '_effect_';
    var FORECAST_SUFFIX = '_forecast';
    var LOWER_LIMIT = 'lower_limit';
    var UPPER_LIMIT = 'upper_limit';
    var ANNOTATION_CIRCLE_SUFFIX = '_annotation_circle';
    var ANNOTATION_LINE_SUFFIX = '_annotation_line';
    var ANNOTATION_RECT_SUFFIX = '_annotation_rect';
    var ANNOTATION_TEXT_SUFFIX = '_annotation_text';
    var ANNOTATION_GROUP_SUFFIX = '_annotation_group';
    var ELLIPSIS = '..';
    var MULTI_POLYGON = 'MultiPolygon';
    var POLYGON = 'Polygon';
    var MULTI_LINE_STRING = 'MultiLineString';
    var LINE_STRING = 'LineString';
    var POINT = 'Point';
    var MULTI_POINT = 'MultiPoint';
    var GEOMETRY_COLLECTION = 'GeometryCollection';
    var POSITIVE_SUFFIX = '_POSITIVE';
    var NEGATIVE_SUFFIX = '_NEGATIVE';

    /**
     * Created by Jeffrey on 2018/1/3.
     */

    var SEPARATOR = '\x1f'; // frame-group connect key

    var GROUP_KEY = '+'; // special value means null

    var NULL_VALUE = '-';
    var EDGE_MOVE_KEY = 'EDGE_MOVE_KEY';
    var NODE_ROOT = '..root';

    /**
     * Created by Jeffrey on 2017/11/8.
     * 两端粗细不一的线
     * varLine : draws a line from A(x1,y1) to B(x2,y2)
     * that starts with a w1 width and ends with a w2 width.
     * @module zrender/graphic/shape/VarLine
     */

    var sq = function sq(v) {
      return v * v;
    };

    var computeKeyPoints = function computeKeyPoints(shape) {
      var x1 = shape.x1,
          y1 = shape.y1,
          x2 = shape.x2,
          y2 = shape.y2,
          w1 = shape.w1,
          w2 = shape.w2;
      var dx = x2 - x1,
          dy = y2 - y1,
          sx1,
          sy1,
          sx2,
          sy2;
      var length = Math.sqrt(sq(dx) + sq(dy)); // length of the AB vector

      if (!length) return; // exit if zero length

      w1 /= 2;
      w2 /= 2; // we only use w1/2 and w2/2 for computations.

      dx /= length;
      dy /= length;
      sx1 = -dy * w1;
      sy1 = dx * w1;
      sx2 = -dy * w2;
      sy2 = dx * w2;
      var angle = Math.atan2(sy1, sx1);
      return {
        p1: [x1 + sx1, y1 + sy1],
        p2: [x1 - sx1, y1 - sy1],
        p3: [x2 + sx2, y2 + sy2],
        p4: [x2 - sx2, y2 - sy2],
        angle: angle
      };
    };

    var drawNormalVarLine = function drawNormalVarLine(ctx, shape) {
      var keyPoints = computeKeyPoints(shape);

      if (!keyPoints) {
        return;
      }

      var p1 = keyPoints.p1,
          p4 = keyPoints.p4,
          angle = keyPoints.angle;
      var x1 = shape.x1,
          y1 = shape.y1,
          x2 = shape.x2,
          y2 = shape.y2,
          w1 = shape.w1,
          w2 = shape.w2;
      ctx.moveTo(p1[0], p1[1]);
      ctx.arc(x1, y1, w1 / 2, angle, angle + Math.PI); // draw A1A2

      ctx.lineTo(p4[0], p4[1]); // draw A2B1

      ctx.arc(x2, y2, w2 / 2, angle + Math.PI, angle); // draw A1A2

      ctx.closePath(); // draw B2A1
    };

    var CURVE_NESS = 0.3;
    function computeArc(ax, ay, bx, by, c) {
      if (c === void 0) {
        c = CURVE_NESS;
      }

      var th = Math.asin(c),
          absX = Math.abs(ax - bx),
          absY = Math.abs(ay - by),
          l = Math.sqrt(absX * absX + absY * absY) / 2,
          direction = ax > bx ? -1 : 1,
          d = direction * l / Math.tan(th),
          al = Math.atan((ay - by) / (bx - ax)),
          w = d * Math.sin(al),
          h = d * Math.cos(al),
          mx = (ax + bx) / 2,
          my = (ay + by) / 2,
          ox = mx + w,
          oy = my + h,
          sAngX = ax - ox,
          sAngY = ay - oy,
          eAngX = bx - ox,
          eAngY = by - oy,
          sAng = normalRadian(Math.atan2(sAngY, sAngX)),
          eAng = normalRadian(Math.atan2(eAngY, eAngX));

      if (sAng > eAng) {
        eAng += Math.PI * 2;
      }

      return [ox, oy, l / c, sAng, eAng];
    }
    var drawCurveVarLine = function drawCurveVarLine(ctx, shape) {
      var keyPoints = computeKeyPoints(shape);

      if (!keyPoints) {
        return;
      }

      var x1 = shape.x1,
          y1 = shape.y1,
          w1 = shape.w1,
          x2 = shape.x2,
          y2 = shape.y2,
          w2 = shape.w2;
      var _keyPoints$p = keyPoints.p1,
          p1x = _keyPoints$p[0],
          p1y = _keyPoints$p[1],
          _keyPoints$p2 = keyPoints.p2,
          p2x = _keyPoints$p2[0],
          p2y = _keyPoints$p2[1],
          _keyPoints$p3 = keyPoints.p3,
          p3x = _keyPoints$p3[0],
          p3y = _keyPoints$p3[1],
          _keyPoints$p4 = keyPoints.p4,
          p4x = _keyPoints$p4[0],
          p4y = _keyPoints$p4[1],
          angle = keyPoints.angle;
      ctx.moveTo(p1x, p1y);
      ctx.arc(x1, y1, w1 / 2, angle + Math.PI, angle, true); // draw A1A2

      ctx.arc.apply(ctx, computeArc(p2x, p2y, p4x, p4y));
      ctx.arc(x2, y2, w2 / 2, angle, angle + Math.PI, true); // draw A1A2

      var _computeArc = computeArc(p1x, p1y, p3x, p3y),
          cx1 = _computeArc[0],
          cy1 = _computeArc[1],
          r1 = _computeArc[2],
          sa1 = _computeArc[3],
          ea1 = _computeArc[4];

      ctx.arc(cx1, cy1, r1, ea1, sa1, true);
    };
    var VarLine = Path.extend({
      type: 'varLine',
      shape: {
        style: LineStyle.NORMAL,
        // Start point
        x1: 0,
        y1: 0,
        // End point
        x2: 0,
        y2: 0,
        w1: 0,
        w2: 0
      },
      style: {
        stroke: null,
        fill: '#000'
      },
      buildPath: function buildPath(ctx, shape) {
        var style = shape.style;
        var drawFn = style === LineStyle.CURVE ? drawCurveVarLine : drawNormalVarLine;
        drawFn(ctx, shape);
      }
    });

    /**
     * @param ctx
     * @param shape
     */
    var percentValue = function percentValue(min, max, pct) {
      return min + (max - min) * pct;
    };
    var k = 1 / 6;

    var percentPos = function percentPos(p1, p2, pct) {
      return {
        x: percentValue(p1.x, p2.x, pct),
        y: percentValue(p1.y, p2.y, pct)
      };
    };

    var bezier = function bezier(p1, p2, p3, p4, t) {
      var t1 = 1 - t;
      return t1 * t1 * t1 * p1 + 3 * t * t1 * t1 * p2 + 3 * t * t * t1 * p3 + t * t * t * p4;
    };

    var bezierPos = function bezierPos(_ref, t) {
      var p1 = _ref[0],
          p2 = _ref[1],
          p3 = _ref[2],
          p4 = _ref[3];
      return {
        x: bezier(p1.x, p2.x, p3.x, p4.x, t),
        y: bezier(p1.y, p2.y, p3.y, p4.y, t)
      };
    };

    var percentCurveVarLinePos = function percentCurveVarLinePos(p1, p2, pct) {
      var _computeArc = computeArc(p1.x, p1.y, p2.x, p2.y),
          cx = _computeArc[0],
          cy = _computeArc[1],
          r = _computeArc[2],
          sa = _computeArc[3],
          ea = _computeArc[4];

      var angle = percentValue(sa, ea, pct);
      return {
        x: cx + r * Math.cos(angle),
        y: cy + r * Math.sin(angle)
      };
    };

    function getBezierCurveKeyPoints(p1, p2, p3, p4) {
      var cx1 = p2.x + (p3.x - p1.x) * k,
          cy1 = p2.y + (p3.y - p1.y) * k,
          cx2 = p3.x + (p2.x - p4.x) * k,
          cy2 = p3.y + (p2.y - p4.y) * k;
      return [p2, {
        x: cx1,
        y: cy1
      }, {
        x: cx2,
        y: cy2
      }, p3];
    }

    function _curvePoints(data, idx) {
      var prevIdx = idx - 1;
      var p1 = data[Math.max(prevIdx - 1, 0)],
          p2 = data[prevIdx],
          p3 = data[idx],
          p4 = data[Math.min(idx + 1, data.length - 1)];
      return getBezierCurveKeyPoints(p1, p2, p3, p4);
    }

    function drawStrokeEffectLine(ctx, op) {
      var points = op.points,
          style = op.style,
          index = op.index,
          pct = op.pct,
          isVarLine = op.isVarLine;
      var curP = points[index],
          nextP = points[index + 1];
      var point;

      if (index === points.length - 1) {
        point = points[index];
      } else {
        if (isVarLine) {
          point = style === LineStyle.CURVE ? percentCurveVarLinePos(curP, nextP, pct) : percentPos(curP, nextP, pct);
        } else {
          if (style === LineStyle.NORMAL) {
            point = percentPos(curP, nextP, pct);
          } else if (style === LineStyle.STEP) {
            var x1 = curP.x,
                y1 = curP.y,
                x2 = nextP.x,
                y2 = nextP.y;
            var f = Math.abs(x1 - x2),
                b = Math.abs(y1 - y2),
                center = {
              x: x2,
              y: y1
            };
            var fp = f / (f + b),
                bp = b / (f + b);
            point = pct <= fp ? percentPos(curP, center, pct / fp) : percentPos(center, nextP, (pct - fp) / bp);
          } else {
            point = points.length === 2 ? percentCurveVarLinePos(curP, nextP, pct) : bezierPos(_curvePoints(points, index + 1), pct);
          }
        }

        point.size = percentValue(curP.size, nextP.size, pct);
      }

      ctx.arc(point.x, point.y, point.size / 2, 0, Math.PI * 2, true);
    }

    var pi = Math.PI,
        tau = 2 * pi,
        epsilon = 1e-6,
        tauEpsilon = tau - epsilon;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath

      this._ = "";
    }

    function path() {
      return new Path$1();
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function moveTo(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function lineTo(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

        if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
          // Equivalently, is (x1,y1) coincident with (x2,y2)?
          // Or, is the radius zero? Line to (x1,y1).
          else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
              this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            } // Otherwise, draw an arc!
            else {
                var x20 = x2 - x0,
                    y20 = y2 - y0,
                    l21_2 = x21 * x21 + y21 * y21,
                    l20_2 = x20 * x20 + y20 * y20,
                    l21 = Math.sqrt(l21_2),
                    l01 = Math.sqrt(l01_2),
                    l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                    t01 = l / l01,
                    t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

                if (Math.abs(t01 - 1) > epsilon) {
                  this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                }

                this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
              }
      },
      arc: function arc(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

        if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
            this._ += "L" + x0 + "," + y0;
          } // Is this arc empty? We’re done.


        if (!r) return; // Does the angle go the wrong way? Flip the direction.

        if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.

        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        } // Is this arc non-empty? Draw an arc!
        else if (da > epsilon) {
            this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
          }
      },
      rect: function rect(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
      },
      toString: function toString() {
        return this._;
      }
    };

    function constant (x) {
      return function constant() {
        return x;
      };
    }

    var pi$1 = Math.PI;

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function areaStart() {
        this._line = 0;
      },
      areaEnd: function areaEnd() {
        this._line = NaN;
      },
      lineStart: function lineStart() {
        this._point = 0;
      },
      lineEnd: function lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function point(x, y) {
        x = +x, y = +y;

        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
          // proceed

          default:
            this._context.lineTo(x, y);

            break;
        }
      }
    };
    function curveLinear (context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }
    function y(p) {
      return p[1];
    }

    function line () {
      var x$$1 = x,
          y$$1 = y,
          defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;

      function line(data) {
        var i,
            n = data.length,
            d,
            defined0 = false,
            buffer;
        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();else output.lineEnd();
          }

          if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function (_) {
        return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
      };

      line.y = function (_) {
        return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
      };

      line.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
      };

      line.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area () {
      var x0 = x,
          x1 = null,
          y0 = constant(0),
          y1 = y,
          defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;

      function area(data) {
        var i,
            j,
            k,
            n = data.length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);
        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();

              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }

              output.lineEnd();
              output.areaEnd();
            }
          }

          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
      };

      area.x0 = function (_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
      };

      area.x1 = function (_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
      };

      area.y = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
      };

      area.y0 = function (_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
      };

      area.y1 = function (_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
      };

      area.lineX0 = area.lineY0 = function () {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function () {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function () {
        return arealine().x(x1).y(y0);
      };

      area.defined = function (_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
      };

      area.curve = function (_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function (_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function _point$1(that, x, y) {
      that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
    }
    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }
    Cardinal.prototype = {
      areaStart: function areaStart() {
        this._line = 0;
      },
      areaEnd: function areaEnd() {
        this._line = NaN;
      },
      lineStart: function lineStart() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function lineEnd() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);

            break;

          case 3:
            _point$1(this, this._x1, this._y1);

            break;
        }

        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function point(x, y) {
        x = +x, y = +y;

        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
            this._x1 = x, this._y1 = y;
            break;

          case 2:
            this._point = 3;
          // proceed

          default:
            _point$1(this, x, y);

            break;
        }

        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };
    var curve = (function custom(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function (tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function sign(x) {
      return x < 0 ? -1 : 1;
    } // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.


    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    } // Calculate a one-sided slope.


    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    } // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


    function _point$3(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;

      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function areaStart() {
        this._line = 0;
      },
      areaEnd: function areaEnd() {
        this._line = NaN;
      },
      lineStart: function lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function lineEnd() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);

            break;

          case 3:
            _point$3(this, this._t0, slope2(this, this._t0));

            break;
        }

        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function point(x, y) {
        var t1 = NaN;
        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
            break;

          case 2:
            this._point = 3;

            _point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);

            break;

          default:
            _point$3(this, this._t0, t1 = slope3(this, x, y));

            break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function moveTo(x, y) {
        this._context.moveTo(y, x);
      },
      closePath: function closePath() {
        this._context.closePath();
      },
      lineTo: function lineTo(x, y) {
        this._context.lineTo(y, x);
      },
      bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
        this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
      }
    };

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function areaStart() {
        this._line = 0;
      },
      areaEnd: function areaEnd() {
        this._line = NaN;
      },
      lineStart: function lineStart() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function lineEnd() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function point(x, y) {
        x = +x, y = +y;

        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
            break;

          case 1:
            this._point = 2;
          // proceed

          default:
            {
              if (this._t <= 0) {
                this._context.lineTo(this._x, y);

                this._context.lineTo(x, y);
              } else {
                var x1 = this._x * (1 - this._t) + x * this._t;

                this._context.lineTo(x1, this._y);

                this._context.lineTo(x1, y);
              }

              break;
            }
        }

        this._x = x, this._y = y;
      }
    };
    function stepAfter(context) {
      return new Step(context, 1);
    }

    function getCurveFunc(style) {
      switch (style) {
        case LineStyle.STEP:
          return stepAfter;

        case LineStyle.CURVE:
          return curve;

        default:
          return curveLinear;
      }
    }

    var createLinePainter = function createLinePainter() {
      var _painter = line().x(function (p) {
        return p[0];
      }).y(function (p) {
        return p[1];
      });

      var linePainter = {
        x: function x(_x) {
          _painter.x(_x);

          return linePainter;
        },
        y: function y(_y) {
          _painter.y(_y);

          return linePainter;
        },
        context: function context(ctx) {
          _painter.context(ctx);

          return linePainter;
        },
        paint: function paint(data) {
          _painter(data);

          _painter.context(null); // 手动解除ctx的引用


          return linePainter;
        },
        style: function style(_style) {
          _painter.curve(getCurveFunc(_style));

          return linePainter;
        },
        normal: function normal() {
          _painter.curve(getCurveFunc(LineStyle.NORMAL));

          return linePainter;
        },
        step: function step$$1() {
          _painter.curve(getCurveFunc(LineStyle.STEP));

          return linePainter;
        },
        curve: function curve$$1() {
          _painter.curve(getCurveFunc(LineStyle.CURVE));

          return linePainter;
        }
      };
      return linePainter;
    };

    var linePainter = createLinePainter();

    /**
     * 根据点的位置和大小，确定上下左右四个方向的x或y
     * @param x
     * @param y
     * @param size
     * @returns {*[]}
     */

    var vIn4Direction = function vIn4Direction(x, y, size) {
      var r = x + size / 2,
          l = r - size,
          t = y - size / 2,
          b = t + size;
      return [r, l, t, b];
    };
    /**
     * 计算kelpLine两个点之间的转角处的上下点
     * @param cur
     * @param next
     * @param horizontal
     * @returns {*[]}
     */


    var getCornerTopAndBottomPoints = function getCornerTopAndBottomPoints(cur, next, horizontal) {
      var nx = next[0],
          ny = next[1],
          ns = next[2],
          cx = cur[0],
          cy = cur[1],
          cs = cur[2];
      var up = horizontal ? ny < cy : nx > cx;

      var _vIn4Direction = vIn4Direction(nx, cy, (cs + ns) / 2),
          r = _vIn4Direction[0],
          l = _vIn4Direction[1],
          t = _vIn4Direction[2],
          b = _vIn4Direction[3];

      var t2x = horizontal ? up ? l : r : r;
      var t2y = horizontal ? t : up ? t : b;
      var b2x = horizontal ? up ? r : l : l;
      var b2y = horizontal ? b : up ? b : t;
      return [[t2x, t2y], [b2x, b2y]];
    };
    /**
     * 从固定位置的点，计算出在kelpLine绘制需要的上下点位置
     * @param points
     * @param index
     * @param horizontal
     * @param zeroSize
     */

    var getTopAndBottomPoints = function getTopAndBottomPoints(points, index, horizontal) {
      var cur = points[index],
          next = points[index + 1],
          prev = points[index - 1];
      var x = cur[0],
          y = cur[1],
          size = cur[2];
      var down = horizontal ? prev ? y > prev[1] : 0 : next ? x > next[0] : 0;
      var first = index === 0,
          last = index === points.length - 1;

      var _vIn4Direction2 = vIn4Direction(x, y, size),
          r = _vIn4Direction2[0],
          l = _vIn4Direction2[1],
          t = _vIn4Direction2[2],
          b = _vIn4Direction2[3];

      var t1x = first ? x : horizontal ? down ? r : l : r,
          t1y = last ? y : horizontal ? t : down ? b : t,
          b1x = first ? x : horizontal ? down ? l : r : l,
          b1y = last ? y : horizontal ? b : down ? t : b;
      return [[t1x, t1y], [b1x, b1y]];
    };

    var collectPoints = function collectPoints(points, horizontal) {
      var tops = [],
          bottoms = [];

      for (var i = 0, len = points.length; i < len; i++) {
        var _getTopAndBottomPoint = getTopAndBottomPoints(points, i, horizontal),
            t1 = _getTopAndBottomPoint[0],
            b1 = _getTopAndBottomPoint[1];

        tops.push(t1);
        bottoms.push(b1);

        if (i < len - 1) {
          var _getCornerTopAndBotto = getCornerTopAndBottomPoints(points[i], points[i + 1], horizontal),
              t2 = _getCornerTopAndBotto[0],
              b2 = _getCornerTopAndBotto[1];

          tops.push(t2);
          bottoms.push(b2);
        }
      }

      return [tops, bottoms];
    };

    function drawStepKelpLine(ctx, shape) {
      var points = shape.points,
          horizontal = shape.horizontal;

      var _collectPoints = collectPoints(points, horizontal),
          top = _collectPoints[0],
          bottom = _collectPoints[1];

      linePainter.context(ctx).normal().paint([].concat(top, bottom.reverse()));
      ctx.closePath();
    }

    function drawNormalKelpLine(ctx, shape) {
      var points = shape.points;
      var topPoints = [],
          bottomPoints = [];

      for (var i = 0, len = points.length; i < len; i++) {
        var prePoint = points[i - 1],
            point = points[i],
            nextPoint = points[i + 1];

        var _calculateKeyPoint = calculateKeyPoint(prePoint, point, nextPoint),
            top = _calculateKeyPoint[0],
            bottom = _calculateKeyPoint[1];

        topPoints.push(top);
        bottomPoints.unshift(bottom);
      }

      var _topPoints$0$ = topPoints[0][0],
          x1 = _topPoints$0$[0],
          y1 = _topPoints$0$[1];
      var _bottomPoints$0$ = bottomPoints[0][0],
          x2 = _bottomPoints$0$[0],
          y2 = _bottomPoints$0$[1];
      ctx.moveTo(x1, y1);
      drawLineOrArc(ctx, topPoints);
      ctx.lineTo(x2, y2);
      drawLineOrArc(ctx, bottomPoints, true);
      ctx.lineTo(x1, y1);
    }
    var drawSingleLineOrArc = function drawSingleLineOrArc(ctx, point, reverse) {
      var single = point.length === 1;

      if (single) {
        var _point$ = point[0],
            x = _point$[0],
            y = _point$[1];
        ctx.lineTo(x, y);
      } else {
        var p1 = point[0],
            p2 = point[1],
            p3 = point[2];
        var x1 = p1[0],
            y1 = p1[1];
        var x2 = p2[0],
            y2 = p2[1],
            a1 = p2[2],
            a2 = p2[3],
            radius = p2[4];
        var x3 = p3[0],
            y3 = p3[1];

        if (reverse) {
          ctx.lineTo(x3, y3);
          ctx.arc(x2, y2, radius, a2, a1);
        } else {
          ctx.lineTo(x1, y1);
          ctx.arc(x2, y2, radius, a1, a2);
        }
      }
    };
    var drawLineOrArc = function drawLineOrArc(ctx, points, reverse) {
      for (var i = 1; i < points.length; i++) {
        drawSingleLineOrArc(ctx, points[i], reverse);
      }
    };
    /**
     * 根据一个点的preNode和nextNode，计算出绘制需要的两个关键点top&bottom
     * @param preNode
     * @param node
     * @param nextNode
     * @returns {*[]}
     */

    function calculateKeyPoint(preNode, node, nextNode) {
      // preNode:{x0, y0}
      // node:{x1, y1}
      // nextNode: {x2, y2}
      var x1 = node[0],
          y1 = node[1],
          s1 = node[2];
      var c1 = [x1, y1];
      var top, bottom; // 第一个点

      if (preNode == null) {
        var x2 = nextNode[0],
            y2 = nextNode[1],
            s2 = nextNode[2];

        var _calculateTangentAngl = calculateTangentAngles(x1, y1, s1, x2, y2, s2),
            a1 = _calculateTangentAngl[0],
            a2 = _calculateTangentAngl[1];

        top = [getAnglePoint(c1, s1, a1)];
        bottom = [getAnglePoint(c1, s1, a2)];
      } // 最后一个点
      else if (nextNode == null) {
          var x0 = preNode[0],
              y0 = preNode[1],
              s0 = preNode[2];

          var _calculateTangentAngl2 = calculateTangentAngles(x0, y0, s0, x1, y1, s1),
              _a = _calculateTangentAngl2[0],
              _a2 = _calculateTangentAngl2[1];

          top = [getAnglePoint(c1, s1, _a)];
          bottom = [getAnglePoint(c1, s1, _a2)];
        } // 中间的点
        else {
            // 计算出四个关键点并判断是相交取相交点或者不相交取三点（p1, c, p2）;
            var _x = preNode[0],
                _y = preNode[1],
                _s = preNode[2],
                c0 = [_x, _y];
            var _x2 = nextNode[0],
                _y2 = nextNode[1],
                _s2 = nextNode[2],
                c2 = [_x2, _y2];

            var _calculateTangentAngl3 = calculateTangentAngles(_x, _y, _s, x1, y1, s1),
                a11 = _calculateTangentAngl3[0],
                a12 = _calculateTangentAngl3[1],
                _calculateTangentAngl4 = calculateTangentAngles(x1, y1, s1, _x2, _y2, _s2),
                a21 = _calculateTangentAngl4[0],
                a22 = _calculateTangentAngl4[1];

            var p01 = getAnglePoint(c0, _s, a11),
                p02 = getAnglePoint(c0, _s, a12),
                p11 = getAnglePoint(c1, s1, a11),
                p12 = getAnglePoint(c1, s1, a12),
                p13 = getAnglePoint(c1, s1, a21),
                p14 = getAnglePoint(c1, s1, a22),
                p21 = getAnglePoint(c2, _s2, a21),
                p22 = getAnglePoint(c2, _s2, a22);
            var line1 = [p01, p11],
                line2 = [p13, p21],
                line3 = [p02, p12],
                line4 = [p14, p22];
            var intersect1 = testIntersect(line1, line2),
                intersect2 = testIntersect(line3, line4);
            var radius = s1 / 2;
            top = [intersect1];
            bottom = [intersect2];

            if (!intersect1) {
              top = [p11, [x1, y1, -a11, -a21, radius], p13, radius];
            }

            if (!intersect2) {
              bottom = [p12, [x1, y1, -a12, -a22, radius], p14, radius];
            }
          }

      return [top, bottom];
    }
    /**
     * NOTE 这里所有的角度都是以直角坐标系x轴正方向为0度，逆时针方向
     * 计算矢量 p1->p2的角度
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     */

    function calculateVectorAngle(x1, y1, x2, y2) {
      if (x1 === x2) {
        return Math.PI / 2 + (y1 > y2 ? 0 : Math.PI);
      }

      var three = y1 < y2 && x1 > x2; // 第三象限

      var two = y1 > y2 && x1 > x2; // 第二象限

      return Math.atan((y1 - y2) / (x2 - x1)) + (three || two ? Math.PI : 0);
    }
    /**
     * 计算圆c1与圆c2的公共切线与圆的相切点，相对于圆心的角度，这里的切线有两条，故切点也有两个
     * @param x1
     * @param y1
     * @param s1
     * @param x2
     * @param y2
     * @param s2
     */


    function calculateTangentAngles(x1, y1, s1, x2, y2, s2) {
      // 第一步，先计算出从c1圆心到c2圆心的矢量的角度
      var vectorAngle = calculateVectorAngle(x1, y1, x2, y2);

      if (s1 === s2) {
        return [vectorAngle + Math.PI / 2, vectorAngle - Math.PI / 2];
      }

      var maxR = s1 / 2,
          minR = s2 / 2,
          revert = false;

      if (maxR < minR) {
        var _ref = [minR, maxR];
        maxR = _ref[0];
        minR = _ref[1];
        revert = true;
      }

      var angle = Math.acos(minR / (distance$1(x1, y1, x2, y2) * minR / (maxR - minR)));
      angle = revert ? Math.PI - angle : angle;
      return [vectorAngle + angle, vectorAngle - angle];
    }

    function distance$1(x1, y1, x2, y2) {
      var dx = x1 - x2,
          dy = y1 - y2;
      return Math.sqrt(dx * dx + dy * dy);
    } // 判断两根长度有限的线是否相交


    function testIntersect(line1, line2) {
      var _line1$ = line1[0],
          x11 = _line1$[0],
          y11 = _line1$[1],
          _line1$2 = line1[1],
          x12 = _line1$2[0],
          y12 = _line1$2[1],
          _line2$ = line2[0],
          x21 = _line2$[0],
          y21 = _line2$[1],
          _line2$2 = line2[1],
          x22 = _line2$2[0],
          y22 = _line2$2[1];
      var k1 = calculateK(x11, y11, x12, y12),
          k2 = calculateK(x21, y21, x22, y22);

      if (Math.abs(k1) === Math.abs(k2)) {
        return null;
      } // y = k1x + b1 & y = k2x + b2 => x = (b1 - b2) / (k2 - k1)


      var b1 = y11 - k1 * x11,
          b2 = y21 - k2 * x21;
      var x = (b1 - b2) / (k2 - k1),
          y = k1 * x + b1;

      var _minMax = minMax([x11, x12]),
          minX = _minMax[0],
          maxX = _minMax[1],
          _minMax2 = minMax([y11, y12]),
          minY = _minMax2[0],
          maxY = _minMax2[1]; // 相交


      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
        return [x, y];
      }

      return null;
    }

    function calculateK(x1, y1, x2, y2) {
      return (y2 - y1) / (x2 - x1);
    }

    function getAnglePoint(_ref2, size, angle) {
      var x = _ref2[0],
          y = _ref2[1];
      var r = size / 2;
      return [x + r * Math.cos(angle), y - r * Math.sin(angle)];
    }

    var getCurvePoint = function getCurvePoint(points) {
      if (points.length === 1) return points[0];
      var _points$ = points[1],
          cx = _points$[0],
          cy = _points$[1],
          a1 = _points$[2],
          a2 = _points$[3],
          r = _points$[4];
      var angle = (a1 + a2) / 2; // 取间隔小于Math.PI的那个中心角

      if (Math.abs(a1 - a2) > Math.PI) {
        angle += Math.PI;
      }

      return [cx + r * Math.cos(angle), cy + r * Math.sign(angle)];
    };
    function drawCurveKelpLine$$1(ctx, shape) {
      var points = shape.points;

      if (points.length === 2) {
        var _points$2 = points[0],
            _x = _points$2[0],
            _y = _points$2[1],
            w1 = _points$2[2];
        var _points$3 = points[1],
            _x2 = _points$3[0],
            _y2 = _points$3[1],
            w2 = _points$3[2];
        drawCurveVarLine(ctx, {
          x1: _x,
          y1: _y,
          w1: w1,
          x2: _x2,
          y2: _y2,
          w2: w2
        });
        return;
      }

      linePainter.context(ctx).curve();
      var top = [],
          bottom = [];

      for (var i = 0, len = points.length; i < len; i++) {
        var prePoint = points[i - 1],
            point = points[i],
            nextPoint = points[i + 1];

        var _calculateKeyPoint = calculateKeyPoint(prePoint, point, nextPoint),
            t = _calculateKeyPoint[0],
            b = _calculateKeyPoint[1];

        top.push(getCurvePoint(t));
        bottom.unshift(getCurvePoint(b));
      }

      var _top$ = top[0],
          x1 = _top$[0],
          y1 = _top$[1];
      var _bottom$ = bottom[0],
          x2 = _bottom$[0],
          y2 = _bottom$[1];
      linePainter.paint(top);
      ctx.lineTo(x2, y2);
      linePainter.context(ctx).paint(bottom);
      ctx.lineTo(x1, y1);
    }

    /**
     * 考虑到用h("path", props)不方便更新且性能不佳，
     * 这边把折线图的绘制抽象成一个shape，考虑到线的粗细不一致，像水中漂浮的海带一样，故命名为海带线
     */
    var KelpLine = Path.extend({
      type: 'kelpLine',
      shape: {
        points: null,
        stroke: true,
        style: LineStyle.NORMAL // normal || step || curve

      },
      style: {
        stroke: 'none',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var stroke = shape.stroke,
            style = shape.style,
            points = shape.points; // points share the same size.

        if (stroke) {
          linePainter.context(ctx).style(style).paint(points);
          return;
        }

        var drawFn = style === LineStyle.CURVE ? drawCurveKelpLine$$1 : style === LineStyle.STEP ? drawStepKelpLine : drawNormalKelpLine;
        drawFn(ctx, shape);
      }
    });

    /**
     * 闭合圆环海带线-主要用于线雷达图
     */

    var RadarLine = Path.extend({
      type: 'radarLine',
      shape: {
        points: []
      },
      style: {
        stroke: 'none',
        fill: null
      },
      buildPath: function buildPath(ctx, _ref) {
        var points = _ref.points;

        // 只有两个点时, 一上一下
        if (points.length === 2) {
          var p1 = points[0],
              p2 = points[1];
          var x1 = p1[0],
              y1 = p1[1],
              s1 = p1[2],
              x2 = p2[0],
              y2 = p2[1],
              s2 = p2[2];
          var r1 = s1 / 2,
              r2 = s2 / 2;
          ctx.moveTo(x1 + r1, y1);
          ctx.lineTo(x2 + r2, y2);
          ctx.arc(x2, y2, r2, 0, Math.PI);
          ctx.lineTo(x1 - r1, y1);
          ctx.arc(x1, y1, r1, Math.PI, Math.PI * 2);
          ctx.closePath();
        } else {
          var newPoints = points.slice();
          newPoints.push(points[0], points[1]); // end-to-end

          var outerPoints = [],
              innerPoints = [];

          for (var i = 0, len = newPoints.length; i < len; i++) {
            var prePoint = newPoints[i - 1],
                point = newPoints[i],
                nextPoint = newPoints[i + 1];

            var _calculateKeyPoint = calculateKeyPoint(prePoint, point, nextPoint),
                outer = _calculateKeyPoint[0],
                inner = _calculateKeyPoint[1];

            i < len - 1 && outerPoints.push(outer);
            i > 0 && i < len - 1 && innerPoints.unshift(inner);
          }

          var _outerPoints$0$ = outerPoints[0][0],
              _x = _outerPoints$0$[0],
              _y = _outerPoints$0$[1],
              _innerPoints$0$ = innerPoints[0][0],
              _x2 = _innerPoints$0$[0],
              _y2 = _innerPoints$0$[1];
          ctx.moveTo(_x, _y);
          drawLineOrArc(ctx, outerPoints);
          ctx.closePath();
          ctx.moveTo(_x2, _y2);
          drawLineOrArc(ctx, innerPoints, true);
          ctx.closePath();
        }
      }
    });

    var xFunc = function xFunc(d) {
      return d[0];
    };

    var y1Func = function y1Func(d) {
      return d[1];
    };

    var y0Func = function y0Func(d) {
      return d[2];
    };

    var areaGenerator = area();
    var Area = Path.extend({
      type: 'area',
      shape: {
        points: null,
        horizontal: true,
        style: LineStyle.NORMAL
      },
      style: {
        stroke: 'none',
        fill: null
      },
      buildPath: function buildPath(ctx, _ref) {
        var points = _ref.points,
            _ref$style = _ref.style,
            style = _ref$style === void 0 ? LineStyle.NORMAL : _ref$style,
            horizontal = _ref.horizontal;
        var generator = horizontal ? areaGenerator.x(xFunc).y0(y0Func).y1(y1Func) : areaGenerator.y(y1Func).x0(y0Func).x1(xFunc);
        var painter = generator.context(ctx).curve(getCurveFunc(style));
        painter(points);
      }
    });

    /**
     * 指针仪表盘指针
     */

    var Pointer = Path.extend({
      type: 'pointer',
      shape: {
        r: 0,
        r0: 0
      },
      style: {
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var r = shape.r,
            r0 = shape.r0;
        var cx = 0,
            cy = 0;
        var left = cx - r,
            right = cx + r0,
            top = cy - r0,
            bottom = cy + r0; // return `M${[left, cy].join()}L${[cx, top].join()}Q${[right, cy].join()},${[cx, bottom].join()}Z`;

        ctx.moveTo(left, cy);
        ctx.lineTo(cx, top);
        ctx.quadraticCurveTo(right, cy, cx, bottom);
        ctx.lineTo(left, cy);
      }
    });

    /**
     * 圆角Arc， ZRender提供的arc方法不支持圆角， 而slotGauge中用于需要用形状来clip SweepGradient，按照之前的arc+stroke不能满足需求
     * 这边自定义个一个圆角的Arc，之前使用d3.arc虽然支持圆角，但是圆角是向内的，这就导致startAngle = endAngle = 0，画出的不是一个圆
     * 这里简单实现一个外圆角的圆弧Graphic
     */
    var PI$3 = Math.PI;

    function getPointPos(radius, angle) {
      var x = radius * Math.cos(angle),
          y = radius * Math.sin(angle);
      return [x, y];
    }

    var RoundCornerArc = Path.extend({
      type: "roundCornerArc",
      shape: {
        r: 0,
        r0: 0,
        startAngle: 0,
        endAngle: 0
      },
      style: {},

      /**
       * 外圆角圆弧path生成
       * @param ctx
       * @param r
       * @param r0
       * @param startAngle
       * @param endAngle
       */
      buildPath: function buildPath(ctx, _ref) {
        var r = _ref.r,
            r0 = _ref.r0,
            startAngle = _ref.startAngle,
            endAngle = _ref.endAngle;
        var r1 = (r + r0) / 2,
            rr = Math.abs(r - r0) / 2;
        var p1 = getPointPos(r1, startAngle);
        var p2 = getPointPos(r1, endAngle);
        var cx = 0,
            cy = 0; // 内圆圆弧->结束角度处外接圆弧->外圆圆弧->起始角度处外接圆弧

        ctx.arc(cx, cy, r0, startAngle, endAngle);
        ctx.arc(p2[0], p2[1], rr, endAngle, endAngle + PI$3);
        ctx.arc(cx, cy, r, endAngle, startAngle, true);
        ctx.arc(p1[0], p1[1], rr, startAngle, startAngle - PI$3, true);
      }
    });

    /**
     * 之前的180度指针仪表盘的表盘是使用一个半圆的arc外加下面一个下边圆角矩形，后来和曹笑确定了一下，表盘还有外部阴影等，这就导致冲突
     * 这边用自定义一个180度指针仪表盘的表盘形状，用于绘制180度指针仪表盘的表盘
     */
    var PI$4 = Math.PI;
    var SEMI_PLOT_RECT_HEIGHT = 0.14; // 180度仪表盘底盘超出部分

    var SEMI_PLOT_BORDER_RADIUS = 0.04; // 180度仪表盘底盘圆角

    var SemiPointerGaugePlot = Path.extend({
      type: "semiPointerGaugePlot",
      shape: {
        cx: 0,
        cy: 0,
        r: 0
      },
      style: {},
      buildPath: function buildPath(ctx, _ref) {
        var cx = _ref.cx,
            cy = _ref.cy,
            r = _ref.r;
        var bh = r * SEMI_PLOT_RECT_HEIGHT;
        var br = r * SEMI_PLOT_BORDER_RADIUS;
        var dx = r - br,
            dy = bh - br,
            y2 = cy + dy; // 左侧端点180度大圆弧至右侧端点->右侧端点连线右下方圆角->右下方圆角->右下方圆角连线左下角圆角->左下方圆角->下方圆角连线左下方端点

        ctx.arc(cx, cy, r, PI$4, PI$4 * 2);
        ctx.lineTo(cx + r, y2);
        ctx.arc(cx + dx, y2, br, 0, PI$4 / 2);
        ctx.lineTo(cx - dx, cy + bh);
        ctx.arc(cx - dx, y2, br, PI$4 / 2, PI$4);
        ctx.lineTo(cx - r, cy);
      }
    });

    /**
     * RegionLine for region exhibition of fake point in timing series prediction
     */

    var LINE_WIDTH = 1.5;
    var WIDTH = 7.5;
    var RegionLine = Path.extend({
      type: 'regionLine',
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
      },
      style: {
        lineWidth: LINE_WIDTH
      },
      buildPath: function buildPath(ctx, _ref) {
        var x1 = _ref.x1,
            y1 = _ref.y1,
            x2 = _ref.x2,
            y2 = _ref.y2;
        var horizontal = x1 === x2;

        if (horizontal && y1 === y2) {
          return;
        }

        var width = WIDTH,
            halfWidth = width / 2;

        if (horizontal) {
          ctx.moveTo(x1 - halfWidth, y1);
          ctx.lineTo(x1 + halfWidth, y1);
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.moveTo(x1 - halfWidth, y2);
          ctx.lineTo(x1 + halfWidth, y2);
        } else {
          ctx.moveTo(x1, y1 - halfWidth);
          ctx.lineTo(x1, y1 + halfWidth);
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.moveTo(x2, y2 - halfWidth);
          ctx.lineTo(x2, y2 + halfWidth);
        }
      }
    });

    var AreaMap = Path.extend({
      type: 'areaMap',
      shape: {
        rings: null
      },
      buildPath: function buildPath(ctx, _ref) {
        var rings = _ref.rings;
        var i, j, len, len2, points, p;

        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];

          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
          }
        }
      }
    });

    var xFunc$1 = function xFunc(d) {
      return d.length ? d[0] : d.x;
    };

    var yFunc = function yFunc(d) {
      return d.length ? d[1] : d.y;
    };

    var StrokeLine = Path.extend({
      type: 'strokeLine',
      shape: {
        points: null,
        horizontal: true,
        style: LineStyle.NORMAL // normal || step || curve

      },
      style: {
        stroke: 'none',
        fill: null
      },
      buildPath: function buildPath(ctx, _ref) {
        var points = _ref.points,
            _ref$style = _ref.style,
            style = _ref$style === void 0 ? LineStyle.NORMAL : _ref$style;
        linePainter.x(xFunc$1).y(yFunc).context(ctx).style(style).paint(points);
      }
    });

    var SymbolConstants = {
      // name
      CIRCLE: 'circle',
      SQUARE: 'square',
      DIAMOND: 'diamond',
      TRIANGLE: 'triangle',
      STAR: 'star',
      CIRCLE_HOLLOW: 'circle_hollow',
      SQUARE_HOLLOW: 'square_hollow',
      DIAMOND_HOLLOW: 'diamond_hollow',
      TRIANGLE_HOLLOW: 'triangle_hollow',
      STAR_HOLLOW: 'star_hollow',
      // Geometry
      GEOM_1: 'geometry_1',
      GEOM_2: 'geometry_2',
      GEOM_3: 'geometry_3',
      GEOM_4: 'geometry_4',
      GEOM_5: 'geometry_5',
      GEOM_6: 'geometry_6',
      GEOM_7: 'geometry_7',
      GEOM_8: 'geometry_8',
      GEOM_9: 'geometry_9',
      GEOM_10: 'geometry_10',
      // Trend
      TREND_1: 'trend_1',
      TREND_2: 'trend_2',
      TREND_3: 'trend_3',
      TREND_4: 'trend_4',
      TREND_5: 'trend_5',
      TREND_6: 'trend_6',
      TREND_7: 'trend_7',
      TREND_8: 'trend_8',
      // Determine
      DET_1: 'determine_1',
      DET_2: 'determine_2',
      DET_3: 'determine_3',
      DET_4: 'determine_4',
      DET_5: 'determine_5',
      DET_6: 'determine_6',
      // Light
      LIGHT_1: 'light_1',
      LIGHT_2: 'light_2',
      LIGHT_3: 'light_3',
      LIGHT_4: 'light_4',
      LIGHT_5: 'light_5',
      LIGHT_6: 'light_6',
      // 地图的点
      MAP: 'map_point'
    };

    var _Diamond;
    var sqrt$1 = Math.sqrt;
    var HOLLOW_LINE_WIDTH = 0.2; // 空心形状的默认宽度
    // 钻石图形是在正方形的基础上做了一步旋转操作，这边特殊标注一下

    var Diamond = (_Diamond = {}, _Diamond[SymbolConstants.DIAMOND] = 1, _Diamond[SymbolConstants.DIAMOND_HOLLOW] = 1, _Diamond[SymbolConstants.GEOM_5] = 1, _Diamond[SymbolConstants.GEOM_6] = 1, _Diamond); // 判断是否为基本类图形

    var BASE_SHAPES = ['circle', 'star', 'diamond', 'triangle', 'square', 'geometry', 'rect']; // 是否为空心形状

    var isHollow = function isHollow(symbol) {
      return symbol.indexOf('hollow') >= 0 || symbol.indexOf('geometry') >= 0 && symbol.split('_')[1] % 2 === 0;
    }; // 获取形状对应的 基本类型名称type以及绘制需要的shape

    var getTypeAndShape = function getTypeAndShape(symbol, radius, circumscribed) {
      if (circumscribed === void 0) {
        circumscribed = true;
      }

      // hollow symbol means fill none and stroke, so has halfLineWidth cut off to suit the size.
      // radius = isHollow(symbol) ? (radius - HOLLOW_LINE_WIDTH / 2) : radius;
      radius = Math.max(0, radius);
      var hollow = isHollow(symbol);
      var type, shape;

      switch (symbol) {
        // 实心圆
        case SymbolConstants.CIRCLE:
        case SymbolConstants.GEOM_1:
          type = 'circle';
          shape = {
            r: radius
          };
          break;
        // 空心圆

        case SymbolConstants.CIRCLE_HOLLOW:
        case SymbolConstants.GEOM_2:
          type = 'sector'; // like hollow single Pie

          shape = {
            startAngle: 0,
            endAngle: Math.PI * 2,
            r: radius,
            r0: radius * (1 - HOLLOW_LINE_WIDTH)
          };
          break;
        // 实心五角星&空心五角星

        case SymbolConstants.STAR:
        case SymbolConstants.GEOM_3:
        case SymbolConstants.STAR_HOLLOW:
        case SymbolConstants.GEOM_4:
          type = hollow ? 'hollowStar' : 'star';
          radius *= circumscribed ? 1 : 1 / Math.sin(Math.PI * 2 / 5);
          shape = {
            n: 5,
            r0: radius / 2,
            r: radius
          };
          break;
        // 三角形&

        case SymbolConstants.TRIANGLE:
        case SymbolConstants.GEOM_7:
        case SymbolConstants.TRIANGLE_HOLLOW:
        case SymbolConstants.GEOM_8:
          type = hollow ? 'hollowStar' : 'star';
          radius *= circumscribed ? 1 : 2 / sqrt$1(3);
          shape = {
            n: 3,
            r0: radius / 2,
            r: radius
          };
          break;

        default:
          type = hollow ? 'hollowRect' : 'rect';
          radius *= circumscribed || Diamond[symbol] ? sqrt$1(2) : 2;
          shape = {
            x: -radius / 2,
            y: -radius / 2,
            width: radius,
            height: radius
          };
      }

      return {
        type: type,
        shape: shape
      };
    };
    function isBasicShape(symbol) {
      var f = symbol.split('_')[0];
      return BASE_SHAPES.indexOf(f) >= 0;
    }
    function renderBasicShape(_ref) {
      var symbol = _ref.symbol,
          radius = _ref.radius,
          style = _ref.style,
          circumscribed = _ref.circumscribed,
          rest = _objectWithoutPropertiesLoose(_ref, ["symbol", "radius", "style", "circumscribed"]);

      var _getTypeAndShape = getTypeAndShape(symbol, radius, circumscribed),
          type = _getTypeAndShape.type,
          shape = _getTypeAndShape.shape;

      return h(type, _extends({}, rest, {
        shape: shape,
        rotation: Diamond[symbol] ? Math.PI / 4 : 0,
        style: style
      }));
    }

    var HollowRect = Path.extend({
      type: 'hollowRect',
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function buildPath(ctx, _ref) {
        var x = _ref.x,
            y = _ref.y,
            width = _ref.width,
            height = _ref.height;

        var moveTo = function moveTo(_ref2) {
          var x = _ref2[0],
              y = _ref2[1];
          ctx.moveTo(x, y);
        };

        var lineTo = function lineTo(_ref3) {
          var x = _ref3[0],
              y = _ref3[1];
          ctx.lineTo(x, y);
        };

        var w = Math.ceil(HOLLOW_LINE_WIDTH * width / 2),
            h = Math.ceil(HOLLOW_LINE_WIDTH * height / 2),
            l1 = x,
            t1 = y,
            r1 = x + width,
            b1 = y + height,
            l2 = x + w,
            t2 = y + h,
            r2 = r1 - w,
            b2 = b1 - h; // draw outer rect clockwise & draw inner rect anti-clockwise

        moveTo([l1, t1]);
        lineTo([r1, t1]);
        lineTo([r1, b1]);
        lineTo([l1, b1]);
        lineTo([l1, t1]);
        ctx.closePath();
        moveTo([l2, t2]);
        lineTo([l2, b2]);
        lineTo([r2, b2]);
        lineTo([r2, t2]);
        lineTo([l2, t2]);
        ctx.closePath();
      }
    });

    var sin$2 = Math.sin,
        cos$2 = Math.cos,
        PI$5 = Math.PI; // only for hollow marker

    var HollowStar = Path.extend({
      type: 'hollowStar',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: null,
        n: 3
      },
      buildPath: function buildPath(ctx, _ref) {
        var cx = _ref.cx,
            cy = _ref.cy,
            r = _ref.r,
            r0 = _ref.r0,
            n = _ref.n;

        if (!n || n < 2) {
          return;
        } // 如果未指定内部顶点外接圆半径，则自动计算


        if (r0 == null) {
          r0 = n > 4 // 相隔的外部顶点的连线的交点，
          // 被取为内部交点，以此计算r0
          ? r * cos$2(2 * PI$5 / n) / cos$2(PI$5 / n) // 二三四角星的特殊处理
          : r / 3;
        }

        var stepDeg = PI$5 / n,
            startDeg = -PI$5 / 2;

        var draw = function draw(percent, step) {
          var pr = r * percent,
              pr0 = r0 * percent;
          var deg = startDeg;

          var x = function x(r) {
            return cx + r * cos$2(deg);
          },
              y = function y(r) {
            return cy + r * sin$2(deg);
          };

          ctx.moveTo(x(pr), y(pr));

          for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
            deg += step;
            ri = i % 2 ? pr : pr0;
            ctx.lineTo(x(ri), y(ri));
          }

          ctx.closePath();
        };

        draw(1, stepDeg); // NOTE: 0.2的宽有点细，这边先调成0.4

        draw(1 - HOLLOW_LINE_WIDTH * 2, -stepDeg);
      }
    });

    /**
     * 指针仪表盘指针
     */

    var EffectLine = Path.extend({
      type: "effectLine",
      shape: {
        points: [],
        process: 0,
        stroke: true,
        horizontal: true,
        style: LineStyle.NORMAL,
        stops: null
      },
      style: {
        fill: null,
        stroke: null
      },
      buildPath: function buildPath(ctx, shape) {
        var points = shape.points,
            progress = shape.progress;

        if (points.lenth < 1) {
          return;
        }

        var index = progress | 0,
            pct = progress - index;

        var option = _extends({}, shape, {
          index: index,
          pct: pct
        });

        drawStrokeEffectLine(ctx, option);
      }
    });

    /**
     * for multi lines like girdLines that shared same style.
     * render it
     */

    var MultiLine = Path.extend({
      type: "multiLine",
      shape: {
        lines: null
      },
      style: {
        stroke: "none",
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var lines = shape.lines;

        _.each(lines, function (line) {
          var x1 = line.x1,
              x2 = line.x2,
              y1 = line.y1,
              y2 = line.y2;
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        });
      }
    });

    var graphic = {
      Group: Group,
      Rect: Rect,
      Circle: Circle,
      Text: Text,
      Heart: Heart,
      Polygon: Polygon,
      Polyline: Polyline,
      Line: Line,
      Sector: Sector,
      Star: Star,
      Arc: Arc,
      Image: ZImage,
      Pointer: Pointer,
      VarLine: VarLine,
      KelpLine: KelpLine,
      RadarLine: RadarLine,
      Area: Area,
      RoundCornerArc: RoundCornerArc,
      SemiPointerGaugePlot: SemiPointerGaugePlot,
      RegionLine: RegionLine,
      AreaMap: AreaMap,
      StrokeLine: StrokeLine,
      HollowRect: HollowRect,
      HollowStar: HollowStar,
      EffectLine: EffectLine,
      MultiLine: MultiLine
    };
    forOwn(graphic, function (ctor, k) {
      var type = k[0].toLowerCase() + k.substr(1);

      graphic[type] = function (cfg) {
        return new ctor(cfg);
      };
    }); // todo
    // `path` generated by `createFromString` cannot change the shape
    // we should avoid using `path` in most case

    graphic.path = function (opt) {
      var pathProxy;
      var opts = opt || {};

      opts.buildPath = function (path, shape) {
        var ctx;
        pathProxy = createPathProxyFromString(shape.str);

        if (path.setData) {
          path.setData(pathProxy.data); // Svg and vml renderer don't have context

          ctx = path.getContext();

          if (ctx) {
            path.rebuildPath(ctx);
          }
        } else {
          ctx = path;
          pathProxy.rebuildPath(ctx);
        }
      };

      opts.applyTransform = function (m) {
        transformPath(pathProxy, m);
        this.dirty(true);
      };

      return new Path(opts);
    };
    /**
     * position/scale/origin in attr may be frozen
     * @param attr
     * @returns {*}
     */

    function createHelper(attr) {
      forEach(TransformNames, function (k) {
        if (attr[k]) {
          attr[k] = attr[k].slice();
        }
      });
      return attr;
    }
    /** Create an element with the given nodeName.
     *    @param {String} nodeName
     *    @param {Object} [attr]   - for `path` to initialize
     *    @returns {Element} node
     */


    function createNode(nodeName, attr) {
      var node;

      if (nodeName === 'path') {
        node = graphic.path(createHelper(attr));
        node.ref = null;
      } else {
        node = graphic[nodeName]();
      }

      return node;
    }
    /** Remove a child node from its parent if attached.
     *    @param {Element} node        The node to remove
     */

    function removeNode(node) {
      // let parentNode = node.parentNode;
      // if (parentNode) parentNode.removeChild(node);
      // todo, zr has several remove methods.
      // Is there any difference between `delFromStorage` and `group.remove`...
      var parent = node.parent || node.__zr;

      if (parent) {
        parent.remove(node);
      }

      if (node.__zr) {
        // remove animation
        node.removeSelfFromZr(node.__zr);
      }
    }

    var pairEqual = function pairEqual(a, b) {
      return a[0] === b[0] && a[1] === b[1];
    };
    /** Set a named attribute on the given Node, with special behavior for some names and event handlers.
     *    If `value` is `null`, the attribute/handler will be removed.
     *    @param {Element} node    - An element to mutate
     *    @param {string} name    - The name/key to set, such as an event or attribute name
     *    @param {any} value        - An attribute value, such as a function to be used as an event handler
     *    @param {Boolean} isPure    - Do we need a deep (2th) comparison (e.g. position...)
     *    @returns {boolean} dirty
     */


    function setAccessor(node, name, value, isPure) {
      // We get the `key` from node directly, so no ignore.
      // But as a convention, `key` shouldn't be used outside the diff.
      //
      // if (name==='key') {
      //     // ignore
      // }
      // else
      if (name === 'ref') {
        var old = node[name]; // if (old) old(null);
        // if (value) value(node);
        // node[name] = value;

        if (old !== value) {
          old && old(null);
          value && value(node);
          node[name] = value;
        }
      } // clip, compare inside `setClip`
      else if (name === 'clip') {
          setClip(node, value, isPure);
        } // array (Element.attrKV), a deeper compare
        else if (TransformNamesMap[name]) {
            return attrHelper(node, name, value, isPure);
          } // as simple value (no deep comparison)
          // update if it's impure or not equal
          else if (!(isPure && value === node[name])) {
              // todo, compare attrKV & set manually
              node.attrKV(name, value);
              return true;
            } // todo, gradient?

    }
    /**
     * position, scale, origin helper
     * @param shape
     * @param key
     * @param value
     * @param isPure
     * @returns {boolean} dirty
     */

    function attrHelper(shape, key, value, isPure) {
      shape[key] = shape[key] || [];
      var target = shape[key];

      if (value) {
        // update if it's impure or not equal
        if (!(isPure && pairEqual(value, target))) {
          try {
            target[0] = value[0];
            target[1] = value[1];
          } catch (e) {}

          return true;
        } // else no update

      }

      return false;
    }
    /**
     * Set a clip to shape
     * @param shape    - zr's element
     * @param cfg      - attr.clip
     * @param isPure   - deep (2th) comparison
     */


    function setClip(shape, cfg, isPure) {
      var vclip = shape._vclip; // the same type, update

      if (vclip && vclip.type === cfg.type) {
        // update, or compare & update
        if (!(isPure && _.isMatch(vclip.shape, cfg.shape))) {
          vclip.setShape(cfg.shape);
        }

        var helper = function helper(key) {
          return key in cfg && attrHelper(vclip, key, cfg[key], isPure) && shape.dirty(false);
        };

        helper('position');
        helper('scale');
        helper('origin');
      } else {
        shape._vclip = graphic[cfg.type](createHelper(cfg));
        shape.setClipPath(shape._vclip);
      }

      cfg.ref && cfg.ref(shape._vclip);
    }

    /** Queue of components that have been mounted and are awaiting componentDidMount */

    var mounts = [];
    /** Diff recursion count, used to track the end of the diff cycle. */

    var diffLevel = 0;
    /** Global flag indicating if the diff is performing hydration */

    var hydrating = false;
    /** Invoke queued componentDidMount lifecycle methods */

    function flushMounts() {
      var c;

      while (c = mounts.pop()) {
        if (c.componentDidMount) c.componentDidMount();
      }
    }
    /** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
     *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
     *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
     *	@returns {Element} dom			The created/mutated element
     *	@private
     */

    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
      // diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
      if (!diffLevel++) {
        // when first starting the diff, check if we're diffing an SVG or within an SVG
        // isSvgMode = parent!=null && parent.ownerSVGElement!==undefined;
        // hydration is indicated by the existing element to be diffed not having a prop cache
        hydrating = dom != null && !(ATTR_KEY in dom);
      }

      var ret = idiff(dom, vnode, context, mountAll, componentRoot); // append the element if its a new parent

      if (parent && ret.parent !== parent) parent.add(ret); // diffLevel being reduced to 0 means we're exiting the diff

      if (! --diffLevel) {
        hydrating = false; // invoke queued componentDidMount lifecycle methods

        if (!componentRoot) flushMounts();
      }

      return ret;
    }
    /** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */

    function idiff(dom, vnode, context, mountAll, componentRoot) {
      var out = dom; // empty values (null, undefined, booleans) render as empty Text nodes
      // if (vnode==null || typeof vnode==='boolean') vnode = '';
      // Fast case: Strings & Numbers create/update Text nodes.
      // if (typeof vnode==='string' || typeof vnode==='number') {
      //
      // 	// update if it's already a Text node:
      // 	if (dom && dom.splitText!==undefined && dom.parentNode && (!dom._component || componentRoot)) {
      // 		/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
      // 		if (dom.nodeValue!=vnode) {
      // 			dom.nodeValue = vnode;
      // 		}
      // 	}
      // 	else {
      // 		// it wasn't a Text node: replace it with one and recycle the old Element
      // 		out = document.createTextNode(vnode);
      // 		if (dom) {
      // 			if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
      // 			recollectNodeTree(dom, true);
      // 		}
      // 	}
      //
      // 	out[ATTR_KEY] = true;
      //
      // 	return out;
      // }

      /**
       * no Text Node
       */

      /**
       * by Jeffrey
       * base node -> null
       * dom空vnode可以看作空白text节点
       * 我们没有text node，直接去掉
       */

      if (!vnode) {
        dom && dom.parent && dom.parent.remove(dom);
        return;
      } // If the VNode represents a Component, perform a component diff:


      var vnodeName = vnode.nodeName;

      if (typeof vnodeName === 'function') {
        return buildComponentFromVNode(dom, vnode, context, mountAll);
      } // Tracks entering and exiting SVG namespace when descending through the tree.
      // isSvgMode = vnodeName==='svg' ? true : vnodeName==='foreignObject' ? false : isSvgMode;
      // If there's no existing element or it's the wrong type, create a new one:
      // vnodeName = String(vnodeName);


      if (!dom || !isNamedNode(dom, vnodeName)) {
        out = createNode(vnodeName, vnode.attributes);

        if (dom) {
          // move children into the replacement node
          // while (dom.firstChild) out.appendChild(dom.firstChild);
          // todo, batch add
          while (dom.childCount && dom.childCount()) {
            out.add(dom.childAt(0));
          } // if the previous Element was mounted into the DOM, replace it inline
          // if (dom.parentNode) dom.parentNode.replaceChild(out, dom);


          if (dom.parent) {
            // todo, replace
            dom.parent.addBefore(out, dom);
            dom.parent.remove(dom);
          } // recycle the old element (skips non-Element node types)


          recollectNodeTree(dom, true);
        }
      }

      var fc = out._children && out._children[0],
          props = out[ATTR_KEY],
          vchildren = vnode.children; // todo, can we move this flag behind the `diffAttributes` to indicate the first render?

      if (props == null) {
        props = out[ATTR_KEY] = true; // for (let a=out.attributes, i=a.length; i--; ) props[a[i].name] = a[i].value;
      } // // Optimization: fast-path for elements containing a single TextNode:
      // if (!hydrating && vchildren && vchildren.length===1 && typeof vchildren[0]==='string' && fc!=null && fc.splitText!==undefined && fc.nextSibling==null) {
      // 	if (fc.nodeValue!=vchildren[0]) {
      // 		fc.nodeValue = vchildren[0];
      // 	}
      // }
      // // otherwise, if there are existing or new children, diff them:
      // else


      if (vchildren && vchildren.length || fc != null) {
        innerDiffNode(out, vchildren, context, mountAll, hydrating);
      } // Apply attributes/props from VNode to the DOM Element:


      diffAttributes(out, vnode.attributes
      /*, props*/
      ); // restore previous SVG mode: (in case we're exiting an SVG namespace)
      // isSvgMode = prevSvgMode;

      return out;
    }
    /** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
     *	@param {Element} dom			Element whose children should be compared & mutated
     *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
     *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
     *	@param {Boolean} mountAll
     *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
     */


    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
      var originalChildren = dom._children,
          children = [],
          keyed = {},
          keyedLen = 0,
          min = 0,
          len = originalChildren.length,
          childrenLen = 0,
          vlen = vchildren ? vchildren.length : 0,
          j,
          c,
          f,
          vchild,
          child; // Build up a map of keyed children and an Array of unkeyed children:

      if (len !== 0) {
        for (var i = 0; i < len; i++) {
          var _child = originalChildren[i],
              // props = child[ATTR_KEY],
          props = _child,
              key = vlen && props ? _child._component ? _child._component.__key : props.key : null;

          if (key != null) {
            keyedLen++;
            keyed[key] = _child;
          } // todo, remove this condition
          else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
              children[childrenLen++] = _child;
            }
        }
      }

      if (vlen !== 0) {
        for (var _i = 0; _i < vlen; _i++) {
          vchild = vchildren[_i];
          child = null; // attempt to find a node based on key matching

          var _key = vchild.key;

          if (_key != null) {
            if (keyedLen && keyed[_key] !== undefined) {
              child = keyed[_key];
              keyed[_key] = undefined;
              keyedLen--;
            }
          } // attempt to pluck a node of the same type from the existing children
          else if (!child && min < childrenLen) {
              for (j = min; j < childrenLen; j++) {
                if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
                  child = c;
                  children[j] = undefined;
                  if (j === childrenLen - 1) childrenLen--;
                  if (j === min) min++;
                  break;
                }
              }
            } // morph the matched/found/created DOM child to match vchild (deep)


          child = idiff(child, vchild, context, mountAll);
          f = originalChildren[_i];

          if (child && child !== dom && child !== f) {
            if (f == null) {
              dom.add(child);
            } // else if (child===f.nextSibling) {
            // todo, optimize
            else if (child === dom._children[dom._children.indexOf(f) + 1]) ; else {
                dom.addBefore(child, f);
              }
          }
        }
      } // remove unused keyed children:


      if (keyedLen) {
        for (var _i2 in keyed) {
          if (keyed[_i2] !== undefined) recollectNodeTree(keyed[_i2], false);
        }
      } // remove orphaned unkeyed children:


      while (min <= childrenLen) {
        if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
      }
    }
    /** Recursively recycle (or just unmount) a node and its descendants.
     *	@param {Node} node						DOM node to start unmount/removal from
     *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
     */


    function recollectNodeTree(node, unmountOnly) {
      var component = node._component;

      if (component) {
        // if node is owned by a Component, unmount that component (ends up recursing back here)
        unmountComponent(component);
      } else {
        // If the node's VNode had a ref function, invoke it with null here.
        // (this is part of the React spec, and smart for unsetting references)
        // if (node[ATTR_KEY]!=null && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);
        if (node.ref) node.ref(null);

        if (unmountOnly === false || node[ATTR_KEY] == null) {
          removeNode(node);
        }

        removeChildren(node);
      }
    }
    /** Recollect/unmount all children.
     *	- we use .lastChild here because it causes less reflow than .firstChild
     *	- it's also cheaper than accessing the .childNodes Live NodeList
     */

    function removeChildren(node) {
      var children = node._children;

      if (children) {
        forEach(children, function (child) {
          child && recollectNodeTree(child, true);
        });
      }
    }
    /** Apply differences in attributes from a VNode to the given DOM Element.
     *	@param {Group|Path} element - Element (zr's) with attributes to diff `attrs` against
     *	@param {Object} attrs		- The desired end-state key-value attribute pairs
     *	// @param {Object} old		- Current/previous attributes (from previous VNode or element's prop cache)
     *  old 空
     * 添加key:
     * 'clip': 添加clip
     * 'pure': 比较group属性防止无用刷新（当多层时）
     *
     * @example
     * {
     *     pure: true,
     *     clip: {
     *         type: 'rect',
     *         shape: {},
     *         position: []
     *     }
     * }
     */

    function diffAttributes(element, attrs) {
      var name; // // remove attributes no longer present on the vnode by setting them to undefined
      // for (name in old) {
      // 	if (!(attrs && attrs[name]!=null) && old[name]!=null) {
      // 		setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
      // 	}
      // }
      //
      // // add new & update changed attributes
      // for (name in attrs) {
      // 	if (name!=='children' && name!=='innerHTML' && (!(name in old) || attrs[name]!==(name==='value' || name==='checked' ? dom[name] : old[name]))) {
      // 		setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
      // 	}
      // }
      // zr-class.attr:
      //
      // Element.attr = attrKVs + dirty
      // Element.attrKV 特殊处理了position, scale, origin
      //
      // Group extends Element
      // Group.attr = Element.attr
      //
      // Displayable extends Element
      // Displayable.attrKV特殊处理了style
      //
      // Path extends Displayable
      // Path.attrKV特殊处理了shape

      if (!attrs) {
        return;
      }

      var isPure = attrs.pure; // `pure` -> compare attrs
      // default is dirty

      var dirty = true; // otherwise we don't know if it's dirty now, compare

      if (isPure) {
        dirty = false;
      } // here may be a bug:
      // h('group', { foo: 1, bar: 2 }) -> h('group', { foo: 1 })
      // but why not set it to `null` explicitly


      if (element.animators.length) {
        // stop previous animation
        element.stopAnimation();
      } // todo, 搞一搞这里居然已经变得这么冗余的关系……


      var isFirstRender = element[ATTR_KEY] !== RENDERED; // no transition in the first render unless `appear` set

      if (attrs.transition && (!isFirstRender || attrs.transition.appear)) {
        var transition = attrs.transition;
        var properties = transition.properties || AnimationNamesMap;
        var appear;

        if (isFirstRender || transition.forceAppear) {
          appear = transition.appear && transition.appear(attrs);
        }

        var _loop = function _loop() {
          if (!attrs.hasOwnProperty(name) || name === 'transition' || name === 'transitionEnd') {
            return "continue";
          }

          var value = attrs[name];
          var appearValue = appear && appear[name];

          if (properties[name] && (!isFirstRender || appearValue)) {
            // gradient no animation
            if (name === 'style') {
              _.each(value, function (sv, sk) {
                if (typeof sv === "object" || typeof element.style[sk] === "object") {
                  element.setStyle(sk, sv);
                  delete value[sk];
                }
              });

              if (value.text != null) {
                element.setStyle("text", value.text);
                delete value.text;
              } // apply blend to element.style immediately


              if (value.blend != null) {
                element.setStyle("blend", value.blend);
              }
            } // zr's animator.when(0) logic is buggy...


            if (appearValue) {
              element.attrKV(name, appearValue);
            } // fixMe ignored animation  key


            if (name === "shape" && value.style) {
              value.style && element.attr("shape", {
                style: value.style,
                stroke: value.stroke
              });
            } // todo,
            // animate doesn't support animate('key')...
            // We can make a custom fn...
            // And add transition key support


            if (name === 'rotation' || name === "origin") {
              var _element$animate$dela;

              element.animate('').delay(transition.delay).when(transition.duration, (_element$animate$dela = {}, _element$animate$dela[name] = value, _element$animate$dela)).start(transition.ease, appearValue);
            } else if (name === "shape" && value.str) {
              element.attrKV(name, value); // for path animate no use, update shape directly
            } else {
              var animator = element.animate(name).delay(transition.delay);
              var frames = transition.frames;

              if (frames && frames[name]) {
                _.each(frames[name], function (_ref) {
                  var frame = _ref.frame,
                      value = _ref.value;
                  animator.when(frame, value);
                });
              } else {
                animator.when(transition.duration, value);
              }

              animator.start(transition.ease, appearValue);
            }
          } else {
            var result = setAccessor(element, name, value, isPure);
            dirty = dirty || result;
          }
        };

        for (name in attrs) {
          var _ret = _loop();

          if (_ret === "continue") continue;
        }
      } else {
        for (name in attrs) {
          if (!attrs.hasOwnProperty(name) || name === 'transition' || name === 'transitionEnd') {
            continue;
          }

          var value = attrs[name];
          var result = setAccessor(element, name, value, isPure);
          dirty = dirty || result;
        }
      }

      var end = attrs['transitionEnd'];
      var animators = element.animators;

      if (end && animators.length) {
        animators[animators.length - 1].done(function () {
          end(element);
        });
      }

      dirty && element.dirty(false);
      element[ATTR_KEY] = RENDERED;
    }

    /** Retains a pool of Components for re-use, keyed on component name.
     *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
     *	@private
     */

    var components = {};
    /** Create a component. Normalizes differences between PFC's and classful Components. */

    function createComponent(Ctor, props, context) {
      var list = components[Ctor.name],
          inst;

      if (Ctor.prototype && Ctor.prototype.render) {
        inst = new Ctor(props, context);
        Component.call(inst, props, context);
      } else {
        inst = new Component(props, context);
        inst.constructor = Ctor;
        inst.render = doRender;
      }

      if (list) {
        for (var i = list.length; i--;) {
          if (list[i].constructor === Ctor) {
            inst.nextBase = list[i].nextBase;
            list.splice(i, 1);
            break;
          }
        }
      }

      return inst;
    }
    /** The `.render()` method for a PFC backing instance. */

    function doRender(props, state, context) {
      return this.constructor(props, context);
    }

    /** Set a component's `props` (generally derived from JSX attributes).
     *	@param {Object} props
     *	@param {Object} [opts]
     *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
     *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
     */

    function setComponentProps(component, props, opts, context, mountAll) {
      if (component._disable) return;
      component._disable = true;
      if (component.__ref = props.ref) delete props.ref;
      if (component.__key = props.key) delete props.key;

      if (!component.base || mountAll) {
        if (component.componentWillMount) component.componentWillMount();
      } else if (component.componentWillReceiveProps) {
        component.componentWillReceiveProps(props, context);
      }

      if (context && context !== component.context) {
        if (!component.prevContext) component.prevContext = component.context;
        component.context = context;
      }

      if (!component.prevProps) component.prevProps = component.props;
      component.props = props;
      component._disable = false;

      if (opts !== NO_RENDER) {
        if (opts === SYNC_RENDER || options.syncComponentUpdates !== false || !component.base) {
          renderComponent(component, SYNC_RENDER, mountAll);
        } else {
          enqueueRender(component);
        }
      }

      if (component.__ref) component.__ref(component);
    }
    /** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
     *	@param {Component} component
     *	@param {Object} [opts]
     *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
     *	@private
     */

    function renderComponent(component, opts, mountAll, isChild) {
      if (component._disable) return;
      var props = component.props,
          state = component.state,
          context = component.context,
          previousProps = component.prevProps || props,
          previousState = component.prevState || state,
          previousContext = component.prevContext || context,
          isUpdate = component.base,
          nextBase = component.nextBase,
          initialBase = isUpdate || nextBase,
          initialChildComponent = component._component,
          skip = false,
          rendered,
          inst,
          cbase; // if updating

      if (isUpdate) {
        component.props = previousProps;
        component.state = previousState;
        component.context = previousContext;

        if (opts !== FORCE_RENDER && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
          skip = true;
        } else if (component.componentWillUpdate) {
          component.componentWillUpdate(props, state, context);
        }

        component.props = props;
        component.state = state;
        component.context = context;
      }

      component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
      component._dirty = false;

      if (!skip) {
        rendered = component.render(props, state, context); // context to pass to the child, can be updated via (grand-)parent component

        if (component.getChildContext) {
          context = extend(extend({}, context), component.getChildContext());
        }

        var childComponent = rendered && rendered.nodeName,
            toUnmount,
            base;

        if (typeof childComponent === 'function') {
          // set up high order component link
          var childProps = getNodeProps(rendered);
          inst = initialChildComponent;

          if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
            setComponentProps(inst, childProps, SYNC_RENDER, context, false);
          } else {
            toUnmount = inst;
            component._component = inst = createComponent(childComponent, childProps, context);
            inst.nextBase = inst.nextBase || nextBase;
            inst._parentComponent = component;
            setComponentProps(inst, childProps, NO_RENDER, context, false);
            renderComponent(inst, SYNC_RENDER, mountAll, true);
          }

          base = inst.base;
        } else {
          cbase = initialBase; // destroy high order component link

          toUnmount = initialChildComponent;

          if (toUnmount) {
            cbase = component._component = null;
          }

          if (initialBase || opts === SYNC_RENDER) {
            if (cbase) cbase._component = null;
            base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parent, true);
          }
        }

        if (initialBase && base !== initialBase && inst !== initialChildComponent) {
          var baseParent = initialBase.parent;

          if (baseParent && base !== baseParent) {
            // baseParent.replaceChild(base, initialBase);
            baseParent.addBefore(base, initialBase);
            baseParent.remove(initialBase);

            if (!toUnmount) {
              initialBase._component = null;
              recollectNodeTree(initialBase, false);
            }
          }
        }

        if (toUnmount) {
          unmountComponent(toUnmount);
        }

        component.base = base;

        if (base && !isChild) {
          var componentRef = component,
              t = component;

          while (t = t._parentComponent) {
            (componentRef = t).base = base;
          }

          base._component = componentRef;
          base._componentConstructor = componentRef.constructor;
        }
      }

      if (!isUpdate || mountAll) {
        mounts.unshift(component);
      } else if (!skip) {
        // Ensure that pending componentDidMount() hooks of child components
        // are called before the componentDidUpdate() hook in the parent.
        // Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
        // flushMounts();
        if (component.componentDidUpdate) {
          component.componentDidUpdate(previousProps, previousState, previousContext);
        }
      }

      if (component._renderCallbacks != null) {
        while (component._renderCallbacks.length) {
          component._renderCallbacks.pop().call(component);
        }
      }

      if (!diffLevel && !isChild) flushMounts();
    }
    /** Apply the Component referenced by a VNode to the DOM.
     *	@param {Element} dom	The DOM node to mutate
     *	@param {VNode} vnode	A Component-referencing VNode
     *	@returns {Element} dom	The created/mutated element
     *	@private
     */

    function buildComponentFromVNode(dom, vnode, context, mountAll) {
      var c = dom && dom._component,
          originalComponent = c,
          oldDom = dom,
          isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
          isOwner = isDirectOwner,
          props = getNodeProps(vnode);

      while (c && !isOwner && (c = c._parentComponent)) {
        isOwner = c.constructor === vnode.nodeName;
      }

      if (c && isOwner && (!mountAll || c._component)) {
        setComponentProps(c, props, ASYNC_RENDER, context, mountAll);
        dom = c.base;
      } else {
        if (originalComponent && !isDirectOwner) {
          unmountComponent(originalComponent);
          dom = oldDom = null;
        }

        c = createComponent(vnode.nodeName, props, context);

        if (dom && !c.nextBase) {
          c.nextBase = dom; // passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:

          oldDom = null;
        }

        setComponentProps(c, props, SYNC_RENDER, context, mountAll);
        dom = c.base;

        if (oldDom && dom !== oldDom) {
          oldDom._component = null;
          recollectNodeTree(oldDom, false);
        }
      }

      return dom;
    }
    /** Remove a component from the DOM and recycle it.
     *	@param {Component} component	The Component instance to unmount
     *	@private
     */

    function unmountComponent(component) {
      var base = component.base;
      component._disable = true;
      if (component.componentWillUnmount) component.componentWillUnmount();
      component.base = null; // recursively tear down & recollect high-order component children:

      var inner = component._component;

      if (inner) {
        unmountComponent(inner);
      } else if (base) {
        if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);
        component.nextBase = base;
        removeNode(base); // 收集之后重新使用，重新setProps的时候，会导致一些属性不会被置为默认，这边先注释掉
        // collectComponent(component);

        removeChildren(base);
      }

      if (component.__ref) component.__ref(null);
    }

    /** Base Component class.
     *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
     *	@public
     *
     *	@example
     *	class MyFoo extends Component {
     *		render(props, state) {
     *			return <div />;
     *		}
     *	}
     */

    function Component(props, context) {
      this._dirty = true;
      /** @public
       *	@type {object}
       */

      this.context = context;
      /** @public
       *	@type {object}
       */

      this.props = props;
      /** @public
       *	@type {object}
       */

      this.state = this.state || {};
    }
    extend(Component.prototype, {
      /** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
       *	@param {object} nextProps
       *	@param {object} nextState
       *	@param {object} nextContext
       *	@returns {Boolean} should the component re-render
       *	@name shouldComponentUpdate
       *	@function
       */

      /** Update component state by copying properties from `state` to `this.state`.
       *	@param {object} state		A hash of state properties to update with new values
       *	@param {function} callback	A function to be called once component state is updated
       */
      setState: function setState(state, callback) {
        var s = this.state;
        if (!this.prevState) this.prevState = extend({}, s);
        extend(s, typeof state === 'function' ? state(s, this.props) : state);
        if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
        enqueueRender(this);
      },

      /** Immediately perform a synchronous re-render of the component.
       *	@param {function} callback		A function to be called after component is re-rendered.
       *	@private
       */
      forceUpdate: function forceUpdate(callback) {
        if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
        renderComponent(this, FORCE_RENDER);
      },

      /** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
       *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
       *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
       *	@param {object} state		The component's current state
       *	@param {object} context		Context object (if a parent component has provided context)
       *	@returns VNode
       */
      render: function render() {}
    });

    var PureComponent$$1 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(PureComponent$$1, _Component);

      function PureComponent$$1(props, context) {
        return _Component.call(this, props, context) || this;
      }

      var _proto = PureComponent$$1.prototype;

      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
      };

      return PureComponent$$1;
    }(Component);

    // TODO Draggable for group
    // FIXME Draggable on element which has parent rotation or scale
    function Draggable() {
      this.on('mousedown', this._dragStart, this);
      this.on('mousemove', this._drag, this);
      this.on('mouseup', this._dragEnd, this);
      this.on('globalout', this._dragEnd, this); // this._dropTarget = null;
      // this._draggingTarget = null;
      // this._x = 0;
      // this._y = 0;
    }

    Draggable.prototype = {
      constructor: Draggable,
      _dragStart: function _dragStart(e) {
        var draggingTarget = e.target;

        if (draggingTarget && draggingTarget.draggable) {
          this._draggingTarget = draggingTarget;
          draggingTarget.dragging = true;
          this._x = e.offsetX;
          this._y = e.offsetY;
          this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);
        }
      },
      _drag: function _drag(e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
          var x = e.offsetX;
          var y = e.offsetY;
          var dx = x - this._x;
          var dy = y - this._y;
          this._x = x;
          this._y = y;
          draggingTarget.drift(dx, dy, e);
          this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);
          var dropTarget = this.findHover(x, y, draggingTarget).target;
          var lastDropTarget = this._dropTarget;
          this._dropTarget = dropTarget;

          if (draggingTarget !== dropTarget) {
            if (lastDropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);
            }

            if (dropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);
            }
          }
        }
      },
      _dragEnd: function _dragEnd(e) {
        var draggingTarget = this._draggingTarget;

        if (draggingTarget) {
          draggingTarget.dragging = false;
        }

        this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);

        if (this._dropTarget) {
          this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);
        }

        this._draggingTarget = null;
        this._dropTarget = null;
      }
    };

    function param(target, e) {
      return {
        target: target,
        topTarget: e && e.topTarget
      };
    }

    /**
     * 事件辅助类
     * @module zrender/core/event
     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
     */
    var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;

    function getBoundingClientRect(el) {
      // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
      return el.getBoundingClientRect ? el.getBoundingClientRect() : {
        left: 0,
        top: 0
      };
    } // `calculate` is optional, default false


    function clientToLocal(el, e, out, calculate) {
      out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative
      // to the padding edge of the target element. The only browser using this convention
      // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
      // not support the properties.
      // (see http://www.jacklmoore.com/notes/mouse-position/)
      // In zr painter.dom, padding edge equals to border edge.
      // FIXME
      // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
      // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
      // is too complex. So css-transfrom dont support in this case temporarily.

      if (calculate || !env$1.canvasSupported) {
        defaultGetZrXY(el, e, out);
      } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
      // ancestor element, so we should make sure el is positioned (e.g., not position:static).
      // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
      // zoom-factor, overflow / opacity layers, transforms ...)
      // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
      // <https://bugs.jquery.com/ticket/8523#comment:14>
      // BTW3, In ff, offsetX/offsetY is always 0.
      else if (env$1.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
          out.zrX = e.layerX;
          out.zrY = e.layerY;
        } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
        else if (e.offsetX != null) {
            out.zrX = e.offsetX;
            out.zrY = e.offsetY;
          } // For some other device, e.g., IOS safari.
          else {
              defaultGetZrXY(el, e, out);
            }

      return out;
    }

    function defaultGetZrXY(el, e, out) {
      // This well-known method below does not support css transform.
      var box = getBoundingClientRect(el);
      out.zrX = e.clientX - box.left;
      out.zrY = e.clientY - box.top;
    }
    /**
     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
     * `calculate` is optional, default false.
     */


    function normalizeEvent(el, e, calculate) {
      e = e || window.event;

      if (e.zrX != null) {
        return e;
      }

      var eventType = e.type;
      var isTouch = eventType && eventType.indexOf('touch') >= 0;

      if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
      } else {
        var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
      } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;
      // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js
      // If e.which has been defined, if may be readonly,
      // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which


      var button = e.button;

      if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
        e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
      }

      return e;
    }
    /**
     * @param {HTMLElement} el
     * @param {string} name
     * @param {Function} handler
     */

    function addEventListener(el, name, handler) {
      if (isDomLevel2) {
        // Reproduct the console warning:
        // [Violation] Added non-passive event listener to a scroll-blocking <some> event.
        // Consider marking event handler as 'passive' to make the page more responsive.
        // Just set console log level: verbose in chrome dev tool.
        // then the warning log will be printed when addEventListener called.
        // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
        // We have not yet found a neat way to using passive. Because in zrender the dom event
        // listener delegate all of the upper events of element. Some of those events need
        // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.
        // Before passive can be adopted, these issues should be considered:
        // (1) Whether and how a zrender user specifies an event listener passive. And by default,
        // passive or not.
        // (2) How to tread that some zrender event listener is passive, and some is not. If
        // we use other way but not preventDefault of mousewheel and touchmove, browser
        // compatibility should be handled.
        // var opts = (env.passiveSupported && name === 'mousewheel')
        //     ? {passive: true}
        //     // By default, the third param of el.addEventListener is `capture: false`.
        //     : void 0;
        // el.addEventListener(name, handler /* , opts */);
        el.addEventListener(name, handler);
      } else {
        el.attachEvent('on' + name, handler);
      }
    }
    function removeEventListener(el, name, handler) {
      if (isDomLevel2) {
        el.removeEventListener(name, handler);
      } else {
        el.detachEvent('on' + name, handler);
      }
    }
    /**
     * preventDefault and stopPropagation.
     * Notice: do not do that in zrender. Upper application
     * do that if necessary.
     *
     * @memberOf module:zrender/core/event
     * @method
     * @param {Event} e : event对象
     */

    var stop = isDomLevel2 ? function (e) {
      e.preventDefault();
      e.stopPropagation();
      e.cancelBubble = true;
    } : function (e) {
      e.returnValue = false;
      e.cancelBubble = true;
    };

    var SILENT = 'silent';

    function makeEventPacket(eveType, targetInfo, event) {
      return {
        type: eveType,
        event: event,
        // target can only be an element that is not silent.
        target: targetInfo.target,
        // topTarget can be a silent element.
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which,
        stop: stopEvent
      };
    }

    function stopEvent(event) {
      stop(this.event);
    }

    function EmptyProxy() {}

    EmptyProxy.prototype.dispose = function () {};

    var handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
    /**
     * @alias module:zrender/Handler
     * @constructor
     * @extends module:zrender/mixin/Eventful
     * @param {module:zrender/Storage} storage Storage instance.
     * @param {module:zrender/Painter} painter Painter instance.
     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
     */

    var Handler = function Handler(storage, painter, proxy, painterRoot) {
      Eventful.call(this);
      this.storage = storage;
      this.painter = painter;
      this.painterRoot = painterRoot;
      proxy = proxy || new EmptyProxy();
      /**
       * Proxy of event. can be Dom, WebGLSurface, etc.
       */

      this.proxy = null;
      /**
       * {target, topTarget, x, y}
       * @private
       * @type {Object}
       */

      this._hovered = {};
      /**
       * @private
       * @type {Date}
       */

      this._lastTouchMoment;
      /**
       * @private
       * @type {number}
       */

      this._lastX;
      /**
       * @private
       * @type {number}
       */

      this._lastY;
      Draggable.call(this);
      this.setHandlerProxy(proxy);
    };

    Handler.prototype = {
      constructor: Handler,
      setHandlerProxy: function setHandlerProxy(proxy) {
        if (this.proxy) {
          this.proxy.dispose();
        }

        if (proxy) {
          each(handlerNames, function (name) {
            proxy.on && proxy.on(name, this[name], this);
          }, this); // Attach handler

          proxy.handler = this;
        }

        this.proxy = proxy;
      },
      mousemove: function mousemove(event) {
        var x = event.zrX;
        var y = event.zrY;
        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call
        // (like 'setOption' or 'dispatchAction') in event handlers, we should find
        // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.
        // See #6198.

        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
          lastHovered = this.findHover(lastHovered.x, lastHovered.y);
          lastHoveredTarget = lastHovered.target;
        }

        var hovered = this._hovered = this.findHover(x, y);
        var hoveredTarget = hovered.target;
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element

        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(lastHovered, 'mouseout', event);
        } // Mouse moving on one element


        this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element

        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(hovered, 'mouseover', event);
        }
      },
      mouseout: function mouseout(event) {
        this.dispatchToElement(this._hovered, 'mouseout', event); // There might be some doms created by upper layer application
        // at the same level of painter.getViewportRoot() (e.g., tooltip
        // dom created by echarts), where 'globalout' event should not
        // be triggered when mouse enters these doms. (But 'mouseout'
        // should be triggered at the original hovered element as usual).

        var element = event.toElement || event.relatedTarget;
        var innerDom;

        do {
          element = element && element.parentNode;
        } while (element && element.nodeType !== 9 && !(innerDom = element === this.painterRoot));

        !innerDom && this.trigger('globalout', {
          event: event
        });
      },

      /**
       * Resize
       */
      resize: function resize(event) {
        this._hovered = {};
      },

      /**
       * Dispatch event
       * @param {string} eventName
       * @param {event=} eventArgs
       */
      dispatch: function dispatch(eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
      },

      /**
       * Dispose
       */
      dispose: function dispose() {
        this.proxy.dispose();
        this.storage = this.proxy = this.painter = null;
      },

      /**
       * 设置默认的cursor style
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function setCursorStyle(cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
      },

      /**
       * 事件分发代理
       *
       * @private
       * @param {Object} targetInfo {target, topTarget} 目标图形元素
       * @param {string} eventName 事件名称
       * @param {Object} event 事件对象
       */
      dispatchToElement: function dispatchToElement(targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;

        if (el && el.silent) {
          return;
        }

        var eventHandler = 'on' + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);

        while (el) {
          el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
          el.trigger(eventName, eventPacket);
          el = el.parent;

          if (eventPacket.cancelBubble) {
            break;
          }
        }

        if (!eventPacket.cancelBubble) {
          // 冒泡到顶级 zrender 对象
          this.trigger(eventName, eventPacket); // 分发事件到用户自定义层
          // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在

          this.painter && this.painter.eachOtherLayer(function (layer) {
            if (typeof layer[eventHandler] === 'function') {
              layer[eventHandler].call(layer, eventPacket);
            }

            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      },

      /**
       * @private
       * @param {number} x
       * @param {number} y
       * @param {module:zrender/graphic/Displayable} exclude
       * @return {model:zrender/Element}
       * @method
       */
      findHover: function findHover(x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = {
          x: x,
          y: y
        };

        for (var i = list.length - 1; i >= 0; i--) {
          var hoverCheckResult;

          if (list[i] !== exclude // getDisplayList may include ignored item in VML mode
          && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
            !out.topTarget && (out.topTarget = list[i]);

            if (hoverCheckResult !== SILENT) {
              out.target = list[i];
              break;
            }
          }
        }

        return out;
      }
    }; // Common handlers

    each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
      Handler.prototype[name] = function (event) {
        // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
        var hovered = this.findHover(event.zrX, event.zrY);
        var hoveredTarget = hovered.target;

        if (name === 'mousedown') {
          this._downEl = hoveredTarget;
          this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup

          this._upEl = hoveredTarget;
        } else if (name === 'mouseup') {
          this._upEl = hoveredTarget;
        } else if (name === 'click') {
          if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,
          // including the case that `mousedown` - `mousemove` - `mouseup`,
          // which should be filtered, otherwise it will bring trouble to
          // pan and zoom.
          || !this._downPoint // Arbitrary value
          || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
            return;
          }

          this._downPoint = null;
        }

        this.dispatchToElement(hovered, name, event);
      };
    });

    function isHover(displayable, x, y) {
      if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
        var el = displayable;
        var isSilent;

        while (el) {
          // If clipped by ancestor.
          // FIXME: If clipPath has neither stroke nor fill,
          // el.clipPath.contain(x, y) will always return false.
          if (el.clipPath && !el.clipPath.contain(x, y)) {
            return false;
          }

          if (el.silent) {
            isSilent = true;
          }

          el = el.parent;
        }

        return isSilent ? SILENT : true;
      }

      return false;
    }

    mixin(Handler, Eventful);
    mixin(Handler, Draggable);

    // https://github.com/mziccard/node-timsort
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;

    function minRunLength(n) {
      var r = 0;

      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }

      return n + r;
    }

    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;

      if (runHi === hi) {
        return 1;
      }

      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }

        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }

      return runHi - lo;
    }

    function reverseRun(array, lo, hi) {
      hi--;

      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }

    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }

      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        var mid;

        while (left < right) {
          mid = left + right >>> 1;

          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }

        var n = start - left;

        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];

          case 2:
            array[left + 2] = array[left + 1];

          case 1:
            array[left + 1] = array[left];
            break;

          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }

        }

        array[left] = pivot;
      }
    }

    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }

      return offset;
    }

    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;

      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;

        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;

        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;

          if (offset <= 0) {
            offset = maxOffset;
          }
        }

        if (offset > maxOffset) {
          offset = maxOffset;
        }

        lastOffset += hint;
        offset += hint;
      }

      lastOffset++;

      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);

        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }

      return offset;
    }

    function TimSort(array, compare) {
      var minGallop = DEFAULT_MIN_GALLOPING;
      var length = 0;
      var runStart;
      var runLength;
      var stackSize = 0;
      length = array.length;

      var tmp = [];
      runStart = [];
      runLength = [];

      function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
      }

      function mergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;

          if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
            if (runLength[n - 1] < runLength[n + 1]) {
              n--;
            }
          } else if (runLength[n] > runLength[n + 1]) {
            break;
          }

          mergeAt(n);
        }
      }

      function forceMergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;

          if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
            n--;
          }

          mergeAt(n);
        }
      }

      function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];
        runLength[i] = length1 + length2;

        if (i === stackSize - 3) {
          runStart[i + 1] = runStart[i + 2];
          runLength[i + 1] = runLength[i + 2];
        }

        stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;

        if (length1 === 0) {
          return;
        }

        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

        if (length2 === 0) {
          return;
        }

        if (length1 <= length2) {
          mergeLow(start1, length1, start2, length2);
        } else {
          mergeHigh(start1, length1, start2, length2);
        }
      }

      function mergeLow(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }

        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];

        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }

          return;
        }

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
          return;
        }

        var _minGallop = minGallop;
        var count1, count2, exit;

        while (1) {
          count1 = 0;
          count2 = 0;
          exit = false;

          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;

              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;

              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }

              dest += count1;
              cursor1 += count1;
              length1 -= count1;

              if (length1 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest++] = array[cursor2++];

            if (--length2 === 0) {
              exit = true;
              break;
            }

            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }

              dest += count2;
              cursor2 += count2;
              length2 -= count2;

              if (length2 === 0) {
                exit = true;
                break;
              }
            }

            array[dest++] = tmp[cursor1++];

            if (--length1 === 1) {
              exit = true;
              break;
            }

            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (_minGallop < 0) {
            _minGallop = 0;
          }

          _minGallop += 2;
        }

        minGallop = _minGallop;
        minGallop < 1 && (minGallop = 1);

        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }

          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error(); // throw new Error('mergeLow preconditions were not respected');
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      }

      function mergeHigh(start1, length1, start2, length2) {
        var i = 0;

        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }

        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];

        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }

          return;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
          return;
        }

        var _minGallop = minGallop;

        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;

          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;

              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;

              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);

          if (exit) {
            break;
          }

          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;

              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }

              if (length1 === 0) {
                exit = true;
                break;
              }
            }

            array[dest--] = tmp[cursor2--];

            if (--length2 === 1) {
              exit = true;
              break;
            }

            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;

              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }

              if (length2 <= 1) {
                exit = true;
                break;
              }
            }

            array[dest--] = array[cursor1--];

            if (--length1 === 0) {
              exit = true;
              break;
            }

            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

          if (exit) {
            break;
          }

          if (_minGallop < 0) {
            _minGallop = 0;
          }

          _minGallop += 2;
        }

        minGallop = _minGallop;

        if (minGallop < 1) {
          minGallop = 1;
        }

        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;

          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }

          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error(); // throw new Error('mergeHigh preconditions were not respected');
        } else {
          customCursor = dest - (length2 - 1);

          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      }

      this.mergeRuns = mergeRuns;
      this.forceMergeRuns = forceMergeRuns;
      this.pushRun = pushRun;
    }

    function sort(array, compare, lo, hi) {
      if (!lo) {
        lo = 0;
      }

      if (!hi) {
        hi = array.length;
      }

      var remaining = hi - lo;

      if (remaining < 2) {
        return;
      }

      var runLength = 0;

      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }

      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);

      do {
        runLength = makeAscendingRun(array, lo, hi, compare);

        if (runLength < minRun) {
          var force = remaining;

          if (force > minRun) {
            force = minRun;
          }

          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }

        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);

      ts.forceMergeRuns();
    }

    function shapeCompareFunc(a, b) {
      if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
          // if (a.z2 === b.z2) {
          //     // FIXME Slow has renderidx compare
          //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
          //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
          //     return a.__renderidx - b.__renderidx;
          // }
          return a.z2 - b.z2;
        }

        return a.z - b.z;
      }

      return a.zlevel - b.zlevel;
    }
    /**
     * 内容仓库 (M)
     * @alias module:zrender/Storage
     * @constructor
     */


    var Storage = function Storage() {
      // jshint ignore:line
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
    };

    Storage.prototype = {
      constructor: Storage,

      /**
       * @param  {Function} cb
       *
       */
      traverse: function traverse(cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
          this._roots[i].traverse(cb, context);
        }
      },

      /**
       * 返回所有图形的绘制队列
       * @param {boolean} [update=false] 是否在返回前更新该数组
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
       *
       * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
       * @return {Array.<module:zrender/graphic/Displayable>}
       */
      getDisplayList: function getDisplayList(update, includeIgnore) {
        includeIgnore = includeIgnore || false;

        if (update) {
          this.updateDisplayList(includeIgnore);
        }

        return this._displayList;
      },

      /**
       * 更新图形的绘制队列。
       * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
       * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
       */
      updateDisplayList: function updateDisplayList(includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;

        for (var i = 0, len = roots.length; i < len; i++) {
          this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }

        displayList.length = this._displayListLen;
        env$1.canvasSupported && sort(displayList, shapeCompareFunc);
      },
      _updateAndAddDisplayable: function _updateAndAddDisplayable(el, clipPaths, includeIgnore) {
        if (el.ignore && !includeIgnore) {
          return;
        }

        el.beforeUpdate();

        if (el.__dirty) {
          el.update();
        }

        el.afterUpdate();
        var userSetClipPath = el.clipPath;

        if (userSetClipPath) {
          // FIXME 效率影响
          if (clipPaths) {
            clipPaths = clipPaths.slice();
          } else {
            clipPaths = [];
          }

          var currentClipPath = userSetClipPath;
          var parentClipPath = el; // Recursively add clip path

          while (currentClipPath) {
            // clipPath 的变换是基于使用这个 clipPath 的元素
            currentClipPath.parent = parentClipPath;
            currentClipPath.updateTransform();
            clipPaths.push(currentClipPath);
            parentClipPath = currentClipPath;
            currentClipPath = currentClipPath.clipPath;
          }
        }

        if (el.isGroup) {
          var children = el._children;

          for (var i = 0; i < children.length; i++) {
            var child = children[i]; // Force to mark as dirty if group is dirty
            // FIXME __dirtyPath ?

            if (el.__dirty) {
              child.__dirty = true;
            }

            this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
          } // Mark group clean here


          el.__dirty = false;
        } else {
          el.__clipPaths = clipPaths;
          this._displayList[this._displayListLen++] = el;
        }
      },

      /**
       * 添加图形(Shape)或者组(Group)到根节点
       * @param {module:zrender/Element} el
       */
      addRoot: function addRoot(el) {
        if (el.__storage === this) {
          return;
        }

        if (el instanceof Group) {
          el.addChildrenToStorage(this);
        }

        this.addToStorage(el);

        this._roots.push(el);
      },

      /**
       * 删除指定的图形(Shape)或者组(Group)
       * @param {string|Array.<string>} [el] 如果为空清空整个Storage
       */
      delRoot: function delRoot(el) {
        if (el == null) {
          // 不指定el清空
          for (var i = 0; i < this._roots.length; i++) {
            var root = this._roots[i];

            if (root instanceof Group) {
              root.delChildrenFromStorage(this);
            }
          }

          this._roots = [];
          this._displayList = [];
          this._displayListLen = 0;
          return;
        }

        if (el instanceof Array) {
          for (var i = 0, l = el.length; i < l; i++) {
            this.delRoot(el[i]);
          }

          return;
        }

        var idx = indexOf(this._roots, el);

        if (idx >= 0) {
          this.delFromStorage(el);

          this._roots.splice(idx, 1);

          if (el instanceof Group) {
            el.delChildrenFromStorage(this);
          }
        }
      },
      addToStorage: function addToStorage(el) {
        if (el) {
          el.__storage = this;
          el.dirty(false);
        }

        return this;
      },
      delFromStorage: function delFromStorage(el) {
        if (el) {
          el.__storage = null;
        }

        return this;
      },

      /**
       * 清空并且释放Storage
       */
      dispose: function dispose() {
        this._renderList = this._roots = null;
      },
      displayableSortFunc: shapeCompareFunc
    };

    /**
     * @module zrender/Layer
     * @author pissang(https://www.github.com/pissang)
     */

    function returnFalse() {
      return false;
    }
    /**
     * 创建dom
     *
     * @inner
     * @param {string} id dom id 待用
     * @param {Painter} painter painter instance
     * @param {number} number
     */


    function createDom(id, painter, dpr) {
      var newDom = createCanvas$1();
      var width = painter.getWidth();
      var height = painter.getHeight();
      var newDomStyle = newDom.style;

      if (newDomStyle) {
        // In node or some other non-browser environment
        newDomStyle.position = 'absolute';
        newDomStyle.left = 0;
        newDomStyle.top = 0;
        newDomStyle.width = width + 'px';
        newDomStyle.height = height + 'px';
        newDom.setAttribute('data-zr-dom-id', id);
      }

      newDom.width = width * dpr;
      newDom.height = height * dpr;
      return newDom;
    }
    /**
     * @alias module:zrender/Layer
     * @constructor
     * @extends module:zrender/mixin/Transformable
     * @param {string} id
     * @param {module:zrender/Painter} painter
     * @param {number} [dpr]
     */


    var Layer = function Layer(id, painter, dpr) {
      var dom;
      dpr = dpr || devicePixelRatio;

      if (typeof id === 'string') {
        dom = createDom(id, painter, dpr);
      } // Not using isDom because in node it will return false
      else if (isObject(id)) {
          dom = id;
          id = dom.id;
        }

      this.id = id;
      this.dom = dom;
      var domStyle = dom.style;

      if (domStyle) {
        // Not in node
        dom.onselectstart = returnFalse; // 避免页面选中的尴尬

        domStyle['-webkit-user-select'] = 'none';
        domStyle['user-select'] = 'none';
        domStyle['-webkit-touch-callout'] = 'none';
        domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
        domStyle['padding'] = 0;
        domStyle['margin'] = 0;
        domStyle['border-width'] = 0;
      }

      this.domBack = null;
      this.ctxBack = null;
      this.painter = painter;
      this.config = null; // Configs

      /**
       * 每次清空画布的颜色
       * @type {string}
       * @default 0
       */

      this.clearColor = 0;
      /**
       * 是否开启动态模糊
       * @type {boolean}
       * @default false
       */

      this.motionBlur = false;
      /**
       * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
       * @type {number}
       * @default 0.7
       */

      this.lastFrameAlpha = 0.7;
      /**
       * Layer dpr
       * @type {number}
       */

      this.dpr = dpr;
    };

    Layer.prototype = {
      constructor: Layer,
      __dirty: true,
      __used: false,
      __drawIndex: 0,
      __startIndex: 0,
      __endIndex: 0,
      incremental: false,
      getElementCount: function getElementCount() {
        return this.__endIndex - this.__startIndex;
      },
      initContext: function initContext() {
        this.ctx = this.dom.getContext('2d');
        this.ctx.dpr = this.dpr;
      },
      createBackBuffer: function createBackBuffer() {
        var dpr = this.dpr;
        this.domBack = createDom('back-' + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext('2d');

        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      },

      /**
       * @param  {number} width
       * @param  {number} height
       */
      resize: function resize(width, height) {
        var dpr = this.dpr;
        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;

        if (domStyle) {
          domStyle.width = width + 'px';
          domStyle.height = height + 'px';
        }

        dom.width = width * dpr;
        dom.height = height * dpr;

        if (domBack) {
          domBack.width = width * dpr;
          domBack.height = height * dpr;

          if (dpr !== 1) {
            this.ctxBack.scale(dpr, dpr);
          }
        }
      },

      /**
       * 清空该层画布
       * @param {boolean} [clearAll]=false Clear all with out motion blur
       * @param {Color} [clearColor]
       */
      clear: function clear(clearAll, clearColor) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var clearColor = clearColor || this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = this.dpr;

        if (haveMotionBLur) {
          if (!this.domBack) {
            this.createBackBuffer();
          }

          this.ctxBack.globalCompositeOperation = 'copy';
          this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }

        ctx.clearRect(0, 0, width, height);

        if (clearColor && clearColor !== 'transparent') {
          var clearColorGradientOrPattern; // Gradient

          if (clearColor.colorStops) {
            // Cache canvas gradient
            clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width: width,
              height: height
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
          } // Pattern
          else if (clearColor.image) {
              clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
            }

          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }

        if (haveMotionBLur) {
          var domBack = this.domBack;
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, 0, 0, width, height);
          ctx.restore();
        }
      }
    };

    var requestAnimationFrame = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
    window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
      setTimeout(func, 16);
    };

    var HOVER_LAYER_ZLEVEL = 1e5;
    var CANVAS_ZLEVEL = 314159;
    var EL_AFTER_INCREMENTAL_INC = 0.01;
    var INCREMENTAL_INC = 0.001;

    function parseInt10(val) {
      return parseInt(val, 10);
    }

    function isLayerValid(layer) {
      if (!layer) {
        return false;
      }

      if (layer.__builtin__) {
        return true;
      }

      if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
        return false;
      }

      return true;
    }

    var tmpRect$1 = new BoundingRect(0, 0, 0, 0);
    var viewRect = new BoundingRect(0, 0, 0, 0);

    function isDisplayableCulled(el, width, height) {
      tmpRect$1.copy(el.getBoundingRect());

      if (el.transform) {
        tmpRect$1.applyTransform(el.transform);
      }

      viewRect.width = width;
      viewRect.height = height;
      return !tmpRect$1.intersect(viewRect);
    }

    function isClipPathChanged(clipPaths, prevClipPaths) {
      if (clipPaths === prevClipPaths) {
        // Can both be null or undefined
        return false;
      }

      if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
        return true;
      }

      for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
          return true;
        }
      }
    }

    function doClip(clipPaths, ctx) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip(); // Transform back

        clipPath.restoreTransform(ctx);
      }
    }

    function createRoot(width, height) {
      var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬

      domRoot.style.cssText = ['position:relative', 'overflow:hidden', 'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';
      return domRoot;
    }
    /**
     * @alias module:zrender/Painter
     * @constructor
     * @param {HTMLElement} root 绘图容器
     * @param {module:zrender/Storage} storage
     * @param {Object} opts
     */


    var Painter = function Painter(root, storage, opts) {
      this.type = 'canvas'; // In node environment using node-canvas

      var singleCanvas = !root.nodeName // In node ?
      || root.nodeName.toUpperCase() === 'CANVAS';
      this._opts = opts = extend$1({}, opts || {});
      /**
       * @type {number}
       */

      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      /**
       * @type {boolean}
       * @private
       */

      this._singleCanvas = singleCanvas;
      /**
       * 绘图容器
       * @type {HTMLElement}
       */

      this.root = root;
      var rootStyle = root.style;

      if (rootStyle) {
        rootStyle['-webkit-tap-highlight-color'] = 'transparent';
        rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';
        root.innerHTML = '';
      }
      /**
       * @type {module:zrender/Storage}
       */


      this.storage = storage;
      /**
       * @type {Array.<number>}
       * @private
       */

      var zlevelList = this._zlevelList = [];
      /**
       * @type {Object.<string, module:zrender/Layer>}
       * @private
       */

      var layers = this._layers = {};
      /**
       * @type {Object.<string, Object>}
       * @private
       */

      this._layerConfig = {};
      /**
       * zrender will do compositing when root is a canvas and have multiple zlevels.
       */

      this._needsManuallyCompositing = false;

      if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var width = root.width;
        var height = root.height;

        if (opts.width != null) {
          width = opts.width;
        }

        if (opts.height != null) {
          height = opts.height;
        }

        this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly

        root.width = width * this.dpr;
        root.height = height * this.dpr;
        this._width = width;
        this._height = height; // Create layer if only one given canvas
        // Device can be specified to create a high dpi image.

        var mainLayer = new Layer(root, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext(); // FIXME Use canvas width and height
        // mainLayer.resize(width, height);

        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.

        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
      /**
       * @type {module:zrender/Layer}
       * @private
       */


      this._hoverlayer = null;
      this._hoverElements = [];
    };

    Painter.prototype = {
      constructor: Painter,
      getType: function getType() {
        return 'canvas';
      },

      /**
       * If painter use a single canvas
       * @return {boolean}
       */
      isSingleCanvas: function isSingleCanvas() {
        return this._singleCanvas;
      },

      /**
       * @return {HTMLDivElement}
       */
      getViewportRoot: function getViewportRoot() {
        return this._domRoot;
      },
      getViewportRootOffset: function getViewportRootOffset() {
        var viewportRoot = this.getViewportRoot();

        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },

      /**
       * 刷新
       * @param {boolean} [paintAll=false] 强制绘制所有displayable
       */
      refresh: function refresh(paintAll) {
        var list = this.storage.getDisplayList(true);
        var zlevelList = this._zlevelList;
        this._redrawId = Math.random();

        this._paintList(list, paintAll, this._redrawId); // Paint custum layers


        for (var i = 0; i < zlevelList.length; i++) {
          var z = zlevelList[i];
          var layer = this._layers[z];

          if (!layer.__builtin__ && layer.refresh) {
            var clearColor = i === 0 ? this._backgroundColor : null;
            layer.refresh(clearColor);
          }
        }

        this.refreshHover();
        return this;
      },
      addHover: function addHover(el, hoverStyle) {
        if (el.__hoverMir) {
          return;
        }

        var elMirror = new el.constructor({
          style: el.style,
          shape: el.shape,
          z: el.z,
          z2: el.z2,
          silent: el.silent
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        hoverStyle && elMirror.setStyle(hoverStyle);

        this._hoverElements.push(elMirror);

        return elMirror;
      },
      removeHover: function removeHover(el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = indexOf(hoverElements, elMirror);

        if (idx >= 0) {
          hoverElements.splice(idx, 1);
        }

        el.__hoverMir = null;
      },
      clearHover: function clearHover(el) {
        var hoverElements = this._hoverElements;

        for (var i = 0; i < hoverElements.length; i++) {
          var from = hoverElements[i].__from;

          if (from) {
            from.__hoverMir = null;
          }
        }

        hoverElements.length = 0;
      },
      refreshHover: function refreshHover() {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();

        if (!len) {
          return;
        }

        sort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel
        // FIXME?

        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }

        var scope = {};
        hoverLayer.ctx.save();

        for (var i = 0; i < len;) {
          var el = hoverElements[i];
          var originalEl = el.__from; // Original el is removed
          // PENDING

          if (!(originalEl && originalEl.__zr)) {
            hoverElements.splice(i, 1);
            originalEl.__hoverMir = null;
            len--;
            continue;
          }

          i++; // Use transform
          // FIXME style and shape ?

          if (!originalEl.invisible) {
            el.transform = originalEl.transform;
            el.invTransform = originalEl.invTransform;
            el.__clipPaths = originalEl.__clipPaths; // el.

            this._doPaintEl(el, hoverLayer, true, scope);
          }
        }

        hoverLayer.ctx.restore();
      },
      getHoverLayer: function getHoverLayer() {
        return this.getLayer(HOVER_LAYER_ZLEVEL);
      },
      _paintList: function _paintList(list, paintAll, redrawId) {
        if (this._redrawId !== redrawId) {
          return;
        }

        paintAll = paintAll || false;

        this._updateLayerStatus(list);

        var finished = this._doPaintList(list, paintAll);

        if (this._needsManuallyCompositing) {
          this._compositeManually();
        }

        if (!finished) {
          var self = this;
          requestAnimationFrame(function () {
            self._paintList(list, paintAll, redrawId);
          });
        }
      },
      _compositeManually: function _compositeManually() {
        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
        var width = this._domRoot.width;
        var height = this._domRoot.height;
        ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?

        this.eachBuiltinLayer(function (layer) {
          if (layer.virtual) {
            ctx.drawImage(layer.dom, 0, 0, width, height);
          }
        });
      },
      _doPaintList: function _doPaintList(list, paintAll) {
        var layerList = [];

        for (var zi = 0; zi < this._zlevelList.length; zi++) {
          var zlevel = this._zlevelList[zi];
          var layer = this._layers[zlevel];

          if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
            layerList.push(layer);
          }
        }

        var finished = true;

        for (var k = 0; k < layerList.length; k++) {
          var layer = layerList[k];
          var ctx = layer.ctx;
          var scope = {};
          ctx.save();
          var start = paintAll ? layer.__startIndex : layer.__drawIndex;
          var useTimer = !paintAll && layer.incremental && Date.now;
          var startTime = useTimer && Date.now();
          var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.

          if (layer.__startIndex === layer.__endIndex) {
            layer.clear(false, clearColor);
          } else if (start === layer.__startIndex) {
            var firstEl = list[start];

            if (!firstEl.incremental || !firstEl.notClear || paintAll) {
              layer.clear(false, clearColor);
            }
          }

          if (start === -1) {
            console.error('For some unknown reason. drawIndex is -1');
            start = layer.__startIndex;
          }

          for (var i = start; i < layer.__endIndex; i++) {
            var el = list[i];

            this._doPaintEl(el, layer, paintAll, scope);

            el.__dirty = el.__dirtyText = false;

            if (useTimer) {
              // Date.now can be executed in 13,025,305 ops/second.
              var dTime = Date.now() - startTime; // Give 15 millisecond to draw.
              // The rest elements will be drawn in the next frame.

              if (dTime > 15) {
                break;
              }
            }
          }

          layer.__drawIndex = i;

          if (layer.__drawIndex < layer.__endIndex) {
            finished = false;
          }

          if (scope.prevElClipPaths) {
            // Needs restore the state. If last drawn element is in the clipping area.
            ctx.restore();
          }

          ctx.restore();
        }

        if (env$1.wxa) {
          // Flush for weixin application
          each(this._layers, function (layer) {
            if (layer && layer.ctx && layer.ctx.draw) {
              layer.ctx.draw();
            }
          });
        }

        return finished;
      },
      _doPaintEl: function _doPaintEl(el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;

        if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
        !el.invisible // Ignore transparent element
        && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas
        // Draw a scale 0 element can cause all following draw wrong
        // And setTransform with scale 0 will cause set back transform failed.
        && !(m && !m[0] && !m[3]) // Ignore culled element
        && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
          var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements

          if (!scope.prevElClipPaths || isClipPathChanged(clipPaths, scope.prevElClipPaths)) {
            // If has previous clipping state, restore from it
            if (scope.prevElClipPaths) {
              currentLayer.ctx.restore();
              scope.prevElClipPaths = null; // Reset prevEl since context has been restored

              scope.prevEl = null;
            } // New clipping state


            if (clipPaths) {
              ctx.save();
              doClip(clipPaths, ctx);
              scope.prevElClipPaths = clipPaths;
            }
          }

          el.beforeBrush && el.beforeBrush(ctx);
          var keepPrevEl = el.brush(ctx, scope.prevEl || null);

          if (keepPrevEl !== true) {
            scope.prevEl = el;
          }

          el.afterBrush && el.afterBrush(ctx);
        }
      },

      /**
       * 获取 zlevel 所在层，如果不存在则会创建一个新的层
       * @param {number} zlevel
       * @param {boolean} virtual Virtual layer will not be inserted into dom.
       * @return {module:zrender/Layer}
       */
      getLayer: function getLayer(zlevel, virtual) {
        if (this._singleCanvas && !this._needsManuallyCompositing) {
          zlevel = CANVAS_ZLEVEL;
        }

        var layer = this._layers[zlevel];

        if (!layer) {
          // Create a new layer
          layer = new Layer('zr_' + zlevel, this, this.dpr);
          layer.zlevel = zlevel;
          layer.__builtin__ = true;

          if (this._layerConfig[zlevel]) {
            merge(layer, this._layerConfig[zlevel], true);
          }

          if (virtual) {
            layer.virtual = virtual;
          }

          this.insertLayer(zlevel, layer); // Context is created after dom inserted to document
          // Or excanvas will get 0px clientWidth and clientHeight

          layer.initContext();
        }

        return layer;
      },
      insertLayer: function insertLayer(zlevel, layer) {
        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;

        if (layersMap[zlevel]) {
          log$1('ZLevel ' + zlevel + ' has been used already');
          return;
        } // Check if is a valid layer


        if (!isLayerValid(layer)) {
          log$1('Layer of zlevel ' + zlevel + ' is not valid');
          return;
        }

        if (len > 0 && zlevel > zlevelList[0]) {
          for (i = 0; i < len - 1; i++) {
            if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
              break;
            }
          }

          prevLayer = layersMap[zlevelList[i]];
        }

        zlevelList.splice(i + 1, 0, zlevel);
        layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.
        // (It can be a WebGL layer and assigned to a ZImage element)
        // But it still under management of zrender.

        if (!layer.virtual) {
          if (prevLayer) {
            var prevDom = prevLayer.dom;

            if (prevDom.nextSibling) {
              domRoot.insertBefore(layer.dom, prevDom.nextSibling);
            } else {
              domRoot.appendChild(layer.dom);
            }
          } else {
            if (domRoot.firstChild) {
              domRoot.insertBefore(layer.dom, domRoot.firstChild);
            } else {
              domRoot.appendChild(layer.dom);
            }
          }
        }
      },
      // Iterate each layer
      eachLayer: function eachLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          cb.call(context, this._layers[z], z);
        }
      },
      // Iterate each buildin layer
      eachBuiltinLayer: function eachBuiltinLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];

          if (layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      // Iterate each other layer except buildin layer
      eachOtherLayer: function eachOtherLayer(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;

        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];

          if (!layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },

      /**
       * 获取所有已创建的层
       * @param {Array.<module:zrender/Layer>} [prevLayer]
       */
      getLayers: function getLayers() {
        return this._layers;
      },
      _updateLayerStatus: function _updateLayerStatus(list) {
        this.eachBuiltinLayer(function (layer, z) {
          layer.__dirty = layer.__used = false;
        });

        function updatePrevLayer(idx) {
          if (prevLayer) {
            if (prevLayer.__endIndex !== idx) {
              prevLayer.__dirty = true;
            }

            prevLayer.__endIndex = idx;
          }
        }

        if (this._singleCanvas) {
          for (var i = 1; i < list.length; i++) {
            var el = list[i];

            if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
        }

        var prevLayer = null;
        var incrementalLayerCount = 0;

        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          var zlevel = el.zlevel;
          var layer; // PENDING If change one incremental element style ?
          // TODO Where there are non-incremental elements between incremental elements.

          if (el.incremental) {
            layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
            layer.incremental = true;
            incrementalLayerCount = 1;
          } else {
            layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
          }

          if (!layer.__builtin__) {
            log$1('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
          }

          if (layer !== prevLayer) {
            layer.__used = true;

            if (layer.__startIndex !== i) {
              layer.__dirty = true;
            }

            layer.__startIndex = i;

            if (!layer.incremental) {
              layer.__drawIndex = i;
            } else {
              // Mark layer draw index needs to update.
              layer.__drawIndex = -1;
            }

            updatePrevLayer(i);
            prevLayer = layer;
          }

          if (el.__dirty) {
            layer.__dirty = true;

            if (layer.incremental && layer.__drawIndex < 0) {
              // Start draw from the first dirty element.
              layer.__drawIndex = i;
            }
          }
        }

        updatePrevLayer(i);
        this.eachBuiltinLayer(function (layer, z) {
          // Used in last frame but not in this frame. Needs clear
          if (!layer.__used && layer.getElementCount() > 0) {
            layer.__dirty = true;
            layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
          } // For incremental layer. In case start index changed and no elements are dirty.


          if (layer.__dirty && layer.__drawIndex < 0) {
            layer.__drawIndex = layer.__startIndex;
          }
        });
      },

      /**
       * 清除hover层外所有内容
       */
      clear: function clear() {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
      },
      _clearLayer: function _clearLayer(layer) {
        layer.clear();
      },
      setBackgroundColor: function setBackgroundColor(backgroundColor) {
        this._backgroundColor = backgroundColor;
      },

      /**
       * 修改指定zlevel的绘制参数
       *
       * @param {string} zlevel
       * @param {Object} config 配置对象
       * @param {string} [config.clearColor=0] 每次清空画布的颜色
       * @param {string} [config.motionBlur=false] 是否开启动态模糊
       * @param {number} [config.lastFrameAlpha=0.7]
       *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
       */
      configLayer: function configLayer(zlevel, config) {
        if (config) {
          var layerConfig = this._layerConfig;

          if (!layerConfig[zlevel]) {
            layerConfig[zlevel] = config;
          } else {
            merge(layerConfig[zlevel], config, true);
          }

          for (var i = 0; i < this._zlevelList.length; i++) {
            var _zlevel = this._zlevelList[i];

            if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
              var layer = this._layers[_zlevel];
              merge(layer, layerConfig[zlevel], true);
            }
          }
        }
      },

      /**
       * 删除指定层
       * @param {number} zlevel 层所在的zlevel
       */
      delLayer: function delLayer(zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];

        if (!layer) {
          return;
        }

        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];
        zlevelList.splice(indexOf(zlevelList, zlevel), 1);
      },

      /**
       * 区域大小变化后重绘
       */
      resize: function resize(width, height) {
        if (!this._domRoot.style) {
          // Maybe in node or worker
          if (width == null || height == null) {
            return;
          }

          this._width = width;
          this._height = height;
          this.getLayer(CANVAS_ZLEVEL).resize(width, height);
        } else {
          var domRoot = this._domRoot; // FIXME Why ?

          domRoot.style.display = 'none'; // Save input w/h

          var opts = this._opts;
          width != null && (opts.width = width);
          height != null && (opts.height = height);
          width = this._getSize(0);
          height = this._getSize(1);
          domRoot.style.display = ''; // 优化没有实际改变的resize

          if (this._width !== width || height !== this._height) {
            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';

            for (var id in this._layers) {
              if (this._layers.hasOwnProperty(id)) {
                this._layers[id].resize(width, height);
              }
            }

            each(this._progressiveLayers, function (layer) {
              layer.resize(width, height);
            });
            this.refresh(true);
          }

          this._width = width;
          this._height = height;
        }

        return this;
      },

      /**
       * 清除单独的一个层
       * @param {number} zlevel
       */
      clearLayer: function clearLayer(zlevel) {
        var layer = this._layers[zlevel];

        if (layer) {
          layer.clear();
        }
      },

      /**
       * 释放
       */
      dispose: function dispose() {
        this.root.innerHTML = '';
        this.root = this.storage = this._domRoot = this._layers = null;
      },

      /**
       * Get canvas which has all thing rendered
       * @param {Object} opts
       * @param {string} [opts.backgroundColor]
       * @param {number} [opts.pixelRatio]
       */
      getRenderedCanvas: function getRenderedCanvas(opts) {
        opts = opts || {};

        if (this._singleCanvas && !this._compositeManually) {
          return this._layers[CANVAS_ZLEVEL].dom;
        }

        var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();
        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);

        if (opts.pixelRatio <= this.dpr) {
          this.refresh();
          var width = imageLayer.dom.width;
          var height = imageLayer.dom.height;
          var ctx = imageLayer.ctx;
          this.eachLayer(function (layer) {
            if (layer.__builtin__) {
              ctx.drawImage(layer.dom, 0, 0, width, height);
            } else if (layer.renderToCanvas) {
              imageLayer.ctx.save();
              layer.renderToCanvas(imageLayer.ctx);
              imageLayer.ctx.restore();
            }
          });
        } else {
          // PENDING, echarts-gl and incremental rendering.
          var scope = {};
          var displayList = this.storage.getDisplayList(true);

          for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];

            this._doPaintEl(el, imageLayer, true, scope);
          }
        }

        return imageLayer.dom;
      },

      /**
       * 获取绘图区域宽度
       */
      getWidth: function getWidth() {
        return this._width;
      },

      /**
       * 获取绘图区域高度
       */
      getHeight: function getHeight() {
        return this._height;
      },
      _getSize: function _getSize(whIdx) {
        var opts = this._opts;
        var wh = ['width', 'height'][whIdx];
        var cwh = ['clientWidth', 'clientHeight'][whIdx];
        var plt = ['paddingLeft', 'paddingTop'][whIdx];
        var prb = ['paddingRight', 'paddingBottom'][whIdx];

        if (opts[wh] != null && opts[wh] !== 'auto') {
          return parseFloat(opts[wh]);
        }

        var root = this.root; // IE8 does not support getComputedStyle, but it use VML.

        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      pathToImage: function pathToImage(path, dpr) {
        dpr = dpr || this.dpr;
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur * dpr;
        var shadowOffsetX = style.shadowOffsetX * dpr;
        var shadowOffsetY = style.shadowOffsetY * dpr;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;
        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;
        var pathTransform = {
          position: path.position,
          rotation: path.rotation,
          scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();

        if (path) {
          path.brush(ctx);
        }

        var ImageShape = ZImage;
        var imgShape = new ImageShape({
          style: {
            x: 0,
            y: 0,
            image: canvas
          }
        });

        if (pathTransform.position != null) {
          imgShape.position = path.position = pathTransform.position;
        }

        if (pathTransform.rotation != null) {
          imgShape.rotation = path.rotation = pathTransform.rotation;
        }

        if (pathTransform.scale != null) {
          imgShape.scale = path.scale = pathTransform.scale;
        }

        return imgShape;
      }
    };

    /**
     * 动画主类, 调度和管理所有动画控制器
     *
     * @module zrender/animation/Animation
     * @author pissang(https://github.com/pissang)
     */
    /**
     * @typedef {Object} IZRenderStage
     * @property {Function} update
     */

    /**
     * @alias module:zrender/animation/Animation
     * @constructor
     * @param {Object} [options]
     * @param {Function} [options.onframe]
     * @param {IZRenderStage} [options.stage]
     * @example
     *     var animation = new Animation();
     *     var obj = {
     *         x: 100,
     *         y: 100
     *     };
     *     animation.animate(node.position)
     *         .when(1000, {
     *             x: 500,
     *             y: 500
     *         })
     *         .when(2000, {
     *             x: 100,
     *             y: 100
     *         })
     *         .start('spline');
     */

    var Animation = function Animation(options) {
      options = options || {};
      this.stage = options.stage || {};

      this.onframe = options.onframe || function () {}; // private properties


      this._clips = [];
      this._running = false;
      this._time;
      this._pausedTime;
      this._pauseStart;
      this._paused = false;
      Eventful.call(this);
    };

    Animation.prototype = {
      constructor: Animation,

      /**
       * 添加 clip
       * @param {module:zrender/animation/Clip} clip
       */
      addClip: function addClip(clip) {
        this._clips.push(clip);
      },

      /**
       * 添加 animator
       * @param {module:zrender/animation/Animator} animator
       */
      addAnimator: function addAnimator(animator) {
        animator.animation = this;
        var clips = animator.getClips();

        for (var i = 0; i < clips.length; i++) {
          this.addClip(clips[i]);
        }
      },

      /**
       * 删除动画片段
       * @param {module:zrender/animation/Clip} clip
       */
      removeClip: function removeClip(clip) {
        var idx = indexOf(this._clips, clip);

        if (idx >= 0) {
          this._clips.splice(idx, 1);
        }
      },

      /**
       * 删除动画片段
       * @param {module:zrender/animation/Animator} animator
       */
      removeAnimator: function removeAnimator(animator) {
        var clips = animator.getClips();

        for (var i = 0; i < clips.length; i++) {
          this.removeClip(clips[i]);
        }

        animator.animation = null;
      },
      _update: function _update() {
        var time = new Date().getTime() - this._pausedTime;

        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;
        var deferredEvents = [];
        var deferredClips = [];

        for (var i = 0; i < len; i++) {
          var clip = clips[i];
          var e = clip.step(time, delta); // Throw out the events need to be called after
          // stage.update, like destroy

          if (e) {
            deferredEvents.push(e);
            deferredClips.push(clip);
          }
        } // Remove the finished clip


        for (var i = 0; i < len;) {
          if (clips[i]._needsRemove) {
            clips[i] = clips[len - 1];
            clips.pop();
            len--;
          } else {
            i++;
          }
        }

        len = deferredEvents.length;

        for (var i = 0; i < len; i++) {
          deferredClips[i].fire(deferredEvents[i]);
        }

        this._time = time;
        this.onframe(delta); // 'frame' should be triggered before stage, because upper application
        // depends on the sequence (e.g., echarts-stream and finish
        // event judge)

        this.trigger('frame', delta);

        if (this.stage.update) {
          this.stage.update();
        }
      },
      _startLoop: function _startLoop() {
        var self = this;
        this._running = true;

        function step() {
          if (self._running) {
            requestAnimationFrame(step);
            !self._paused && self._update();
          }
        }

        requestAnimationFrame(step);
      },

      /**
       * Start animation.
       */
      start: function start() {
        this._time = new Date().getTime();
        this._pausedTime = 0;

        this._startLoop();
      },

      /**
       * Stop animation.
       */
      stop: function stop$$1() {
        this._running = false;
      },

      /**
       * Pause animation.
       */
      pause: function pause() {
        if (!this._paused) {
          this._pauseStart = new Date().getTime();
          this._paused = true;
        }
      },

      /**
       * Resume animation.
       */
      resume: function resume() {
        if (this._paused) {
          this._pausedTime += new Date().getTime() - this._pauseStart;
          this._paused = false;
        }
      },

      /**
       * Clear animation.
       */
      clear: function clear() {
        this._clips = [];
      },

      /**
       * Whether animation finished.
       */
      isFinished: function isFinished() {
        return !this._clips.length;
      },

      /**
       * Creat animator for a target, whose props can be animated.
       *
       * @param  {Object} target
       * @param  {Object} options
       * @param  {boolean} [options.loop=false] Whether loop animation.
       * @param  {Function} [options.getter=null] Get value from target.
       * @param  {Function} [options.setter=null] Set value to target.
       * @return {module:zrender/animation/Animation~Animator}
       */
      // TODO Gap
      animate: function animate(target, options) {
        options = options || {};
        var animator = new Animator(target, options.loop, options.getter, options.setter);
        this.addAnimator(animator);
        return animator;
      }
    };
    mixin(Animation, Eventful);

    /**
     * Only implements needed gestures for mobile.
     */

    var GestureMgr = function GestureMgr() {
      /**
       * @private
       * @type {Array.<Object>}
       */
      this._track = [];
    };

    GestureMgr.prototype = {
      constructor: GestureMgr,
      recognize: function recognize(event, target, root) {
        this._doTrack(event, target, root);

        return this._recognize(event);
      },
      clear: function clear() {
        this._track.length = 0;
        return this;
      },
      _doTrack: function _doTrack(event, target, root) {
        var touches = event.touches;

        if (!touches) {
          return;
        }

        var trackItem = {
          points: [],
          touches: [],
          target: target,
          event: event
        };

        for (var i = 0, len = touches.length; i < len; i++) {
          var touch = touches[i];
          var pos = clientToLocal(root, touch, {});
          trackItem.points.push([pos.zrX, pos.zrY]);
          trackItem.touches.push(touch);
        }

        this._track.push(trackItem);
      },
      _recognize: function _recognize(event) {
        for (var eventName in recognizers) {
          if (recognizers.hasOwnProperty(eventName)) {
            var gestureInfo = recognizers[eventName](this._track, event);

            if (gestureInfo) {
              return gestureInfo;
            }
          }
        }
      }
    };

    function dist$1(pointPair) {
      var dx = pointPair[1][0] - pointPair[0][0];
      var dy = pointPair[1][1] - pointPair[0][1];
      return Math.sqrt(dx * dx + dy * dy);
    }

    function center(pointPair) {
      return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
    }

    var recognizers = {
      pinch: function pinch(track, event) {
        var trackLen = track.length;

        if (!trackLen) {
          return;
        }

        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

        if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
          var pinchScale = dist$1(pinchEnd) / dist$1(pinchPre);
          !isFinite(pinchScale) && (pinchScale = 1);
          event.pinchScale = pinchScale;
          var pinchCenter = center(pinchEnd);
          event.pinchX = pinchCenter[0];
          event.pinchY = pinchCenter[1];
          return {
            type: 'pinch',
            target: track[0].target,
            event: event
          };
        }
      } // Only pinch currently.

    };

    var TOUCH_CLICK_DELAY = 300;
    var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];
    var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];
    var pointerEventNames = {
      pointerdown: 1,
      pointerup: 1,
      pointermove: 1,
      pointerout: 1
    };
    var pointerHandlerNames = map$1(mouseHandlerNames, function (name) {
      var nm = name.replace('mouse', 'pointer');
      return pointerEventNames[nm] ? nm : name;
    });

    function eventNameFix(name) {
      return name === 'mousewheel' && env$1.browser.firefox ? 'DOMMouseScroll' : name;
    }

    function processGesture(proxy, event, stage) {
      var gestureMgr = proxy._gestureMgr;
      stage === 'start' && gestureMgr.clear();
      var gestureInfo = gestureMgr.recognize(event, proxy.handler.findHover(event.zrX, event.zrY, null).target, proxy.dom);
      stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.

      if (gestureInfo) {
        var type = gestureInfo.type;
        event.gestureEvent = type;
        proxy.handler.dispatchToElement({
          target: gestureInfo.target
        }, type, gestureInfo.event);
      }
    } // function onMSGestureChange(proxy, event) {
    //     if (event.translationX || event.translationY) {
    //         // mousemove is carried by MSGesture to reduce the sensitivity.
    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);
    //     }
    //     if (event.scale !== 1) {
    //         event.pinchX = event.offsetX;
    //         event.pinchY = event.offsetY;
    //         event.pinchScale = event.scale;
    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);
    //     }
    // }

    /**
     * Prevent mouse event from being dispatched after Touch Events action
     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
     * Result: Blocking Mouse Events for 700ms.
     */


    function setTouchTimer(instance) {
      instance._touching = true;
      clearTimeout(instance._touchTimer);
      instance._touchTimer = setTimeout(function () {
        instance._touching = false;
      }, 700);
    }

    var domHandlers = {
      /**
       * Mouse move handler
       * @inner
       * @param {Event} event
       */
      mousemove: function mousemove(event) {
        event = normalizeEvent(this.dom, event);
        this.trigger('mousemove', event);
      },

      /**
       * Mouse out handler
       * @inner
       * @param {Event} event
       */
      mouseout: function mouseout(event) {
        event = normalizeEvent(this.dom, event);
        var element = event.toElement || event.relatedTarget;

        if (element !== this.dom) {
          while (element && element.nodeType !== 9) {
            // 忽略包含在root中的dom引起的mouseOut
            if (element === this.dom) {
              return;
            }

            element = element.parentNode;
          }
        }

        this.trigger('mouseout', event);
      },

      /**
       * Touch开始响应函数
       * @inner
       * @param {Event} event
       */
      touchstart: function touchstart(event) {
        // Default mouse behaviour should not be disabled here.
        // For example, page may needs to be slided.
        event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.

        event.zrByTouch = true;
        this._lastTouchMoment = new Date();
        processGesture(this, event, 'start'); // In touch device, trigger `mousemove`(`mouseover`) should
        // be triggered, and must before `mousedown` triggered.

        domHandlers.mousemove.call(this, event);
        domHandlers.mousedown.call(this, event);
        setTouchTimer(this);
      },

      /**
       * Touch移动响应函数
       * @inner
       * @param {Event} event
       */
      touchmove: function touchmove(event) {
        event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.

        event.zrByTouch = true;
        processGesture(this, event, 'change'); // Mouse move should always be triggered no matter whether
        // there is gestrue event, because mouse move and pinch may
        // be used at the same time.

        domHandlers.mousemove.call(this, event);
        setTouchTimer(this);
      },

      /**
       * Touch结束响应函数
       * @inner
       * @param {Event} event
       */
      touchend: function touchend(event) {
        event = normalizeEvent(this.dom, event); // Mark touch, which is useful in distinguish touch and
        // mouse event in upper applicatoin.

        event.zrByTouch = true;
        processGesture(this, event, 'end');
        domHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
        // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
        // we can conveniently implement "hover style" in both PC and touch device just
        // by listening to `mouseover` to add "hover style" and listening to `mouseout`
        // to remove "hover style" on an element, without any additional code for
        // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
        // style" will remain for user view)
        // click event should always be triggered no matter whether
        // there is gestrue event. System click can not be prevented.

        if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
          domHandlers.click.call(this, event);
        }

        setTouchTimer(this);
      },
      pointerdown: function pointerdown(event) {
        domHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {
        //     this._msGesture.addPointer(event.pointerId);
        // }
      },
      pointermove: function pointermove(event) {
        // FIXME
        // pointermove is so sensitive that it always triggered when
        // tap(click) on touch screen, which affect some judgement in
        // upper application. So, we dont support mousemove on MS touch
        // device yet.
        if (!isPointerFromTouch(event)) {
          domHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function pointerup(event) {
        domHandlers.mouseup.call(this, event);
      },
      pointerout: function pointerout(event) {
        // pointerout will be triggered when tap on touch screen
        // (IE11+/Edge on MS Surface) after click event triggered,
        // which is inconsistent with the mousout behavior we defined
        // in touchend. So we unify them.
        // (check domHandlers.touchend for detailed explanation)
        if (!isPointerFromTouch(event)) {
          domHandlers.mouseout.call(this, event);
        }
      }
    };

    function isPointerFromTouch(event) {
      var pointerType = event.pointerType;
      return pointerType === 'pen' || pointerType === 'touch';
    } // function useMSGuesture(handlerProxy, event) {
    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;
    // }
    // Common handlers


    each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
      domHandlers[name] = function (event) {
        event = normalizeEvent(this.dom, event);
        this.trigger(name, event);
      };
    });
    /**
     * 为控制类实例初始化dom 事件处理函数
     *
     * @inner
     * @param {module:zrender/Handler} instance 控制类实例
     */

    function initDomHandler(instance) {
      each(touchHandlerNames, function (name) {
        instance._handlers[name] = bind(domHandlers[name], instance);
      });
      each(pointerHandlerNames, function (name) {
        instance._handlers[name] = bind(domHandlers[name], instance);
      });
      each(mouseHandlerNames, function (name) {
        instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
      });

      function makeMouseHandler(fn, instance) {
        return function () {
          if (instance._touching) {
            return;
          }

          return fn.apply(instance, arguments);
        };
      }
    }

    function HandlerDomProxy(dom) {
      Eventful.call(this);
      this.dom = dom;
      /**
       * @private
       * @type {boolean}
       */

      this._touching = false;
      /**
       * @private
       * @type {number}
       */

      this._touchTimer;
      /**
       * @private
       * @type {module:zrender/core/GestureMgr}
       */

      this._gestureMgr = new GestureMgr();
      this._handlers = {};
      initDomHandler(this);

      if (env$1.pointerEventsSupported) {
        // Only IE11+/Edge
        // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),
        // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event
        // at the same time.
        // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on
        // screen, which do not occurs in pointer event.
        // So we use pointer event to both detect touch gesture and mouse behavior.
        mountHandlers(pointerHandlerNames, this); // FIXME
        // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,
        // which does not prevent defuault behavior occasionally (which may cause view port
        // zoomed in but use can not zoom it back). And event.preventDefault() does not work.
        // So we have to not to use MSGesture and not to support touchmove and pinch on MS
        // touch screen. And we only support click behavior on MS touch screen now.
        // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.
        // We dont support touch on IE on win7.
        // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>
        // if (typeof MSGesture === 'function') {
        //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line
        //     dom.addEventListener('MSGestureChange', onMSGestureChange);
        // }
      } else {
        if (env$1.touchEventsSupported) {
          mountHandlers(touchHandlerNames, this); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
          // addEventListener(root, 'mouseout', this._mouseoutHandler);
        } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface
        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
        // mouse event can not be handle in those devices.
        // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent
        // mouseevent after touch event triggered, see `setTouchTimer`.


        mountHandlers(mouseHandlerNames, this);
      }

      function mountHandlers(handlerNames, instance) {
        each(handlerNames, function (name) {
          addEventListener(dom, eventNameFix(name), instance._handlers[name]);
        }, instance);
      }
    }

    var handlerDomProxyProto = HandlerDomProxy.prototype;

    handlerDomProxyProto.dispose = function () {
      var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

      for (var i = 0; i < handlerNames.length; i++) {
        var name = handlerNames[i];
        removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
      }
    };

    handlerDomProxyProto.setCursor = function (cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
    };

    mixin(HandlerDomProxy, Eventful);

    /*!
    * ZRender, a high performance 2d drawing library.
    *
    * Copyright (c) 2013, Baidu Inc.
    * All rights reserved.
    *
    * LICENSE
    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
    */
    var useVML = !env$1.canvasSupported;
    var painterCtors = {
      canvas: Painter
    };
    var instances = {}; // ZRender实例map索引
    /**
     * Initializing a zrender instance
     * @param {HTMLElement} dom
     * @param {Object} [opts]
     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
     * @param {number} [opts.devicePixelRatio]
     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
     * @return {module:zrender/ZRender}
     */

    function init(dom, opts) {
      var zr = new ZRender(guid(), dom, opts);
      instances[zr.id] = zr;
      return zr;
    }

    function delInstance(id) {
      delete instances[id];
    }
    /**
     * @module zrender/ZRender
     */

    /**
     * @constructor
     * @alias module:zrender/ZRender
     * @param {string} id
     * @param {HTMLElement} dom
     * @param {Object} opts
     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
     * @param {number} [opts.devicePixelRatio]
     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
     */


    var ZRender = function ZRender(id, dom, opts) {
      opts = opts || {};
      /**
       * @type {HTMLDomElement}
       */

      this.dom = dom;
      /**
       * @type {string}
       */

      this.id = id;
      var self = this;
      var storage = new Storage();
      var rendererType = opts.renderer; // TODO WebGL

      if (useVML) {
        if (!painterCtors.vml) {
          throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
        }

        rendererType = 'vml';
      } else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = 'canvas';
      }

      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      this.storage = storage;
      this.painter = painter;
      var handerProxy = !env$1.node && !env$1.worker ? new HandlerDomProxy(painter.getViewportRoot()) : null;
      this.handler = new Handler(storage, painter, handerProxy, painter.root);
      /**
       * @type {module:zrender/animation/Animation}
       */

      this.animation = new Animation({
        stage: {
          update: bind(this.flush, this)
        }
      });
      this.animation.start();
      /**
       * @type {boolean}
       * @private
       */

      this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画
      // FIXME 有点ugly

      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;

      storage.delFromStorage = function (el) {
        oldDelFromStorage.call(storage, el);
        el && el.removeSelfFromZr(self);
      };

      storage.addToStorage = function (el) {
        oldAddToStorage.call(storage, el);
        el.addSelfToZr(self);
      };
    };

    ZRender.prototype = {
      constructor: ZRender,

      /**
       * 获取实例唯一标识
       * @return {string}
       */
      getId: function getId() {
        return this.id;
      },

      /**
       * 添加元素
       * @param  {module:zrender/Element} el
       */
      add: function add(el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
      },

      /**
       * 删除元素
       * @param  {module:zrender/Element} el
       */
      remove: function remove(el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
      },

      /**
       * Change configuration of layer
       * @param {string} zLevel
       * @param {Object} config
       * @param {string} [config.clearColor=0] Clear color
       * @param {string} [config.motionBlur=false] If enable motion blur
       * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
      */
      configLayer: function configLayer(zLevel, config) {
        if (this.painter.configLayer) {
          this.painter.configLayer(zLevel, config);
        }

        this._needsRefresh = true;
      },

      /**
       * Set background color
       * @param {string} backgroundColor
       */
      setBackgroundColor: function setBackgroundColor(backgroundColor) {
        if (this.painter.setBackgroundColor) {
          this.painter.setBackgroundColor(backgroundColor);
        }

        this._needsRefresh = true;
      },

      /**
       * Repaint the canvas immediately
       */
      refreshImmediately: function refreshImmediately() {
        // var start = new Date();
        // Clear needsRefresh ahead to avoid something wrong happens in refresh
        // Or it will cause zrender refreshes again and again.
        this._needsRefresh = false;
        this.painter.refresh();
        /**
         * Avoid trigger zr.refresh in Element#beforeUpdate hook
         */

        this._needsRefresh = false; // var end = new Date();
        // var log = document.getElementById('log');
        // if (log) {
        //     log.innerHTML = log.innerHTML + '<br>' + (end - start);
        // }
      },

      /**
       * Mark and repaint the canvas in the next frame of browser
       */
      refresh: function refresh() {
        this._needsRefresh = true;
      },

      /**
       * Perform all refresh
       */
      flush: function flush() {
        var triggerRendered;

        if (this._needsRefresh) {
          triggerRendered = true;
          this.refreshImmediately();
        }

        if (this._needsRefreshHover) {
          triggerRendered = true;
          this.refreshHoverImmediately();
        }

        triggerRendered && this.trigger('rendered');
      },

      /**
       * Add element to hover layer
       * @param  {module:zrender/Element} el
       * @param {Object} style
       */
      addHover: function addHover(el, style) {
        if (this.painter.addHover) {
          var elMirror = this.painter.addHover(el, style);
          this.refreshHover();
          return elMirror;
        }
      },

      /**
       * Add element from hover layer
       * @param  {module:zrender/Element} el
       */
      removeHover: function removeHover(el) {
        if (this.painter.removeHover) {
          this.painter.removeHover(el);
          this.refreshHover();
        }
      },

      /**
       * Clear all hover elements in hover layer
       * @param  {module:zrender/Element} el
       */
      clearHover: function clearHover() {
        if (this.painter.clearHover) {
          this.painter.clearHover();
          this.refreshHover();
        }
      },

      /**
       * Refresh hover in next frame
       */
      refreshHover: function refreshHover() {
        this._needsRefreshHover = true;
      },

      /**
       * Refresh hover immediately
       */
      refreshHoverImmediately: function refreshHoverImmediately() {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
      },

      /**
       * Resize the canvas.
       * Should be invoked when container size is changed
       * @param {Object} [opts]
       * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
       * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
       */
      resize: function resize(opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
      },

      /**
       * Stop and clear all animation immediately
       */
      clearAnimation: function clearAnimation() {
        this.animation.clear();
      },

      /**
       * Get container width
       */
      getWidth: function getWidth() {
        return this.painter.getWidth();
      },

      /**
       * Get container height
       */
      getHeight: function getHeight() {
        return this.painter.getHeight();
      },

      /**
       * Export the canvas as Base64 URL
       * @param {string} type
       * @param {string} [backgroundColor='#fff']
       * @return {string} Base64 URL
       */
      // toDataURL: function(type, backgroundColor) {
      //     return this.painter.getRenderedCanvas({
      //         backgroundColor: backgroundColor
      //     }).toDataURL(type);
      // },

      /**
       * Converting a path to image.
       * It has much better performance of drawing image rather than drawing a vector path.
       * @param {module:zrender/graphic/Path} e
       * @param {number} width
       * @param {number} height
       */
      pathToImage: function pathToImage(e, dpr) {
        return this.painter.pathToImage(e, dpr);
      },

      /**
       * Set default cursor
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function setCursorStyle(cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
      },

      /**
       * Find hovered element
       * @param {number} x
       * @param {number} y
       * @return {Object} {target, topTarget}
       */
      findHover: function findHover(x, y) {
        return this.handler.findHover(x, y);
      },

      /**
       * Bind event
       *
       * @param {string} eventName Event name
       * @param {Function} eventHandler Handler function
       * @param {Object} [context] Context object
       */
      on: function on(eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
      },

      /**
       * Unbind event
       * @param {string} eventName Event name
       * @param {Function} [eventHandler] Handler function
       */
      off: function off(eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
      },

      /**
       * Trigger event manually
       *
       * @param {string} eventName Event name
       * @param {event=} event Event object
       */
      trigger: function trigger(eventName, event) {
        this.handler.trigger(eventName, event);
      },

      /**
       * Clear all objects and the canvas.
       */
      clear: function clear() {
        this.storage.delRoot();
        this.painter.clear();
      },

      /**
       * Dispose self.
       */
      dispose: function dispose() {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.storage = this.painter = this.handler = null;
        delInstance(this.id);
      }
    };

    Displayable.prototype.centerDistSquare = function (x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      var centerX = rect.x + rect.width / 2,
          centerY = rect.y + rect.height / 2;
      return (centerX - localPos[0]) * (centerX - localPos[0]) + (centerY - localPos[1]) * (centerY - localPos[1]);
    };

    Displayable.prototype.getBoundingCenter = function () {
      var rect = this.getBoundingRect();
      var centerX = rect.x + rect.width / 2,
          centerY = rect.y + rect.height / 2;
      return this.transformCoordToGlobal(centerX, centerY);
    };

    var oldBoundingRectCreator = PathProxy.prototype.getBoundingRect; // NOTE zr的boundingRect在某些特殊的情况下计算出来的x, y, width或者height为NaN， 导致的结果就是canvasGradient抛错，我们从源头上避免过于麻烦
    // NOTE 这边直接重写这个方法，保证返回的rect里面不存在NaN

    PathProxy.prototype.getBoundingRect = function () {
      var rect = oldBoundingRectCreator.call(this);
      if (isNaN(rect.x)) rect.x = 0;
      if (isNaN(rect.y)) rect.y = 0;
      if (isNaN(rect.width)) rect.width = 0;
      if (isNaN(rect.height)) rect.height = 0;
      return rect;
    };

    var _ctx$1;
    /**
     * http://kms.finedevelop.com/pages/viewpage.action?pageId=45587265
     * for some special reason,
     * we override zr.measureText for getting accurately result because of minFontSize in chrome settings.
     */


    function overrideTextMethod() {
      $override$1("measureText", function (text, font) {
        if (!_ctx$1) {
          var canvas = createCanvas$1();
          var style = canvas.style;

          if (style) {
            style['opacity'] = "0";
            style['visibility'] = "hidden";
            style['position'] = "absolute";
            style['top'] = "-100000px";
            style['left'] = "0";
          }

          document && document.body && document.body.appendChild(canvas);
          _ctx$1 = canvas.getContext("2d");
        }

        _ctx$1.font = font || DEFAULT_FONT;
        return _ctx$1.measureText(text);
      });
    }

    if (typeof document !== 'undefined') {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', overrideTextMethod);
      } else {
        overrideTextMethod();
      }
    }

    // There are several static functions which can be called without instantiating L.SVG:
    // @function create(name: String): SVGElement
    // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
    // corresponding to the class name passed. For example, using 'line' will return
    // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).

    function svgCreate(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    } // @function pointsToPath(rings: Point[], closed: Boolean): String

    /*
     * @namespace Browser
     * @aka L.Browser
     *
     * A namespace with static properties for browser/feature detection used by Leaflet internally.
     *
     * @example
     *
     * ```js
     * if (L.Browser.ielt9) {
     *   alert('Upgrade your browser, dude!');
     * }
     * ```
     */

    var style = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).

    var ie = 'ActiveXObject' in window; // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.

    var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.

    var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;
    // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).

    var webkit = userAgentContains('webkit'); // @property android: Boolean
    // `true` for any browser running on an Android platform.

    var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.

    var android23 = userAgentContains('android 2') || userAgentContains('android 3'); // @property opera: Boolean; `true` for the Opera browser

    var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.

    var chrome = userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.

    var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.

    var safari = !chrome && userAgentContains('safari');
    var phantom = userAgentContains('phantom'); // @property opera12: Boolean
    // `true` for the Opera browser supporting CSS transforms (version 12 or later).

    var opera12 = 'OTransition' in style; // @property win: Boolean; `true` when the browser is running in a Windows platform

    var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.

    var ie3d = ie && 'transition' in style; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.

    var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.

    var gecko3d = 'MozPerspective' in style; // @property any3d: Boolean
    // `true` for all browsers supporting CSS transforms.

    var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.

    var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
    // `true` for browsers implementing the Microsoft touch events model (notably IE10).

    var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean
    // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).

    var pointer = !!(window.PointerEvent || msPointer); // @property touch: Boolean
    // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
    // This does not necessarily mean that the browser is running in a computer with
    // a touchscreen, it only means that the browser is capable of understanding
    // touch events.

    var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.

    var mobileOpera = mobile && opera; // @property mobileGecko: Boolean
    // `true` for browsers on a high-resolution "retina" screen.

    var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property canvas: Boolean
    // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).

    var canvas = function () {
      return !!document.createElement('canvas').getContext;
    }(); // @property svg: Boolean
    // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).

    var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean
    // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).

    var vml = !svg && function () {
      try {
        var div = document.createElement('div');
        div.innerHTML = '<v:shape adj="1"/>';
        var shape = div.firstChild;
        shape.style.behavior = 'url(#default#VML)';
        return shape && typeof shape.adj === 'object';
      } catch (e) {
        return false;
      }
    }();

    function userAgentContains(str) {
      return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
    }

    var getOrientation = function getOrientation() {
      var orientation = env$1.touchEventsSupported && typeof screen !== 'undefined' && screen.orientation && screen.orientation.type || '';
      return orientation.indexOf('landscape') !== -1 ? 'landscape' : 'portrait';
    };

    var env$2 = _extends({}, env$1, {
      domEventsSupported: typeof window !== 'undefined' && window.Event,
      any3d: any3d,
      getOrientation: getOrientation
    });

    // resource: https://github.com/AlloyTeam/AlloyFinger/blob/4a34955d672dd1f3477b8ccaa60dfe5bec2e35db/alloy_finger.js
    var TOUCHSTART = 'touchstart',
        TOUCHMOVE = 'touchmove',
        TOUCHEND = 'touchend';
    var TOUCH_HANDLER_NAMES = [TOUCHSTART, TOUCHMOVE, TOUCHEND];
    var EVENTS = ['rotate', 'touchStart', 'multipointStart', 'multipointEnd', 'pinch', 'swipe', 'tap', 'doubleTap', 'longTap', 'singleTap', // 'pressMove',
    'panStart', 'pan', 'panEnd', // 'twoFingerPressMove',
    'touchMove', 'touchEnd' // 'touchCancel'
    ]; // todo, check by direction instead of len

    var MIN_PINCH_LEN = 50;

    function getValidPinchStartLen(v) {
      v = Math.abs(v);
      return v < MIN_PINCH_LEN ? 0 : v;
    }

    function getLen(v) {
      return Math.sqrt(v.x * v.x + v.y * v.y);
    }

    function dot$1(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y;
    }

    function getAngle(v1, v2) {
      var mr = getLen(v1) * getLen(v2);
      if (mr === 0) return 0;
      var r = dot$1(v1, v2) / mr;
      if (r > 1) r = 1;
      return Math.acos(r);
    }

    function cross$1(v1, v2) {
      return v1.x * v2.y - v2.x * v1.y;
    }

    function getRotateAngle(v1, v2) {
      var angle = getAngle(v1, v2);

      if (cross$1(v1, v2) > 0) {
        angle *= -1;
      }

      return angle * 180 / Math.PI;
    }
    /**
     * custom touch event proxy
     * 监听dom事件，或由外部dispatch模拟触发事件
     * 通过start/move/end 交由内部统一处理成上层事件
     *
     * 坐标问题：
     * 1. 识别 target 需要转换过的坐标
     *    dom的事件：会调用zr转换，把touches第一个坐标转换后作为zrX/zrY放到event上
     *    外部触发事件：需要已经转换过的，这样直接设置zrX/zrY
     * 2. 识别手势需要 touches 中 screenX/screenY
     *    外部触发的直接设置了screenX = x
     */
    // todo = =有个问题，原来计算移动用的pageX，当页面移动的时候，就错乱了，所以改screenX；但是识别目标，还是要用pageX


    var GestureProxy =
    /*#__PURE__*/
    function () {
      function GestureProxy(handler, opt) {
        if (opt === void 0) {
          opt = {};
        }

        handler.proxy = this;
        this.handler = handler;
        this.preV = {
          x: null,
          y: null
        };
        this.pinchStartLen = null;
        this.zoom = 1;
        this.isDoubleTap = false;
        this.delta = null;
        this.last = null;
        this.now = null;
        this.tapTimeout = null;
        this.singleTapTimeout = null;
        this.longTapTimeout = null;
        this.swipeTimeout = null;
        this.x1 = this.x2 = this.sx2 = this.y1 = this.y2 = this.sy2 = null;
        this.preTapPosition = {
          x: null,
          y: null
        };
        this._preventTap = false;
        this._preventPan = false;
        this._panning = false;
        this.element = null; // for filter to compare
        // android event is too sensitive
        // filter no movement event

        this.__preEvent = {}; // add listeners to browser's dom

        if (!opt.disableDomListener && env$2.domEventsSupported) {
          this.initDomHandler();
        }
      }

      var _proto = GestureProxy.prototype;

      _proto.initDomHandler = function initDomHandler() {
        var _this = this;

        var dom = this.dom = this.handler.painter.getViewportRoot();
        this._domHandler = this.domHandler.bind(this);
        TOUCH_HANDLER_NAMES.forEach(function (name) {
          return dom.addEventListener(name, _this._domHandler);
        });
      };

      _proto.disposeDomHandler = function disposeDomHandler() {
        var _this2 = this;

        if (this.dom) {
          TOUCH_HANDLER_NAMES.forEach(function (name) {
            return _this2.dom.removeEventListener(name, _this2._domHandler);
          });
        }
      };

      _proto.domHandler = function domHandler(event) {
        event = normalizeEvent(this.dom, event);
        this.recognize(event);
      }
      /**
       * dispatch event manually
       * only the basic start/move/end event
       *
       * @param {Object}   obj         - the object contains touch info
       * @param {string}   obj.type    - `touchstart`|`touchmove`|`touchend`
       * @param {Object[]} obj.touches - touch pointers
       *
       * @example
       *
       * dispatch({
       *   type: 'touchstart',
       *   touches: [{
       *      x: 1,
       *      y: 1
       *   }]
       * });
       */
      ;

      _proto.dispatch = function dispatch(obj) {
        if (!obj || !obj.type || !obj.touches) {
          console.warn('touchEvent obj.type & obj.touches are required!');
          return;
        } // build the dom like event


        var event = obj; // flag it's a synthetic event

        event.vanSynth = true;
        event.time = +new Date();

        if (obj.type === TOUCHEND) {
          var pre = this.__preEvent;
          event.changedTouches = pre.touches;
          event.zrX = pre.zrX;
          event.zrY = pre.zrY;
        } else {
          event.zrX = obj.touches[0].x | 0;
          event.zrY = obj.touches[0].y | 0;
        }

        event.touches.forEach(function (touch) {
          touch.screenX = touch.x | 0;
          touch.screenY = touch.y | 0;
        });

        if (!this._shouldBeFiltered(event)) {
          this.recognize(event);
          this.__preEvent = event;
        }
      };

      _proto.recognize = function recognize(event) {
        var type = event.type;

        if (type === TOUCHSTART) {
          this.element = this.handler.findHover(event.zrX, event.zrY, null).target;
          this.start(event);

          this.__incubate(event);
        } else if (type === TOUCHMOVE) {
          this.move(event);
        } else if (type === TOUCHEND) {
          this.end(event);
        } else {
          throw 'unrecognized type:' + type;
        }
      };

      _proto.start = function start(evt) {
        if (!evt.touches) return;
        this.now = Date.now();
        this.x1 = evt.touches[0].screenX;
        this.y1 = evt.touches[0].screenY; // 不知道为什么Alloy要从第二次move开始算delta...
        // 感觉完全没必要……

        this.x2 = this.x1;
        this.y2 = this.y1;
        this.delta = this.now - (this.last || this.now); // #event

        this.touchStart(evt, this.element);

        if (this.preTapPosition.x !== null) {
          this.isDoubleTap = this.delta > 0 && this.delta <= 250 && Math.abs(this.preTapPosition.x - this.x1) < 30 && Math.abs(this.preTapPosition.y - this.y1) < 30;
          if (this.isDoubleTap) clearTimeout(this.singleTapTimeout);
        }

        this.preTapPosition.x = this.x1;
        this.preTapPosition.y = this.y1;
        this.last = this.now;
        var preV = this.preV,
            len = evt.touches.length;

        if (len > 1) {
          this._preventPan = true;

          if (this._panning) {
            this._panning = false;
            this.panEnd(evt, this.element);
          } // set zrX/zrY


          this._clientToLocal(evt);

          this._cancelLongTap();

          this._cancelSingleTap();

          var v = {
            x: evt.touches[1].screenX - this.x1,
            y: evt.touches[1].screenY - this.y1
          };
          preV.x = v.x;
          preV.y = v.y;
          this.pinchStartLen = getLen(preV);
          this.pinchStartLenX = getValidPinchStartLen(v.x);
          this.pinchStartLenY = getValidPinchStartLen(v.y); // #event

          this.multipointStart(evt, this.element);
        } else {
          this._preventPan = false;
        }

        this._preventTap = false;
        this.longTapTimeout = setTimeout(function () {
          // #event
          this.longTap(evt, this.element);
          this._preventTap = true;
        }.bind(this), 750);
      };

      _proto.move = function move(evt) {
        if (!evt.touches) return;
        var preV = this.preV,
            len = evt.touches.length,
            currentX = evt.touches[0].screenX,
            currentY = evt.touches[0].screenY;
        this.isDoubleTap = false;

        if (len > 1) {
          this._preventTap = true; // set zrX/zrY

          this._clientToLocal(evt);

          var sCurrentX = evt.touches[1].screenX,
              sCurrentY = evt.touches[1].screenY;
          var v = {
            x: evt.touches[1].screenX - currentX,
            y: evt.touches[1].screenY - currentY
          };

          if (preV.x !== null) {
            if (this.pinchStartLen > 0) {
              evt.zoom = getLen(v) / this.pinchStartLen;
              evt.zoomX = this.pinchStartLenX ? Math.abs(v.x) / this.pinchStartLenX : 1;
              evt.zoomY = this.pinchStartLenY ? Math.abs(v.y) / this.pinchStartLenY : 1; // #event

              this.pinch(evt, this.element);
            }

            evt.angle = getRotateAngle(v, preV); // #event

            this.rotate(evt, this.element);
          }

          preV.x = v.x;
          preV.y = v.y;

          if (this.x2 !== null && this.sx2 !== null) {
            evt.deltaX = (currentX - this.x2 + sCurrentX - this.sx2) / 2;
            evt.deltaY = (currentY - this.y2 + sCurrentY - this.sy2) / 2;
          } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
          } // #event
          // this.twoFingerPressMove(evt, this.startElement);


          this.sx2 = sCurrentX;
          this.sy2 = sCurrentY;
        } else {
          if (this.x2 !== null) {
            evt.deltaX = currentX - this.x2;
            evt.deltaY = currentY - this.y2; //move事件中添加对当前触摸点到初始触摸点的判断，
            //如果曾经大于过某个距离(比如8),就认为是移动到某个地方又移回来，应该不再触发tap事件才对。

            var movedX = Math.abs(this.x1 - this.x2),
                movedY = Math.abs(this.y1 - this.y2);

            if (movedX > 8 || movedY > 8) {
              this._preventTap = true;
            }
          } else {
            evt.deltaX = 0;
            evt.deltaY = 0;
          } // #event
          // this.pressMove(evt, this.startElement);
          // Maybe pan outside to inside.
          // Should we strict the event to which is started from inside only?


          if (!this._preventPan) {
            if (this._panning) {
              this.pan(evt, this.element);
            } else {
              this._panning = true;
              this.panStart(evt, this.element);
            }
          }
        } // #event
        // moved to the beginning;
        // do we have to fire `move` on startElement?


        this.touchMove(evt, this.element);

        this._cancelLongTap();

        this.x2 = currentX;
        this.y2 = currentY;
      };

      _proto.end = function end(evt) {
        if (!evt.changedTouches) return;

        this._cancelLongTap();

        var self = this;

        if (evt.touches.length < 2) {
          // #event
          this.multipointEnd(evt, this.element);
          this.sx2 = this.sy2 = null;
        } else {
          // set zrX/zrY
          this._clientToLocal(evt);
        } //swipe


        if (this.x2 && Math.abs(this.x1 - this.x2) > 30 || this.y2 && Math.abs(this.y1 - this.y2) > 30) {
          evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);
          this.swipeTimeout = setTimeout(function () {
            // #event
            self.swipe(evt, self.element);
          }, 0);
        } else {
          this.tapTimeout = setTimeout(function () {
            if (!self._preventTap) {
              // #event
              self.tap(evt, self.element);
            } // trigger double tap immediately


            if (self.isDoubleTap) {
              // #event
              self.doubleTap(evt, self.element);
              self.isDoubleTap = false;
            }
          }, 0);

          if (!self.isDoubleTap) {
            self.singleTapTimeout = setTimeout(function () {
              // #event
              self.singleTap(evt, self.element);
            }, 250);
          }
        } // #event


        if (this._panning) {
          this._panning = false;
          this.panEnd(evt, this.element);
        }

        this.touchEnd(evt, this.element);
        this.preV.x = 0;
        this.preV.y = 0;
        this.zoom = 1;
        this.pinchStartLen = this.pinchStartLenX = this.pinchStartLenY = null;
        this.x1 = this.x2 = this.y1 = this.y2 = null;
      } // filter same touches & no movement move
      ;

      _proto._shouldBeFiltered = function _shouldBeFiltered(e) {
        if (!e || this._isSameEvent(this.__preEvent, e)) {
          return true;
        }

        if (e.type === 'touchstart') ; else if (e.type === 'touchmove') {
          return this._isSameTouches(this.__preEvent.touches, e.touches);
        } else if (e.type === 'touchend') ;
      };

      _proto._isSameEvent = function _isSameEvent(pre, now) {
        if (!(pre && now && pre.type === now.type)) {
          return false;
        }

        return this._isSameTouches(pre.touches, now.touches);
      };

      _proto._isSameTouches = function _isSameTouches(pre, now) {
        if (!(pre && now && pre.length === now.length)) {
          return false;
        }

        var theSamePoint = function theSamePoint(p1, p2) {
          return p1.screenX === p2.screenX && p1.screenY === p2.screenY;
        };

        return pre.every(function (p, i) {
          return theSamePoint(p, now[i]);
        });
      };

      _proto._clientToLocal = function _clientToLocal(evt) {
        if (!evt.vanSynth) {
          // convert coordinate
          // set zrX/zrY directly to `touch`
          var touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;

          for (var i = 0; i < touches.length; ++i) {
            var touch = touches[i];
            var p = clientToLocal(this.handler.painterRoot, touch); // make it the same as synthesis event

            touch.x = Math.round(p.zrX);
            touch.y = Math.round(p.zrY);
          }
        }
      };

      _proto._cancelLongTap = function _cancelLongTap() {
        clearTimeout(this.longTapTimeout);
      };

      _proto._cancelSingleTap = function _cancelSingleTap() {
        clearTimeout(this.singleTapTimeout);
      };

      _proto._swipeDirection = function _swipeDirection(x1, x2, y1, y2) {
        return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';
      };

      _proto.dispose = function dispose() {
        if (this.singleTapTimeout) clearTimeout(this.singleTapTimeout);
        if (this.tapTimeout) clearTimeout(this.tapTimeout);
        if (this.longTapTimeout) clearTimeout(this.longTapTimeout);
        if (this.swipeTimeout) clearTimeout(this.swipeTimeout);
        if (this.__incubatingTimeout) clearTimeout(this.__incubatingTimeout);
        this.preV = this.pinchStartLen = this.zoom = this.isDoubleTap = this.delta = this.last = this.now = this.tapTimeout = this.singleTapTimeout = this.longTapTimeout = this.swipeTimeout = this.x1 = this.x2 = this.y1 = this.y2 = this.preTapPosition = this.rotate = this.touchStart = this.multipointStart = this.multipointEnd = this.pinch = this.swipe = this.tap = this.doubleTap = this.longTap = this.singleTap = this.pressMove = this.touchMove = this.touchEnd = this.touchCancel = this.twoFingerPressMove = null;
        this.element = this.__preEvent = null;
        this.disposeDomHandler();
        return null;
      };

      return GestureProxy;
    }();

    EVENTS.forEach(function (name) {
      var type = name.toLowerCase();

      GestureProxy.prototype[name] = function (event, target) {
        // target && console.log(type);
        this.handler.dispatchToElement({
          target: target
        }, type, event);
      };
    });
    /**
     * 常常搞不清移动端测试到底用的什么js
     * 搞个办法显示打包信息
     * 5s内左上角按8次，左下角，右下角
     */

    GestureProxy.prototype.__incubate = function (event) {
      var _this3 = this;

      var zrX = event.zrX,
          zrY = event.zrY; // console.log(this.__incubating);

      var painter = this.handler && this.handler.painter;

      if (!painter) {
        return;
      }

      var S = 40;
      var width = painter.getWidth() - S,
          height = painter.getHeight() - S;
      var n = this.__incubating;

      if (n < 1 && zrX < S && zrY < S) {
        clearTimeout(this.__incubatingTimeout);
        this.__incubatingTimeout = setTimeout(function () {
          _this3.__incubating = 0; // console.log('cancel incubate');
        }, 5000);
        this.__incubating = 1;
      } else if (n < 8 && zrX < S && zrY < S) {
        ++this.__incubating;
      } else if (n === 8 && zrX < S && zrY > height) {
        ++this.__incubating;
      } else if (n === 9 && zrX > width && zrY > height) {
        clearTimeout(this.__incubatingTimeout);
        this.__incubating = 0; // console.log('fire');

        var g = this.handler.storage && this.handler.storage._roots[0];
        var zr = g && g.__zr;
        zr && zr.__infoCard && zr.add(zr.__infoCard);
      } else {
        clearTimeout(this.__incubatingTimeout);
        this.__incubating = 0;
      }
    };

    function GestureTouch(handler, opt) {
      // off useless drag events
      handler.off(); // we will replace zr's handler proxy

      handler.setHandlerProxy(null);
      return new GestureProxy(handler, opt);
    }

    var param$1 = function param(target) {
      return {
        target: target
      };
    };

    function GestureMouse(handler) {
      var checkingTarget = null,
          panningTarget = null;
      var docHandlerProxy = new HandlerDomProxy(document);
      docHandlerProxy.handler = handler; // prevent error if touch event fired

      handler.on('mousedown', mousedownHandler);
      handler.on('mousemove', mousemoveHandler);
      docHandlerProxy.on('mousemove', pan, handler);
      docHandlerProxy.on('mouseup', panEnd, handler);

      function mousedownHandler(ze) {
        checkingTarget = ze.target;

        if (checkingTarget) {
          var e = ze.event;
          this._x = e.clientX;
          this._y = e.clientY;
        }
      }

      function mousemoveHandler(ze) {
        // pan -> down & move the same target
        if (!(checkingTarget && checkingTarget === ze.target)) {
          return;
        }

        var e = ze.event;
        var dx = e.deltaX = e.clientX - this._x;
        var dy = e.deltaY = e.clientY - this._y;

        if (Math.sqrt(dx * dx + dy * dy) < 1) {
          return;
        }

        panningTarget = checkingTarget;
        checkingTarget = null;
        this._x = e.clientX;
        this._y = e.clientY;
        this.dispatchToElement(param$1(panningTarget), 'panstart', e);
      } // `e` comes from `document`, it's a native event obj


      function pan(e) {
        if (!panningTarget) {
          return;
        }

        e.deltaX = e.clientX - this._x;
        e.deltaY = e.clientY - this._y;
        this._x = e.clientX;
        this._y = e.clientY;
        this.dispatchToElement(param$1(panningTarget), 'pan', e);
      } // native event obj


      function panEnd(e) {
        if (panningTarget) {
          this.dispatchToElement(param$1(panningTarget), 'panend', e);
        }

        checkingTarget = panningTarget = null;
      }

      var originDispose = handler.proxy.dispose;

      handler.proxy.dispose = function () {
        originDispose.call(this);
        docHandlerProxy.dispose();
      };
    }

    /**
     * attach gesture add-on
     * @param {ZRender} zr                     - zrender instance
     * @param {object} options
     * @param {boolean|string} options.touch   - is touch env
     * @param {Eventful}       options.emitter - to trigger touch event
     * @returns {object} proxy                 - handler proxy
     * @constructor
     */

    function Gesture(zr, _ref) {
      var touch = _ref.touch,
          emitter = _ref.emitter,
          disableDomListener = _ref.disableDomListener;

      if (touch) {
        return GestureTouch(zr.handler, {
          emitter: emitter,
          disableDomListener: disableDomListener
        });
      } else {
        return GestureMouse(zr.handler);
      }
    }

    // https://github.com/developit/preact/tree/821c793bcff199999e88167da4f84c38f2fd5d73
    var group$1 = graphic.group;
    var instances$1 = {};

    var _dispose = function _dispose(zr) {
      var id = zr.getId();
      zr.dispose();
      delete instances$1[id];
    }; // As we add custom properties to zr;
    // We have to use our `dispose` to dispose the render result


    function dispose$1(zr) {
      if (zr) {
        _dispose(zr);
      } else {
        for (var key in instances$1) {
          if (instances$1.hasOwnProperty(key)) {
            _dispose(instances$1[key]);
          }
        }
      }
    }
    /** Render JSX into a `parent` Element.
     *	@param {VNode} vnode		A (JSX) VNode to render
     *	@param {Element} dom		DOM element to render into
     *	@param {Object} [options]       - Additional options
     *	@param {ZRender} [options.zr]   - ZRender instance. Re-use existed zr instance.
     *  @param {boolean|string} [options.touch]- touch env
     *	@public
     */

    function render(vnode, dom, options) {
      if (options === void 0) {
        options = {};
      }

      var zr = options.zr || init(dom, options);
      instances$1[zr.getId()] = zr; // 并没有研究多一层group会不会对性能有影响
      // 这里的主要目的是利用已有的parent/children操作

      var parent = group$1();
      zr.add(parent);
      zr.__infoCard = graphic.rect({
        z: 100000,
        shape: {
          width: 200,
          height: 100
        },
        style: {
          fill: '#0b9',
          text: ['1.3.1', '50816ed', '5/7/2019, 5:29:17 PM'].join('\n'),
          textFill: '#e55',
          fontSize: 16
        },
        ontap: function ontap() {
          zr.remove(zr.__infoCard);
        }
      }); // custom properties

      zr.__parent = parent; // PENDING, return ret or zr

      var ret = diff(null, vnode, {}, false, parent, false);
      zr.__ret = ret; // attach custom
      //

      !env$1.node && Gesture(zr, options);
      return zr;
    }
    render.initZr = init;

    var frame = 0,
        // is an animation frame pending?
    timeout = 0,
        // is a timeout pending?
    interval = 0,
        // are any timers active?
    pokeDelay = 1000,
        // how frequently we check for clock skew
    taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
      setTimeout(f, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function restart(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;else taskHead = this;
          taskTail = this;
        }

        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function stop() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time) {
      var t = new Timer();
      t.restart(callback, delay, time);
      return t;
    }
    function timerFlush() {
      now(); // Get the current time, if not already set.

      ++frame; // Pretend we’ve set an alarm, if we haven’t already.

      var t = taskHead,
          e;

      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
        t = t._next;
      }

      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout = 0;

      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(),
          delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0,
          t1 = taskHead,
          t2,
          time = Infinity;

      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }

      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.

      if (timeout) timeout = clearTimeout(timeout);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

      if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout$1 (callback, delay, time) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart(function (elapsed) {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval$1 (callback, delay, time) {
      var t = new Timer(),
          total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      delay = +delay, time = time == null ? now() : +time;
      t.restart(function tick(elapsed) {
        elapsed += total;
        t.restart(tick, total += delay, time);
        callback(elapsed);
      }, delay, time);
      return t;
    }

    function define (constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }
    function extend$2(parent, definition) {
      var prototype = Object.create(parent.prototype);

      for (var key in definition) {
        prototype[key] = definition[key];
      }

      return prototype;
    }

    function Color() {}
    var _darker = 0.7;

    var _brighter = 1 / _darker;
    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex3 = /^#([0-9a-f]{3})$/,
        reHex6 = /^#([0-9a-f]{6})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };
    define(Color, color, {
      displayable: function displayable() {
        return this.rgb().displayable();
      },
      toString: function toString() {
        return this.rgb() + "";
      }
    });
    function color(format) {
      var m;
      format = (format + "").trim().toLowerCase();
      return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
      ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend$2(Color, {
      brighter: function brighter(k) {
        k = k == null ? _brighter : Math.pow(_brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function darker(k) {
        k = k == null ? _darker : Math.pow(_darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function rgb() {
        return this;
      },
      displayable: function displayable() {
        return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
      },
      toString: function toString() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl();
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;

      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }

      return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend$2(Color, {
      brighter: function brighter(k) {
        k = k == null ? _brighter : Math.pow(_brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function darker(k) {
        k = k == null ? _darker : Math.pow(_darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
      },
      displayable: function displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
      }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */

    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    var Kn = 18,
        Xn = 0.950470,
        // D65 standard referent
    Yn = 1,
        Zn = 1.088830,
        t0 = 4 / 29,
        t1 = 6 / 29,
        t2 = 3 * t1 * t1,
        t3 = t1 * t1 * t1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);

      if (o instanceof Hcl) {
        var h = o.h * deg2rad;
        return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
      }

      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var b = rgb2xyz(o.r),
          a = rgb2xyz(o.g),
          l = rgb2xyz(o.b),
          x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
          y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
          z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function lab(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Lab, lab, extend$2(Color, {
      brighter: function brighter(k) {
        return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker: function darker(k) {
        return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb: function rgb$$1() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        y = Yn * lab2xyz(y);
        x = Xn * lab2xyz(x);
        z = Zn * lab2xyz(z);
        return new Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
        xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }

    function lab2xyz(t) {
      return t > t1 ? t * t * t : t2 * (t - t0);
    }

    function xyz2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2xyz(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      var h = Math.atan2(o.b, o.a) * rad2deg;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function hcl(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }
    define(Hcl, hcl, extend$2(Color, {
      brighter: function brighter(k) {
        return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
      },
      darker: function darker(k) {
        return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
      },
      rgb: function rgb$$1() {
        return labConvert(this).rgb();
      }
    }));

    var A$1 = -0.14861,
        B$1 = +1.78277,
        C$1 = -0.29227,
        D = -0.90649,
        E = +1.97294,
        ED = E * D,
        EB = E * B$1,
        BC_DA = B$1 * C$1 - D * A$1;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C$1 * bl) / D,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
          // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }
    define(Cubehelix, cubehelix, extend$2(Color, {
      brighter: function brighter$$1(k) {
        k = k == null ? _brighter : Math.pow(_brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function darker$$1(k) {
        k = k == null ? _darker : Math.pow(_darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function rgb$$1() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(255 * (l + a * (A$1 * cosh + B$1 * sinh)), 255 * (l + a * (C$1 * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
      }
    }));

    function constant$1 (x) {
      return function () {
        return x;
      };
    }

    function linear(a, d) {
      return function (t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue(a, b) {
      var d = b - a;
      return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$1(isNaN(a) ? b : a);
    }
    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function (a, b) {
        return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
      };
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
    }

    var rgb$1 = (function rgbGamma(y) {
      var color$$1 = gamma(y);

      function rgb$$1(start, end) {
        var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
            g = color$$1(start.g, end.g),
            b = color$$1(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function (t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$$1.gamma = rgbGamma;
      return rgb$$1;
    })(1);

    function array (a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) {
        x[i] = interpolateValue(a[i], b[i]);
      }

      for (; i < nb; ++i) {
        c[i] = b[i];
      }

      return function (t) {
        for (i = 0; i < na; ++i) {
          c[i] = x[i](t);
        }

        return c;
      };
    }

    function date (a, b) {
      var d = new Date();
      return a = +a, b -= a, function (t) {
        return d.setTime(a + b * t), d;
      };
    }

    function reinterpolate (a, b) {
      return a = +a, b -= a, function (t) {
        return a + b * t;
      };
    }

    function object (a, b) {
      var i = {},
          c = {},
          k;
      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolateValue(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function (t) {
        for (k in i) {
          c[k] = i[k](t);
        }

        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function () {
        return b;
      };
    }

    function one(b) {
      return function (t) {
        return b(t) + "";
      };
    }

    function string (a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0,
          // scan index for next number in b
      am,
          // current match in a
      bm,
          // current match in b
      bs,
          // string preceding current number in b, if any
      i = -1,
          // index in s
      s = [],
          // string constants and placeholders
      q = []; // number interpolators
      // Coerce inputs to strings.

      a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

      while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }

        if ((am = am[0]) === (bm = bm[0])) {
          // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else {
          // interpolate non-matching numbers
          s[++i] = null;
          q.push({
            i: i,
            x: reinterpolate(am, bm)
          });
        }

        bi = reB.lastIndex;
      } // Add remains of b.


      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      } // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.


      return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
        for (var i = 0, o; i < b; ++i) {
          s[(o = q[i]).i] = o.x(t);
        }

        return s.join("");
      });
    }

    function interpolateValue (a, b) {
      var t = typeof b,
          c;
      return b == null || t === "boolean" ? constant$1(b) : (t === "number" ? reinterpolate : t === "string" ? (c = color(b)) ? (b = c, rgb$1) : string : b instanceof color ? rgb$1 : b instanceof Date ? date : Array.isArray(b) ? array : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : reinterpolate)(a, b);
    }

    function interpolateRound (a, b) {
      return a = +a, b -= a, function (t) {
        return Math.round(a + b * t);
      };
    }

    var degrees = 180 / Math.PI;
    var identity$2 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose (a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;
    function parseSvg(value) {
      if (value == null) return identity$2;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({
            i: i - 4,
            x: reinterpolate(xa, xb)
          }, {
            i: i - 2,
            x: reinterpolate(ya, yb)
          });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

          q.push({
            i: s.push(pop(s) + "rotate(", null, degParen) - 2,
            x: reinterpolate(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({
            i: s.push(pop(s) + "skewX(", null, degParen) - 2,
            x: reinterpolate(a, b)
          });
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({
            i: i - 4,
            x: reinterpolate(xa, xb)
          }, {
            i: i - 2,
            x: reinterpolate(ya, yb)
          });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function (a, b) {
        var s = [],
            // string constants and placeholders
        q = []; // number interpolators

        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc

        return function (t) {
          var i = -1,
              n = q.length,
              o;

          while (++i < n) {
            s[(o = q[i]).i] = o.x(t);
          }

          return s.join("");
        };
      };
    }
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var rho = Math.SQRT2;

    function cubehelix$1(hue$$1) {
      return function cubehelixGamma(y) {
        y = +y;

        function cubehelix$$1(start, end) {
          var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function (t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix$$1.gamma = cubehelixGamma;
        return cubehelix$$1;
      }(1);
    }

    cubehelix$1(hue);
    var cubehelixLong = cubehelix$1(nogamma);

    function getInterpolator(attr) {
      if (attr === 'transform') {
        return interpolateTransformSvg;
      }

      return interpolateValue;
    }

    function getTween(nameSpace, attr, value1) {
      return function tween() {
        var _this = this;

        var value0 = nameSpace ? this.state[nameSpace][attr] : this.state[attr];

        if (value0 === value1) {
          return null;
        }

        var i = getInterpolator(attr)(value0, value1);
        var stateTween;

        if (nameSpace === null) {
          stateTween = function stateTween(t) {
            _this.setState(function () {
              var _ref;

              return _ref = {}, _ref[attr] = i(t), _ref;
            });
          };
        } else {
          stateTween = function stateTween(t) {
            _this.setState(function (state) {
              var _r;

              // return { [nameSpace]: { ...state[nameSpace], [attr]: i(t) } };
              var r = (_r = {}, _r[nameSpace] = _extends({}, state[nameSpace]), _r);
              r[nameSpace][attr] = i(t);
              return r;
            });
          };
        }

        return stateTween;
      };
    }

    function tween (nameSpace, attr, value) {
      return getTween.call(this, nameSpace, attr, value);
    }

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule (node, stateKey, id, timing, tweens, events) {
      if (events === void 0) {
        events = {};
      }

      var schedules = node.TRANSITION_SCHEDULES;

      if (!schedules) {
        node.TRANSITION_SCHEDULES = {}; // eslint-disable-line no-param-reassign
      } else if (id in schedules) {
        return;
      }

      var config = _extends({
        stateKey: stateKey,
        events: events,
        tweens: tweens
      }, timing, {
        timer: null,
        state: CREATED
      });

      create$2(node, id, config);
    }

    function create$2(node, id, config) {
      var schedules = node.TRANSITION_SCHEDULES; // Initialize the transition timer when the transition is created.
      // Note the actual delay is not known until the first callback!

      var transition = _extends({}, config);

      var n = transition.tweens.length;
      var tweens = new Array(n);
      schedules[id] = transition;
      transition.timer = timer(schedule, 0, transition.time);

      function schedule(elapsed) {
        transition.state = SCHEDULED;
        transition.timer.restart(start, transition.delay, transition.time); // If the elapsed delay is less than our first sleep, start immediately.

        if (transition.delay <= elapsed) {
          start(elapsed - transition.delay);
        }
      }

      function start(elapsed) {
        // eslint-disable-line consistent-return
        // If the state is not SCHEDULED, then we previously errored on start.
        if (transition.state !== SCHEDULED) return stop();

        for (var sid in schedules) {
          // eslint-disable-line
          var s = schedules[sid];

          if (s.stateKey !== transition.stateKey) {
            continue; // eslint-disable-line no-continue
          } // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!


          if (s.state === STARTED) return timeout$1(start); // 1. Interrupt the active transition, if any. dispatch the interrupt event.
          // 2. Cancel any pre-empted transitions. No interrupt event is dispatched
          // because the cancelled transitions never started. Note that this also
          // removes this transition from the pending list!

          if (s.state === RUNNING) {
            s.state = ENDED;
            s.timer.stop();

            if (s.events.interrupt && typeof s.events.interrupt === 'function') {
              s.events.interrupt.call(this);
            }

            delete schedules[sid];
          } else if (+sid < id) {
            s.state = ENDED;
            s.timer.stop();
            delete schedules[sid];
          }
        } // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.


        timeout$1(function () {
          if (transition.state === STARTED) {
            transition.state = RUNNING;
            transition.timer.restart(tick, transition.delay, transition.time);
            tick(elapsed);
          }
        });
        transition.state = STARTING;

        if (transition.events.start && typeof transition.events.start === 'function') {
          transition.events.start.call(node);
        }

        if (transition.state !== STARTING) {
          // interrupted
          return; // eslint-disable-line consistent-return
        }

        transition.state = STARTED; // Initialize the tween, deleting null tween.

        var j = -1;

        for (var i = 0; i < n; ++i) {
          var res = transition.tweens[i].call(node);

          if (res) {
            tweens[++j] = res;
          }
        }

        tweens.length = j + 1;
      }

      function tick(elapsed) {
        var t = 1;

        if (elapsed < transition.duration) {
          t = transition.ease.call(null, elapsed / transition.duration);
        } else {
          transition.timer.restart(stop);
          transition.state = ENDING;
        }

        var i = -1;

        while (++i < tweens.length) {
          tweens[i].call(null, t);
        }

        if (transition.state === ENDING) {
          if (transition.events.end && typeof transition.events.end === 'function') {
            transition.events.end.call(node);
          }

          stop();
        }
      }

      function stop() {
        transition.state = ENDED;
        transition.timer.stop();
        delete schedules[id];

        for (var i in schedules) {
          return;
        } // eslint-disable-line guard-for-in, no-restricted-syntax


        delete node.TRANSITION_SCHEDULES; // eslint-disable-line no-param-reassign
      }
    }

    function once(func) {
      var called = false;
      return function transitionEvent() {
        if (!called) {
          called = true;
          func.call(this);
        }
      };
    }

    var id$1 = 0;
    function newId() {
      return ++id$1;
    } // from https://github.com/d3/d3-ease/blob/master/src/linear.js

    function linear$1(t) {
      return +t;
    }

    var preset = {
      time: null,
      delay: 0,
      duration: 250,
      ease: linear$1
    };

    function scheduleTransitions(config) {
      var _this = this;

      if (config === void 0) {
        config = {};
      }

      var transitions = _extends({}, config);

      var events = transitions.events || {};
      delete transitions.events; // each event handler should be called only once

      Object.keys(events).forEach(function (d) {
        if (typeof events[d] !== 'function') {
          throw new Error('Event handlers must be a function');
        } else {
          events[d] = once(events[d]);
        }
      });
      var timing = transitions.timing || {};
      delete transitions.timing;
      Object.keys(transitions).forEach(function (stateKey) {
        var tweens = [];

        if (typeof transitions[stateKey] === 'object' && Array.isArray(transitions[stateKey]) === false) {
          Object.keys(transitions[stateKey]).forEach(function (attr) {
            var val = transitions[stateKey][attr];

            if (Array.isArray(val)) {
              if (val.length === 1) {
                tweens.push(tween.call(_this, stateKey, attr, val[0]));
              } else {
                _this.setState(function (state) {
                  var _r;

                  // return { [stateKey]: { ...state[stateKey], [attr]: val[0] } };
                  var r = (_r = {}, _r[stateKey] = _extends({}, state[stateKey]), _r);
                  r[stateKey][attr] = val[0];
                  return r;
                });

                tweens.push(tween.call(_this, stateKey, attr, val[1]));
              }
            } else if (typeof val === 'function') {
              var getResonanceCustomTween = function getResonanceCustomTween() {
                var resonanceCustomTween = function resonanceCustomTween(t) {
                  _this.setState(function (state) {
                    var _r2;

                    // return { [stateKey]: { ...state[stateKey], [attr]: val(t) } };
                    var r = (_r2 = {}, _r2[stateKey] = _extends({}, state[stateKey]), _r2);
                    r[stateKey][attr] = val(t);
                    return r;
                  });
                };

                return resonanceCustomTween;
              };

              tweens.push(getResonanceCustomTween);
            } else {
              _this.setState(function (state) {
                var _r3;

                // return { [stateKey]: { ...state[stateKey], [attr]: val } };
                var r = (_r3 = {}, _r3[stateKey] = _extends({}, state[stateKey]), _r3);
                r[stateKey][attr] = val;
                return r;
              }); // This assures any existing transitions are stopped


              tweens.push(tween.call(_this, stateKey, attr, val));
            }
          });
        } else {
          var val = transitions[stateKey];

          if (Array.isArray(val)) {
            if (val.length === 1) {
              tweens.push(tween.call(_this, null, stateKey, val[0]));
            } else {
              _this.setState(function () {
                var _ref;

                return _ref = {}, _ref[stateKey] = val[0], _ref;
              });

              tweens.push(tween.call(_this, null, stateKey, val[1]));
            }
          } else if (typeof val === 'function') {
            var getResonanceCustomTween = function getResonanceCustomTween() {
              var resonanceCustomTween = function resonanceCustomTween(t) {
                _this.setState(function () {
                  var _ref2;

                  return _ref2 = {}, _ref2[stateKey] = val(t), _ref2;
                });
              };

              return resonanceCustomTween;
            };

            tweens.push(getResonanceCustomTween);
          } else {
            _this.setState(function () {
              var _ref3;

              return _ref3 = {}, _ref3[stateKey] = val, _ref3;
            }); // This assures any existing transitions are stopped


            tweens.push(tween.call(_this, null, stateKey, val));
          }
        }

        var timingConfig = _extends({}, preset, timing, {
          time: now()
        });

        schedule(_this, stateKey, newId(), timingConfig, tweens, events);
      });
    }

    function transition(config) {
      var _this2 = this;

      if (Array.isArray(config)) {
        config.forEach(function (c) {
          scheduleTransitions.call(_this2, c);
        });
      } else {
        scheduleTransitions.call(this, config);
      }
    }

    // @flow weak
    function stop$1() {
      var ts = this.TRANSITION_SCHEDULES;

      if (ts) {
        Object.keys(ts).forEach(function (s) {
          ts[s].timer.stop();
        });
      }
    }

    /* eslint-disable flowtype/require-valid-file-annotation */

    var Animate$$1 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Animate$$1, _Component);

      function Animate$$1(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        _this.state = typeof _this.props.start === 'function' ? _this.props.start() : _extends({}, _this.props.start);
        _this.interval = null;
        _this.renderNull = true;
        _this.checkTransitionStatus = _this.checkTransitionStatus.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = Animate$$1.prototype;

      _proto.componentWillMount = function componentWillMount() {
        if (this.props.show === true) {
          this.renderNull = false;
        }
      };

      _proto.componentDidMount = function componentDidMount() {
        var _this$props = this.props,
            enter = _this$props.enter,
            show = _this$props.show;

        if (enter && show === true) {
          transition.call(this, typeof enter === 'function' ? enter() : enter);
        }
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(next) {
        var _this2 = this;

        var show = next.show,
            start = next.start,
            enter = next.enter,
            update = next.update,
            leave = next.leave;

        if (this.props.show === false && this.renderNull === true && show === true) {
          this.renderNull = false;
          this.setState(function () {
            return typeof start === 'function' ? start() : start;
          }, function () {
            if (enter) {
              transition.call(_this2, typeof enter === 'function' ? enter() : enter);
            }
          });
        } else if (this.props.show === true && show === false) {
          if (leave) {
            transition.call(this, typeof leave === 'function' ? leave() : leave);
            this.interval = interval$1(this.checkTransitionStatus);
          } else {
            this.renderNull = true;
            this.setState(function (prevState) {
              return prevState;
            }); // force render as null
          }
        } else if (show === true && update) {
          if (this.interval) {
            this.interval.stop();
          }

          transition.call(this, typeof update === 'function' ? update() : update);
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        if (this.interval) {
          this.interval.stop();
        }

        stop$1.call(this);
      };

      _proto.checkTransitionStatus = function checkTransitionStatus() {
        if (!this.TRANSITION_SCHEDULES) {
          this.interval.stop();

          if (this.props.show === false) {
            this.renderNull = true;
            this.setState(function (prevState) {
              return prevState;
            }); // force render as null
          }
        }
      };

      _proto.render = function render$$1() {
        if (this.renderNull === true) {
          return h("group", null);
        }

        return this.props.children[0](this.state);
      };

      return Animate$$1;
    }(Component);

    Animate$$1.defaultProps = {
      show: true
    };

    // @flow weak

    /* eslint guard-for-in: "off", no-restricted-syntax: "off" */
    // Node constructor used to manage transitions internally
    // Basically a modified preact component (https://github.com/developit/preact)
    function extend$3(obj, props) {
      for (var i in props) {
        obj[i] = props[i]; // eslint-disable-line no-param-reassign
      }

      return obj;
    }

    function Node(key, data, type, condition) {
      this.key = key;
      this.data = data;
      this.type = type;
      this.condition = condition;
      this.prevCondition = null;
      this.state = {};
    }

    extend$3(Node.prototype, {
      setState: function setState(state) {
        var s = this.state;
        extend$3(s, typeof state === 'function' ? state(s) : state);
      },
      updateData: function updateData(data) {
        this.lastData = this.data;
        this.data = data;
        return this;
      },
      updateType: function updateType(type) {
        this.type = type;
        return this;
      },
      updateCondition: function updateCondition(condition) {
        this.prevCondition = this.condition;
        this.condition = condition;
      }
    });

    // @flow weak

    /* eslint no-continue: "off" */

    /* based on react-motion's mergeDiff (https://github.com/chenglou/react-motion) */
    function mergeKeys(currNodeKeys, currKeyIndex, nextNodeKeys, nextKeyIndex) {
      var allKeys = [];

      for (var i = 0; i < nextNodeKeys.length; i++) {
        allKeys[i] = nextNodeKeys[i];
      }

      for (var _i = 0; _i < currNodeKeys.length; _i++) {
        if (nextKeyIndex[currNodeKeys[_i]] === undefined) {
          allKeys.push(currNodeKeys[_i]);
        }
      }

      return allKeys.sort(function (a, b) {
        var nextOrderA = nextKeyIndex[a];
        var nextOrderB = nextKeyIndex[b];
        var currOrderA = currKeyIndex[a];
        var currOrderB = currKeyIndex[b];

        if (nextOrderA != null && nextOrderB != null) {
          return nextKeyIndex[a] - nextKeyIndex[b];
        } else if (currOrderA != null && currOrderB != null) {
          return currKeyIndex[a] - currKeyIndex[b];
        } else if (nextOrderA != null) {
          for (var _i2 = 0; _i2 < nextNodeKeys.length; _i2++) {
            var pivot = nextNodeKeys[_i2];

            if (!currKeyIndex[pivot]) {
              continue;
            }

            if (nextOrderA < nextKeyIndex[pivot] && currOrderB > currKeyIndex[pivot]) {
              return -1;
            } else if (nextOrderA > nextKeyIndex[pivot] && currOrderB < currKeyIndex[pivot]) {
              return 1;
            }
          }

          return 1;
        }

        for (var _i3 = 0; _i3 < nextNodeKeys.length; _i3++) {
          var _pivot = nextNodeKeys[_i3];

          if (!currKeyIndex[_pivot]) {
            continue;
          }

          if (nextOrderB < nextKeyIndex[_pivot] && currOrderA > currKeyIndex[_pivot]) {
            return 1;
          } else if (nextOrderB > nextKeyIndex[_pivot] && currOrderA < currKeyIndex[_pivot]) {
            return -1;
          }
        }

        return -1;
      });
    }

    // @flow weak
    var ENTER$1 = 'ENTER';
    var UPDATE$1 = 'UPDATE';
    var LEAVE$1 = 'LEAVE';

    var NodeGroup$$1 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(NodeGroup$$1, _Component);

      function NodeGroup$$1(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        _this.state = {
          nodes: []
        };
        _this.nodeHash = {};
        _this.nodeKeys = [];
        _this.interval = null;
        _this.unmounting = false;
        _this.animate = _this.animate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = NodeGroup$$1.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.updateNodes(this.props);
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(next) {
        if (next.data !== this.props.data) {
          this.updateNodes(next);
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        var _this2 = this;

        this.unmounting = true;

        if (this.interval) {
          this.interval.stop();
        }

        this.nodeKeys.forEach(function (key) {
          stop$1.call(_this2.nodeHash[key]);
        });
      };

      _proto.updateNodes = function updateNodes(props) {
        var data = props.data,
            keyAccessor = props.keyAccessor,
            start = props.start,
            enter = props.enter,
            update = props.update,
            leave = props.leave;
        var currKeyIndex = {};
        var currNodeKeys = this.nodeKeys;
        var currNodeKeysLength = this.nodeKeys.length;

        for (var i = 0; i < currNodeKeysLength; i++) {
          currKeyIndex[currNodeKeys[i]] = i;
        }

        var nextKeyIndex = {};
        var nextNodeKeys = [];

        for (var _i = 0; _i < data.length; _i++) {
          var d = data[_i];
          var k = keyAccessor(d, _i);
          nextKeyIndex[k] = _i;
          nextNodeKeys.push(k);

          if (currKeyIndex[k] === undefined) {
            this.nodeHash[k] = new Node(k, d, ENTER$1);
          }
        }

        for (var _i2 = 0; _i2 < currNodeKeysLength; _i2++) {
          var _k = currNodeKeys[_i2];
          var n = this.nodeHash[_k];

          if (nextKeyIndex[_k] !== undefined) {
            n.updateData(data[nextKeyIndex[_k]]);
            n.updateType(UPDATE$1);
          } else {
            n.updateType(LEAVE$1);
          }
        }

        this.nodeKeys = mergeKeys(currNodeKeys, currKeyIndex, nextNodeKeys, nextKeyIndex);

        for (var _i3 = 0; _i3 < this.nodeKeys.length; _i3++) {
          var _k2 = this.nodeKeys[_i3];
          var _n = this.nodeHash[_k2];
          var _d = _n.data;

          if (_n.type === ENTER$1) {
            _n.setState(start(_d, nextKeyIndex[_k2]));

            transition.call(_n, enter(_d, nextKeyIndex[_k2]));
          } else if (_n.type === LEAVE$1) {
            transition.call(_n, leave(_d, currKeyIndex[_k2]));
          } else {
            transition.call(_n, update(_d, nextKeyIndex[_k2]));
          }
        }

        if (!this.interval) {
          this.interval = interval$1(this.animate);
        } else {
          this.interval.restart(this.animate);
        }

        this.renderNodes();
      };

      _proto.animate = function animate() {
        if (this.unmounting) {
          return;
        }

        var pending = false;
        var nextNodeKeys = [];
        var length = this.nodeKeys.length;

        for (var i = 0; i < length; i++) {
          var k = this.nodeKeys[i];
          var n = this.nodeHash[k];

          if (n.TRANSITION_SCHEDULES) {
            pending = true;
          }

          if (n.type === LEAVE$1 && !n.TRANSITION_SCHEDULES) {
            delete this.nodeHash[k];
          } else {
            nextNodeKeys.push(k);
          }
        }

        if (!pending) {
          this.interval.stop();
        }

        this.nodeKeys = nextNodeKeys;
        this.renderNodes();
      };

      _proto.renderNodes = function renderNodes() {
        var _this3 = this;

        this.setState(function () {
          return {
            nodes: _this3.nodeKeys.map(function (key) {
              return _this3.nodeHash[key];
            })
          };
        });
      };

      _proto.render = function render$$1() {
        return this.props.children[0](this.state.nodes);
      };

      return NodeGroup$$1;
    }(Component);

    NodeGroup$$1.defaultProps = {
      keyAccessor: function keyAccessor(d) {
        return d.id;
      },
      enter: function enter() {},
      update: function update() {},
      leave: function leave() {}
    };

    var NodeGroup$$2 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(NodeGroup, _Component);

      function NodeGroup(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        _this.state = {
          nodes: []
        }; // todo,

        _this.elements = {};
        _this.nodeHash = {};
        _this.removedNodes = {};
        _this.nodeKeys = [];
        _this.interval = null;
        _this.unmounting = false;
        _this.cleaning = false;
        _this.clean = _this.clean.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.deferredClean = _this.deferredClean.bind(_assertThisInitialized(_assertThisInitialized(_this)));

        _this.updateData(props);

        return _this;
      }

      var _proto = NodeGroup.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(next) {
        if (next.data !== this.props.data) {
          this.updateData(next);
        } else {
          this.updateNodes(next);
        }

        this.removedNodes = {};
      };

      _proto.updateData = function updateData(props) {
        var data = props.data,
            keyAccessor = props.keyAccessor,
            fadeChecker = props.fadeChecker,
            highlights = props.highlights;
        var currKeyIndex = {};
        var currNodeKeys = this.nodeKeys;
        var currNodeKeysLength = this.nodeKeys.length;

        for (var i = 0; i < currNodeKeysLength; i++) {
          currKeyIndex[currNodeKeys[i]] = i;
        }

        var nextKeyIndex = {};
        var nextNodeKeys = [];
        var nodeHash = {};
        var isFade = fadeChecker;

        for (var _i = 0; _i < data.length; _i++) {
          var d = data[_i];
          var k = keyAccessor(d, _i);
          nextKeyIndex[k] = _i;
          nextNodeKeys.push(k);

          if (this.nodeHash[k]) {
            nodeHash[k] = this.nodeHash[k];
            nodeHash[k].updateData(d);
          } else {
            nodeHash[k] = new Node(k, d, ENTER, null);
          }
        }

        for (var _i2 = 0, len = nextNodeKeys.length; _i2 < len; _i2++) {
          var _k = nextNodeKeys[_i2];
          var n = nodeHash[_k];
          var _d = data[nextKeyIndex[_k]];

          if (_d.vanish) {
            n.updateType(LEAVE);
          } else {
            this.nodeHash[_k] && n.updateType(UPDATE);

            if (isFade(_d)) {
              n.updateCondition(FADE);
            } else if (highlights[_k]) {
              n.updateCondition(HOVER);
            } else {
              n.updateCondition(null);
            }
          }
        }

        this.nodeHash = nodeHash;
        this.nodeKeys = nextNodeKeys;
        this.renderNodes();
      };

      _proto.updateNodes = function updateNodes(props) {
        var _this2 = this;

        // data no change
        // filter(fade) or highlights change
        var highlights = props.highlights,
            fadeChecker = props.fadeChecker;
        forEach(this.nodeKeys, function (k) {
          var n = _this2.nodeHash[k];
          var d = n.data;

          if (n.type === ENTER) {
            n.updateType(UPDATE);
          }

          if (fadeChecker(d)) {
            n.updateCondition(FADE);
          } else if (highlights[k]) {
            n.updateCondition(HOVER);
          } else {
            n.updateCondition(null);
          }
        });
      };

      _proto.clean = function clean(element) {
        if (!element) {
          return;
        }

        var id = element.id;
        this.removedNodes[id] = this.nodeHash[id];
        delete this.nodeHash[id];

        if (this.cleaning) {
          return;
        }

        this.cleaning = true;
        defer(this.deferredClean);
      };

      _proto.deferredClean = function deferredClean() {
        this.nodeKeys = Object.keys(this.nodeHash);
        this.renderNodes();
        this.cleaning = false;
      };

      _proto.renderNodes = function renderNodes() {
        var _this3 = this;

        // sync animate result and vnode
        this.setState({
          nodes: this.nodeKeys.map(function (key) {
            return _this3.nodeHash[key];
          })
        });
      };

      _proto.render = function render$$1() {
        // todo,
        // 1. Render `group` here, render fn returns one level children
        // 2. Can we remove state.nodes? Use elements directly.
        return this.props.children[0](this.state.nodes, this.clean);
      };

      return NodeGroup;
    }(Component);

    NodeGroup$$2.defaultProps = {
      keyAccessor: function keyAccessor(d) {
        return d.id;
      }
    };

    // https://github.com/react-tools/react-move/tree/dfd0239a75fdaa09d1a82bcbb7f014d0e1da2e59

    /**
     * Prints a warning in the console if it exists.
     *
     * @param {String} message The warning message.
     * @returns {void}
     */

    /**
     * @param {any} obj The object to inspect.
     * @returns {boolean} True if the argument appears to be a plain object.
     */
    function isPlainObject(obj) {
      if (typeof obj !== 'object' || obj === null) return false;
      var proto = obj;

      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }

      return Object.getPrototypeOf(obj) === proto;
    }

    var invariant = function invariant(condition, format) {
      if (!condition) {
        console.error(format);
      }
    };

    var defaultMapStateToProps = function defaultMapStateToProps(state) {
      return {};
    }; // eslint-disable-line no-unused-vars


    var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
      return {
        dispatch: dispatch
      };
    };

    var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
      return _extends({}, parentProps, stateProps, dispatchProps);
    };

    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || 'Component';
    }

    var errorObject = {
      value: null
    };

    function tryCatch(fn, ctx) {
      try {
        return fn.apply(ctx);
      } catch (e) {
        errorObject.value = e;
        return errorObject;
      }
    } // Helps track hot reloading.


    var nextVersion = 0;
    function connect(mapStateToProps, mapDispatchToProps, mergeProps, options$$1) {
      if (options$$1 === void 0) {
        options$$1 = {};
      }

      var shouldSubscribe = Boolean(mapStateToProps);
      var mapState = mapStateToProps || defaultMapStateToProps;
      var mapDispatch;

      if (typeof mapDispatchToProps === 'function') {
        mapDispatch = mapDispatchToProps;
      } else if (!mapDispatchToProps) {
        mapDispatch = defaultMapDispatchToProps;
      } else {
        throw 'mapDispatchToProps as a object is unsupported'; // mapDispatch = wrapActionCreators(mapDispatchToProps)
      }

      var finalMergeProps = mergeProps || defaultMergeProps;
      var _options = options$$1,
          _options$pure = _options.pure,
          pure = _options$pure === void 0 ? true : _options$pure,
          _options$withRef = _options.withRef,
          withRef = _options$withRef === void 0 ? false : _options$withRef;
      var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps; // Helps track hot reloading.

      var version = nextVersion++;
      return function wrapWithConnect(WrappedComponent) {
        var connectDisplayName = "Connect(" + getDisplayName(WrappedComponent) + ")";

        function computeMergedProps(stateProps, dispatchProps, parentProps) {
          var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);

          return mergedProps;
        }

        var Connect =
        /*#__PURE__*/
        function (_Component) {
          _inheritsLoose(Connect, _Component);

          var _proto = Connect.prototype;

          _proto.shouldComponentUpdate = function shouldComponentUpdate() {
            return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
          };

          function Connect(props, context) {
            var _this;

            _this = _Component.call(this, props, context) || this;
            _this.version = version;
            _this.store = props.store || context.store;
            invariant(_this.store, "Could not find \"store\" in either the context or " + ("props of \"" + connectDisplayName + "\". ") + "Either wrap the root component in a <Provider>, " + ("or explicitly pass \"store\" as a prop to \"" + connectDisplayName + "\"."));

            var storeState = _this.store.getState();

            _this.state = {
              storeState: storeState
            };

            _this.clearCache();

            return _this;
          }

          _proto.computeStateProps = function computeStateProps(store, props) {
            if (!this.finalMapStateToProps) {
              return this.configureFinalMapState(store, props);
            }

            var state = store.getState();
            var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);

            return stateProps;
          };

          _proto.configureFinalMapState = function configureFinalMapState(store, props) {
            var mappedState = mapState(store.getState(), props);
            var isFactory = typeof mappedState === 'function';
            this.finalMapStateToProps = isFactory ? mappedState : mapState;
            this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;

            if (isFactory) {
              return this.computeStateProps(store, props);
            }

            return mappedState;
          };

          _proto.computeDispatchProps = function computeDispatchProps(store, props) {
            if (!this.finalMapDispatchToProps) {
              return this.configureFinalMapDispatch(store, props);
            }

            var dispatch = store.dispatch;
            var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);

            return dispatchProps;
          };

          _proto.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
            var mappedDispatch = mapDispatch(store.dispatch, props);
            var isFactory = typeof mappedDispatch === 'function';
            this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
            this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;

            if (isFactory) {
              return this.computeDispatchProps(store, props);
            }

            return mappedDispatch;
          };

          _proto.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
            var nextStateProps = this.computeStateProps(this.store, this.props);

            if (this.stateProps && shallowEqual(nextStateProps, this.stateProps)) {
              return false;
            }

            this.stateProps = nextStateProps;
            return true;
          };

          _proto.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
            var nextDispatchProps = this.computeDispatchProps(this.store, this.props);

            if (this.dispatchProps && shallowEqual(nextDispatchProps, this.dispatchProps)) {
              return false;
            }

            this.dispatchProps = nextDispatchProps;
            return true;
          };

          _proto.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
            var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);

            if (this.mergedProps && checkMergedEquals && shallowEqual(nextMergedProps, this.mergedProps)) {
              return false;
            }

            this.mergedProps = nextMergedProps;
            return true;
          };

          _proto.isSubscribed = function isSubscribed() {
            return typeof this.unsubscribe === 'function';
          };

          _proto.trySubscribe = function trySubscribe() {
            if (shouldSubscribe && !this.unsubscribe) {
              this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
              this.handleChange();
            }
          };

          _proto.tryUnsubscribe = function tryUnsubscribe() {
            if (this.unsubscribe) {
              this.unsubscribe();
              this.unsubscribe = null;
            }
          };

          _proto.componentDidMount = function componentDidMount() {
            this.trySubscribe();
          };

          _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
            if (!pure || !shallowEqual(nextProps, this.props)) {
              this.haveOwnPropsChanged = true;
            }
          };

          _proto.componentWillUnmount = function componentWillUnmount() {
            this.tryUnsubscribe();
            this.clearCache();
          };

          _proto.clearCache = function clearCache() {
            this.dispatchProps = null;
            this.stateProps = null;
            this.mergedProps = null;
            this.haveOwnPropsChanged = true;
            this.hasStoreStateChanged = true;
            this.haveStatePropsBeenPrecalculated = false;
            this.statePropsPrecalculationError = null;
            this.renderedElement = null;
            this.finalMapDispatchToProps = null;
            this.finalMapStateToProps = null;
          };

          _proto.handleChange = function handleChange() {
            if (!this.unsubscribe) {
              return;
            }

            var storeState = this.store.getState();
            var prevStoreState = this.state.storeState;

            if (pure && prevStoreState === storeState) {
              return;
            }

            if (pure && !this.doStatePropsDependOnOwnProps) {
              var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);

              if (!haveStatePropsChanged) {
                return;
              }

              if (haveStatePropsChanged === errorObject) {
                this.statePropsPrecalculationError = errorObject.value;
              }

              this.haveStatePropsBeenPrecalculated = true;
            }

            this.hasStoreStateChanged = true;
            this.setState({
              storeState: storeState
            });
          };

          _proto.getWrappedInstance = function getWrappedInstance() {
            invariant(withRef, "To access the wrapped instance, you need to specify " + "{ withRef: true } as the fourth argument of the connect() call.");
            return this.refs.wrappedInstance;
          };

          _proto.render = function render$$1() {
            var haveOwnPropsChanged = this.haveOwnPropsChanged,
                hasStoreStateChanged = this.hasStoreStateChanged,
                haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated,
                statePropsPrecalculationError = this.statePropsPrecalculationError,
                renderedElement = this.renderedElement;
            this.haveOwnPropsChanged = false;
            this.hasStoreStateChanged = false;
            this.haveStatePropsBeenPrecalculated = false;
            this.statePropsPrecalculationError = null;

            if (statePropsPrecalculationError) {
              throw statePropsPrecalculationError;
            }

            var shouldUpdateStateProps = true;
            var shouldUpdateDispatchProps = true;

            if (pure && renderedElement) {
              shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
              shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
            }

            var haveStatePropsChanged = false;
            var haveDispatchPropsChanged = false;

            if (haveStatePropsBeenPrecalculated) {
              haveStatePropsChanged = true;
            } else if (shouldUpdateStateProps) {
              haveStatePropsChanged = this.updateStatePropsIfNeeded();
            }

            if (shouldUpdateDispatchProps) {
              haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
            }

            var haveMergedPropsChanged = true;

            if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
              haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
            } else {
              haveMergedPropsChanged = false;
            }

            if (!haveMergedPropsChanged && renderedElement) {
              return renderedElement;
            }

            if (withRef) {
              this.renderedElement = h(WrappedComponent, _extends({}, this.mergedProps, {
                ref: 'wrappedInstance'
              }));
            } else {
              this.renderedElement = h(WrappedComponent, this.mergedProps);
            }

            return this.renderedElement;
          };

          return Connect;
        }(Component);

        Connect.displayName = connectDisplayName;
        Connect.WrappedComponent = WrappedComponent; // Connect.contextTypes = {


        return Connect;
      };
    }

    /**
     * These are private action types reserved by Redux.
     * For any unknown actions, you must return the current state.
     * If the current state is undefined, you must return the initial state.
     * Do not reference these action types directly in your code.
     */
    var ActionTypes$1 = {
      INIT: '@@redux/INIT' // 一不小心用了4.0 下面和devTools 不兼容
      // + Math.random()
      //   .toString(36)
      //   .substring(7)
      //   .split('')
      //   .join('.')
      ,
      REPLACE: '@@redux/REPLACE' // + Math.random()
      //   .toString(36)
      //   .substring(7)
      //   .split('')
      //   .join('.')

    };

    /**
     * Creates a Redux store that holds the state tree.
     * The only way to change the data in the store is to call `dispatch()` on it.
     *
     * There should only be a single store in your app. To specify how different
     * parts of the state tree respond to actions, you may combine several reducers
     * into a single reducer function by using `combineReducers`.
     *
     * @param {Function} reducer A function that returns the next state tree, given
     * the current state tree and the action to handle.
     *
     * @param {any} [preloadedState] The initial state. You may optionally specify it
     * to hydrate the state from the server in universal apps, or to restore a
     * previously serialized user session.
     * If you use `combineReducers` to produce the root reducer function, this must be
     * an object with the same shape as `combineReducers` keys.
     *
     * @param {Function} [enhancer] The store enhancer. You may optionally specify it
     * to enhance the store with third-party capabilities such as middleware,
     * time travel, persistence, etc. The only store enhancer that ships with Redux
     * is `applyMiddleware()`.
     *
     * @returns {Store} A Redux store that lets you read the state, dispatch actions
     * and subscribe to changes.
     */

    function createStore(reducer, preloadedState, enhancer) {
      if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
        enhancer = preloadedState;
        preloadedState = undefined;
      }

      if (typeof enhancer !== 'undefined') {
        if (typeof enhancer !== 'function') {
          throw new Error('Expected the enhancer to be a function.');
        }

        return enhancer(createStore)(reducer, preloadedState);
      }

      if (typeof reducer !== 'function') {
        throw new Error('Expected the reducer to be a function.');
      }

      var currentReducer = reducer;
      var currentState = preloadedState;
      var currentListeners = [];
      var nextListeners = currentListeners;
      var isDispatching = false;

      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      /**
       * Reads the state tree managed by the store.
       *
       * @returns {any} The current state tree of your application.
       */


      function getState() {
        if (isDispatching) {
          throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
        }

        return currentState;
      }
      /**
       * Adds a change listener. It will be called any time an action is dispatched,
       * and some part of the state tree may potentially have changed. You may then
       * call `getState()` to read the current state tree inside the callback.
       *
       * You may call `dispatch()` from a change listener, with the following
       * caveats:
       *
       * 1. The subscriptions are snapshotted just before every `dispatch()` call.
       * If you subscribe or unsubscribe while the listeners are being invoked, this
       * will not have any effect on the `dispatch()` that is currently in progress.
       * However, the next `dispatch()` call, whether nested or not, will use a more
       * recent snapshot of the subscription list.
       *
       * 2. The listener should not expect to see all state changes, as the state
       * might have been updated multiple times during a nested `dispatch()` before
       * the listener is called. It is, however, guaranteed that all subscribers
       * registered before the `dispatch()` started will be called with the latest
       * state by the time it exits.
       *
       * @param {Function} listener A callback to be invoked on every dispatch.
       * @returns {Function} A function to remove this change listener.
       */


      function subscribe(listener) {
        if (typeof listener !== 'function') {
          throw new Error('Expected listener to be a function.');
        }

        if (isDispatching) {
          throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See http://redux.js.org/docs/api/Store.html#subscribe for more details.');
        }

        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }

          if (isDispatching) {
            throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See http://redux.js.org/docs/api/Store.html#subscribe for more details.');
          }

          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index = nextListeners.indexOf(listener);
          nextListeners.splice(index, 1);
        };
      }
      /**
       * Dispatches an action. It is the only way to trigger a state change.
       *
       * The `reducer` function, used to create the store, will be called with the
       * current state tree and the given `action`. Its return value will
       * be considered the **next** state of the tree, and the change listeners
       * will be notified.
       *
       * The base implementation only supports plain object actions. If you want to
       * dispatch a Promise, an Observable, a thunk, or something else, you need to
       * wrap your store creating function into the corresponding middleware. For
       * example, see the documentation for the `redux-thunk` package. Even the
       * middleware will eventually dispatch plain object actions using this method.
       *
       * @param {Object} action A plain object representing “what changed”. It is
       * a good idea to keep actions serializable so you can record and replay user
       * sessions, or use the time travelling `redux-devtools`. An action must have
       * a `type` property which may not be `undefined`. It is a good idea to use
       * string constants for action types.
       *
       * @returns {Object} For convenience, the same action object you dispatched.
       *
       * Note that, if you use a custom middleware, it may wrap `dispatch()` to
       * return something else (for example, a Promise you can await).
       */


      function dispatch(action) {
        // todo, remove in prod
        if (!isPlainObject(action)) {
          throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
        }

        if (typeof action.type === 'undefined') {
          throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
        }

        if (isDispatching) {
          throw new Error('Reducers may not dispatch actions.');
        }

        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }

        var listeners = currentListeners = nextListeners;

        for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];
          listener();
        }

        return action;
      }
      /**
       * Replaces the reducer currently used by the store to calculate the state.
       *
       * You might need this if your app implements code splitting and you want to
       * load some of the reducers dynamically. You might also need this if you
       * implement a hot reloading mechanism for Redux.
       *
       * @param {Function} nextReducer The reducer for the store to use instead.
       * @returns {void}
       */


      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== 'function') {
          throw new Error('Expected the nextReducer to be a function.');
        }

        currentReducer = nextReducer;
        dispatch({
          type: ActionTypes$1.REPLACE
        });
      } // When a store is created, an "INIT" action is dispatched so that every
      // reducer returns their initial state. This effectively populates
      // the initial state tree.


      dispatch({
        type: ActionTypes$1.INIT
      });
      return {
        dispatch: dispatch,
        subscribe: subscribe,
        getState: getState,
        replaceReducer: replaceReducer
      };
    }

    /**
     * Composes single-argument functions from right to left. The rightmost
     * function can take multiple arguments as it provides the signature for
     * the resulting composite function.
     *
     * @param {...Function} funcs The functions to compose.
     * @returns {Function} A function obtained by composing the argument functions
     * from right to left. For example, compose(f, g, h) is identical to doing
     * (...args) => f(g(h(...args))).
     */

    function compose() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }

      if (funcs.length === 0) {
        return function (arg) {
          return arg;
        };
      }

      if (funcs.length === 1) {
        return funcs[0];
      } // return funcs.reduce((a, b) => (...args) => a(b(...args)))


      return reduce(funcs, function (a, b) {
        return function () {
          return a(b.apply(void 0, arguments));
        };
      });
    }

    /**
     * Creates a store enhancer that applies middleware to the dispatch method
     * of the Redux store. This is handy for a variety of tasks, such as expressing
     * asynchronous actions in a concise manner, or logging every action payload.
     *
     * See `redux-thunk` package as an example of the Redux middleware.
     *
     * Because middleware is potentially asynchronous, this should be the first
     * store enhancer in the composition chain.
     *
     * Note that each middleware will be given the `dispatch` and `getState` functions
     * as named arguments.
     *
     * @param {...Function} middlewares The middleware chain to be applied.
     * @returns {Function} A store enhancer applying the middleware.
     */

    function applyMiddleware() {
      for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        middlewares[_key] = arguments[_key];
      }

      return function (createStore) {
        return function () {
          var store = createStore.apply(void 0, arguments);

          var _dispatch = function dispatch() {
            throw new Error("Dispatching while constructing your middleware is not allowed. " + "Other middleware would not be applied to this dispatch.");
          };

          var chain = [];
          var middlewareAPI = {
            getState: store.getState,
            dispatch: function dispatch() {
              return _dispatch.apply(void 0, arguments);
            }
          };
          chain = map(middlewares, function (middleware) {
            return middleware(middlewareAPI);
          });
          _dispatch = compose.apply(void 0, chain)(store.dispatch);
          return _extends({}, store, {
            dispatch: _dispatch
          });
        };
      };
    }

    /**
     * Created by Jeffrey on 2018/8/21.
     */
    // https://raw.githubusercontent.com/reduxjs/reselect/3932567f7ca88d8dface5b46b0d2e0f23bd8ae07/src/index.js
    // FIXME
    // 本来的考虑是需要run ES3环境
    // 现在看来大多数都是ES5以上，ES3应该用shim/sham兼容
    function defaultEqualityCheck(a, b) {
      return a === b;
    }

    function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
      if (prev === null || next === null || prev.length !== next.length) {
        return false;
      } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.


      var length = prev.length;

      for (var i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
          return false;
        }
      }

      return true;
    }

    function defaultMemoize(func, equalityCheck) {
      if (equalityCheck === void 0) {
        equalityCheck = defaultEqualityCheck;
      }

      var lastArgs = null;
      var lastResult = null; // we reference arguments instead of spreading them for performance reasons

      return function () {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
          // apply arguments instead of spreading for performance.
          lastResult = func.apply(null, arguments);
        }

        lastArgs = arguments;
        return lastResult;
      };
    }

    function getDependencies(funcs) {
      var dependencies = _.isArray(funcs[0]) ? funcs[0] : funcs;

      if (!_.every(dependencies, function (dep) {
        return typeof dep === 'function';
      })) {
        var dependencyTypes = _.map(dependencies, function (dep) {
          return typeof dep;
        }).join(', ');

        throw new Error('Selector creators expect all input-selectors to be functions, ' + ("instead received the following types: [" + dependencyTypes + "]"));
      }

      return dependencies;
    }

    function createSelectorCreator(memoize) {
      for (var _len = arguments.length, memoizeOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        memoizeOptions[_key - 1] = arguments[_key];
      }

      return function () {
        for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          funcs[_key2] = arguments[_key2];
        }

        var recomputations = 0;
        var resultFunc = funcs.pop();
        var dependencies = getDependencies(funcs);
        var memoizedResultFunc = memoize.apply(void 0, [function () {
          recomputations++; // apply arguments instead of spreading for performance.

          return resultFunc.apply(null, arguments);
        }].concat(memoizeOptions)); // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.

        var selector = memoize(function () {
          var params = [];
          var length = dependencies.length;

          for (var i = 0; i < length; i++) {
            // apply arguments instead of spreading and mutate a local list of params for performance.
            params.push(dependencies[i].apply(null, arguments));
          } // apply arguments instead of spreading for performance.


          return memoizedResultFunc.apply(null, params);
        });
        selector.resultFunc = resultFunc;
        selector.dependencies = dependencies;

        selector.recomputations = function () {
          return recomputations;
        };

        selector.resetRecomputations = function () {
          return recomputations = 0;
        };

        return selector;
      };
    }
    var createSelector = createSelectorCreator(defaultMemoize);

    /**
     * Created by Jeffrey on 2018/1/18.
     */

    // https://github.com/tshelburne/redux-batched-actions/blob/44c35b41abd5371b77907440d2bc84a29c834a54/src/index.js
    var BATCH = 'BATCHING_REDUCER.BATCH';
    function batchActions(actions, type) {
      if (type === void 0) {
        type = BATCH;
      }

      return {
        type: type,
        meta: {
          batch: true
        },
        payload: actions
      };
    }
    function enableBatching(reduce) {
      return function batchingReducer(state, action) {
        if (action && action.meta && action.meta.batch) {
          return _.reduce(action.payload, batchingReducer, state);
        }

        return reduce(state, action);
      };
    }

    // https://github.com/gaearon/redux-thunk/blob/4f96ec0239453623adde857b7e7ad8c4f2897bf1/src/index.js

    function createThunkMiddleware(extraArgument) {
      return function (_ref) {
        var dispatch = _ref.dispatch,
            getState = _ref.getState;
        return function (next) {
          return function (action) {
            if (typeof action === 'function') {
              return action(dispatch, getState, extraArgument);
            }

            if (action.length === 0) {
              return;
            } else if (action.length === 1) {
              action = action[0];
            } else if (action.length != null) {
              action = batchActions(action);
            }

            return next(action);
          };
        };
      };
    }

    var thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;

    /**
     * Created by Jeffrey on 2018/12/13.
     */
    var basicState = {
      size: {
        width: 0,
        height: 0
      },
      focusPosition: {
        // they are percent values
        // 要表达缩放时候的中心，需要2个量
        // 关注的shape点在图上的位置；交互的点在plot view的位置
        // 更确切地说，数据不变的话，只是一个相对比例位置
        scroll: [0, 0],
        plot: [0, 0]
      },
      enableMap: false,
      bigData: false,
      animation: true,
      specialMode: null,
      scaled: {
        x: 1,
        y: 1
      },
      // isScrolling: true,
      hoverStage: STAGES.NORMAL,
      // todo, 合并scrolling zooming等交互状态key
      // initPos: null,
      // 移动端需要tooltip info，但是自己不显示，发送出去
      // 这个key或许只有pc需要
      tooltip: {
        geom: null,
        row: null,
        geoms: {},
        dims: [],
        instance: null
      },
      targets: {},
      highlightNode: null,
      sliderFilter: {},
      tagFilter: {},
      // scrollProps: null,
      darkTheme: false,
      inverted: false,
      condition: {
        annotation: {},
        imageFill: {}
      },
      facetX: {},
      facetY: {},
      geoms: [],
      defs: {},
      legend: {// default theme ?
        // style: {
        //     fontFamily: "sans-serif",
        //     fontSize: 12,
        //     textFill: "#1A1A1A",
        //     mobile: false,
        //     fontScale: 1,
        //     fontWeight: "",
        //     fontStyle: ""
        // },
        // enabled: true,
        // borderColor: "transparent",
        // position: "right"
      },
      mapConfig: {} // set to map field?
      // url: "",
      // center: {
      //     lat: 0,
      //     lng: 0
      // },
      // zoom: 1,
      // crs: "EPSG3857",

    };

    /**
     * Created by eason on 2017/10/11.
     */
    var distance$2 = function distance(a, b) {
      return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
    };
    function containsPoint(rect, point) {
      if (!rect || !point) {
        return false;
      }

      var x = point.x,
          y = point.y;
      return rect.x < x && rect.x + rect.width > x && rect.y < y && rect.y + rect.height > y;
    }
    function lineSubPixelOpt(xOry, borderWidth) {
      if (borderWidth === void 0) {
        borderWidth = 1;
      }

      return borderWidth % 2 === 0 ? Math.round(xOry) : Math.round(xOry - 0.5) + 0.5;
    }
    function rectSubPixelOpt(_ref, borderWidth) {
      var _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y,
          width = _ref.width,
          height = _ref.height;

      if (borderWidth === void 0) {
        borderWidth = 1;
      }

      var result = {};
      result.x = lineSubPixelOpt(x, borderWidth);
      result.y = lineSubPixelOpt(y, borderWidth);
      result.width = Math.round(width);
      result.height = Math.round(height);
      return result;
    }
    var det = 5; //鼠标操作的误差范围

    function onTopBorder(bounds, pos) {
      return pos.y >= bounds.y && pos.y <= bounds.y + det;
    }
    function onBottomBorder(bounds, pos) {
      var y = bounds.y + bounds.height;
      return pos.y <= y && pos.y >= y - det;
    }
    function onLeftBorder(bounds, pos) {
      return pos.x >= bounds.x && pos.x <= bounds.x + det;
    }
    function onRightBorder(bounds, pos) {
      var x = bounds.x + bounds.width;
      return pos.x <= x && pos.x >= x - det;
    }
    function sideOfBounds(bounds, pos) {
      if (pos.y < bounds.y) {
        return 'top';
      }

      if (pos.y > bounds.y + bounds.height) {
        return 'bottom';
      }

      if (pos.x < bounds.x) {
        return 'left';
      }

      if (pos.x > bounds.x + bounds.width) {
        return 'right';
      }
    }
    var boundsOfDiagonalPoints = function boundsOfDiagonalPoints(p0, p1) {
      return {
        x: Math.min(p0.x, p1.x),
        y: Math.min(p0.y, p1.y),
        width: Math.abs(p0.x - p1.x),
        height: Math.abs(p0.y - p1.y)
      };
    };
    var clipBounds = function clipBounds(bounds, position, size) {
      switch (position) {
        case Direction.TOP:
          bounds.y += size;
          bounds.height -= size;
          break;

        case Direction.BOTTOM:
          bounds.height -= size;
          break;

        case Direction.LEFT:
          bounds.x += size;
          bounds.width -= size;
          break;

        case Direction.RIGHT:
          bounds.width -= size;
          break;
      }
    };
    var getEdgeChecker = function getEdgeChecker(bounds, det) {
      if (det === void 0) {
        det = 1;
      }

      var x = bounds.x,
          y = bounds.y,
          width = bounds.width,
          height = bounds.height;

      var onEdge = function onEdge(ps1, ps2) {
        return Math.abs(ps1 - ps2) <= det;
      };

      return {
        onTopEdge: function onTopEdge(pos) {
          return onEdge(pos, y);
        },
        onRightEdge: function onRightEdge(pos) {
          return onEdge(pos, x + width);
        },
        onBottomEdge: function onBottomEdge(pos) {
          return onEdge(pos, y + height);
        },
        onLeftEdge: function onLeftEdge(pos) {
          return onEdge(pos, x);
        }
      };
    };

    function ascending$1 (a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector (compare) {
      if (compare.length === 1) compare = ascendingComparator(compare);
      return {
        left: function left(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;

          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
          }

          return lo;
        },
        right: function right(a, x, lo, hi) {
          if (lo == null) lo = 0;
          if (hi == null) hi = a.length;

          while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
          }

          return lo;
        }
      };
    }

    function ascendingComparator(f) {
      return function (d, x) {
        return ascending$1(f(d), x);
      };
    }

    var ascendingBisect = bisector(ascending$1);
    var bisectRight = ascendingBisect.right;

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);
    function ticks (start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;
      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        start = Math.ceil(start / step);
        stop = Math.floor(stop / step);
        ticks = new Array(n = Math.ceil(stop - start + 1));

        while (++i < n) {
          ticks[i] = (start + i) * step;
        }
      } else {
        start = Math.floor(start * step);
        stop = Math.ceil(stop * step);
        ticks = new Array(n = Math.ceil(start - stop + 1));

        while (++i < n) {
          ticks[i] = (start - i) / step;
        }
      }

      if (reverse) ticks.reverse();
      return ticks;
    }
    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }
    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    var prefix = "$";

    function Map$1() {}

    Map$1.prototype = map$3.prototype = {
      constructor: Map$1,
      has: function has(key) {
        return prefix + key in this;
      },
      get: function get(key) {
        return this[prefix + key];
      },
      set: function set(key, value) {
        this[prefix + key] = value;
        return this;
      },
      remove: function remove(key) {
        var property = prefix + key;
        return property in this && delete this[property];
      },
      clear: function clear() {
        for (var property in this) {
          if (property[0] === prefix) delete this[property];
        }
      },
      keys: function keys() {
        var keys = [];

        for (var property in this) {
          if (property[0] === prefix) keys.push(property.slice(1));
        }

        return keys;
      },
      values: function values() {
        var values = [];

        for (var property in this) {
          if (property[0] === prefix) values.push(this[property]);
        }

        return values;
      },
      entries: function entries() {
        var entries = [];

        for (var property in this) {
          if (property[0] === prefix) entries.push({
            key: property.slice(1),
            value: this[property]
          });
        }

        return entries;
      },
      size: function size() {
        var size = 0;

        for (var property in this) {
          if (property[0] === prefix) ++size;
        }

        return size;
      },
      empty: function empty() {
        for (var property in this) {
          if (property[0] === prefix) return false;
        }

        return true;
      },
      each: function each(f) {
        for (var property in this) {
          if (property[0] === prefix) f(this[property], property.slice(1), this);
        }
      }
    };

    function map$3(object, f) {
      var map = new Map$1(); // Copy constructor.

      if (object instanceof Map$1) object.each(function (value, key) {
        map.set(key, value);
      }); // Index array by numeric index or specified key function.
      else if (Array.isArray(object)) {
          var i = -1,
              n = object.length,
              o;
          if (f == null) while (++i < n) {
            map.set(i, object[i]);
          } else while (++i < n) {
            map.set(f(o = object[i], i, object), o);
          }
        } // Convert object to map.
        else if (object) for (var key in object) {
            map.set(key, object[key]);
          }
      return map;
    }

    function Set() {}

    var proto = map$3.prototype;
    Set.prototype = set$2.prototype = {
      constructor: Set,
      has: proto.has,
      add: function add(value) {
        value += "";
        this[prefix + value] = value;
        return this;
      },
      remove: proto.remove,
      clear: proto.clear,
      values: proto.keys,
      size: proto.size,
      empty: proto.empty,
      each: proto.each
    };

    function set$2(object, f) {
      var set = new Set(); // Copy constructor.

      if (object instanceof Set) object.each(function (value) {
        set.add(value);
      }); // Otherwise, assume it’s an array.
      else if (object) {
          var i = -1,
              n = object.length;
          if (f == null) while (++i < n) {
            set.add(object[i]);
          } else while (++i < n) {
            set.add(f(object[i], i, object));
          }
        }
      return set;
    }

    var array$2 = Array.prototype;
    var map$4 = array$2.map;
    var slice$4 = array$2.slice;

    var implicit = {
      name: "implicit"
    };
    function ordinal(range) {
      var index = map$3(),
          domain = [],
          unknown = implicit;
      range = range == null ? [] : slice$4.call(range);

      function scale(d) {
        var key = d + "",
            i = index.get(key);

        if (!i) {
          if (unknown !== implicit) return unknown;
          index.set(key, i = domain.push(d));
        }

        return range[(i - 1) % range.length];
      }

      scale.domain = function (_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = map$3();
        var i = -1,
            n = _.length,
            d,
            key;

        while (++i < n) {
          if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
        }

        return scale;
      };

      scale.range = function (_) {
        return arguments.length ? (range = slice$4.call(_), scale) : range.slice();
      };

      scale.unknown = function (_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function () {
        return ordinal().domain(domain).range(range).unknown(unknown);
      };

      return scale;
    }

    function constant$3 (x) {
      return function () {
        return x;
      };
    }

    function number$1 (x) {
      return +x;
    }

    var unit = [0, 1];
    function deinterpolateLinear(a, b) {
      return (b -= a = +a) ? function (x) {
        return (x - a) / b;
      } : constant$3(b);
    }

    function deinterpolateClamp(deinterpolate) {
      return function (a, b) {
        var d = deinterpolate(a = +a, b = +b);
        return function (x) {
          return x <= a ? 0 : x >= b ? 1 : d(x);
        };
      };
    }

    function reinterpolateClamp(reinterpolate$$1) {
      return function (a, b) {
        var r = reinterpolate$$1(a = +a, b = +b);
        return function (t) {
          return t <= 0 ? a : t >= 1 ? b : r(t);
        };
      };
    }

    function bimap(domain, range$$1, deinterpolate, reinterpolate$$1) {
      var d0 = domain[0],
          d1 = domain[1],
          r0 = range$$1[0],
          r1 = range$$1[1];
      if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate$$1(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate$$1(r0, r1);
      return function (x) {
        return r0(d0(x));
      };
    }

    function polymap(domain, range$$1, deinterpolate, reinterpolate$$1) {
      var j = Math.min(domain.length, range$$1.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1; // Reverse descending domains.

      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range$$1 = range$$1.slice().reverse();
      }

      while (++i < j) {
        d[i] = deinterpolate(domain[i], domain[i + 1]);
        r[i] = reinterpolate$$1(range$$1[i], range$$1[i + 1]);
      }

      return function (x) {
        var i = bisectRight(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$2(source, target) {
      return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
    } // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].

    function continuous(deinterpolate, reinterpolate$$1) {
      var domain = unit,
          range$$1 = unit,
          interpolate$$1 = interpolateValue,
          clamp = false,
          piecewise,
          output,
          input;

      function rescale() {
        piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
      }

      scale.invert = function (y) {
        return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate$$1) : reinterpolate$$1)))(+y);
      };

      scale.domain = function (_) {
        return arguments.length ? (domain = map$4.call(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function (_) {
        return arguments.length ? (range$$1 = slice$4.call(_), rescale()) : range$$1.slice();
      };

      scale.rangeRound = function (_) {
        return range$$1 = slice$4.call(_), interpolate$$1 = interpolateRound, rescale();
      };

      scale.clamp = function (_) {
        return arguments.length ? (clamp = !!_, rescale()) : clamp;
      };

      scale.interpolate = function (_) {
        return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
      };

      return rescale();
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimal(1.23) returns ["123", 0].
    function formatDecimal (x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity

      var i,
          coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

      return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
    }

    function exponent (x) {
      return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup (grouping, thousands) {
      return function (value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals (numerals) {
      return function (value) {
        return value.replace(/[0-9]/g, function (i) {
          return numerals[+i];
        });
      };
    }

    function formatDefault (x, p) {
      x = x.toPrecision(p);

      out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (x[i]) {
          case ".":
            i0 = i1 = i;
            break;

          case "0":
            if (i0 === 0) i0 = i;
            i1 = i;
            break;

          case "e":
            break out;

          default:
            if (i0 > 0) i0 = 0;
            break;
        }
      }

      return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
    }

    var prefixExponent;
    function formatPrefixAuto (x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded (x, p) {
      var d = formatDecimal(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "": formatDefault,
      "%": function _(x, p) {
        return (x * 100).toFixed(p);
      },
      "b": function b(x) {
        return Math.round(x).toString(2);
      },
      "c": function c(x) {
        return x + "";
      },
      "d": function d(x) {
        return Math.round(x).toString(10);
      },
      "e": function e(x, p) {
        return x.toExponential(p);
      },
      "f": function f(x, p) {
        return x.toFixed(p);
      },
      "g": function g(x, p) {
        return x.toPrecision(p);
      },
      "o": function o(x) {
        return Math.round(x).toString(8);
      },
      "p": function p(x, _p) {
        return formatRounded(x * 100, _p);
      },
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": function X(x) {
        return Math.round(x).toString(16).toUpperCase();
      },
      "x": function x(_x) {
        return Math.round(_x).toString(16);
      }
    };

    var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
      return new FormatSpecifier(specifier);
    }
    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match,
          fill = match[1] || " ",
          align = match[2] || ">",
          sign = match[3] || "-",
          symbol = match[4] || "",
          zero = !!match[5],
          width = match[6] && +match[6],
          comma = !!match[7],
          precision = match[8] && +match[8].slice(1),
          type = match[9] || ""; // The "n" type is an alias for ",g".

      if (type === "n") comma = true, type = "g"; // Map invalid types to the default format.
      else if (!formatTypes[type]) type = ""; // If zero fill is specified, padding goes after sign and before digits.

      if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
      this.fill = fill;
      this.align = align;
      this.sign = sign;
      this.symbol = symbol;
      this.zero = zero;
      this.width = width;
      this.comma = comma;
      this.precision = precision;
      this.type = type;
    }

    FormatSpecifier.prototype.toString = function () {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
    };

    function identity$4 (x) {
      return x;
    }

    var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale (locale) {
      var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$4,
          currency = locale.currency,
          decimal = locale.decimal,
          numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$4,
          percent = locale.percent || "%";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);
        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            type = specifier.type; // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.

        var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : ""; // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?

        var formatType = formatTypes[type],
            maybeSuffix = !type || /[defgprs%]/.test(type); // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].

        precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i,
              n,
              c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value; // Perform the initial formatting.

            var valueNegative = value < 0;
            value = formatType(Math.abs(value), precision); // If a negative value rounds to zero during formatting, treat as positive.

            if (valueNegative && +value === 0) valueNegative = false; // Compute the prefix and suffix.

            valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.

            if (maybeSuffix) {
              i = -1, n = value.length;

              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          } // If the fill character is not "0", grouping is applied before padding.


          if (comma && !zero) value = group(value, Infinity); // Compute the padding.

          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

          switch (align) {
            case "<":
              value = valuePrefix + value + valueSuffix + padding;
              break;

            case "=":
              value = valuePrefix + padding + value + valueSuffix;
              break;

            case "^":
              value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
              break;

            default:
              value = padding + valuePrefix + value + valueSuffix;
              break;
          }

          return numerals(value);
        }

        format.toString = function () {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function (value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale;
    var format;
    var formatPrefix;
    defaultLocale({
      decimal: ".",
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }

    function precisionFixed (step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix (step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound (step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat (domain, count, specifier) {
      var start = domain[0],
          stop = domain[domain.length - 1],
          step = tickStep(start, stop, count == null ? 10 : count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);

      switch (specifier.type) {
        case "s":
          {
            var value = Math.max(Math.abs(start), Math.abs(stop));
            if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
            return formatPrefix(specifier, value);
          }

        case "":
        case "e":
        case "g":
        case "p":
        case "r":
          {
            if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
            break;
          }

        case "f":
        case "%":
          {
            if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
            break;
          }
      }

      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function (count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function (count, specifier) {
        return tickFormat(domain(), count, specifier);
      };

      scale.nice = function (count) {
        if (count == null) count = 10;
        var d = domain(),
            i0 = 0,
            i1 = d.length - 1,
            start = d[i0],
            stop = d[i1],
            step;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }

        step = tickIncrement(start, stop, count);

        if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
          step = tickIncrement(start, stop, count);
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
          step = tickIncrement(start, stop, count);
        }

        if (step > 0) {
          d[i0] = Math.floor(start / step) * step;
          d[i1] = Math.ceil(stop / step) * step;
          domain(d);
        } else if (step < 0) {
          d[i0] = Math.ceil(start * step) / step;
          d[i1] = Math.floor(stop * step) / step;
          domain(d);
        }

        return scale;
      };

      return scale;
    }
    function linear$2() {
      var scale = continuous(deinterpolateLinear, reinterpolate);

      scale.copy = function () {
        return copy$2(scale, linear$2());
      };

      return linearish(scale);
    }

    function nice (domain, interval) {
      domain = domain.slice();
      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function deinterpolate(a, b) {
      return (b = Math.log(b / a)) ? function (x) {
        return Math.log(x / a) / b;
      } : constant$3(b);
    }

    function reinterpolate$1(a, b) {
      return a < 0 ? function (t) {
        return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
      } : function (t) {
        return Math.pow(b, t) * Math.pow(a, 1 - t);
      };
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
        return Math.pow(base, x);
      };
    }

    function logp(base) {
      return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
        return Math.log(x) / base;
      });
    }

    function reflect(f) {
      return function (x) {
        return -f(-x);
      };
    }

    function log$2() {
      var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),
          domain = scale.domain,
          base = 10,
          logs = logp(10),
          pows = powp(10);

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
        return scale;
      }

      scale.base = function (_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function (_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = function (count) {
        var d = domain(),
            u = d[0],
            v = d[d.length - 1],
            r;
        if (r = v < u) i = u, u = v, v = i;
        var i = logs(u),
            j = logs(v),
            p,
            k,
            t,
            n = count == null ? 10 : +count,
            z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.round(i) - 1, j = Math.round(j) + 1;
          if (u > 0) for (; i < j; ++i) {
            for (k = 1, p = pows(i); k < base; ++k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i < j; ++i) {
            for (k = base - 1, p = pows(i); k >= 1; --k) {
              t = p * k;
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }

        return r ? z.reverse() : z;
      };

      scale.tickFormat = function (count, specifier) {
        if (specifier == null) specifier = base === 10 ? ".0e" : ",";
        if (typeof specifier !== "function") specifier = format(specifier);
        if (count === Infinity) return specifier;
        if (count == null) count = 10;
        var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?

        return function (d) {
          var i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = function () {
        return domain(nice(domain(), {
          floor: function floor(x) {
            return pows(Math.floor(logs(x)));
          },
          ceil: function ceil(x) {
            return pows(Math.ceil(logs(x)));
          }
        }));
      };

      scale.copy = function () {
        return copy$2(scale, log$2().base(base));
      };

      return scale;
    }

    var t0$1 = new Date(),
        t1$1 = new Date();
    function newInterval(floori, offseti, count, field) {
      function interval(date) {
        return floori(date = new Date(+date)), date;
      }

      interval.floor = interval;

      interval.ceil = function (date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function (date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function (date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function (start, stop, step) {
        var range = [],
            previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

        do {
          range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        } while (previous < start && start < stop);

        return range;
      };

      interval.filter = function (test) {
        return newInterval(function (date) {
          if (date >= date) while (floori(date), !test(date)) {
            date.setTime(date - 1);
          }
        }, function (date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

            }
          }
        });
      };

      if (count) {
        interval.count = function (start, end) {
          t0$1.setTime(+start), t1$1.setTime(+end);
          floori(t0$1), floori(t1$1);
          return Math.floor(count(t0$1, t1$1));
        };

        interval.every = function (step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
            return field(d) % step === 0;
          } : function (d) {
            return interval.count(0, d) % step === 0;
          });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function () {// noop
    }, function (date, step) {
      date.setTime(+date + step);
    }, function (start, end) {
      return end - start;
    }); // An optimized implementation for this simple case.

    millisecond.every = function (k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function (date) {
        date.setTime(Math.floor(date / k) * k);
      }, function (date, step) {
        date.setTime(+date + step * k);
      }, function (start, end) {
        return (end - start) / k;
      });
    };
    var milliseconds = millisecond.range;

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    var second = newInterval(function (date) {
      date.setTime(Math.floor(date / durationSecond) * durationSecond);
    }, function (date, step) {
      date.setTime(+date + step * durationSecond);
    }, function (start, end) {
      return (end - start) / durationSecond;
    }, function (date) {
      return date.getUTCSeconds();
    });
    var seconds = second.range;

    var minute = newInterval(function (date) {
      date.setTime(Math.floor(date / durationMinute) * durationMinute);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getMinutes();
    });
    var minutes = minute.range;

    var hour = newInterval(function (date) {
      var offset = date.getTimezoneOffset() * durationMinute % durationHour;
      if (offset < 0) offset += durationHour;
      date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getHours();
    });
    var hours = hour.range;

    var day = newInterval(function (date) {
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setDate(date.getDate() + step);
    }, function (start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function (date) {
      return date.getDate() - 1;
    });
    var days = day.range;

    function weekday(i) {
      return newInterval(function (date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);
    var sundays = sunday.range;
    var mondays = monday.range;
    var thursdays = thursday.range;

    var month = newInterval(function (date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setMonth(date.getMonth() + step);
    }, function (start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
      return date.getMonth();
    });
    var months = month.range;

    var year = newInterval(function (date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function (date) {
      return date.getFullYear();
    }); // An optimized implementation for this simple case.

    year.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };
    var years = year.range;

    var utcMinute = newInterval(function (date) {
      date.setUTCSeconds(0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationMinute);
    }, function (start, end) {
      return (end - start) / durationMinute;
    }, function (date) {
      return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function (date) {
      date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
      date.setTime(+date + step * durationHour);
    }, function (start, end) {
      return (end - start) / durationHour;
    }, function (date) {
      return date.getUTCHours();
    });
    var utcHours = utcHour.range;

    var utcDay = newInterval(function (date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
      return (end - start) / durationDay;
    }, function (date) {
      return date.getUTCDate() - 1;
    });
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function (date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function (start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);
    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcThursdays = utcThursday.range;

    var utcMonth = newInterval(function (date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
      return date.getUTCMonth();
    });
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function (date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
      return date.getUTCFullYear();
    }); // An optimized implementation for this simple case.

    utcYear.every = function (k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };
    var utcYears = utcYear.range;

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }

      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }

      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newYear(y) {
      return {
        y: y,
        m: 0,
        d: 1,
        H: 0,
        M: 0,
        S: 0,
        L: 0
      };
    }

    function formatLocale$1(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;
      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);
      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };
      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };
      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      }; // These recursive directive definitions must be deferred.

      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function (date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;
          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, newDate) {
        return function (string) {
          var d = newYear(1900),
              i = parseSpecifier(d, specifier, string += "", 0),
              week,
              day$$1;
          if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

          if ("Q" in d) return new Date(d.Q); // The am-pm flag is 0 for AM, and 1 for PM.

          if ("p" in d) d.H = d.H % 12 + d.p * 12; // Convert day-of-week and week-of-year to day-of-year.

          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;

            if ("Z" in d) {
              week = utcDate(newYear(d.y)), day$$1 = week.getUTCDay();
              week = day$$1 > 4 || day$$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = newDate(newYear(d.y)), day$$1 = week.getDay();
              week = day$$1 > 4 || day$$1 === 0 ? monday.ceil(week) : monday(week);
              week = day.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
          } // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.


          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          } // Otherwise, all fields are in local time.


          return newDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);

          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || (j = parse(d, string, j)) < 0) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      return {
        format: function format(specifier) {
          var f = newFormat(specifier += "", formats);

          f.toString = function () {
            return specifier;
          };

          return f;
        },
        parse: function parse(specifier) {
          var p = newParse(specifier += "", localDate);

          p.toString = function () {
            return specifier;
          };

          return p;
        },
        utcFormat: function utcFormat(specifier) {
          var f = newFormat(specifier += "", utcFormats);

          f.toString = function () {
            return specifier;
          };

          return f;
        },
        utcParse: function utcParse(specifier) {
          var p = newParse(specifier, utcDate);

          p.toString = function () {
            return specifier;
          };

          return p;
        }
      };
    }
    var pads = {
      "-": "",
      "_": " ",
      "0": "0"
    },
        numberRe = /^\s*\d+/,
        // note: ignores next directive
    percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      var map = {},
          i = -1,
          n = names.length;

      while (++i < n) {
        map[names[i].toLowerCase()] = i;
      }

      return map;
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0] * 1000, i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + day.count(year(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day$$1 = d.getDay();
      return day$$1 === 0 ? 7 : day$$1;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(year(d), d), p, 2);
    }

    function formatWeekNumberISO(d, p) {
      var day$$1 = d.getDay();
      d = day$$1 >= 4 || day$$1 === 0 ? thursday(d) : thursday.ceil(d);
      return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(year(d), d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear(d), d), p, 2);
    }

    function formatUTCWeekNumberISO(d, p) {
      var day$$1 = d.getUTCDay();
      d = day$$1 >= 4 || day$$1 === 0 ? utcThursday(d) : utcThursday.ceil(d);
      return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear(d), d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale$1;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;
    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      timeFormat = locale$1.format;
      timeParse = locale$1.parse;
      utcFormat = locale$1.utcFormat;
      utcParse = locale$1.utcParse;
      return locale$1;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

    function colors (s) {
      return s.match(/.{6}/g).map(function (x) {
        return "#" + x;
      });
    }

    colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

    colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

    colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

    cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
    var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));
    var rainbow = cubehelix();

    function ramp(range) {
      var n = range.length;
      return function (t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    /**
     * 获取值轴对应的Scale
     */

    var getAxisScale = function getAxisScale(facet, measureId, node) {
      var scaleMap = facet.scaleMap,
          horizontal = facet.horizontal;

      if (!scaleMap || !scaleMap[measureId]) {
        return;
      }

      var scaleDef = scaleMap[measureId];
      var logBase = scaleDef.logBase,
          reverse = scaleDef.reverse;

      var _ref = scaleDef.domain || [0, 100],
          min = _ref[0],
          max = _ref[1];

      var domain = horizontal ^ reverse ? [min, max] : [max, min];
      var _node$measurePosMap$m = node.measurePosMap[measureId],
          start = _node$measurePosMap$m[0],
          end = _node$measurePosMap$m[1];
      var range = [Math.min(start, end), Math.max(start, end)];
      return (logBase === 0 ? linear$2() : log$2().base(logBase)).domain(domain).range(range);
    };
    /**
     * distinguish baseFacet & geomFacet
     * @returns {{baseFacet: *, geomFacet: *}}
     */

    var diffFacet = function diffFacet() {
      var facetX, facetY;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (args.length === 1) {
        var _args$ = args[0];
        facetX = _args$.facetX;
        facetY = _args$.facetY;
      } else {
        facetX = args[0];
        facetY = args[1];
      }

      var xMeasureToGeom = facetX.measuresToGeoms;
      return {
        baseFacet: xMeasureToGeom ? facetY : facetX,
        geomFacet: xMeasureToGeom ? facetX : facetY,
        inverted: xMeasureToGeom
      };
    };

    var getSharedId = function getSharedId(row, dimensions) {
      return _.map(dimensions, function (id) {
        return row[id];
      }).join('*');
    };
    /**
     * 根据当前的选中的点所在的cell, 过滤出满足共享提示的分区
     * @param cell
     * @param cellMap
     * @param inverted
     * @returns {*}
     */


    var getSharedCells = function getSharedCells(cell, cellMap, inverted) {
      var indexKey = inverted ? 'yIndex' : 'xIndex',
          hoverIndex = cell[indexKey];
      return _.pick(cellMap, function (cell) {
        return cell[indexKey] === hoverIndex;
      });
    };
    /**
     * dimension -> {name, id, format}
     * @param dimensions
     * @param defs
     * @param baseFacetData
     */

    var getSharedDims = function getSharedDims(dimensions, defs, baseFacetData) {
      return _.map(dimensions, function (id) {
        return {
          id: id,
          name: baseFacetData.getFieldById(id).name,
          format: defs[id].format
        };
      });
    };
    /**
     * 获取共享数据点提示时对应的geoms和rowIds
     * @param row
     * @param dimensions
     * @param inverted
     * @param sharedCells
     * @param defs
     * @returns {{sharedGeoms, sharedRowIds}}
     */

    var getSharedTooltipInfo = function getSharedTooltipInfo(_ref) {
      var row = _ref.row,
          dimensions = _ref.dimensions,
          sharedCells = _ref.sharedCells,
          defs = _ref.defs;
      var tooltipId = getSharedId(row, dimensions);

      var getGeomMeasureFormat = function getGeomMeasureFormat(measureId) {
        return defs[measureId].format;
      };

      var sharedGeoms = {},
          sharedRowIds = {};

      _.each(sharedCells, function (cell) {
        _.each(cell.geoms, function (_ref2) {
          var geom = _ref2.geom,
              rows = _ref2.rows;
          var measure = geom.measure,
              data = geom.data;

          var _data$getFieldById = data.getFieldById(measure),
              name = _data$getFieldById.name;

          _.each(rows, function (row) {
            if (getSharedId(row, dimensions) === tooltipId) {
              // add to highlight
              sharedRowIds[row.id] = true; // init targetGeom

              if (!sharedGeoms[measure]) {
                sharedGeoms[measure] = {
                  name: name,
                  rows: [],
                  format: getGeomMeasureFormat(measure)
                };
              } // add row


              sharedGeoms[measure].rows.push(row);
            }
          });
        });
      });

      return {
        sharedGeoms: sharedGeoms,
        sharedRowIds: sharedRowIds
      };
    };
    var dealTooltipAndHighlights = function dealTooltipAndHighlights(id, state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          rowMap = state.rowMap,
          geoms = state.geoms,
          cellMap = state.cellMap,
          tooltipShared = state.tooltipShared,
          defs = state.defs;
      var row = rowMap[id],
          geom = geoms[row.geomIndex];
      var targets = {}; // 存储高亮的rowId

      var _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet,
          inverted = _diffFacet.inverted;

      var dimensions = baseFacet.dimensions,
          hasMeasure = baseFacet.hasMeasure,
          baseFacetData = baseFacet.data;
      var tooltip = {
        geom: geom,
        row: row,
        tooltipShared: tooltipShared
      };
      var highlightNode; // NOTE 开启共享且baseFacet上有且仅有维度字段，才去寻找共享数据点

      if (tooltipShared && dimensions.length && !hasMeasure) {
        highlightNode = getSharedId(row, dimensions);
        var currentCell = cellMap[row.cellId];
        var sharedCells = getSharedCells(currentCell, cellMap, inverted);

        var _getSharedTooltipInfo = getSharedTooltipInfo({
          row: row,
          sharedCells: sharedCells,
          dimensions: dimensions,
          defs: defs
        }),
            sharedGeoms = _getSharedTooltipInfo.sharedGeoms,
            sharedRowIds = _getSharedTooltipInfo.sharedRowIds;

        tooltip.geoms = sharedGeoms;
        tooltip.dims = getSharedDims(dimensions, defs, baseFacetData);

        _.extend(targets, sharedRowIds);
      } else {
        targets[id] = true;
      }

      return {
        tooltip: tooltip,
        targets: targets,
        highlightNode: highlightNode
      };
    };

    var clamp$1 = clamp;
    var VERTICAL = 'vertical';
     // TODO, DON'T export too many values here
    // case 1: paddings are all the same, export total thumb space
    // case 2: different, take padding/thickness as props.

    var THUMB_THICKNESS = 6;
    var THUMB_PADDING = 3;
    var MOBILE_THUMB_THICKNESS = 4;
    var THUMB_RADIUS = 3;
    var COLOR_BASE = '#3d4d66';
    var THUMB_COLOR = modifyAlpha(COLOR_BASE, 0.1),
        TRACK_COLOR = modifyAlpha(COLOR_BASE, 0.03),
        ON_THUMB_COLOR = modifyAlpha(COLOR_BASE, 0.3),
        ON_TRACK_COLOR = modifyAlpha(COLOR_BASE, 0.05);
    var DARK_COLOR_BASE = '#fff';
    var DARK_THUMB_COLOR = modifyAlpha(DARK_COLOR_BASE, 0.15),
        DARK_TRACK_COLOR = modifyAlpha(DARK_COLOR_BASE, 0.06),
        ON_DARK_THUMB_COLOR = modifyAlpha(DARK_COLOR_BASE, 0.3),
        ON_DARK_TRACK_COLOR = modifyAlpha(DARK_COLOR_BASE, 0.1);
    var MIN_THUMB_LENGTH = 20;

    var ScrollBar =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(ScrollBar, _Component);

      function ScrollBar(props) {
        var _this;

        _this = _Component.call(this, props) || this; // only visible or not;
        // no hover on/off

        var isDefaultOn = !!props.touch;
        _this.state = {
          trackOn: isDefaultOn,
          thumbOn: isDefaultOn,
          panning: false
        };
        _this.startPos = {};
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = ScrollBar.prototype;

      _proto.onTrackMouseOver = function onTrackMouseOver() {
        this.setState({
          trackOn: true,
          thumbOn: true
        });
      };

      _proto.onTrackMouseOut = function onTrackMouseOut() {
        this.setState({
          trackOn: false,
          thumbOn: false
        });
      };

      _proto.onThumbMouseOver = function onThumbMouseOver(e) {
        this.setState({
          trackOn: true,
          thumbOn: true
        });
      };

      _proto.onThumbMouseOut = function onThumbMouseOut() {
        this.setState({
          trackOn: false,
          thumbOn: false
        });
      };

      _proto.onThumbPanStart = function onThumbPanStart(e) {
        var _this$props = this.props,
            onThumbPanStart = _this$props.onThumbPanStart,
            pct = _this$props.pct;
        this.startPos = {
          x: e.offsetX,
          y: e.offsetY,
          pct: pct
        };
        this.setState({
          panning: true
        });
        onThumbPanStart && onThumbPanStart();
        return true;
      };

      _proto.onThumbPan = function onThumbPan(e) {
        var _this$props2 = this.props,
            _this$props2$directio = _this$props2.direction,
            direction = _this$props2$directio === void 0 ? VERTICAL : _this$props2$directio,
            onThumbPan = _this$props2.onThumbPan,
            length = _this$props2.length,
            scrollLength = _this$props2.scrollLength;
        if (!onThumbPan) return;
        var _this$startPos = this.startPos,
            x = _this$startPos.x,
            y = _this$startPos.y,
            pct = _this$startPos.pct;
        var d = direction === VERTICAL ? e.offsetY - y : e.offsetX - x;
        var nextPct = clamp$1(pct + d / getThumbMovableLength(length, scrollLength), 0, 1);
        onThumbPan(nextPct);
        return true;
      };

      _proto.onThumbPanEnd = function onThumbPanEnd() {
        var onThumbPanEnd = this.props.onThumbPanEnd;
        this.setState({
          panning: false
        });
        onThumbPanEnd && onThumbPanEnd();
        return true;
      };

      _proto.render = function render$$1() {
        var _this$props3 = this.props,
            touch = _this$props3.touch,
            _this$props3$directio = _this$props3.direction,
            direction = _this$props3$directio === void 0 ? VERTICAL : _this$props3$directio,
            _this$props3$x = _this$props3.x,
            x = _this$props3$x === void 0 ? 0 : _this$props3$x,
            _this$props3$y = _this$props3.y,
            y = _this$props3$y === void 0 ? 0 : _this$props3$y,
            _this$props3$length = _this$props3.length,
            length = _this$props3$length === void 0 ? 0 : _this$props3$length,
            _this$props3$scrollLe = _this$props3.scrollLength,
            scrollLength = _this$props3$scrollLe === void 0 ? 0 : _this$props3$scrollLe,
            _this$props3$pct = _this$props3.pct,
            pct = _this$props3$pct === void 0 ? 0 : _this$props3$pct,
            darkTheme = _this$props3.darkTheme;
        var _this$state = this.state,
            trackOn = _this$state.trackOn,
            thumbOn = _this$state.thumbOn,
            panning = _this$state.panning;
        var silent = !!touch;
        var visible = this.props.visible; // todo, merge store defaults

        if (!touch) {
          // visible when default or panning
          visible = visible == null ? true : visible || panning;
        }

        var isVertical = direction === VERTICAL,
            thumbLength = getThumbLength(length, scrollLength),
            thumbPos = getThumbPosByPct(length, scrollLength, pct);
        var trackFill = trackOn ? ON_TRACK_COLOR : TRACK_COLOR,
            thumbFill = thumbOn ? ON_THUMB_COLOR : THUMB_COLOR;

        if (darkTheme) {
          trackFill = trackOn ? ON_DARK_TRACK_COLOR : DARK_TRACK_COLOR;
          thumbFill = thumbOn ? ON_DARK_THUMB_COLOR : DARK_THUMB_COLOR;
        }

        var thumbThickness = touch ? MOBILE_THUMB_THICKNESS : THUMB_THICKNESS;
        return h('group', {
          silent: silent
        }, // track
        !touch && h('rect', {
          invisible: !visible,
          zlevel: StaticLayerZ,
          cursor: null,
          shape: {
            x: x,
            y: y,
            width: isVertical ? thumbThickness : length,
            height: isVertical ? length : thumbThickness,
            r: THUMB_RADIUS
          },
          style: {
            fill: trackFill
          },
          onmouseover: this.onTrackMouseOver,
          onmouseout: this.onTrackMouseOut
        }), // thumb
        h('rect', {
          invisible: !visible,
          zlevel: StaticLayerZ,
          pannable: true,
          shape: {
            x: isVertical ? x : thumbPos,
            y: isVertical ? thumbPos : y,
            width: isVertical ? thumbThickness : thumbLength,
            height: isVertical ? thumbLength : thumbThickness,
            r: THUMB_RADIUS
          },
          style: {
            fill: thumbFill
          },
          onmouseover: this.onThumbMouseOver,
          onmouseout: this.onThumbMouseOut,
          onpanstart: this.onThumbPanStart,
          onpan: this.onThumbPan,
          onpanend: this.onThumbPanEnd
        }));
      };

      return ScrollBar;
    }(Component);
    /**
     * calc thumb length, min = 20
     * @param length
     * @param scrollLength
     * @returns {number}
     */

    function getThumbLength(length, scrollLength) {
      var l = length / scrollLength * length;
      return Math.max(l, MIN_THUMB_LENGTH);
    }
    /**
     * length that thumb can drag
     * @param length
     * @param scrollLength
     * @returns {number}
     */

    function getThumbMovableLength(length, scrollLength) {
      return length - getThumbLength(length, scrollLength);
    }
    /**
     * get thumb's position according to percent
     * @param length
     * @param scrollLength
     * @param pct
     * @returns {number}
     */

    function getThumbPosByPct(length, scrollLength, pct) {
      return getThumbMovableLength(length, scrollLength) * clamp$1(pct, 0, 1);
    }

    /**
     * Created by Jeffrey on 2018/1/8.
     */
    var PIXEL_STEP = 15;
    function normalizeWheel(e) {
      e.vanDeltaY = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;

      if (e.wheelDeltaY) {
        e.vanDeltaY = e.wheelDeltaY / 120;
      }

      e.vanDeltaX = 0;

      if (e.wheelDeltaX) {
        e.vanDeltaX = e.wheelDeltaX / 120;
      }

      e.vanDeltaY *= PIXEL_STEP;
      e.vanDeltaX *= PIXEL_STEP;
      return e;
    }

    var BORDER_WIDTH = 1;
    var needScroll = function needScroll(length, scrollLength) {
      return length < scrollLength;
    };
    var getOffsetByPct = function getOffsetByPct(length, scrollLength, pct) {
      var v = (length - scrollLength) * pct || 0;

      if (isFinite(v)) {
        return v;
      }

      return 0;
    };
    var getPctByOffset = function getPctByOffset(length, scrollLength, offset) {
      var v = offset / (length - scrollLength) || 0;

      if (isFinite(v)) {
        return v;
      }

      return 0;
    };

    var Background =
    /*#__PURE__*/
    function (_PureComponent) {
      _inheritsLoose(Background, _PureComponent);

      function Background() {
        return _PureComponent.apply(this, arguments) || this;
      }

      var _proto = Background.prototype;

      _proto.render = function render$$1() {
        var shape = rectSubPixelOpt(this.props);
        var _this$props = this.props,
            background = _this$props.background,
            borderColor = _this$props.borderColor;
        return h('rect', {
          cursor: null,
          // @CHART-9065, 第一个版本的滚动条改的bug, 已经不需要了
          // z: -1, // under axis
          shape: shape,
          style: {
            fill: background || 'transparent',
            stroke: borderColor || 'transparent'
          }
        });
      };

      return Background;
    }(PureComponent$$1);

    var ControlledScrollArea = function ControlledScrollArea(_ref) {
      var touch = _ref.touch,
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y,
          width = _ref.width,
          height = _ref.height,
          scrollWidth = _ref.scrollWidth,
          scrollHeight = _ref.scrollHeight,
          thumbOffsetX = _ref.thumbOffsetX,
          thumbOffsetY = _ref.thumbOffsetY,
          pctX = _ref.pctX,
          pctY = _ref.pctY,
          offsetX = _ref.offsetX,
          offsetY = _ref.offsetY,
          visible = _ref.visible,
          handleThumbPanY = _ref.handleThumbPanY,
          handleThumbPanX = _ref.handleThumbPanX,
          handleEnter = _ref.handleEnter,
          handleLeave = _ref.handleLeave,
          handleMousewheel = _ref.handleMousewheel,
          handleTouchStart = _ref.handleTouchStart,
          handleTouchMove = _ref.handleTouchMove,
          handleTouchEnd = _ref.handleTouchEnd,
          handlePanStart = _ref.handlePanStart,
          handlePan = _ref.handlePan,
          handlePanEnd = _ref.handlePanEnd,
          handleTap = _ref.handleTap,
          handleLongTap = _ref.handleLongTap,
          handlePinch = _ref.handlePinch,
          handleMultipointStart = _ref.handleMultipointStart,
          handleMultipointEnd = _ref.handleMultipointEnd,
          children = _ref.children,
          darkTheme = _ref.darkTheme,
          borderColor = _ref.borderColor,
          background = _ref.background;
      // todo, simple group case needs refresh test
      scrollWidth = Math.max(width, scrollWidth || 0);
      scrollHeight = Math.max(height, scrollHeight || 0);
      var needScrollX = needScroll(width, scrollWidth);
      var needScrollY = needScroll(height, scrollHeight);
      offsetX = offsetX == null ? getOffsetByPct(width, scrollWidth, pctX) : offsetX;
      offsetY = offsetY == null ? getOffsetByPct(height, scrollHeight, pctY) : offsetY;
      pctX = pctX == null ? getPctByOffset(width, scrollWidth, offsetX) : pctX;
      pctY = pctY == null ? getPctByOffset(height, scrollHeight, offsetY) : pctY;
      var thumbThickness = THUMB_THICKNESS;
      var barHeight = height,
          barWidth = width; // 如果有thumbOffset，则不处理冲突；否则默认处理冲突
      // 现在只有touch时候有2个thumb冲突

      if (thumbOffsetX == null && thumbOffsetY == null && needScrollX && needScrollY) {
        barHeight -= thumbThickness;
        barWidth -= thumbThickness;
      }

      thumbOffsetX = thumbOffsetX == null ? -thumbThickness : thumbOffsetX;
      thumbOffsetY = thumbOffsetY == null ? -thumbThickness : thumbOffsetY; // 考虑border不被内部nodes遮住

      var clipY = -offsetY,
          clipHeight = height;

      if (borderColor !== 'transparent') {
        clipY += BORDER_WIDTH;
        clipHeight -= BORDER_WIDTH;
      } // move wrapper to scroll


      var wrapper = h('group', {
        // pure: true,
        clip: {
          type: 'rect',
          shape: {
            x: -offsetX,
            y: clipY,
            width: width,
            height: clipHeight
          }
        },
        position: [offsetX, offsetY]
      }, children);
      return h('group', {
        // pure: true,  // pure will cause position not update
        position: [x, y],
        // outer leftTop
        onmousewheel: handleMousewheel,
        onmouseover: handleEnter,
        onmouseout: handleLeave,
        ontouchstart: handleTouchStart,
        ontouchmove: handleTouchMove,
        ontouchend: handleTouchEnd,
        onpanstart: handlePanStart,
        onpan: handlePan,
        onpanend: handlePanEnd,
        ontap: handleTap,
        onpinch: handlePinch,
        onmultipointstart: handleMultipointStart,
        onmultipointend: handleMultipointEnd,
        onlongtap: handleLongTap
      }, h(Background, {
        width: width,
        height: height,
        background: background,
        borderColor: borderColor
      }), // main area
      wrapper, needScrollX && h(ScrollBar, {
        touch: touch,
        direction: 'horizontal',
        x: 0,
        y: height + thumbOffsetY,
        length: barWidth,
        scrollLength: scrollWidth,
        pct: pctX,
        visible: visible,
        onThumbPan: handleThumbPanX,
        darkTheme: darkTheme
      }), needScrollY && h(ScrollBar, {
        touch: touch,
        direction: 'vertical',
        x: width + thumbOffsetX,
        y: 0,
        length: barHeight,
        scrollLength: scrollHeight,
        pct: pctY,
        visible: visible,
        onThumbPan: handleThumbPanY,
        darkTheme: darkTheme
      }));
    };

    var ScrollArea =
    /*#__PURE__*/
    function (_PureComponent2) {
      _inheritsLoose(ScrollArea, _PureComponent2);

      function ScrollArea(props) {
        var _this;

        _this = _PureComponent2.call(this, props) || this;
        _this.state = {
          visible: false,
          pctX: 0,
          pctY: 0
        };
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto2 = ScrollArea.prototype;

      _proto2.onHover = function onHover(enterOrLeave) {
        this.setState({
          visible: enterOrLeave
        });
      };

      _proto2.onEnter = function onEnter() {
        this.onHover(true);
      };

      _proto2.onLeave = function onLeave() {
        this.onHover(false);
      };

      _proto2.onMove = function onMove(e, d) {
        var nextState = getPctsByDelta(d || e, _extends({}, this.props, this.state));

        if (this.state.pctX !== nextState.pctX || this.state.pctY !== nextState.pctY) {
          stop$2(e);
          this.setState(nextState);
        }
      };

      _proto2.onMousewheel = function onMousewheel(e) {
        stop$2(e);
        normalizeWheel(e.event);
        this.onMove(e.event, {
          deltaX: e.event.vanDeltaX,
          deltaY: e.event.vanDeltaY
        });
      };

      _proto2.onPanStart = function onPanStart(e) {
        var nextState = getPctsByDelta(e.event, _extends({}, this.props, this.state));
        nextState.visible = true;
        stop$2(e);
        this.setState(nextState);
      };

      _proto2.onPanMove = function onPanMove(e) {
        this.onMove(e.event);
      };

      _proto2.onPanEnd = function onPanEnd() {
        this.onHover(false);
      };

      _proto2.onThumbPanY = function onThumbPanY(pctY) {
        this.setState({
          pctY: pctY
        });
      };

      _proto2.onThumbPanX = function onThumbPanX(pctX) {
        this.setState({
          pctX: pctX
        });
      };

      _proto2.render = function render$$1(_ref2) {
        var touch = _ref2.touch;

        var scrollProps = _extends({}, this.props, this.state, {
          handleEnter: this.onEnter,
          handleLeave: this.onLeave,
          handleMousewheel: this.onMousewheel,
          handleThumbPanY: this.onThumbPanY,
          handleThumbPanX: this.onThumbPanX
        });

        if (touch) {
          scrollProps.handlePanStart = this.onPanStart;
          scrollProps.handlePan = this.onPanMove;
          scrollProps.handlePanEnd = this.onPanEnd;
        }

        return h(ControlledScrollArea, scrollProps);
      };

      return ScrollArea;
    }(PureComponent$$1);
    /**
     * @deprecated
     *
     * @param d
     * @param width
     * @param height
     * @param scrollWidth
     * @param scrollHeight
     * @param paddingLeft
     * @param paddingTop
     * @param paddingRight
     * @param paddingBottom
     * @param pctX
     * @param pctY
     * @returns {{rawPctX: *, rawPctY: *}}
     */


    var getPctsByDelta = function getPctsByDelta(d, _ref3) {
      var width = _ref3.width,
          height = _ref3.height,
          scrollWidth = _ref3.scrollWidth,
          scrollHeight = _ref3.scrollHeight,
          _ref3$paddingLeft = _ref3.paddingLeft,
          paddingLeft = _ref3$paddingLeft === void 0 ? 0 : _ref3$paddingLeft,
          _ref3$paddingTop = _ref3.paddingTop,
          paddingTop = _ref3$paddingTop === void 0 ? 0 : _ref3$paddingTop,
          _ref3$paddingRight = _ref3.paddingRight,
          paddingRight = _ref3$paddingRight === void 0 ? 0 : _ref3$paddingRight,
          _ref3$paddingBottom = _ref3.paddingBottom,
          paddingBottom = _ref3$paddingBottom === void 0 ? 0 : _ref3$paddingBottom,
          _ref3$pctX = _ref3.pctX,
          pctX = _ref3$pctX === void 0 ? 0 : _ref3$pctX,
          _ref3$pctY = _ref3.pctY,
          pctY = _ref3$pctY === void 0 ? 0 : _ref3$pctY;
      // todo, 拆分逻辑，2种：
      // 1. 是原始值，需要能够出界的原始值，判断边界情况
      // 2. 是处理渲染及优化的限制值
      var deltaX = d.deltaX,
          deltaY = d.deltaY;
      var innerWidth = width - paddingLeft - paddingRight;
      var innerHeight = height - paddingTop - paddingBottom;
      var nextPctX = pctX + getPctByOffset(innerWidth, scrollWidth, deltaX);
      var nextPctY = pctY + getPctByOffset(innerHeight, scrollHeight, deltaY);
      var nextState = {
        rawPctX: nextPctX,
        rawPctY: nextPctY
      };
      var xWithinBounds = true,
          yWithinBounds = true;

      if (scrollWidth > innerWidth) {
        if (nextPctX <= 0) {
          nextState.pctX = 0;
          nextState.horizontalEdge = 'left';
          xWithinBounds = false;
        } else if (nextPctX >= 1) {
          nextState.pctX = 1;
          nextState.horizontalEdge = 'right';
          xWithinBounds = false;
        } else {
          nextState.pctX = nextPctX;
        }
      }

      if (scrollHeight > innerHeight) {
        if (nextPctY <= 0) {
          nextState.pctY = 0;
          nextState.verticalEdge = 'top';
          yWithinBounds = false;
        } else if (nextPctY >= 1) {
          nextState.pctY = 1;
          nextState.verticalEdge = 'bottom';
          yWithinBounds = false;
        } else {
          // console.log(nextPctY, deltaY, pctY, getPctByOffset(width, scrollWidth, deltaY));
          nextState.pctY = nextPctY;
        }
      } // if (between(nextPctX, 0, 1) && pctX !== nextPctX) {
      //     nextState.pctX = nextPctX;
      // }
      // if (between(nextPctY, 0, 1) && pctY !== nextPctY) {
      //     nextState.pctY = nextPctY;
      // }


      nextState.withinBounds = xWithinBounds && yWithinBounds;
      return nextState;
    };
    ScrollArea.THUMB_THICKNESS = THUMB_THICKNESS;

    var getZRInstanceById = function getZRInstanceById(id, zr) {
      var list = zr.storage.getDisplayList();

      for (var i = 0, len = list.length; i < len; i++) {
        var ins = list[i];

        if (ins.id === id) {
          return ins;
        }
      }
    };

    function isBoundsOverlapped(aBounds, bBounds) {
      if (!aBounds || !bBounds) {
        return false;
      }

      var minx = Math.max(aBounds.x, bBounds.x);
      var miny = Math.max(aBounds.y, bBounds.y);
      var maxx = Math.min(aBounds.x + aBounds.width, bBounds.x + bBounds.width);
      var maxy = Math.min(aBounds.y + aBounds.height, bBounds.y + bBounds.height);
      return minx <= maxx && miny <= maxy;
    }
    function getBoundsCenter(bounds) {
      var x = bounds.x,
          y = bounds.y,
          width = bounds.width,
          height = bounds.height;
      return [x + width / 2, y + height / 2];
    }
    function setCenter(bounds, center) {
      var cx = center[0],
          cy = center[1],
          width = bounds.width,
          height = bounds.height;
      bounds.x = cx - width / 2;
      bounds.y = cy - height / 2;
    }

    var BoundsManager =
    /*#__PURE__*/
    function () {
      function BoundsManager() {
        this.boundsList = [];
      }

      var _proto = BoundsManager.prototype;

      _proto.addBounds = function addBounds(bounds) {
        this.boundsList.push(bounds);
      };

      _proto.isOverlapped = function isOverlapped(bounds) {
        for (var i = this.boundsList.length - 1; i >= 0; i--) {
          if (isBoundsOverlapped(bounds, this.boundsList[i])) {
            return true;
          }
        }

        return false;
      };

      _proto.isEmpty = function isEmpty() {
        return this.boundsList.length === 0;
      };

      return BoundsManager;
    }();

    var intersectInstance = function intersectInstance(type, instance, bounds) {
      if (!instance) {
        return false;
      }
      // return intersectFn(instance, bounds);


      var boundingRect = _extends({}, instance.getBoundingRect());

      var _instance$transform = instance.transform,
          sx = _instance$transform[0],
          sy = _instance$transform[3],
          tx = _instance$transform[4],
          ty = _instance$transform[5]; // apply matrix

      boundingRect.x = tx + boundingRect.x * sx;
      boundingRect.y = ty + boundingRect.y * sy;
      boundingRect.width *= sx;
      boundingRect.height *= sy;
      return isBoundsOverlapped(bounds, boundingRect);
    };

    var selectionFilter$$1 = function selectionFilter$$1(bounds, state, list) {
      var instanceMap = {};

      _.each(list, function (instance) {
        if (typeof instance.id === 'string') {
          instanceMap[instance.id] = instance;
        }
      });

      var scrollBounds = state.scrollBounds,
          cellMap = state.cellMap;
      var _x = scrollBounds.x,
          _y = scrollBounds.y;
      var selectCells = [];
      var x = bounds.x,
          y = bounds.y,
          width = bounds.width,
          height = bounds.height;
      var translateBounds = {
        x: x - _x,
        y: y - _y,
        width: width,
        height: height
      }; // 划分出选中的分区，缩小查找范围

      _.each(cellMap, function (cell) {
        if (isBoundsOverlapped(cell.bounds, translateBounds)) {
          selectCells.push(cell);
        }
      });

      var output = []; // 在选中的分区内再遍历rowInstance判断是否相交并记录

      _.each(selectCells, function (cell) {
        _.each(cell.geoms, function (_ref) {
          var rows = _ref.rows,
              geom = _ref.geom,
              frameMeasure = _ref.frameMeasure;
          var type = geom.type,
              measure = geom.measure;

          _.each(rows, function (row) {
            var instance = instanceMap[row.id];

            if (intersectInstance(type, instance, bounds)) {
              output.push({
                row: row,
                measure: measure,
                frameMeasure: frameMeasure
              });
            }
          });
        });
      });

      return output;
    };

    var filterFacetMeasures = function filterFacetMeasures(facet, filterMeasureMap) {
      var measures = facet.measures,
          measuresOverlapped = facet.measuresOverlapped;

      var filterMeasures = function filterMeasures(measures) {
        return _.filter(measures, function (id) {
          return filterMeasureMap[id];
        });
      };

      var newMeasures;

      if (measuresOverlapped) {
        var first = measures[0],
            second = measures[1];
        newMeasures = [filterMeasures(first), filterMeasures(second)];
      } else {
        newMeasures = filterMeasures(measures);
      }

      return _extends({}, facet, {
        measures: newMeasures
      });
    };

    // TODO: find from cell group element's children

    function findTarget(_ref, derived, zr) {
      var target = _ref.target,
          pos = _ref.pos;
      var plotBounds = derived.plotBounds;
      var x = clamp(pos.x, plotBounds.x, plotBounds.x + plotBounds.width);
      var y = clamp(pos.y, plotBounds.y, plotBounds.y + plotBounds.height);

      if (!target) {
        target = zr.handler.findHover(x, y, null).target;
      }

      if (typeof target.id === 'string') {
        return target;
      }

      var _derived$scrollBounds = derived.scrollBounds,
          sx = _derived$scrollBounds.x,
          sy = _derived$scrollBounds.y;
      var relativePos = {
        x: x - sx,
        y: y - sy
      };

      var cell = _.find(derived.cellMap, function (v) {
        return containsPoint(v.bounds, relativePos);
      });

      if (cell) {
        var idMap = {};
        cell.geoms.forEach(function (_ref2) {
          var rows = _ref2.rows;
          rows.forEach(function (row) {
            return idMap[row.id] = true;
          });
        });
        var instanceList = zr.storage.getDisplayList();
        var closestTarget = null;
        var lastDistance = Number.MAX_VALUE;

        for (var i = instanceList.length - 1; i >= 0; i--) {
          var _target = instanceList[i];

          if (!idMap[_target.id]) {
            continue;
          }

          var dist = 0;

          if (!_target.silent && typeof _target.id === 'string' && (dist = _target.centerDistSquare(x, y)) < lastDistance) {
            lastDistance = dist;
            closestTarget = _target;
          }
        }

        return closestTarget;
      }
    }

    var MEASURE_SCALE_MAX = 10;

    var hasMeasure = function hasMeasure(facet) {
      return facet.measures.length;
    }; // TODO, 可以不用倒推的


    var getZoomLimit = function getZoomLimit(state) {
      var scaled = state.zoom;
      var _state$plotBounds = state.plotBounds,
          width = _state$plotBounds.width,
          height = _state$plotBounds.height;
      var _state$scrollBounds = state.scrollBounds,
          scrollWidth = _state$scrollBounds.width,
          scrollHeight = _state$scrollBounds.height;
      var initScrollWidth = scrollWidth / scaled.x,
          initScrollHeight = scrollHeight / scaled.y; // min: no scroll

      var minScaleX = clamp(width / initScrollWidth, 0, 1),
          minScaleY = clamp(height / initScrollHeight, 0, 1);
      var initFacetXUnit = state.facetX.unit,
          initFacetYUnit = state.facetY.unit; // max: 10 times measure; or one dimension occupies view

      var maxScaleX = hasMeasure(state.facetX) ? MEASURE_SCALE_MAX : width / initFacetXUnit,
          maxScaleY = hasMeasure(state.facetY) ? MEASURE_SCALE_MAX : height / initFacetYUnit;
      return {
        x: [minScaleX, maxScaleX],
        y: [minScaleY, maxScaleY]
      };
    };

    /**
     * Created by Jeffrey on 2018/5/31.
     */
    var stop$2 = env$2.domEventsSupported ? function (e) {
      e = e.event || e; // 和 cancelBubble = true ; preventDefault 差不多
      // 通知移动端是否要处理

      e.shouldNativeHandle = false; // we may receive synthetic event without preventDefault & stopPropagation

      if (e.vanSynth) {
        return;
      }

      if (!e.cancelable) {
        return;
      }

      stop(e);
    } : function nonDomStop() {};

    // two types reducers:
    // 1. compare the target only. That way, the pos is kept on the first turn.
    // 2. compare the target and pos and others

    function targetEqual(a, b) {
      // check b contains a
      // and a == b's subset
      for (var key in a) {
        if (!(b[key] && shallowEqual(a[key], b[key]))) {
          return false;
        }
      } // check a contains b


      for (var _key in b) {
        if (!(_key in a)) return false;
      }

      return true;
    }

    /**
     * Created by Jeffrey on 2018/3/26.
     */
    // NOTE: 图例中增加fieldIds，用于legendChecker的逻辑判断
    // NOTE: fieldIds指图例对应的指标ids， 一个图例可以对应多个fieldId(多个图形中相同属性中字段不重复生成图例)
    // NOTE: fieldIds的下标表示geomIndex，理解即第几个图形中拖了fieldId为'xxxx'的字段，对于没有拖入的字段，使用null占位

    var encodeFilterKey = function encodeFilterKey(ids) {
      return _.map(ids, function (id) {
        return id ? id : '';
      }).join(SEPARATOR);
    };
    var decodeFilterKey = function decodeFilterKey(key) {
      return key.split(SEPARATOR);
    };
    /**
     * 数值范围类型vanishChecker
     * @param vanishes
     */

    var getRangeVanishChecker = function getRangeVanishChecker(vanishes) {
      var vanishedRanges = _.map(vanishes, function (s) {
        return _.map(s.split('~'), Number);
      });

      return function (value) {
        if (isNaN(+value)) {
          return false;
        }

        for (var i = 0, len = vanishedRanges.length; i < len; i++) {
          var _vanishedRanges$i = vanishedRanges[i],
              min = _vanishedRanges$i[0],
              max = _vanishedRanges$i[1]; // [min, max)

          if (min <= value && value < max) {
            return true;
          }
        }

        return false;
      };
    };
    /**
     * 普通点击图例VanishChecker
     * @param vanishes
     * @returns {function(*): *}
     */

    var getEqualVanishChecker = function getEqualVanishChecker(vanishes) {
      var vanished = vanishes.reduce(function (a, b) {
        a[b] = 1;
        return a;
      }, {});
      return function (value) {
        return vanished[value];
      };
    };
    /**
     * VanishChecker 点击图例过滤器，用于判断元素是否消失
     * @param vanishDims -> tagFilter
     * @returns {*}
     */

    function getVanishChecker(vanishDims) {
      if (!vanishDims) {
        return FALSE_FUNCTION;
      }

      if (_.isFunction(vanishDims)) {
        return vanishDims;
      }

      var vanishers = _.map(Object.keys(vanishDims), function (k) {
        var vanishes = vanishDims[k];
        return {
          ids: k.split(SEPARATOR),
          checker: vanishes.length ? vanishes[0].indexOf('~') >= 0 ? getRangeVanishChecker(vanishes) // 范围图例
          : getEqualVanishChecker(vanishes) // 普通图例
          : FALSE_FUNCTION
        };
      });

      if (!vanishers.length) {
        return FALSE_FUNCTION;
      }

      return function isVanish(row, id) {
        // NOTE 整个tagFilter里面包括多个图例，其中还有一些同名字段
        // NOTE 这里只要判断有一个checker满足，那么该vanish就成立
        return _.some(vanishers, function (_ref) {
          var ids = _ref.ids,
              checker = _ref.checker;
          return id ? _.contains(ids, id) ? checker(row[id]) : false : _.some(ids, function (id) {
            return row[id] == null ? false : checker(row[id]);
          });
        });
      };
    }
    /**
     * FadeChecker 所有滑块图例的过滤器，用于判断元素是否灰化
     * @param filterMap
     * @returns {*}
     */

    function getFadeChecker(filterMap) {
      var filterKeys = Object.keys(filterMap);

      if (!filterKeys.length) {
        return FALSE_FUNCTION;
      }

      return function isFade(row) {
        var geomIndex = row.geomIndex;
        return !_.every(filterKeys, function (filterKey) {
          var fieldIds = decodeFilterKey(filterKey),
              fieldId = fieldIds[geomIndex];
          return fieldId ? between(row[fieldId], filterMap[filterKey].from, filterMap[filterKey].to) : true;
        });
      };
    }

    var getSharedDefKeyMap = function getSharedDefKeyMap(facet) {
      if (!facet.measuresOverlapped) {
        return null;
      }

      var keyMap = {};
      var firstAxisKey = Direction.LEFT,
          secondAxisKey = Direction.RIGHT;

      if (facet.horizontal) {
        firstAxisKey = Direction.BOTTOM;
        secondAxisKey = Direction.TOP;
      }

      var _facet$measures = facet.measures,
          firstMeasures = _facet$measures[0],
          secondMeasures = _facet$measures[1];

      _.each(firstMeasures, function (id) {
        return keyMap[id] = firstAxisKey;
      });

      _.each(secondMeasures, function (id) {
        return keyMap[id] = secondAxisKey;
      });

      return keyMap;
    };
    var createGetMeasureDefKeyFunc = function createGetMeasureDefKeyFunc(facet) {
      if (facet.measuresOverlapped) {
        var keyMap = getSharedDefKeyMap(facet);
        return function (id) {
          return keyMap[id];
        };
      }

      return function (id) {
        return id;
      };
    };
    var getAllMeasuresOnFacet = function getAllMeasuresOnFacet(facet) {
      var measures = facet.measures;
      return facet.measuresOverlapped ? measures[0].concat(measures[1]) : measures;
    };

    var Aes =
    /*#__PURE__*/
    function () {
      function Aes(props) {
        this.props = props;
      }

      var _proto = Aes.prototype;

      _proto.dealMapping = function dealMapping() {
        return [];
      };

      _proto.isConstField = function isConstField() {
        return this.constValue != null;
      };

      _proto.getLegend = function getLegend()
      /* geomData */
      {
        return null;
      };

      Aes.dealMeasureValueRange = function dealMeasureValueRange(range) {
        var min = range[0],
            max = range[1];

        if (min !== max) {
          return range;
        } // 最大最小值相同时(只有一个值，或者所有值都一样), 则 min > 0 ? [0, min] : (min < 0 ? [min, 0] : [0, 1)


        if (max === 0) {
          max = 1;
        }

        min = Math.min(0, min);
        max = Math.max(0, max);
        return [min, max];
      };

      return Aes;
    }();

    var ValidFn = function ValidFn() {
      return true;
    };

    var getStepDomainWithRanges = function getStepDomainWithRanges(minMax$$1, range) {
      if (range.length <= 1) {
        return [];
      }

      var min = minMax$$1[0],
          max = minMax$$1[1],
          step = (max - min) / (range.length - 1);
      return _.map(range, function (v, i) {
        return accAdd(min, accMul(i, step));
      });
    };
    var VisualAes =
    /*#__PURE__*/
    function (_Aes) {
      _inheritsLoose(VisualAes, _Aes);

      function VisualAes(props, geom) {
        var _this;

        _this = _Aes.call(this, props) || this;
        _this.validChecker = ValidFn;

        if (_.isObject(props)) {
          _this.type = props.type;
          _this.id = props.id;
          _this.range = props.range;
          _this.groupId = props.groupId || _this.id;
          _this.domain = props.domain || _this._getAutoDomain(geom);
        } else {
          _this.constValue = props;
        }

        return _this;
      }
      /**
       * 计算获取自动的domain
       * @param geom
       * @returns {*}
       * @private
       */


      var _proto = VisualAes.prototype;

      _proto._getAutoDomain = function _getAutoDomain(geom) {
        var data = geom.data;
        return data.isMeasure(this.id) ? this.getMeasureDomain(geom) : this.getDimensionDomain(geom);
      };

      _proto.isDomainFromZero = function isDomainFromZero() {
        return false;
      }
      /**
       * 自动的指标对应的domain
       * @param geom
       */
      ;

      _proto.getMeasureDomain = function getMeasureDomain(geom) {
        var minMax$$1 = Aes.dealMeasureValueRange(geom.data.minMax(this.id));
        minMax$$1[0] = this.isDomainFromZero() ? Math.min(minMax$$1[0], 0) : minMax$$1[0];
        return minMax$$1;
      }
      /**
       * 获取自动的维度字段对应的domain
       */
      ;

      _proto.getDimensionDomain = function getDimensionDomain(geom) {
        var dataMap = geom.dataMap;
        var groupId = this.groupId; // for 指标名称对应的domain应该从多个geom中提取

        var total = _.reduce(dataMap, function (collection, data) {
          var col = data.getColByGroupId(groupId);
          return [].concat(collection, col);
        }, []);

        return _.uniq(total);
      };

      _proto.dealMapping = function dealMapping(provider) {
        var _this2 = this;

        if (this.isConstField()) {
          return _.map(new Array(provider.getRowCount()), function () {
            return _this2.constValue;
          });
        }

        return this.mapping(provider);
      };

      _proto._OriginValueMapping = function _OriginValueMapping() {};

      _proto.mapping = function mapping(provider) {
        return provider.isMeasure(this.id) ? this.dealMeasureMapping(provider) : provider.isDimension(this.id) ? this.dealDimensionMapping(provider) : [];
      };

      _proto.dealMeasureMapping = function dealMeasureMapping(provider) {
        var scale = linear$2().domain(this.domain).range(this.range);
        return _.map(provider.getColById(this.id), function (value) {
          value = scale(value);
          return _.isNaN(value) ? 0 : value;
        });
      };

      _proto.dealDimensionMapping = function dealDimensionMapping(provider) {
        // 维度字段按照序号进行scale
        var domainMap = oneBasedIndexMap(this.domain);
        var scale = linear$2().range(this.range).domain([0, this.domain.length]);
        return _.map(provider.getColById(this.id), function (value) {
          var index = domainMap[value || ''];

          return scale(index);
        });
      }
      /**
       * 设置vanishChecker
       * @param vanishChecker
       */
      ;

      _proto.setValidChecker = function setValidChecker(vanishChecker) {
        var id = this.id;

        this.validChecker = function (value) {
          var _vanishChecker;

          return !vanishChecker((_vanishChecker = {}, _vanishChecker[id] = value, _vanishChecker), id);
        };
      };

      return VisualAes;
    }(Aes);

    /**
     * @param {Array.<Object>} colorStops
     */
    var Gradient = function Gradient(colorStops) {
      this.colorStops = colorStops || [];
    };

    Gradient.prototype = {
      constructor: Gradient,
      addColorStop: function addColorStop(offset, color) {
        this.colorStops.push({
          offset: offset,
          color: color
        });
      }
    };

    /**
     * x, y, x2, y2 are all percent from 0 to 1
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {number} [x2=1]
     * @param {number} [y2=0]
     * @param {Array.<Object>} colorStops
     * @param {boolean} [globalCoord=false]
     */

    var LinearGradient = function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {type: 'linear', colorStops: ...}`, where
      // this constructor will not be called.
      this.x = x == null ? 0 : x;
      this.y = y == null ? 0 : y;
      this.x2 = x2 == null ? 1 : x2;
      this.y2 = y2 == null ? 0 : y2; // Can be cloned

      this.type = 'linear'; // If use global coord

      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };

    LinearGradient.prototype = {
      constructor: LinearGradient
    };
    inherits(LinearGradient, Gradient);

    /**
     * x, y, r are all percent from 0 to 1
     * @param {number} [x=0.5]
     * @param {number} [y=0.5]
     * @param {number} [r=0.5]
     * @param {Array.<Object>} [colorStops]
     * @param {boolean} [globalCoord=false]
     */

    var RadialGradient = function RadialGradient(x, y, r, colorStops, globalCoord) {
      // Should do nothing more in this constructor. Because gradient can be
      // declard by `color: {type: 'radial', colorStops: ...}`, where
      // this constructor will not be called.
      this.x = x == null ? 0.5 : x;
      this.y = y == null ? 0.5 : y;
      this.r = r == null ? 0.5 : r; // Can be cloned

      this.type = 'radial'; // If use global coord

      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };

    RadialGradient.prototype = {
      constructor: RadialGradient
    };
    inherits(RadialGradient, Gradient);

    var linearGradualColorCache = new LRU(32);
    var radialGradualColorCache = new LRU(32);

    var getDividerColor = function getDividerColor(color, divider) {
      var rgbaArr = parse(color);
      forEach(rgbaArr, function (v, i) {
        i < 3 && (rgbaArr[i] = rgbaArr[i] / divider >> 0);
      });
      return stringify(rgbaArr, 'rgba');
    }; // http://www.finedevelop.com/pages/viewpage.action?pageId=18460724


    var INTERVAL_GRADUAL_DIVIDER = 0.9;
    var getLinearGradualColor = function getLinearGradualColor(_ref) {
      var color = _ref.color,
          type = _ref.type,
          _ref$stops = _ref.stops,
          stops = _ref$stops === void 0 ? [1, 0, 0, 0] : _ref$stops,
          _ref$divider = _ref.divider,
          divider = _ref$divider === void 0 ? INTERVAL_GRADUAL_DIVIDER : _ref$divider;
      var key = type + "_" + color;
      var gradient = linearGradualColorCache.get(key);

      if (gradient) {
        return gradient;
      } // 这个instance == gradient plain object


      gradient = _construct(LinearGradient, stops);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, getDividerColor(color, divider));
      linearGradualColorCache.put(key, gradient);
      return gradient;
    }; // http://www.finedevelop.com/pages/viewpage.action?pageId=18460724

    var PIE_GRADUAL_DIVIDER = 0.8;
    var getRadialGradualColor = function getRadialGradualColor(color, r, r0) {
      var key = color + "_" + r + "_" + r0;
      var gradient = radialGradualColorCache.get(key);

      if (gradient) {
        return gradient;
      }

      gradient = new RadialGradient(0, 0, r, [], true);
      gradient.addColorStop(r0 / r, getDividerColor(color, PIE_GRADUAL_DIVIDER));
      gradient.addColorStop(1, color);
      radialGradualColorCache.put(key, gradient);
      return gradient;
    };
    var min$4 = Math.min;
    var highlight = function highlight(color, ratio) {
      if (ratio === void 0) {
        ratio = 0.65;
      }

      if (typeof color !== 'string') {
        return color;
      }

      var rgbaArr = parse(color);
      var highlightArr = rgbaArr.slice(); // keep alpha

      var i = -1;

      while (++i < 3) {
        var a = rgbaArr[i] / 255; // as foreground channel [0, 1]

        var b = a; // background

        var c = 0; // blend result
        // vivid light

        if (a > 0.5) {
          // like color dodge
          c = min$4(1, b / (2 * (1 - a)));
        } else {
          // like color burn
          c = 1 - min$4(1, (1 - b) / (2 * a));
        } // blend with origin


        c = ratio * a + (1 - ratio) * c;
        c *= 255; // map to [0, 255]

        highlightArr[i] = c | 0;
      } // console.log(rgbaArr, highlightArr);


      return stringify(highlightArr, 'rgba');
    };
    var mixColorWithHSB = function mixColorWithHSB(color, detH, detS, detB) {
      var rgba = parse(color);
      var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);
      hsb[0] += detH;
      hsb[1] += detS;
      hsb[2] += detB;
      var rgb = hsb2rgb(hsb[0], hsb[1], hsb[2]);
      return stringify(rgb, 'rgb');
    };
    function hsb2rgb(hue, saturation, brightness) {
      saturation = Math.min(1, Math.max(0, saturation));
      brightness = Math.min(1, Math.max(0, brightness));
      var r = 0,
          g = 0,
          b = 0;

      if (saturation === 0) {
        r = g = b = brightness * 255.0 + 0.5;
      } else {
        var h = (hue - Math.floor(hue)) * 6.0,
            f = h - Math.floor(h),
            p = brightness * (1.0 - saturation),
            q = brightness * (1.0 - saturation * f),
            t = brightness * (1.0 - saturation * (1.0 - f));

        switch (Math.floor(h)) {
          case 0:
            r = brightness * 255.0 + 0.5;
            g = t * 255.0 + 0.5;
            b = p * 255.0 + 0.5;
            break;

          case 1:
            r = q * 255.0 + 0.5;
            g = brightness * 255.0 + 0.5;
            b = p * 255.0 + 0.5;
            break;

          case 2:
            r = p * 255.0 + 0.5;
            g = brightness * 255.0 + 0.5;
            b = t * 255.0 + 0.5;
            break;

          case 3:
            r = p * 255.0 + 0.5;
            g = q * 255.0 + 0.5;
            b = brightness * 255.0 + 0.5;
            break;

          case 4:
            r = t * 255.0 + 0.5;
            g = p * 255.0 + 0.5;
            b = brightness * 255.0 + 0.5;
            break;

          case 5:
            r = brightness * 255.0 + 0.5;
            g = p * 255.0 + 0.5;
            b = q * 255.0 + 0.5;
            break;
        }
      }

      var rgb = [];
      rgb.push(Math.floor(r));
      rgb.push(Math.floor(g));
      rgb.push(Math.floor(b));
      return rgb;
    }
    function rgb2hsb(r, g, b) {
      var hue, saturation, brightness;
      var hsbvals = [3];
      var cmax = r > g ? r : g;

      if (b > cmax) {
        cmax = b;
      }

      var cmin = r < g ? r : g;

      if (b < cmin) {
        cmin = b;
      }

      brightness = cmax / 255.0;

      if (cmax !== 0) {
        saturation = (cmax - cmin) / cmax;
      } else {
        saturation = 0;
      }

      if (saturation === 0) {
        hue = 0;
      } else {
        var redc = (cmax - r) / (cmax - cmin);
        var greenc = (cmax - g) / (cmax - cmin);
        var bluec = (cmax - b) / (cmax - cmin);

        if (r == cmax) {
          hue = bluec - greenc;
        } else if (g == cmax) {
          hue = 2.0 + redc - bluec;
        } else {
          hue = 4.0 + greenc - redc;
        }

        hue = hue / 6.0;

        if (hue < 0) {
          hue = hue + 1.0;
        }
      }

      hsbvals[0] = hue;
      hsbvals[1] = saturation;
      hsbvals[2] = brightness;
      return hsbvals;
    }
    var scaleColor = function scaleColor(domain, range) {
      return linear$2().domain(domain).range(range).interpolate(interpolateValue).interpolate(interpolateValue);
    };

    var initNormalLegend = function initNormalLegend(title) {
      return {
        title: title,
        items: [],
        format: null,
        fieldIds: []
      };
    };

    var initGradientLegend = function initGradientLegend(title) {
      return {
        title: title,
        type: 'colorContinuum',
        from: 0,
        to: 0,
        min: 0,
        max: 0,
        colorStops: [],
        format: null,
        fieldIds: []
      };
    };

    var ColorAes =
    /*#__PURE__*/
    function (_VisualAes) {
      _inheritsLoose(ColorAes, _VisualAes);

      function ColorAes(props, geom) {
        var _this;

        _this = _VisualAes.call(this, props, geom) || this;
        _this.style = _this.props.style || ColorStyle.NORMAL;
        return _this;
      }

      var _proto = ColorAes.prototype;

      _proto._isStepColor = function _isStepColor() {
        return this.props.style === ColorStyle.STEP;
      };

      _proto.getMeasureDomain = function getMeasureDomain(geom) {
        var data = geom.data;
        var domain = Aes.dealMeasureValueRange(data.minMax(this.id));
        return getStepDomainWithRanges(domain, this.range);
      };

      _proto.mapping = function mapping(provider) {
        var _this2 = this;

        var isNormal = this.style === ColorStyle.NORMAL,
            isStep = this._isStepColor();

        var range = this.range,
            domain = this.domain;
        var ordinalScale = ordinal().domain(domain).range(range);
        return _.map(provider.getColById(this.id), function (value) {
          return isNormal ? ordinalScale(value) : isStep ? _this2._getStepGradientColor(value) : _this2._getContinuousColor(domain, value);
        });
      };

      _proto._getStepGradientColor = function _getStepGradientColor(value) {
        var domain = this.domain,
            range = this.range,
            len = range.length,
            domainLen = domain.length,
            min = domain[0],
            max = domain[domainLen - 1];
        var index = 1; //   step gradient colors start from second.

        if (value >= max) {
          index = len - 1;
        } else if (inRange([min, max], value)) {
          for (var i = 0; i < domainLen - 1; i++) {
            if (inRange(this.domain.slice(i, i + 2), value, true, false)) {
              index = i + 1;
              break;
            }
          }
        }

        return this.range[index];
      };

      _proto._getContinuousColor = function _getContinuousColor(domain, value) {
        var _minMax = minMax(domain),
            min = _minMax[0],
            max = _minMax[1];

        var stops = this._getStops([min, max]);

        var len = stops.length;

        if (value < min) {
          return this.range[0];
        }

        if (value >= max) {
          return this.range[this.range.length - 1];
        }

        for (var i = 0; i < len - 1; i++) {
          var left = stops[i],
              right = stops[i + 1]; // todo cache rgb domain & range

          if (inRange(stops.slice(i, i + 2), value, true, false)) {
            var scale = scaleColor([left, right], this.range.slice(i, i + 2));
            return scale(value);
          }
        }
      };

      _proto.getLegend = function getLegend(legend, geomData) {
        var legendItem;

        switch (this.style) {
          case ColorStyle.STEP:
            legendItem = this._getStepNormalColorLegend(geomData);
            legend.tags.push(legendItem);
            break;

          case ColorStyle.CONTINUOUS:
            legendItem = this._getContinuousColorLegend(geomData);
            legend.sliders.push(legendItem);
            break;

          default:
            legendItem = this._getNormalColorLegend(geomData);
            legend.tags.push(legendItem);
            break;
        }

        return legendItem;
      } // dimension field in color aes.
      ;

      _proto._getNormalColorLegend = function _getNormalColorLegend(geomData) {
        var _this3 = this;

        var _geomData$getFieldByI = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI.name;

        var domain = this.domain,
            range = this.range;
        var legend = initNormalLegend(name);
        var scale = ordinal().domain(domain).range(range);

        _.each(domain, function (value) {
          value = value || '';
          legend.items.push({
            name: value,
            icon: 'rect',
            color: scale(value),
            valid: _this3.validChecker(value),
            on: true
          });
        });

        return legend;
      };

      _proto._getStepNormalColorLegend = function _getStepNormalColorLegend(geomData) {
        var _geomData$getFieldByI2 = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI2.name;

        var domain = this.domain;
        var legend = initNormalLegend(name);

        for (var i = 0, len = domain.length; i < len - 1; i++) {
          var value = domain[i],
              nextValue = domain[i + 1];
          legend.items.push({
            name: value + "~" + nextValue,
            icon: 'rect',
            color: this.range[i + 1],
            from: value,
            to: nextValue,
            maximum: domain[len - 1],
            valid: this.validChecker((value + nextValue) / 2),
            // average for check status
            on: true
          });
        }

        return legend;
      };

      _proto._getContinuousColorLegend = function _getContinuousColorLegend(geomData) {
        var _geomData$getFieldByI3 = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI3.name;

        var domain = this.domain;
        var legend = initGradientLegend(name);

        var _minMax2 = minMax(domain),
            min = _minMax2[0],
            max = _minMax2[1];

        var stops = this._getStops([min, max]);

        legend.min = min;
        legend.max = max;
        legend.from = min;
        legend.to = max;

        for (var i = 0, len = this.range.length; i < len; i++) {
          var color = this.range[i],
              value = stops[i],
              offset = min === max ? 0 : (value - min) / (max - min);
          legend.colorStops.push({
            offset: offset,
            color: color
          });
        }

        return legend;
      } // 根据原来的domain比例计算新的新比例
      ;

      _proto._getStops = function _getStops(minMaxArr) {
        var stops = [];
        var scale = linear$2().domain(minMax(this.domain)).range(minMaxArr);

        _.each(this.domain, function (v) {
          return stops.push(scale(v));
        });

        return stops;
      };

      return ColorAes;
    }(VisualAes);

    var LEGEND_ICON_MIN = 1;
    var LEGEND_ICON_MAX = 5;
    var SizeAes =
    /*#__PURE__*/
    function (_VisualAes) {
      _inheritsLoose(SizeAes, _VisualAes);

      function SizeAes(props, geom) {
        return _VisualAes.call(this, props, geom) || this;
      }

      var _proto = SizeAes.prototype;

      _proto.getLegend = function getLegend(legend, geomData) {
        var legendItem;

        if (geomData.isMeasure(this.id)) {
          legendItem = this._getRangeLegend(geomData);
          legend.sliders.push(legendItem);
        } else if (geomData.isDimension(this.id)) {
          legendItem = this._getNormalLegend(geomData);
          legend.tags.push(legendItem);
        }

        return legendItem;
      };

      _proto.isDomainFromZero = function isDomainFromZero() {
        return true;
      };

      _proto._getRangeLegend = function _getRangeLegend(geomData) {
        var _geomData$getFieldByI = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI.name;

        var legend = initGradientLegend(name);
        legend.type = 'AsymmetricSlider';

        var _Aes$dealMeasureValue = Aes.dealMeasureValueRange(geomData.minMax(this.id)),
            min = _Aes$dealMeasureValue[0],
            max = _Aes$dealMeasureValue[1];

        legend.min = min;
        legend.max = max;
        legend.from = min;
        legend.to = max;
        legend.colorStops.push({
          offset: 0,
          color: DEFAULT_LEGEND_ICON_COLOR
        });
        legend.colorStops.push({
          offset: 1,
          color: DEFAULT_LEGEND_ICON_COLOR
        });
        return legend;
      };

      _proto._getNormalLegend = function _getNormalLegend(geomData) {
        var _this = this;

        var _geomData$getFieldByI2 = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI2.name;

        var ordinal$$1 = geomData.ordinal(this.id);
        var legend = initNormalLegend(name);
        var scale = linear$2().range([LEGEND_ICON_MIN, LEGEND_ICON_MAX]).domain([0, ordinal$$1.length - 1]);

        _.each(ordinal$$1, function (text, i) {
          legend.items.push({
            name: text || '',
            color: DEFAULT_LEGEND_ICON_COLOR,
            icon: 'circle',
            radius: scale(i),
            valid: _this.validChecker(ordinal$$1[i]),
            on: true
          });
        });

        return legend;
      };

      return SizeAes;
    }(VisualAes);

    var SymbolAes =
    /*#__PURE__*/
    function (_VisualAes) {
      _inheritsLoose(SymbolAes, _VisualAes);

      function SymbolAes(props, geom) {
        return _VisualAes.call(this, props, geom) || this;
      }

      var _proto = SymbolAes.prototype;

      _proto.mapping = function mapping(provider) {
        var colList = [];

        if (provider.isMeasure(this.id)) {
          colList = this._dealMeasureMapping(provider);
        } else {
          colList = this._dealDimensionMapping(provider);
        }

        return colList;
      };

      _proto.getMeasureDomain = function getMeasureDomain(geom) {
        var minMax = Aes.dealMeasureValueRange(geom.data.minMax(this.id)); // Note: 关于StepDomain 的生成, 主要是domain > range 即
        // 1~2: 3, 2~3:4这样的, 描述就是domain: [1, 2, 3], range: [3, 3, 4]
        // 这里我们需要生成和range.length + 1的Domain, 故range要前补充一位

        var _this$range = this.range,
            first = _this$range[0];
        var range = [first].concat(this.range);
        return getStepDomainWithRanges(minMax, range);
      };

      _proto._dealMeasureMapping = function _dealMeasureMapping(provider) {
        var _this = this;

        return _.map(provider.getColById(this.id), function (value) {
          var symbol = null;

          for (var i = _this.domain.length - 2; i >= 0; i--) {
            var rangeValue = _this.domain[i];

            if (value > rangeValue) {
              symbol = _this.range[i];
              break;
            }
          }

          if (symbol == null) {
            symbol = _this.range[0];
          }

          return symbol;
        });
      };

      _proto._dealDimensionMapping = function _dealDimensionMapping(provider) {
        var scale = ordinal().domain(this.domain).range(this.range);
        return _.map(provider.getColById(this.id), function (value) {
          return scale(value);
        });
      };

      _proto.getLegend = function getLegend(legend, geomData) {
        var legendItem;

        if (geomData.isMeasure(this.id)) {
          legendItem = this._getRangeNormalLegend(geomData);
        } else {
          legendItem = this._getNormalLegend(geomData);
        }

        legend.tags.push(legendItem);
        return legendItem;
      } // dimension field type in aes.
      ;

      _proto._getNormalLegend = function _getNormalLegend(geomData) {
        var _this2 = this;

        var _geomData$getFieldByI = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI.name,
            legend = initNormalLegend(name);

        var domain = this.domain,
            range = this.range;
        var scale = ordinal().range(range).domain(domain);

        _.each(domain, function (value) {
          value = value || '';
          legend.items.push({
            name: value || '',
            icon: scale(value),
            color: DEFAULT_LEGEND_ICON_COLOR,
            valid: _this2.validChecker(value),
            on: true
          });
        });

        return legend;
      };

      _proto._getRangeNormalLegend = function _getRangeNormalLegend(geomData) {
        var _geomData$getFieldByI2 = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI2.name;

        var legend = initNormalLegend(name);

        for (var i = 0, len = this.domain.length; i < len - 1; i++) {
          var value = this.domain[i],
              nextValue = this.domain[i + 1];
          legend.items.push({
            name: value + "~" + nextValue,
            from: value,
            to: nextValue,
            maximum: this.domain[len - 1],
            icon: this.range[i],
            color: DEFAULT_LEGEND_ICON_COLOR,
            valid: this.validChecker((value + nextValue) / 2),
            // average for check status
            on: true
          });
        }

        return legend;
      };

      return SymbolAes;
    }(VisualAes);

    var PointersAes =
    /*#__PURE__*/
    function (_Aes) {
      _inheritsLoose(PointersAes, _Aes);

      function PointersAes(ids) {
        var _this;

        _this = _Aes.call(this, ids) || this;
        _this.ids = _.isArray(ids) ? ids : [ids];
        return _this;
      }

      var _proto = PointersAes.prototype;

      _proto.dealMapping = function dealMapping(dataModel) {
        var cols = _.map(this.ids, function (id) {
          var originCol = dataModel.getColById(id);

          if (dataModel.isMeasure(id)) {
            return originCol;
          } // if id is dimension, return index list


          var indexMap = oneBasedIndexMap(originCol); // BI-38951

          return _.map(originCol, function (name) {
            return indexMap[name];
          });
        });
        /**
         * [
         *      [1, 2, 3, 4, 5],
         *      [6, 7, 8, 9, 10]
         * ] =>
         * [
         *      [1, 6],
         *      [2, 7],
         *      [3, 8],
         *      [4, 9],
         *      [5, 10]
         * ]
         */


        return _.unzip(cols);
      };

      return PointersAes;
    }(Aes);

    var TargetAes =
    /*#__PURE__*/
    function (_Aes) {
      _inheritsLoose(TargetAes, _Aes);

      function TargetAes(props) {
        var _this;

        _this = _Aes.call(this, props) || this;
        _this.id = props;
        return _this;
      }

      var _proto = TargetAes.prototype;

      _proto.dealMapping = function dealMapping(provider) {
        return provider.isMeasure(this.id) ? provider.getColById(this.id) : this.dealDimensionMapping(provider);
      };

      _proto.dealDimensionMapping = function dealDimensionMapping(provider) {
        var domain = provider.getColById(this.id);
        var domainMap = oneBasedIndexMap(domain);
        return _.map(domain, function (v) {
          return domainMap[v];
        });
      };

      return TargetAes;
    }(Aes);

    var DEFAULT_HEAT_CONFIG = {
      min: 0,
      max: 5,
      gradient: {
        '0': '#ffffff',
        '0.25': '#0000ff',
        '0.5': '#00ff00',
        '0.75': '#ffff00',
        '1': '#ff0000'
      },
      blur: 1,
      maxOpacity: 1,
      minOpacity: 0
    };

    var HeatColorAes =
    /*#__PURE__*/
    function (_VisualAes) {
      _inheritsLoose(HeatColorAes, _VisualAes);

      function HeatColorAes(props, geom) {
        var _this;

        _this = _VisualAes.call(this, props, geom) || this;
        _this.constValue = props.constValue;
        _this.range = props.range;
        _this.max = props.max;
        _this.style = ColorStyle.CONTINUOUS;
        var _props$config = props.config,
            config = _props$config === void 0 ? DEFAULT_HEAT_CONFIG : _props$config;
        _this.config = config;
        return _this;
      }

      var _proto = HeatColorAes.prototype;

      _proto._getAutoDomain = function _getAutoDomain(geom) {
        var id = this.id,
            max = this.max;
        var data = geom.data;
        var domain;

        if (this.isConstField()) {
          domain = [1, max];
        } else if (data.isMeasure(id)) {
          domain = Aes.dealMeasureValueRange(data.minMax(this.id));
        } else {
          var col = data.ordinal(id);
          domain = col.length === 1 ? [0, 1] : [1, col.length];
        }

        return getStepDomainWithRanges(domain, this.props.range);
      };

      _proto.dealMapping = function dealMapping(provider) {
        if (this.isConstField()) {
          return _VisualAes.prototype.dealMapping.call(this, provider);
        }

        var id = this.id,
            col = provider.getColById(id);

        if (provider.isMeasure(id)) {
          return col;
        }

        var ordinal = oneBasedIndexMap(col);
        return _.map(col, function (v) {
          return ordinal[v];
        });
      };

      _proto.getLegend = function getLegend(legend, geomData) {
        var _geomData$getFieldByI = geomData.getFieldById(this.id),
            name = _geomData$getFieldByI.name;

        var slider = initGradientLegend(name); // const { min, max, gradient } = this.config;

        var domain = this.domain,
            range = this.range;
        var len = domain.length;
        var min = domain[0];
        var max = domain[len - 1];
        slider.min = min;
        slider.max = max;
        slider.from = min;
        slider.to = max;
        slider.colorStops = _.map(domain, function (d, i) {
          return {
            offset: (d - min) / (max - min),
            color: range[i]
          };
        });
        legend.sliders.push(slider);
        return slider;
      };

      return HeatColorAes;
    }(VisualAes);

    var abs$2 = Math.abs;

    var PieAngleAes =
    /*#__PURE__*/
    function (_VisualAes) {
      _inheritsLoose(PieAngleAes, _VisualAes);

      function PieAngleAes() {
        return _VisualAes.apply(this, arguments) || this;
      }

      var _proto = PieAngleAes.prototype;

      _proto.isDomainFromZero = function isDomainFromZero() {
        return true;
      };

      _proto.dealMeasureMapping = function dealMeasureMapping(provider) {
        return _.map(provider.getColById(this.id), function (value) {
          value = abs$2(value); // @BI-42399

          return _.isNaN(value) ? 0 : value;
        });
      };

      return PieAngleAes;
    }(VisualAes);

    var _loadedAes = {};
    function registerAes(type, Aes) {
      _loadedAes[type] = Aes;
    }
    function getAesInstance(type, geom, props) {
      var geomType = geom.type;

      if (geomType === ChartLibrary.HEAT_MAP && type === AesTypes.COLOR) {
        type = AesTypes.HEAT_COLOR;
      }

      if (_loadedAes[type]) {
        return new _loadedAes[type](props, geom);
      }

      if (MappingAesTypes[type]) {
        return new VisualAes(props, geom);
      }

      console.warn("refuse to provide AesInstance which is not a mapping typed aes");
    }
    registerAes(AesTypes.COLOR, ColorAes);
    registerAes(AesTypes.SIZE, SizeAes);
    registerAes(AesTypes.SYMBOL, SymbolAes);
    registerAes(AesTypes.POINTERS, PointersAes);
    registerAes(AesTypes.TARGET, TargetAes);
    registerAes(AesTypes.HEAT_COLOR, HeatColorAes);
    registerAes(AesTypes.PIE_ANGLE, PieAngleAes);

    /**
     * 是否是有意义的数值字段
     * @param value
     * @returns {boolean}
     */
    function isMeaningfulNumericValue(value) {
      value = +value;
      return !isNaN(value) && isFinite(value);
    }

    function getUpperForecastDimensionId(dimensionId) {
      return dimensionId + UPPER_LIMIT;
    }
    function getLowerForecastDimensionId(dimensionId) {
      return dimensionId + LOWER_LIMIT;
    }

    var _isDimension = function isDimension(type) {
      return type === FieldType.DIMENSION;
    };

    var _isMeasure = function isMeasure(type) {
      return type === FieldType.MEASURE;
    };

    var transformField = function transformField(f) {
      var type = f.type;
      return _extends({}, f, {
        isDimension: _isDimension(type),
        isMeasure: _isMeasure(type)
      });
    };

    var transformFields = function transformFields(fields) {
      return _.map(fields, function (f) {
        return transformField(f);
      });
    };

    var Frame =
    /*#__PURE__*/
    function () {
      function Frame(fields, colData) {
        this.fields = transformFields(fields) || [];
        this.colData = colData || [];
      }

      var _proto = Frame.prototype;

      _proto.getFieldById = function getFieldById(id) {
        for (var i = 0, len = this.fields.length; i < len; i++) {
          if (this.fields[i].id === id) {
            return this.fields[i];
          }
        }

        return null;
      };

      _proto.contains = function contains(fieldId) {
        return this.indexOf(fieldId) !== -1;
      };

      _proto.indexOf = function indexOf(fieldId) {
        for (var i = 0, len = this.fields.length; i < len; i++) {
          if (this.fields[i].id === fieldId) {
            return i;
          }
        }

        return -1;
      };

      _proto.getRowCount = function getRowCount() {
        var colData = this.colData;
        return colData && colData.length ? colData[0].length : 0;
      };

      _proto.colCount = function colCount() {
        return (this.fields || []).length;
      };

      _proto.each = function each(func) {
        for (var frame = this, count = frame.getRowCount(), rowIndex = 0; rowIndex < count; rowIndex++) {
          func(frame._getObject(rowIndex), rowIndex);
        }

        return frame;
      };

      _proto.rowObject = function rowObject(rowIndex) {
        return this._getObject(rowIndex);
      };

      _proto.addCol = function addCol(field, value) {
        field = transformField(field);

        if (this.contains(field.id)) {
          this.replaceCol(field.id, value);
        } else {
          this.fields.push(field);
          this.colData.push(value);
        }
      };

      _proto.delCol = function delCol(fieldId) {
        var index = this.indexOf(fieldId);

        if (index > -1) {
          this.fields.splice(index, 1);
          this.colData.splice(index, 1);
        }
      } // todo add cached rows
      ;

      _proto.toRows = function toRows() {
        var rows = [];

        for (var i = 0, len = this.getRowCount(); i < len; i++) {
          rows.push(this.rowObject(i));
        }

        return rows;
      };

      _proto._getObject = function _getObject(rowIndex) {
        var frame = this,
            colData = frame.colData,
            colNames = frame.fields,
            colCount = frame.colCount();
        var row = {};

        for (var colIndex = 0; colIndex < colCount; colIndex++) {
          row[colNames[colIndex].id] = colData[colIndex][rowIndex];
        }

        return row;
      };

      _proto.replaceCol = function replaceCol(id, value) {
        var index = this.indexOf(id);
        this.colData[index] = value;
      };

      _proto.getColById = function getColById(id) {
        var index = this.indexOf(id);
        return index === -1 ? [] : this.colData[index];
      };

      _proto.getColByGroupId = function getColByGroupId(groupId) {
        var index = -1;

        for (var i = 0, len = this.fields.length; i < len; i++) {
          if (this.fields[i].groupId === groupId) {
            index = i;
            break;
          }
        }

        return index === -1 ? [] : this.colData[index];
      };

      _proto.addFrame = function addFrame() {
        var fields, colData;

        if (arguments.length === 1) {
          var _arguments$ = arguments[0];
          fields = _arguments$.fields;
          colData = _arguments$.colData;
        } else if (arguments.length === 2) {
          fields = arguments[0];
          colData = arguments[1];
        }

        this.fields = this.fields.concat(transformFields(fields));
        this.colData = this.colData.concat(colData);
        return this;
      };

      _proto.isEmptyCol = function isEmptyCol(id) {
        var col = this.getColById(id);

        if (col.length === 0) {
          return true;
        }

        var isDimension = this.isDimension(id);
        var nullChecker = isDimension ? function (v) {
          return v === NULL_VALUE || v == null;
        } : function (v) {
          return isNaN(+v);
        };
        return _.every(col, function (value) {
          return nullChecker(value);
        });
      };

      _proto.ordinal = function ordinal(id) {
        var col = this.getColById(id);
        var hash = {};

        _.each(col, function (v) {
          return hash[v] = true;
        });

        return _.reduce(hash, function (arr, c, key) {
          arr.push(key);
          return arr;
        }, []);
      };

      _proto.map = function map$$1(func) {
        var results = [];
        this.each(function (row, index) {
          results.push(func(row, index));
        });
        return results;
      };

      _proto.minMax = function minMax(id, tagFilter) {
        var upper = getUpperForecastDimensionId(id),
            lower = getLowerForecastDimensionId(id);
        var min = Number.MAX_VALUE,
            max = -min,
            isEmpty = true,
            isForecastField = this.contains(upper);
        var vanishChecker = getVanishChecker(tagFilter);
        this.each(function (row) {
          if (!vanishChecker(row)) {
            var value = +row[id];

            if (!isMeaningfulNumericValue(value)) {
              return;
            }

            isEmpty = false;
            min = Math.min(min, value);
            max = Math.max(max, value);

            if (isForecastField) {
              if (row[lower] !== NULL_VALUE) {
                min = Math.min(min, row[lower]);
              }

              if (row[upper] !== NULL_VALUE) {
                max = Math.max(max, row[upper]);
              }
            }
          }
        });
        return isEmpty ? Frame.getDefaultMinMax() : [min, max];
      };

      _proto.sum = function sum(id, tagFilter) {
        var sum = 0;
        var vanishChecker = getVanishChecker(tagFilter);
        this.each(function (row) {
          // vanish or meaningless value use 0 instead
          sum += vanishChecker(row) || !isMeaningfulNumericValue(row[id]) ? 0 : +row[id];
        });
        return sum;
      };

      _proto.filter = function filter$$1(ids) {
        var _this = this;

        var newFields = [],
            newColData = [];
        var colDataMap = {};

        _.each(this.fields, function (field, index) {
          colDataMap[field.id] = {
            field: field,
            col: _this.colData[index]
          };
        });

        _.each(ids, function (id) {
          var _colDataMap$id = colDataMap[id],
              field = _colDataMap$id.field,
              col = _colDataMap$id.col;
          newFields.push(field);
          newColData.push(col);
        });

        return new Frame(newFields, newColData);
      };

      _proto.isDimension = function isDimension(fieldId) {
        var field = this.getFieldById(fieldId);
        return field && _isDimension(field.type);
      };

      _proto.isMeasure = function isMeasure(fieldId) {
        var field = this.getFieldById(fieldId);
        return field && _isMeasure(field.type);
      };

      return Frame;
    }();

    Frame.group = function (frame, groupName) {
      if (!groupName) return [frame];
      var map$$1 = Frame.groupToMap(frame, groupName);
      var group = [];

      _.each(map$$1, function (value) {
        group.push(value);
      });

      return group;
    };

    Frame.groupToMap = function (frame, groupBy) {
      var map$$1 = {};
      var groups = _.isArray(groupBy) ? groupBy : groupBy.replace(/\s+/g, '').split('*');

      groupBy = function groupBy(row) {
        for (var key = '', i = 0, n = groups.length; i < n; i++) {
          key += row[groups[i]].toString();
        }

        return key;
      };

      frame.each(function (row, rowIndex) {
        var n = groupBy(row);
        map$$1[n] ? map$$1[n].push(rowIndex) : map$$1[n] = [rowIndex];
      });

      _.each(map$$1, function (rowIndexArray, key) {
        var colData = [];

        _.each(frame.fields, function (field, index) {
          var origin = frame.colData[index];

          var value = _.map(rowIndexArray, function (rowIndex) {
            return origin[rowIndex];
          });

          colData.push(value);
        });

        map$$1[key] = new Frame(frame.fields, colData);
      });

      return map$$1;
    };

    Frame.getDefaultMinMax = function () {
      var arr = [0, 100];
      arr.isDefault = true;
      return arr;
    };

    Frame.minMax = function (geom, id, filter$$1) {
      var dataModel = geom.data,
          type = geom.type,
          size = geom.size;
      var sizeAes = getAesInstance(AesTypes.SIZE, geom, size); // 矩形块的size上有字段的时候，会往正向或者负向延伸，计算minMax的时候把这个size加上。

      if (type === ChartLibrary.SQUARE && sizeAes && !sizeAes.isConstField()) {
        var geomValueCol = dataModel.getColById(id);
        var sizeCol = dataModel.isMeasure(sizeAes.id) ? dataModel.getColById(sizeAes.id) : Frame.getNumericalDimensionCol(dataModel.getColById(sizeAes.id));

        var sumCol = _.map(geomValueCol, function (v, i) {
          return v + sizeCol[i];
        });

        var minMax = dataModel.minMax(id, filter$$1);
        dataModel.addCol({
          name: 'square',
          id: 'square',
          type: FieldType.ATTR,
          constField: false
        }, sumCol);
        var newMinMax = dataModel.minMax('square', filter$$1);
        var totalValues = [].concat(newMinMax, minMax);
        dataModel.delCol('square');
        return [Math.min.apply(Math, totalValues), Math.max.apply(Math, totalValues)];
      }

      return dataModel.minMax(id, filter$$1);
    };

    Frame.isNotEmptyCol = function (dataModel, id, filter$$1) {
      var vanishChecker = getVanishChecker(filter$$1);
      return _.some(dataModel.toRows(), function (row) {
        return !(vanishChecker(row) || row[id] === '-');
      });
    };

    Frame.getNumericalDimensionCol = function (stringCol) {
      var numericalCol = [];
      var arrayIndexSet = oneBasedIndexMap(stringCol);

      for (var index = 0, len = stringCol.length; index < len; index++) {
        numericalCol[index] = arrayIndexSet[stringCol[index]];
      }

      return numericalCol;
    };

    var H_SHADOW_BLUR = 5;
    function fadeStyle(style) {
      style.fill = Fade.Fill;
      style.opacity = Fade.Opacity;
    }
    function hoverStyle(style) {
      var hColor = highlight(style.fill);
      style.fill = style.shadowColor = hColor;
      style.shadowBlur = H_SHADOW_BLUR;
    }
    function fakeStyle(style) {
      style.opacity *= 0.5;
    }
    var getFieldsInAes = function getFieldsInAes(aesthetics, type) {
      var aes = getAesByType(aesthetics, type);
      return aes && aes.fields || [];
    };
    /**
     * 获取指定类型的Aes
     * @param aesthetics
     * @param type
     * @returns {*}
     */

    var getAesByType = function getAesByType(aesthetics, type) {
      if (!aesthetics) {
        return;
      }

      return filter(aesthetics, function (aes) {
        return aes.type === type;
      })[0];
    };
    var getGeomTransitionProps = function getGeomTransitionProps(Timing) {
      if (Timing === void 0) {
        Timing = {};
      }

      return function (node, process, clean) {
        var type = node.type,
            condition = node.condition,
            prevCondition = node.prevCondition;
        var transition, transitionEnd;

        if (type === ENTER) {
          transition = process === SHOW ? Timing.SHOW_ENTER : Timing.INIT;
        } else if (type === UPDATE) {
          if (condition !== FADE && prevCondition === FADE) {
            transition = Fade.Timing;
          } else if (process === SHOW) {
            transition = Timing.SHOW_UPDATE;
          } else if (process === HIDE) {
            transition = Timing.HIDE_UPDATE;
          } else if (condition === HOVER || prevCondition === HOVER) {
            transition = Timing.HOVER;
          }
        } else if (type === LEAVE) {
          transition = Timing.HIDE_LEAVE;
          transitionEnd = clean;
        }

        return {
          transition: transition,
          transitionEnd: transitionEnd
        };
      };
    };
    /**
     * 是否使用百分比大小，适用于Pie, Funnel, Gauge, Square
     * @param baseFacet
     * @param geomFacet
     * @returns {boolean}
     */

    var isGeomUsePercentSize = function isGeomUsePercentSize(baseFacet, geomFacet) {
      return !geomFacet.hasMeasure || !baseFacet.hasMeasure && baseFacet.dimensions.length > 0;
    };
    var groupRowsByPos = function groupRowsByPos(rows, cb) {
      _.each(_.groupBy(rows, function (row) {
        return row.x + SEPARATOR + row.y;
      }), function (groupedRows, groupId) {
        var center = _.map(groupId.split(SEPARATOR), Number);

        cb(groupedRows, groupId, center);
      });
    }; // @BI-39116 layout的时候如果图表是inverted的话，要把所有的row的x y交换掉，这样才能正确计算tooltip pos。

    var exchangeXY = function exchangeXY(row, inverted) {
      var ox = row.x,
          oy = row.y;

      if (inverted) {
        row.x = oy;
        row.y = ox;
      }
    };

    function adjustLabel(_ref) {
      var rows = _ref.rows,
          geom = _ref.geom,
          manager = _ref.manager,
          cellBounds = _ref.cellBounds;

      if (!rows.length) {
        return;
      }

      var adjust = geom.dataLabel.adjust,
          inverted = geom.inverted;
      var isHorizontalBasedAxis = !inverted;

      if (adjust === DataLabel.HIDE) {
        // 标签显示的顺序和图形画的顺序一致
        rows = rows.slice().reverse();
        forEach(rows, function (row) {
          var bounds = row.dataLabel.bounds;

          if (manager.isOverlapped(bounds)) {
            row.dataLabel = null;
          } else {
            manager.addBounds(bounds);
          }
        });
        return;
      } // auto adjust label position, vertical or horizontal
      // vertical direction position adjust


      function verticalPosFix(start, end, step, labelBounds) {
        for (var y = start; step < 0 ? y > end : y < end; y += step) {
          var newBounds = _extends({}, labelBounds, {
            y: y
          });

          if (!manager.isOverlapped(newBounds)) {
            manager.addBounds(newBounds);
            return newBounds;
          }
        }
      } // horizontal direction position adjust


      function horizontalPosFix(start, end, step, labelBounds) {
        for (var x = start; step < 0 ? x > end : x < end; x += step) {
          var newBounds = _extends({}, labelBounds, {
            x: x
          });

          if (!manager.isOverlapped(newBounds)) {
            manager.addBounds(newBounds);
            return newBounds;
          }
        }
      }

      var key = inverted ? 'x' : 'y';
      var points = rows.slice().sort(function (a, b) {
        return a.dataLabel.bounds[key] - b.dataLabel.bounds[key];
      });
      var toRightBottom = inverted ? points[0].dataLabel.bounds.x < 0 : points[0].dataLabel.bounds.y < cellBounds.y;
      forEach(rows, function (row) {
        var dataLabel = row.dataLabel,
            bounds = row.dataLabel.bounds;
        var step = 3; // each step adjust 3px

        var testBounds; // vertical direction

        if (isHorizontalBasedAxis) {
          var startY, endY;

          if (toRightBottom) {
            startY = Math.max(cellBounds.y, bounds.y);
            endY = cellBounds.y + cellBounds.height - bounds.height;
            testBounds = verticalPosFix(startY, endY, step, bounds);
          } else {
            endY = cellBounds.y;
            startY = Math.min(bounds.y, cellBounds.y + cellBounds.height - bounds.height);
            testBounds = verticalPosFix(startY, endY, -step, bounds);
          }
        } // horizontal direction
        else {
            var startX, endX;
            var left = cellBounds.x,
                right = left + cellBounds.width;

            if (toRightBottom) {
              startX = Math.max(cellBounds.x, left);
              endX = right - bounds.width;
              testBounds = horizontalPosFix(startX, endX, step, bounds);
            } else {
              startX = Math.min(bounds.x, right - bounds.width);
              endX = left;
              testBounds = horizontalPosFix(startX, endX, -step, bounds);
            }
          }

        if (testBounds) {
          dataLabel.bounds = testBounds;
        } else {
          row.dataLabel = null; // 调整后找不到合理的位置，则直接当隐藏处理
        }
      });
    }

    var FONT_SIZE = 12; // avoid throw error while try to change frozen richStyle

    var cloneRichStyle = function cloneRichStyle(style, cover) {
      if (cover === void 0) {
        cover = {};
      }

      var newStyle = {};

      _.each(style, function (v, k) {
        newStyle[k] = assign({}, v, cover);
      });

      return newStyle;
    };

    var validValue = function validValue(row, id) {
      var value = row[id];
      return value !== NULL_VALUE && value != null ? value : '';
    }; // 格式化formatter中的字段为具体的内容


    var getRichContent = function getRichContent(richConfig, row) {
      var formatter = richConfig.formatter,
          fields = richConfig.fields,
          _richConfig$formatMap = richConfig.formatMap,
          formatMap = _richConfig$formatMap === void 0 ? {} : _richConfig$formatMap;
      var text = formatter;

      _.each(fields, function (fieldId) {
        var value = getFormattedText(validValue(row, fieldId), formatMap[fieldId]);
        text = text.replace(new RegExp('\\$\\{' + fieldId + '\\}', 'g'), value);
      });

      return text.replace(/(\n)+$/, ''); // 剔除最后多余的换行符
    };
    var highlightRichStyle = function highlightRichStyle(rich) {
      _.each(rich, function (style) {
        return style.textFill = highlight(style.textFill);
      });
    };

    var STYLE_REG$1 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
    /**
     * 文本内容格式化
     * @param richConfig  富文本格式，内容相关
     * @param row  数据点
     */

    function formatText(richConfig, row) {
      if (!richConfig) {
        return {};
      }

      var style = richConfig.style; // 第一步，格式化字段值

      var text = getRichContent(richConfig, row);
      var result;
      var lastIndex = STYLE_REG$1.lastIndex = 0; // 格式化样式到对应具体的文字上

      var lines = [];

      while ((result = STYLE_REG$1.exec(text)) != null) {
        var matchIndex = result.index;

        if (matchIndex > lastIndex) {
          pushLine(lines, text.substring(lastIndex, matchIndex));
        }

        pushLine(lines, result[2], style[result[1]]);
        lastIndex = STYLE_REG$1.lastIndex;
      }

      if (lastIndex < text.length) {
        pushLine(lines, text.substring(lastIndex, text.length));
      }

      return {
        data: lines,
        text: text,
        style: style
      }; // 根据换行符，把不同行的文字分隔到不同的line里面

      function pushLine(lines, str, style) {
        var strs = str.split('\n');

        for (var i = 0; i < strs.length; i++) {
          var _text = strs[i],
              isEmpty = _text === '';
          var textObj = {
            text: _text,
            style: style
          }; // 换行左侧的应该放在上一行

          if (!i) {
            var line = lines[lines.length - 1] || (lines[0] = []);
            !isEmpty && line.push(textObj);
          } else {
            lines.push(isEmpty ? [] : [textObj]);
          }
        }
      }
    }

    var toFont = function toFont(style) {
      var _style$fontWeight = style.fontWeight,
          fontWeight = _style$fontWeight === void 0 ? '' : _style$fontWeight,
          _style$fontFamily = style.fontFamily,
          fontFamily = _style$fontFamily === void 0 ? 'Arial' : _style$fontFamily,
          _style$fontSize = style.fontSize,
          fontSize = _style$fontSize === void 0 ? 14 : _style$fontSize;
      return fontWeight + " " + fontSize + "px " + fontFamily;
    };
    /**
     * canvas计算文字尺寸
     * @param text      文字内容
     * @param style     样式
     * @param rotation  弧度
     * @returns {*[]}
     */

    function calcTextDim(text, style, rotation) {
      if (style === void 0) {
        style = {};
      }

      if (rotation === void 0) {
        rotation = 0;
      }

      var font = toFont(style);
      var width = measureText(text, font).width;
      var sa = Math.abs(Math.sin(rotation)),
          ca = Math.abs(Math.cos(rotation));
      var _style = style,
          fontSize = _style.fontSize; // 向上取整

      return [Math.ceil(width * ca + fontSize * sa), Math.ceil(fontSize * ca + width * sa)];
    }
    /**
     * zr在关于truncate计算ellipsis时，对传入的outerWidth做了-1的操作，比如我们计算出来文字宽度是40px，
     * 然后我们设置outerWidth也是40px，但是对zr来说就用39px来装40px，就装不下了.
     * 看了一下zr那边没有办法直接重写，在这里统一做+1的操作
     * @param width
     * @returns {*}
     */

    var getTruncateOuterWidth = function getTruncateOuterWidth(width) {
      return width + 1;
    };

    var DEFAULT_SIZE = 14;
    var LINE_PADDING = 0.5;
    var DEFAULT_LINE_HEIGHT$1 = DEFAULT_SIZE * (1 + LINE_PADDING);
    var DEFAULT_STYLE = {
      fontSize: DEFAULT_SIZE
    };

    var Paragraph = function Paragraph(_ref) {
      var _ref$bounds = _ref.bounds,
          x = _ref$bounds.x,
          y = _ref$bounds.y,
          data = _ref.data,
          borderColor = _ref.borderColor,
          opacity = _ref.opacity,
          onmousemove = _ref.onmousemove,
          onmouseout = _ref.onmouseout,
          rest = _objectWithoutPropertiesLoose(_ref, ["bounds", "data", "borderColor", "opacity", "onmousemove", "onmouseout"]);

      return h('group', {
        position: [x, y],
        onmousemove: onmousemove,
        onmouseout: onmouseout
      }, _.map(getTextGroup(data), function (textObj) {
        var style = textObj.style,
            _textObj$dim = textObj.dim,
            x = _textObj$dim.x,
            y = _textObj$dim.y,
            text = textObj.text;
        var textFill = style.color || style.textFill;
        return h('text', _extends({}, rest, {
          position: [x, y],
          style: _extends({
            text: text
          }, style, {
            textFill: textFill,
            opacity: opacity,
            textStroke: borderColor,
            textStrokeWidth: 1
          })
        }));
      }));
    };
    /**
     * 把一个段落里的多层的文字对象拿到一层数组里面
     * @param lines
     * @returns {Array}
     */

    function getTextGroup(lines) {
      var textGroup = [];

      _.each(lines, function (line) {
        textGroup.push.apply(textGroup, line);
      });

      return textGroup;
    }
    /**
     * 计算文字段落的尺寸
     * @param lines 二维数组，第一维表示行，第二维表示行内的不同样式的文字对象
     * @param center 是否居中对齐
     * @param lineGap 是否居中对齐
     */


    function calcParagraphSize(lines, center, lineGap) {
      if (lineGap === void 0) {
        lineGap = 0;
      }

      var width = 0,
          height = 0,
          dimCache = []; // 第一步先计算出独立样式的文字的width&height，整体段落的dim

      _.each(lines, function (line, lineIndex) {
        var lineWidth = 0,
            lineHeight = 0;

        _.each(line, function (textObj, index) {
          var style = textObj.style || DEFAULT_STYLE;
          var dim = calcTextDim(textObj.text, style);
          var dw = dim[0];
          var dh = dim[1];
          textObj.dim = {
            x: lineWidth,
            y: height,
            width: dw,
            height: dh
          };
          lineWidth += dw;
          lineHeight = Math.max(dh, lineHeight);

          if (index === line.length - 1) {
            dimCache.push([lineWidth, lineHeight]);
          }
        });

        width = Math.max(lineWidth, width); // 0-1表示使用行高的百分比

        var gap = lineGap > 0 ? lineGap < 1 ? lineHeight * lineGap : lineGap : 0;
        height += (lineHeight || DEFAULT_LINE_HEIGHT$1) + (lineIndex === lines.length - 1 ? 0 : gap);
      }); // 第二步，文字对齐处理，计算出独立文字的精确位置


      _.each(lines, function (line, index) {
        var lineDim = dimCache[index];

        if (!lineDim) {
          return;
        } // 水平居中，x方向的位移是统一的,


        var xTrans = center ? (width - lineDim[0]) / 2 : 0;

        _.each(line, function (textObj) {
          var dim = textObj.dim;
          dim.x += xTrans;
          dim.y += (lineDim[1] - dim.height) / 2; // 行内垂直居中
        });
      });

      return [width, height];
    }
    /**
     * 从row和richText中生成Paragraph的props
     * @param row
     * @param rich
     * @param cover
     * @returns {{bounds: {width, height}, data: Array}}
     */

    function rowToParagraphProp(_ref2) {
      var row = _ref2.row,
          _ref2$rich = _ref2.rich,
          rich = _ref2$rich === void 0 ? {} : _ref2$rich,
          _ref2$center = _ref2.center,
          center = _ref2$center === void 0 ? false : _ref2$center,
          _ref2$lineGap = _ref2.lineGap,
          lineGap = _ref2$lineGap === void 0 ? 0 : _ref2$lineGap;

      var _formatText = formatText(rich, row),
          _formatText$data = _formatText.data,
          data = _formatText$data === void 0 ? [] : _formatText$data,
          _formatText$text = _formatText.text,
          text = _formatText$text === void 0 ? '' : _formatText$text;

      var _calcParagraphSize = calcParagraphSize(data, center, lineGap),
          width = _calcParagraphSize[0],
          height = _calcParagraphSize[1];

      return {
        bounds: {
          width: width,
          height: height
        },
        data: data,
        text: text,
        rich: rich.style
      };
    }

    var H_GAP = 10; // 牵引线转折点距离标签的距离

    var TRACT_LINE_SIZE = 0.1; // 牵引线长度占比

    var TRACT_LINE_GAP = 3;
    function calcDataLabelPos(_ref) {
      var geom = _ref.geom,
          bounds = _ref.bounds,
          row = _ref.row,
          _ref$maxRadius = _ref.maxRadius,
          maxRadius = _ref$maxRadius === void 0 ? geom.maxRadius : _ref$maxRadius,
          position = _ref.position;
      var lw = bounds.width;
      var _geom$rotation = geom.rotation,
          rotation = _geom$rotation === void 0 ? 0 : _geom$rotation;
      var _row$shape = row.shape,
          r = _row$shape.r,
          r0 = _row$shape.r0,
          sa = _row$shape.startAngle,
          ea = _row$shape.endAngle;
      sa += rotation;
      ea += rotation;
      var ma = normalRadian((sa + ea) / 2),
          radius = position === DataLabel.INSIDE ? (r + r0) / 2 : maxRadius * (1 + TRACT_LINE_SIZE);

      var _calcPolarPos = calcPolarPos(radius, ma),
          x = _calcPolarPos[0],
          y = _calcPolarPos[1]; // label outside need adjust for tractLine


      if (position === DataLabel.OUTSIDE) {
        // 牵引线的三个点
        var p1 = calcPolarPos(r + TRACT_LINE_GAP, ma),
            p2 = [x, y],
            p3 = [x, y];
        var gap = H_GAP - TRACT_LINE_GAP;

        switch (calcAngleQuadrant(ma)) {
          case 2:
          case 3:
            x -= lw / 2 + H_GAP;
            p3[0] -= gap;
            break;

          default:
            x += lw / 2 + H_GAP;
            p3[0] += gap;
        } // storage tractLine points


        row.dataLabel.points = [p1, p2, p3];
      } // fixME 一个尴尬的问题就是，饼图绘制时扇形标签等都是相对于圆心计算的，但是标签调整又是对于整个分区，那么调整的时候用的位置应该是实际位置
      // 这里返回实际位置， 绘制的时候再把偏移去掉......


      return [x + row.x, y + row.y];
    }

    var PI$6 = Math.PI;
    var INNER_RADIUS_PERCENT = 2 / 3;
    var HOVER_PCT = 1.05;

    var sum$3 = function sum(points) {
      return reduce(points, function (total, _ref) {
        var vanish = _ref.vanish,
            size = _ref.size;
        return total + (vanish ? 0 : size);
      }, 0);
    };

    var getMultiPieMaxRadius = function getMultiPieMaxRadius(bounds) {
      return Math.min(bounds.width, bounds.height) * (0.5 / HOVER_PCT);
    };
    var layout = function layout(rows, props) {
      var _props$geom = props.geom,
          hierarchy = _props$geom.hierarchy,
          _props$geom$innerRadi = _props$geom.innerRadius,
          innerRadius = _props$geom$innerRadi === void 0 ? 0 : _props$geom$innerRadi,
          bounds = props.cell.bounds;
      var maxRadius = getMultiPieMaxRadius(bounds); // const validRows = filter(rows, row => !row.vanish);
      // 第一步，生成树形结构

      var root = generateTreeNode(rows, hierarchy); // 第二步，按照层级关系进行布局，计算row.shape

      layoutMultiPie(root, maxRadius, innerRadius); // 删除节点之间的依赖关系

      forEach(rows, function (row) {
        row.maxRadius = maxRadius;
        delete row.parent;
        delete row.children;
      });
      root = null;
    };
    /**
     * 多层饼图布局，计算startAngle&endAngle&r&r0
     * @param root
     * @param maxRadius
     * @param innerRadiusRatio
     */

    var layoutMultiPie = function layoutMultiPie(root, maxRadius, innerRadiusRatio) {
      var level = root.level - 1;
      var r0 = maxRadius * innerRadiusRatio,
          leftR = maxRadius - r0;
      var firstR, averageR; // 内径不为0是所有扇形径宽一致

      if (innerRadiusRatio) {
        averageR = leftR / level;
        firstR = r0 + averageR;
      } else {
        averageR = level === 1 ? 0 : leftR * (1 - INNER_RADIUS_PERCENT) / (level - 1);
        firstR = r0 + leftR * INNER_RADIUS_PERCENT;
      }

      function outerR(point) {
        if (level === 1) return maxRadius;
        return firstR + averageR * (point.depth - 1);
      }

      function innerR(point) {
        var dp = point.depth;

        if (dp === 0) {
          return 0;
        }

        return dp === 1 ? r0 : outerR(point.parent);
      }

      var dealChildren = function dealChildren(root) {
        if (root.shape == null) {
          root.shape = {
            startAngle: -PI$6 / 2,
            endAngle: PI$6 * 1.5
          };
        }

        var _root$shape = root.shape,
            startAngle = _root$shape.startAngle,
            endAngle = _root$shape.endAngle,
            totalAngle = endAngle - startAngle;
        var children = root.children,
            sumValue = sum$3(children);
        var preAngle = startAngle;
        forEach(root.children, function (point) {
          var angle = point.vanish ? 0 : point.size / sumValue * totalAngle;
          var r = outerR(point),
              r0 = innerR(point),
              pct = [r / maxRadius, r0 / maxRadius]; // fixMe 调整了半径之后，原来的占比关系就错乱了....

          point.shape = {
            startAngle: preAngle,
            endAngle: preAngle += angle,
            r: r,
            r0: r0,
            pct: pct
          };
          point.children && point.children.length && dealChildren(point);
        });
      };

      dealChildren(root);
    };
    /**
     * 多层饼图扇形颜色
     * @param color
     * @param ratio
     * @returns {*}
     */


    var getHSLFill = function getHSLFill(color, ratio) {
      var rgba = parse(color);
      var hsb = rgb2hsb(rgba[0], rgba[1], rgba[2]);
      var detS = -hsb[1] * ratio,
          detB = (1 - hsb[2]) * ratio;
      return mixColorWithHSB(color, 0, detS, detB);
    };
    /**
     * 从包含所有层级的扁平rows中，构建层级关系
     * @param rows
     * @param granularity
     */

    var generateTreeNode = function generateTreeNode(rows, granularity) {
      if (granularity === void 0) {
        granularity = [];
      }

      var dataMap = {},
          len = granularity.length; // 对于上一层的数据来说，下一层的细粒度对应的值为null，那么我们从最外层开始，依次过滤对应层级细粒度补位null的row，即为该层的元素

      var leftRows = rows;

      var _loop = function _loop(i) {
        var tmp = [],
            level = len - i,
            depth = len + 1 - level,
            key = granularity[i],
            data = dataMap[depth] = dataMap[depth] || [];
        forEach(leftRows, function (row) {
          if (row[key] == null) {
            tmp.push(row);
          } else {
            row.level = level;
            row.depth = depth;
            data.push(row);
          }
        });
        leftRows = tmp;
      };

      for (var i = len - 1; i >= 0; i--) {
        _loop(i);
      }

      var root = {
        id: '..root',
        depth: 0,
        level: Math.max(len + 1, 2),
        children: [],
        pids: [] // useful in multiPie while hover to find parentId

      };

      var relate = function relate(child, parent) {
        parent.children = parent.children || [];
        child.parent = parent;
        parent.children.push(child);
        child.pids = [].concat(parent.pids, [parent.id]);
      };

      var toKey = function toKey(datum, ids) {
        return map(ids, function (id) {
          return datum[id];
        }).join('*');
      };

      var _loop2 = function _loop2(i) {
        var data = dataMap[i + 1];
        forEach(data, function (datum) {
          var ids = granularity.slice(0, i);
          relate(datum, i === 0 ? root : find(dataMap[i], function (preDatum) {
            return toKey(preDatum, ids) === toKey(datum, ids);
          }));
        });
      };

      for (var i = 0; i < len; i++) {
        _loop2(i);
      }

      if (len === 0) {
        var row = rows[0];
        row.depth = row.level = 1;
        row.parent = root;
        row.pids = ['..root'];
        root.children.push(row);
      }

      return root;
    };
    /**
     * 处理高亮： 找出hoverRow以及其所有的parent
     * @param data
     * @param highlights
     */


    var dealHighlight = function dealHighlight(data, highlights) {
      var hoverIds = {};
      forEach(data, function (datum) {
        var id = datum.id;

        if (highlights[id]) {
          forEach([].concat(datum.pids, [id]), function (id) {
            hoverIds[id] = true;
          });
        }
      });
      return hoverIds;
    };

    var adjustMultiPieRadius = function adjustMultiPieRadius(_ref) {
      var geom = _ref.geom,
          rows = _ref.rows,
          cellBounds = _ref.cellBounds,
          position = _ref.position,
          cell = _ref.cell;
      var maxRadius = getMultiPieMaxRadius(cellBounds);
      var minPct = 0.5,
          step = 0.1;
      var left = cellBounds.x,
          top = cellBounds.y,
          width = cellBounds.width,
          height = cellBounds.height;
      var right = left + width,
          bottom = top + height;

      var outOfCell = function outOfCell(bounds) {
        var x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height;
        return x < left || y < top || x + width > right || y + height > bottom;
      };

      var pct = 1 - step,
          radius;

      var labelRows = _.filter(rows, function (row) {
        return row.dataLabel && row.level === 1;
      }),
          len = labelRows.length;

      if (labelRows.length === 0) {
        cell.maxRadius = maxRadius;
        return;
      }

      while (pct >= minPct) {
        radius = maxRadius * pct;
        var overflow = false;

        for (var i = 0; i < len; i++) {
          var row = labelRows[i],
              bounds = row.dataLabel.bounds;
          var pos = calcDataLabelPos$1({
            row: row,
            geom: geom,
            position: position,
            bounds: bounds,
            radius: radius
          });
          setCenter(bounds, pos);

          if (outOfCell(bounds)) {
            overflow = true;
            break;
          }
        }

        if (!overflow) {
          break;
        }

        pct -= step;
      } // update shape && labelPos


      _.each(rows, function (row) {
        var shape = row.shape,
            _shape$pct = shape.pct,
            rp = _shape$pct[0],
            r0p = _shape$pct[1]; // 多层饼图的最大半径放在分区上

        cell.maxRadius = radius;
        shape.r0 = radius * r0p;
        shape.r = radius * rp;

        if (row.dataLabel) {
          var _bounds = row.dataLabel.bounds;
          var center = calcDataLabelPos$1({
            row: row,
            geom: geom,
            position: position,
            bounds: _bounds,
            radius: radius
          });
          setCenter(_bounds, center);
        }
      });
    };
    var calcDataLabelPos$1 = function calcDataLabelPos$$1(_ref2) {
      var row = _ref2.row,
          geom = _ref2.geom,
          position = _ref2.position,
          bounds = _ref2.bounds,
          radius = _ref2.radius;

      // Note 由于多层饼图是由矩形树图转换的, 所以这里的position可能为center，这里统一作为Inside处理
      if (position !== DataLabel.OUTSIDE) {
        position = DataLabel.INSIDE;
      }

      return calcDataLabelPos({
        maxRadius: radius || getMultiPieMaxRadius(bounds),
        row: row,
        geom: geom,
        position: row.level === 1 ? position : DataLabel.INSIDE,
        bounds: bounds
      });
    };

    var LABEL_GAP = 0.2;

    var defaultPosition = function defaultPosition(_ref) {
      var row = _ref.row;
      return [row.x, row.y];
    };

    function dealLabel(_ref2) {
      var geom = _ref2.geom,
          rows = _ref2.rows,
          cellBounds = _ref2.cellBounds,
          manager = _ref2.manager,
          enableMap = _ref2.enableMap,
          cell = _ref2.cell;
      var type = geom.type,
          measure = geom.measure,
          dataLabel = geom.dataLabel,
          labelFields = geom.dataLabel.fields,
          dataModel = geom.data;
      var showWay = dataLabel.showWay,
          allowOverlap = dataLabel.allowOverlap,
          valid = dataLabel.valid,
          adjust = dataLabel.adjust,
          position = dataLabel.position;

      if (!valid) {
        return;
      }

      var _Geom$getGeom = Geom.getGeom(type, enableMap),
          _Geom$getGeom$adjustL = _Geom$getGeom.adjustLater,
          adjustLater = _Geom$getGeom$adjustL === void 0 ? false : _Geom$getGeom$adjustL,
          _Geom$getGeom$calcDat = _Geom$getGeom.calcDataLabelPos,
          calcDataLabelPos = _Geom$getGeom$calcDat === void 0 ? defaultPosition : _Geom$getGeom$calcDat,
          _Geom$getGeom$adjustD = _Geom$getGeom.adjustDataLabel,
          adjustDataLabel = _Geom$getGeom$adjustD === void 0 ? adjustLabel : _Geom$getGeom$adjustD;

      var validRows = _.filter(rows, function (row) {
        return !row.vanish;
      }); // http://www.finedevelop.com/pages/viewpage.action?pageId=18661273
      // 显示最大最小值


      if (showWay === DataLabel.EXTREME) {
        var labelMeasures = _.filter(labelFields, function (fieldId) {
          return dataModel.isMeasure(fieldId);
        });

        var id = labelMeasures.pop() || (dataModel.contains(measure) ? measure : null); // measure 为 graphic且标签中没有指标字段的时候，显示全部标签
        // geom measure 为 graphic 的时候显示全部标签

        if (id) {
          // @BI-28956
          var sorted = _.filter(rows, function (row) {
            return !isNaN(+row[id]);
          }).sort(function (a, b) {
            return a[id] - b[id];
          });

          if (sorted.length <= 2) {
            validRows = sorted;
          } else {
            validRows = [];
            var min = sorted[0][id],
                max = sorted[sorted.length - 1][id]; // @BI-32554: 1, 1, 2,3, 4, 5, 5, 5 => [1, 1, 5, 5, 5]

            _.each(sorted, function (row) {
              (row[id] === min || row[id] === max) && validRows.push(row);
            });
          }
        }
      }

      var validLabelRows = _.filter(validRows, function (row) {
        var _rowToParagraphProp = rowToParagraphProp({
          row: row,
          rich: dataLabel,
          lineGap: LABEL_GAP
        }),
            bounds = _rowToParagraphProp.bounds,
            text = _rowToParagraphProp.text; // 过滤掉空label，不做多余的计算


        if (text === '') {
          return false;
        }

        row.dataLabel = {
          bounds: bounds,
          text: text
        };
        var pos = calcDataLabelPos({
          row: row,
          geom: geom,
          bounds: bounds,
          position: position,
          cell: cell
        });
        pos && setCenter(bounds, pos);
        return true;
      });

      if (geom.type === ChartLibrary.MULTI_PIE && position === DataLabel.OUTSIDE) {
        adjustMultiPieRadius({
          rows: rows,
          geom: geom,
          position: position,
          cellBounds: cellBounds,
          cell: cell
        });
      }

      !allowOverlap && !adjustLater && adjustDataLabel({
        rows: validLabelRows,
        geom: geom,
        manager: manager,
        adjust: adjust,
        cellBounds: cellBounds,
        position: position,
        // multiPie 的 maxRadius 在cell属性上
        cell: cell
      });
    }

    var applyRowColorToLabelRichStyle = function applyRowColorToLabelRichStyle(row, _ref, applyTheme, style, autoColor) {
      var position = _ref.position,
          textFill = _ref.textFill;
      var out = {};
      var inside = position === DataLabel.CENTER || position === DataLabel.INSIDE;
      forOwn(style, function (v, k) {
        out[k] = _extends({}, v, {
          textLineHeight: v.fontSize * (LABEL_GAP + 1),
          textFill: v.textFill || autoColor || (inside || applyTheme ? textFill : row.color)
        });
      });
      return out;
    };

    var LABEL_KEY = '_label';

    var appear = function appear(_ref2) {
      var style = _ref2.style;
      return {
        style: _extends({}, style, {
          opacity: 0
        })
      };
    };

    var getEnterLabelTransition = function getEnterLabelTransition(delay) {
      return {
        delay: delay,
        duration: 400,
        ease: Ease.Default,
        appear: appear
      };
    };

    function renderDataLabel$$1(_ref3) {
      var node = _ref3.node,
          animation = _ref3.animation,
          dataLabel = _ref3.dataLabel,
          translate = _ref3.translate,
          scale = _ref3.scale,
          process = _ref3.process,
          gTransition = _ref3.transition,
          absolutePos = _ref3.position,
          _ref3$ref = _ref3.ref,
          ref = _ref3$ref === void 0 ? DO_NOTHING : _ref3$ref,
          isFade = _ref3.isFade,
          _ref3$z = _ref3.z,
          z = _ref3$z === void 0 ? LabelLayerZ : _ref3$z,
          invisible = _ref3.invisible,
          applyTheme = _ref3.applyTheme,
          _ref3$autoColor = _ref3.autoColor,
          autoColor = _ref3$autoColor === void 0 ? '' : _ref3$autoColor,
          tractLine = _ref3.tractLine,
          rest = _objectWithoutPropertiesLoose(_ref3, ["node", "animation", "dataLabel", "translate", "scale", "process", "transition", "position", "ref", "isFade", "z", "invisible", "applyTheme", "autoColor", "tractLine"]);

      var _ref4 = node || rest,
          data = _ref4.data,
          _ref4$row = _ref4.row,
          row = _ref4$row === void 0 ? data : _ref4$row,
          type = _ref4.type,
          condition = _ref4.condition,
          prevCondition = _ref4.prevCondition;

      if (!row || !row.dataLabel || !row.dataLabel.text) {
        return null;
      }

      var isHover = condition === HOVER;
      var innerLabel = dataLabel.position === DataLabel.CENTER || dataLabel.position === DataLabel.INSIDE;

      if (!translate) {
        translate = isHover && !innerLabel ? [0, -DataLabel.HOVER_TRANS] : [0, 0];
      }

      if (!scale) {
        scale = isHover && innerLabel ? DataLabel.HOVER_SCALE : [1, 1];
      }

      var _row$dataLabel = row.dataLabel,
          text = _row$dataLabel.text,
          bounds = _row$dataLabel.bounds,
          id = row.id;
      var key = id + LABEL_KEY;
      var position = absolutePos || getBoundsCenter(bounds);

      if (translate) {
        position[0] += translate[0];
        position[1] += translate[1];
      }

      var style = {
        text: text,
        rich: applyRowColorToLabelRichStyle(row, dataLabel, applyTheme, dataLabel.style, autoColor),
        fontSize: 12,
        textAlign: 'center',
        textVerticalAlign: 'middle',
        textShadowColor: 'rgba(0, 0, 0, 0.15)',
        textShadowOffsetX: 0.5,
        textShadowOffsetY: 0.5,
        textShadowBlur: 1,
        opacity: 1
      };

      if (isFade) {
        fadeStyle(style);
      }

      var _ref5 = gTransition || {},
          _ref5$duration = _ref5.duration,
          duration = _ref5$duration === void 0 ? 0 : _ref5$duration,
          _ref5$delay = _ref5.delay,
          delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
          _ref5$ease = _ref5.ease,
          ease = _ref5$ease === void 0 ? Ease.Default : _ref5$ease;

      var transition, transitionEnd;

      if (animation) {
        if (type === ENTER) {
          transition = getEnterLabelTransition(delay + duration);
        } else if (type === UPDATE) {
          if (isHover || prevCondition === HOVER) {
            transition = {
              delay: delay,
              duration: duration,
              ease: ease
            };
          } else if (process === SHOW || process === HIDE) {
            transition = {
              delay: delay,
              duration: duration,
              ease: ease
            };
          }
        } else if (type === LEAVE) {
          return null;
        }
      }

      var labelNode = h('text', {
        key: key,
        id: key,
        invisible: invisible,
        silent: true,
        scale: scale,
        ref: ref,
        transition: transition,
        transitionEnd: transitionEnd,
        position: position,
        z: z,
        style: style
      });
      var tractLineNode = tractLine ? h('polyline', _extends({}, tractLine, {
        invisible: invisible,
        transition: transition,
        transitionEnd: transitionEnd,
        style: {
          lineWidth: 0.5,
          stroke: row.color,
          opacity: isFade ? Fade.Opacity : 1
        }
      })) : null;
      return [tractLineNode, labelNode];
    }

    var TILT_ANGLE = Math.PI / 6; // 30°

    var LINE_LENGTH = 19;
    var V_DISTANCE = LINE_LENGTH * Math.sin(TILT_ANGLE);
    var H_DISTANCE = LINE_LENGTH * Math.cos(TILT_ANGLE);
    /**
     * 调整Annotation的方向，尽量保证不超出cellBounds
     * @param cellBounds
     * @param bounds
     * @param startPos
     * @param direction
     * @returns {{adjustDir: string, endPos: *[]}}
     */

    function adjustAnnotation(_ref) {
      var cellBounds = _ref.cellBounds,
          bounds = _ref.bounds,
          startPos = _ref.startPos,
          _ref$direction = _ref.direction,
          direction = _ref$direction === void 0 ? Direction.RIGHT_TOP : _ref$direction;
      var sx = startPos[0],
          sy = startPos[1];
      var cx = cellBounds.x,
          cy = cellBounds.y,
          cw = cellBounds.width,
          ch = cellBounds.height;
      var width = bounds.width,
          height = bounds.height;

      var _direction$split = direction.split(Direction.SEPARATOR),
          hDir = _direction$split[0],
          vDir = _direction$split[1];

      var _hDir = hDir,
          _vDir = vDir; // 竖直方向调整

      if (vDir === Direction.TOP && sy - V_DISTANCE - height < cy) {
        _vDir = Direction.BOTTOM;
      } else if (vDir === Direction.BOTTOM && sy + V_DISTANCE + height > cy + ch) {
        _vDir = Direction.TOP;
      }

      var ey = sy + V_DISTANCE * (vDir === Direction.BOTTOM ? 1 : -1),
          ex = sx + H_DISTANCE * (hDir === Direction.RIGHT ? 1 : -1);
      var left = sx - H_DISTANCE - width,
          right = sx + H_DISTANCE + width; // 水平方向调整

      if (hDir === Direction.RIGHT && right > cx + cw) {
        // 放左边仍旧会溢出，则在右边调整位置，最多调整到牵引钱垂直
        if (left < cx) {
          ex = Math.max(sx, cx - width);
        } else {
          ex = sx - H_DISTANCE;
          _hDir = Direction.LEFT;
        }
      } else if (hDir === Direction.LEFT && left < cx) {
        if (right > cx + cw) {
          ex = Math.min(sx, cx + width);
        } else {
          ex = sx + H_DISTANCE;
          _hDir = Direction.RIGHT;
        }
      }

      return {
        adjustDir: _hDir + Direction.SEPARATOR + _vDir,
        // 注释框相对于牵引线起始点的方向
        endPos: [ex - sx, ey - sy] // 牵引线结束点位置

      };
    }

    var FILL = '#D7D7D7';
    var OPACITY = 0.5;
    var CIRCLE_SIZE = 4;
    var BACKGROUND_GAP = 5;
    var BACKGROUND_RADIUS = 2;
    var style$1 = {
      fill: FILL,
      opacity: OPACITY
    };

    var getBackgroundShape = function getBackgroundShape(bounds, position, direction) {
      var w = bounds.width,
          h$$1 = bounds.height,
          x = position[0],
          y = position[1],
          _direction$split = direction.split(Direction.SEPARATOR),
          hDir = _direction$split[0],
          vDir = _direction$split[1];

      var height = h$$1 + BACKGROUND_GAP * 2,
          width = w + BACKGROUND_GAP * 2;
      return {
        x: x + (hDir === Direction.RIGHT ? 0 : -width),
        y: y + (vDir === Direction.BOTTOM ? 0 : -height),
        width: width,
        height: height,
        r: BACKGROUND_RADIUS
      };
    };

    var getCircleEnterTransition = function getCircleEnterTransition(delay) {
      return {
        delay: delay,
        duration: 200,
        ease: Ease.A,
        appear: function appear(_ref) {
          var shape = _ref.shape;
          return {
            shape: _extends({}, shape, {
              r: 0
            })
          };
        }
      };
    };

    var getLineEnterTransition = function getLineEnterTransition(delay) {
      return {
        delay: delay + 200,
        duration: 200,
        ease: Ease.Default,
        appear: function appear(_ref2) {
          var _ref2$shape = _ref2.shape,
              x1 = _ref2$shape.x1,
              y1 = _ref2$shape.y1;
          return {
            shape: {
              x1: x1,
              y1: y1,
              x2: x1,
              y2: y1
            }
          };
        }
      };
    };

    var getRectEnterTransition = function getRectEnterTransition(delay, direction) {
      return {
        delay: delay + 400,
        duration: 200,
        ease: Ease.Default,
        appear: function appear(_ref3) {
          var _ref3$shape = _ref3.shape,
              x = _ref3$shape.x,
              y = _ref3$shape.y,
              width = _ref3$shape.width,
              height = _ref3$shape.height;

          var _direction$split2 = direction.split(Direction.SEPARATOR),
              hDir = _direction$split2[0],
              vDir = _direction$split2[1];

          if (hDir === Direction.LEFT) {
            x -= width;
          }

          if (vDir === Direction.TOP) {
            y += height;
          }

          width = 0;
          height = 0;
          return {
            shape: {
              x: x,
              y: y,
              width: width,
              height: height
            }
          };
        }
      };
    };

    var getTextEnterTransition = function getTextEnterTransition(delay) {
      return {
        delay: delay + 600,
        ease: Ease.Default,
        duration: 200,
        appear: function appear(_ref4) {
          var style = _ref4.style;
          return {
            style: _extends({}, style, {
              opacity: 0
            })
          };
        }
      };
    };

    var renderAnnotation = function renderAnnotation(_ref5) {
      var node = _ref5.node,
          gTransition = _ref5.transition,
          isHover = _ref5.isHover,
          _ref5$startPos = _ref5.startPos,
          startPos = _ref5$startPos === void 0 ? [0, 0] : _ref5$startPos,
          _ref5$translate = _ref5.translate,
          translate = _ref5$translate === void 0 ? [0, 0] : _ref5$translate,
          hoverTranslate = _ref5.hoverTranslate,
          direction = _ref5.direction,
          cellBounds = _ref5.cellBounds,
          invisible = _ref5.invisible,
          rest = _objectWithoutPropertiesLoose(_ref5, ["node", "transition", "isHover", "startPos", "translate", "hoverTranslate", "direction", "cellBounds", "invisible"]);

      var _ref6 = node || rest,
          data = _ref6.data,
          _ref6$row = _ref6.row,
          row = _ref6$row === void 0 ? data : _ref6$row,
          type = _ref6.type,
          condition = _ref6.condition,
          prevCondition = _ref6.prevCondition;

      if (!row || !row.annotation) {
        return null;
      }

      var key = row.id;

      if (!hoverTranslate) {
        hoverTranslate = isHover ? [0, -DataLabel.HOVER_TRANS] : [0, 0];
      }

      var _rowToParagraphProp = rowToParagraphProp({
        row: row,
        rich: row.annotation
      }),
          bounds = _rowToParagraphProp.bounds,
          text = _rowToParagraphProp.text,
          rich = _rowToParagraphProp.rich;

      var x1 = startPos[0],
          y1 = startPos[1],
          tx = translate[0],
          ty = translate[1],
          _hoverTranslate = hoverTranslate,
          hx = _hoverTranslate[0],
          hy = _hoverTranslate[1];

      var _adjustAnnotation = adjustAnnotation({
        cellBounds: cellBounds,
        bounds: bounds,
        startPos: [x1 + tx, y1 + ty],
        direction: direction
      }),
          endPos = _adjustAnnotation.endPos,
          adjustDir = _adjustAnnotation.adjustDir;

      var x2 = endPos[0],
          y2 = endPos[1];
      x1 += hx;
      y1 += hy;
      var circleShape = {
        r: CIRCLE_SIZE,
        cx: 0,
        cy: 0
      };
      var lineShape = {
        x1: 0,
        y1: 0,
        x2: x2,
        y2: y2
      };
      var rectShape = getBackgroundShape(bounds, endPos, adjustDir);
      var circleTransition, lineTransition, rectTransition, textTransition;

      var _ref7 = gTransition || {},
          _ref7$delay = _ref7.delay,
          delay = _ref7$delay === void 0 ? 0 : _ref7$delay,
          _ref7$duration = _ref7.duration,
          duration = _ref7$duration === void 0 ? 0 : _ref7$duration,
          _ref7$ease = _ref7.ease,
          ease = _ref7$ease === void 0 ? Ease.Default : _ref7$ease;

      var total = delay + duration;

      if (type === ENTER) {
        circleTransition = getCircleEnterTransition(total);
        lineTransition = getLineEnterTransition(total);
        rectTransition = getRectEnterTransition(total, adjustDir);
        textTransition = getTextEnterTransition(total);
      } else if (type === UPDATE) {
        if (condition === HOVER || prevCondition === HOVER) {
          circleTransition = lineTransition = rectTransition = textTransition = {
            delay: delay,
            duration: duration,
            ease: ease
          };
        } else {
          circleTransition = getCircleEnterTransition(total);
          lineTransition = getLineEnterTransition(total);
          rectTransition = getRectEnterTransition(total, adjustDir);
          textTransition = getTextEnterTransition(total);
        }
      } else if (type === LEAVE) {
        return null;
      }

      var circleNode = h('circle', {
        key: key + ANNOTATION_CIRCLE_SUFFIX,
        silent: true,
        transition: circleTransition,
        z: AnnotationZ,
        shape: circleShape,
        invisible: invisible,
        style: style$1
      });
      var lineNode = h('line', {
        key: key + ANNOTATION_LINE_SUFFIX,
        transition: lineTransition,
        silent: true,
        z: AnnotationZ,
        shape: lineShape,
        invisible: invisible,
        style: {
          stroke: FILL,
          opacity: OPACITY
        }
      });
      var backgroundNode = h('rect', {
        key: key + ANNOTATION_RECT_SUFFIX,
        transition: rectTransition,
        silent: true,
        z: AnnotationZ,
        shape: rectShape,
        style: style$1,
        invisible: invisible
      });
      var x = rectShape.x,
          y = rectShape.y,
          height = rectShape.height;
      var textNode = h('text', {
        key: key + ANNOTATION_TEXT_SUFFIX,
        transition: textTransition,
        silent: true,
        z: AnnotationZ,
        invisible: invisible,
        position: [x + BACKGROUND_GAP, y + height / 2],
        style: {
          fontSize: 12,
          text: text,
          textAlign: 'left',
          textVerticalAlign: 'middle',
          rich: cloneRichStyle(rich),
          opacity: 1
        }
      });
      var groupKey = key + ANNOTATION_GROUP_SUFFIX;
      return h('group', {
        position: [x1, y1],
        key: groupKey,
        id: groupKey
      }, circleNode, lineNode, backgroundNode, textNode);
    };

    var Geometry =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Geometry, _Component);

      function Geometry(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this; // 用于缓存当前CellGeometryGroup下所有实例化的ZRElement

        _this._nodeHash = {}; // 缓存需要在component.render之后开始的闪烁动画

        _this._effectHash = {}; // 缓存实现闪烁动画的effectAnimator

        _this._effectAnimators = {};
        _this._getGroup = _this._getGroup.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this._init = true;
        return _this;
      }
      /**
       * 这里提供一个便捷的快速创建EffectAni的方法
       * 具体的动画帧计算需要手动写during
       * @param id
       * @param effect
       * @param duration
       * @param delay
       * @returns {*}
       */


      var _proto = Geometry.prototype;

      _proto.createEffectAni = function createEffectAni(id, effect, duration, delay) {
        if (delay === void 0) {
          delay = 0;
        }

        var zr = this.props.zr;
        var animator = new Animator({
          pct: 0
        }, true).when(duration, {
          pct: 1
        }).delay(delay);
        zr.animation.addAnimator(animator);

        if (!this._effectAnimators[id]) {
          this._effectAnimators[id] = [];
          this._effectAnimators[id]._effect = effect; // cache effect duration
        }

        this._effectAnimators[id].push(animator);

        return animator;
      }
      /**
       * 更新NodeHash
       */
      ;

      _proto._updateNodeHash = function _updateNodeHash() {
        var _groupNode = this._groupNode;

        if (!_groupNode) {
          return;
        }

        var hash = {};

        _.each(_groupNode._children, function (child) {
          if (child.key) {
            hash[child.key] = child;
          }
        });

        this._nodeHash = hash;
      }
      /**
       * 获取row
       * @param id
       * @returns {*}
       */
      ;

      _proto.getRow = function getRow(id) {
        return this.props.rowMap[id];
      };

      _proto.componentDidMount = function componentDidMount() {
        this._init = false;

        this._updateNodeHash();
      };

      _proto.componentDidUpdate = function componentDidUpdate() {
        var _this2 = this;

        this._updateNodeHash(); // 移除特定闪烁动画:
        // 1. 原始row不存在或者row上effect为0
        // 2. effect时间发生改变的


        _.each(this._effectAnimators, function (animators, id) {
          var row = _this2.getRow(id),
              oldEffect = animators._effect,
              effect = row && row.effect;

          if (_this2._unValidEffectIds[id] || oldEffect !== effect) {
            _.each(animators, function (ani) {
              return ani.stop();
            });

            delete _this2._effectAnimators[id];
          }
        }); // 对于那些update却没有transitionEnd触发异步闪烁动画的
        // 统一在componentDidUpdate里触发


        _.each(this._effectHash, function (effect, id) {
          return _this2._showEffect(id, effect);
        });

        this._effectHash = {};
      }
      /**
       * 创建闪烁动画，此时的EffectNode已经被实例化
       * NOTE http://kms.finedevelop.com/pages/editpage.action?pageId=44886145 -> Effect
       */
      ;

      _proto._showEffect = function _showEffect(id, effect) {
        if (this._effectAnimators[id]) {
          return;
        }

        this.showEffect(id, effect);
      }
      /**
       * 根据具体图形的闪烁动画实现效果，创建animators实现闪烁动画
       */
      ;

      _proto.showEffect = function showEffect()
      /* id, effect */
      {}
      /**
       * 根据id获取对应的ZRElement
       * NOTE 应该在componentRender之后使用
       * @param id
       * @returns {*}
       */
      ;

      _proto.getZNode = function getZNode(id) {
        return this._nodeHash[id];
      }
      /**
       * 记录groupNode
       * @param el
       * @private
       */
      ;

      _proto._getGroup = function _getGroup(el) {
        return el ? this._groupNode = el : this._groupNode;
      }
      /**
       * 获取group.props.用于render
       * @returns {{onmouseover: *, onmousemove: *, onmouseout: *, onclick: *, ref: Geometry._getGroup}}
       */
      ;

      _proto.getGroupProps = function getGroupProps() {
        var _this3 = this;

        var _this$props = this.props,
            animation = _this$props.animation,
            onmouseover = _this$props.onmouseover,
            onmouseout = _this$props.onmouseout,
            onclick = _this$props.onclick;
        var props = {
          onmouseover: onmouseover,
          onmousemove: onmouseover,
          onmouseout: onmouseout,
          onclick: onclick,
          ref: this._getGroup
        };

        if (this._groupTransition && animation) {
          props.transition = this._groupTransition;

          props.transitionEnd = function () {
            return _this3.triggerGroupEffects();
          };
        }

        return props;
      }
      /**
       * 统一触发闪烁动画
       */
      ;

      _proto.triggerGroupEffects = function triggerGroupEffects() {
        var _this4 = this;

        var rows = this.props.rows;

        _.each(rows, function (row) {
          var id = row.id,
              effect = row.effect;
          effect && !_this4._unValidEffectIds[id] && _this4._showEffect(id, effect);
        });
      }
      /**
       * group transition for some geometry like pie or treeMap
       * @returns {null}
       */
      ;

      _proto.getGroupTransition = function getGroupTransition() {
        return null;
      };

      _proto.render = function render$$1() {
        var _this5 = this;

        var _this$props2 = this.props,
            animation = _this$props2.animation,
            process = _this$props2.process,
            rows = _this$props2.rows,
            fadeChecker = _this$props2.fadeChecker,
            highlights = _this$props2.highlights,
            bounds = _this$props2.bounds,
            dataLabel = _this$props2.dataLabel,
            opacity = _this$props2.opacity;
        this._groupTransition = this.getGroupTransition();
        var unValidEffectIds = this._unValidEffectIds = {};
        var getTransitionProps = this.getTransitionProps;
        var data = this.state.data;
        return h(NodeGroup$$2, {
          data: data || rows,
          process: process,
          fadeChecker: fadeChecker,
          highlights: highlights
        }, function (nodes, clean) {
          return h('group', _this5.getGroupProps(), _.map(nodes, function (node, index) {
            var key = node.key,
                row = node.data,
                type = node.type,
                condition = node.condition;
            var effect = row.effect;
            var isFade = condition === FADE,
                isHover = condition === HOVER,
                isLeave = type === LEAVE,
                isEnter = type === ENTER,
                isUpdate = type === UPDATE;
            var transitionProps = getTransitionProps && animation ? getTransitionProps(node, process, clean) : {};
            var effectValid = effect && !(isFade || isLeave || row.vanish); // cache for remove animator when componentDidUpdate

            if (!effectValid) {
              unValidEffectIds[key] = true;
            }

            var guideRefer = {};

            if (transitionProps) {
              transitionProps.isFade = isFade;
              transitionProps.isHover = isHover;
              transitionProps.isLeave = isLeave;
              transitionProps.isEnter = isEnter;
              transitionProps.isUpdate = isUpdate;
              transitionProps.z = isHover ? HoverLayerZ : NormalLayerZ;
              transitionProps.silent = isFade || isLeave;
              var transitionEnd = transitionProps.transitionEnd,
                  transition = transitionProps.transition;

              if (effectValid) {
                // 图形存在过渡动画的在过渡动画之后触发闪烁动画
                if (transition) {
                  transitionProps.transitionEnd = function (el) {
                    transitionEnd && transitionEnd(el);

                    _this5._showEffect(key, effect);
                  };
                } // 否则cache一下id，在componentDidUpdate里面统一触发
                else {
                    _this5._effectHash[key] = effect;
                  }
              }

              guideRefer = {
                node: node,
                key: key,
                animation: animation,
                transition: transition,
                process: process,
                isFade: isFade,
                isHover: isHover,
                cellBounds: bounds,
                opacity: opacity,
                dataLabel: dataLabel
              };
            }

            var graphicNode = _this5.renderGraphic(node, transitionProps, index); // NOTE 这里的refer只是绘制label需要的数据的引用，具体的绘制场景中可能还会添加新的东西


            _this5.addExtraGuideReferProps(guideRefer, node);

            var guides = _this5.renderGuides(guideRefer, node);

            var effectNodes = effect && _this5.renderEffect(node);

            return [effectNodes, graphicNode, guides];
          }));
        });
      }
      /**
       * 添加额外的属性到GuideRefer上
       */
      ;

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps()
      /* refer, node */
      {}
      /**
       * 绘制图形
       */
      ;

      _proto.renderGraphic = function renderGraphic()
      /* node, transitionProps */
      {}
      /**
       * 绘制标签,注释等
       */
      ;

      _proto.renderGuides = function renderGuides(refer) {
        return [renderDataLabel$$1(refer), renderAnnotation(refer)];
      }
      /**
       * Effect 比较特殊，单独拿出来
       */
      ;

      _proto.renderEffect = function renderEffect()
      /* node */
      {};

      return Geometry;
    }(Component);

    Geometry.getRowBounds = function (row, xValue, inverted) {
      var posX = +xValue || 0;
      var posY = +row['y'] || 0;
      var size = +row[AesTypes.SIZE] || 0;

      var _ref = inverted ? [posY, posX] : [posX, posY],
          x = _ref[0],
          y = _ref[1];

      x -= size;
      y -= size;
      return {
        x: x,
        y: y,
        width: size * 2,
        height: size * 2
      };
    };

    Geometry.getShapeBounds = function (row) {
      var shape = row.shape,
          x = row.x,
          y = row.y,
          size = row.size;
      return shape ? shape : {
        x: x,
        y: y,
        width: size * 2,
        height: size * 2
      };
    };

    var _loadedGeom = {};

    var defaultLayout = function defaultLayout(rows, _ref) {
      var inverted = _ref.inverted;
      return _.each(rows, function (row) {
        exchangeXY(row, inverted);
      });
    };

    var DO_NOTHING$1 = function DO_NOTHING() {};

    function registerGeom(type, GeomComponent) {
      // set default method
      if (!GeomComponent.layout) {
        GeomComponent.layout = defaultLayout;
      }

      if (!GeomComponent.adjust) {
        GeomComponent.adjust = DO_NOTHING$1;
      }

      if (!GeomComponent.dealData) {
        GeomComponent.dealData = DO_NOTHING$1;
      }

      if (!GeomComponent.getRowBounds) {
        GeomComponent.getRowBounds = Geometry.getRowBounds;
      }

      if (!GeomComponent.getShapeBounds) {
        GeomComponent.getShapeBounds = Geometry.getShapeBounds;
      }

      _loadedGeom[type] = GeomComponent;
    }

    function getGeom(type, isMap) {
      if (isMap === void 0) {
        isMap = false;
      }

      type = isMap ? getMapGeomType(type) : type;
      return _loadedGeom[type];
    }

    function getMapGeomType(type) {
      if (type === 'square' || type === 'treeMap') {
        return 'pillar';
      }

      if (type === 'forcePoint') {
        return 'point';
      }

      if (type === 'wordCloud') {
        return 'text';
      }

      return type;
    }

    var getAes = function getAes(aesthetics, type) {
      var aes = null;

      _.each(aesthetics, function (aesthetic) {
        if (aesthetic.type == type) {
          aes = aesthetic;
        }
      });

      return aes;
    };

    var createGeomGroup = function createGeomGroup(type, Geometry$$1) {
      var createGeomGroup = function createGeomGroup(props) {
        var rows = props.rows;

        var groupedRows = _.groupBy(rows, function (row) {
          return row.groupId;
        });

        return h('group', null, _.map(groupedRows, function (rows) {
          return h(Geometry$$1, _extends({}, props, {
            rows: rows
          }));
        }));
      };

      createGeomGroup.displayName = type[0].toUpperCase() + type.substr(1) + 'Group';
      registerGeom(type, createGeomGroup);
      return createGeomGroup;
    };

    var Geom = {
      registerGeom: registerGeom,
      createGeomGroup: createGeomGroup,
      getGeom: getGeom,
      getAes: getAes,
      diffFacet: diffFacet
    };

    /*
     * @namespace Util
     *
     * Various utility functions, used by Leaflet internally.
     */

    Object.freeze = function (obj) {
      return obj;
    }; // @function extend(dest: Object, src?: Object): Object
    // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.


    function extend$4(dest) {
      var i, j, len, src;

      for (j = 1, len = arguments.length; j < len; j++) {
        src = arguments[j];

        for (i in src) {
          dest[i] = src[i];
        }
      }

      return dest;
    } // @function create(proto: Object, properties?: Object): Object
    // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

    var create$3 = Object.create || function () {
      function F() {}

      return function (proto) {
        F.prototype = proto;
        return new F();
      };
    }(); // @function bind(fn: Function, …): Function
    // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
    // Has a `L.bind()` shortcut.

    function bind$1(fn, obj) {
      var slice = Array.prototype.slice;

      if (fn.bind) {
        return fn.bind.apply(fn, slice.call(arguments, 1));
      }

      var args = slice.call(arguments, 2);
      return function () {
        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
      };
    } // @property lastId: Number
    // Last unique ID used by [`stamp()`](#util-stamp)

    var lastId = 0; // @function stamp(obj: Object): Number
    // Returns the unique ID of an object, assiging it one if it doesn't have it.

    function stamp(obj) {
      /*eslint-disable */
      obj._leaflet_id = obj._leaflet_id || ++lastId;
      return obj._leaflet_id;
      /*eslint-enable */
    } // @function throttle(fn: Function, time: Number, context: Object): Function
    // Returns a function which executes function `fn` with the given scope `context`
    // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
    // `fn` will be called no more than one time per given amount of `time`. The arguments
    // received by the bound function will be any arguments passed when binding the
    // function, followed by any arguments passed when invoking the bound function.
    // Has an `L.throttle` shortcut.

    function throttle(fn, time, context) {
      var lock, args, wrapperFn, later;

      later = function later() {
        // reset lock and call if queued
        lock = false;

        if (args) {
          wrapperFn.apply(context, args);
          args = false;
        }
      };

      wrapperFn = function wrapperFn() {
        if (lock) {
          // called too soon, queue to call later
          args = arguments;
        } else {
          // call and lock until later
          fn.apply(context, arguments);
          setTimeout(later, time);
          lock = true;
        }
      };

      return wrapperFn;
    } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
    // Returns the number `num` modulo `range` in such a way so it lies within
    // `range[0]` and `range[1]`. The returned value will be always smaller than
    // `range[1]` unless `includeMax` is set to `true`.

    function wrapNum(x, range, includeMax) {
      var max = range[1],
          min = range[0],
          d = max - min;
      return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
    } // @function falseFn(): Function
    // Returns a function which always returns `false`.

    function falseFn() {
      return false;
    } // @function formatNum(num: Number, digits?: Number): Number
    // Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.

    function formatNum(num, digits) {
      var pow = Math.pow(10, digits || 5);
      return Math.round(num * pow) / pow;
    } // @function trim(str: String): String
    // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)

    function trim$1(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    } // @function splitWords(str: String): String[]
    // Trims and splits the string on whitespace and returns the array of parts.

    function splitWords(str) {
      return trim$1(str).split(/\s+/);
    } // @function setOptions(obj: Object, options: Object): Object
    // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.

    function setOptions(obj, options) {
      if (!obj.hasOwnProperty('options')) {
        obj.options = obj.options ? create$3(obj.options) : {};
      }

      for (var i in options) {
        obj.options[i] = options[i];
      }

      return obj.options;
    } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
    // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
    // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
    // be appended at the end. If `uppercase` is `true`, the parameter names will
    // be uppercased (e.g. `'?A=foo&B=bar'`)

    function getParamString(obj, existingUrl, uppercase) {
      var params = [];

      for (var i in obj) {
        params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
      }

      return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
    }
    var templateRe = /\{ *([\w_\-]+) *\}/g; // @function template(str: String, data: Object): String
    // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
    // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
    // `('Hello foo, bar')`. You can also specify functions instead of strings for
    // data values — they will be evaluated passing `data` as an argument.

    function template(str, data) {
      return str.replace(templateRe, function (str, key) {
        var value = data[key];

        if (value === undefined) {
          throw new Error('No value provided for variable ' + str);
        } else if (typeof value === 'function') {
          value = value(data);
        }

        return value;
      });
    } // @function isArray(obj): Boolean
    // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)

    var isArray$2 = Array.isArray || function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    }; // @function indexOf(array: Array, el: Object): Number
    // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)

    function indexOf$1(array, el) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === el) {
          return i;
        }
      }

      return -1;
    } // @property emptyImageUrl: String
    // Data URI string containing a base64-encoded empty GIF image.
    // Used as a hack to free memory from unused images on WebKit-powered
    // mobile devices (by setting image `src` to this string).

    var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

    function getPrefixed(name) {
      return window['webkit' + name] || window['moz' + name] || window['ms' + name];
    }

    var lastTime = 0; // fallback for IE 7-8

    function timeoutDefer(fn) {
      var time = +new Date(),
          timeToCall = Math.max(0, 16 - (time - lastTime));
      lastTime = time + timeToCall;
      return window.setTimeout(fn, timeToCall);
    }

    var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
    var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
      window.clearTimeout(id);
    }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
    // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
    // `context` if given. When `immediate` is set, `fn` is called immediately if
    // the browser doesn't have native support for
    // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
    // otherwise it's delayed. Returns a request ID that can be used to cancel the request.

    function requestAnimFrame(fn, context, immediate) {
      if (immediate && requestFn === timeoutDefer) {
        fn.call(context);
      } else {
        return requestFn.call(window, bind$1(fn, context));
      }
    } // @function cancelAnimFrame(id: Number): undefined
    // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).

    function cancelAnimFrame(id) {
      if (id) {
        cancelFn.call(window, id);
      }
    }

    /*
     * @class Point
     * @aka L.Point
     *
     * Represents a point with `x` and `y` coordinates in pixels.
     *
     * @example
     *
     * ```js
     * var point = L.point(200, 300);
     * ```
     *
     * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
     *
     * ```js
     * map.panBy([200, 300]);
     * map.panBy(L.point(200, 300));
     * ```
     */

    function Point(x, y, round) {
      // @property x: Number; The `x` coordinate of the point
      this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point

      this.y = round ? Math.round(y) : y;
    }
    Point.prototype = {
      // @method clone(): Point
      // Returns a copy of the current point.
      clone: function clone() {
        return new Point(this.x, this.y);
      },
      // @method add(otherPoint: Point): Point
      // Returns the result of addition of the current and the given points.
      add: function add(point) {
        // non-destructive, returns a new point
        return this.clone()._add(toPoint(point));
      },
      _add: function _add(point) {
        // destructive, used directly for performance in situations where it's safe to modify existing point
        this.x += point.x;
        this.y += point.y;
        return this;
      },
      // @method subtract(otherPoint: Point): Point
      // Returns the result of subtraction of the given point from the current.
      subtract: function subtract(point) {
        return this.clone()._subtract(toPoint(point));
      },
      _subtract: function _subtract(point) {
        this.x -= point.x;
        this.y -= point.y;
        return this;
      },
      // @method divideBy(num: Number): Point
      // Returns the result of division of the current point by the given number.
      divideBy: function divideBy(num) {
        return this.clone()._divideBy(num);
      },
      _divideBy: function _divideBy(num) {
        this.x /= num;
        this.y /= num;
        return this;
      },
      // @method multiplyBy(num: Number): Point
      // Returns the result of multiplication of the current point by the given number.
      multiplyBy: function multiplyBy(num) {
        return this.clone()._multiplyBy(num);
      },
      _multiplyBy: function _multiplyBy(num) {
        this.x *= num;
        this.y *= num;
        return this;
      },
      // @method scaleBy(scale: Point): Point
      // Multiply each coordinate of the current point by each coordinate of
      // `scale`. In linear algebra terms, multiply the point by the
      // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
      // defined by `scale`.
      scaleBy: function scaleBy(point) {
        return new Point(this.x * point.x, this.y * point.y);
      },
      // @method unscaleBy(scale: Point): Point
      // Inverse of `scaleBy`. Divide each coordinate of the current point by
      // each coordinate of `scale`.
      unscaleBy: function unscaleBy(point) {
        return new Point(this.x / point.x, this.y / point.y);
      },
      // @method round(): Point
      // Returns a copy of the current point with rounded coordinates.
      round: function round() {
        return this.clone()._round();
      },
      _round: function _round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      // @method floor(): Point
      // Returns a copy of the current point with floored coordinates (rounded down).
      floor: function floor() {
        return this.clone()._floor();
      },
      _floor: function _floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      // @method ceil(): Point
      // Returns a copy of the current point with ceiled coordinates (rounded up).
      ceil: function ceil() {
        return this.clone()._ceil();
      },
      _ceil: function _ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      // @method distanceTo(otherPoint: Point): Number
      // Returns the cartesian distance between the current and the given points.
      distanceTo: function distanceTo(point) {
        point = toPoint(point);
        var x = point.x - this.x,
            y = point.y - this.y;
        return Math.sqrt(x * x + y * y);
      },
      // @method equals(otherPoint: Point): Boolean
      // Returns `true` if the given point has the same coordinates.
      equals: function equals(point) {
        point = toPoint(point);
        return point.x === this.x && point.y === this.y;
      },
      // @method contains(otherPoint: Point): Boolean
      // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
      contains: function contains(point) {
        point = toPoint(point);
        return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
      },
      // @method toString(): String
      // Returns a string representation of the point for debugging purposes.
      toString: function toString() {
        return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
      }
    }; // @factory L.point(x: Number, y: Number, round?: Boolean)
    // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.
    // @alternative
    // @factory L.point(coords: Number[])
    // Expects an array of the form `[x, y]` instead.
    // @alternative
    // @factory L.point(coords: Object)
    // Expects a plain object of the form `{x: Number, y: Number}` instead.

    function toPoint(x, y, round) {
      if (x instanceof Point) {
        return x;
      }

      if (isArray$2(x)) {
        return new Point(x[0], x[1]);
      }

      if (x === undefined || x === null) {
        return x;
      }

      if (typeof x === 'object' && 'x' in x && 'y' in x) {
        return new Point(x.x, x.y);
      }

      return new Point(x, y, round);
    }

    /*
     * @class Bounds
     * @aka L.Bounds
     *
     * Represents a rectangular area in pixel coordinates.
     *
     * @example
     *
     * ```js
     * var p1 = L.point(10, 10),
     * p2 = L.point(40, 60),
     * bounds = L.bounds(p1, p2);
     * ```
     *
     * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
     *
     * ```js
     * otherBounds.intersects([[10, 10], [40, 60]]);
     * ```
     */

    function Bounds(a, b) {
      if (!a) {
        return;
      }

      var points = b ? [a, b] : a;

      for (var i = 0, len = points.length; i < len; i++) {
        this.extend(points[i]);
      }
    }
    Bounds.prototype = {
      // @method extend(point: Point): this
      // Extends the bounds to contain the given point.
      extend: function extend(point) {
        // (Point)
        point = toPoint(point); // @property min: Point
        // The top left corner of the rectangle.
        // @property max: Point
        // The bottom right corner of the rectangle.

        if (!this.min && !this.max) {
          this.min = point.clone();
          this.max = point.clone();
        } else {
          this.min.x = Math.min(point.x, this.min.x);
          this.max.x = Math.max(point.x, this.max.x);
          this.min.y = Math.min(point.y, this.min.y);
          this.max.y = Math.max(point.y, this.max.y);
        }

        return this;
      },
      // @method getCenter(round?: Boolean): Point
      // Returns the center point of the bounds.
      getCenter: function getCenter(round) {
        return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
      },
      // @method getBottomLeft(): Point
      // Returns the bottom-left point of the bounds.
      getBottomLeft: function getBottomLeft() {
        return new Point(this.min.x, this.max.y);
      },
      // @method getTopRight(): Point
      // Returns the top-right point of the bounds.
      getTopRight: function getTopRight() {
        // -> Point
        return new Point(this.max.x, this.min.y);
      },
      // @method getTopLeft(): Point
      // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
      getTopLeft: function getTopLeft() {
        return this.min; // left, top
      },
      // @method getBottomRight(): Point
      // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
      getBottomRight: function getBottomRight() {
        return this.max; // right, bottom
      },
      // @method getSize(): Point
      // Returns the size of the given bounds
      getSize: function getSize() {
        return this.max.subtract(this.min);
      },
      // @method contains(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains(point: Point): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function contains(obj) {
        var min, max;

        if (typeof obj[0] === 'number' || obj instanceof Point) {
          obj = toPoint(obj);
        } else {
          obj = toBounds(obj);
        }

        if (obj instanceof Bounds) {
          min = obj.min;
          max = obj.max;
        } else {
          min = max = obj;
        }

        return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
      },
      // @method intersects(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds
      // intersect if they have at least one point in common.
      intersects: function intersects(bounds) {
        // (Bounds) -> Boolean
        bounds = toBounds(bounds);
        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max,
            xIntersects = max2.x >= min.x && min2.x <= max.x,
            yIntersects = max2.y >= min.y && min2.y <= max.y;
        return xIntersects && yIntersects;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds
      // overlap if their intersection is an area.
      overlaps: function overlaps(bounds) {
        // (Bounds) -> Boolean
        bounds = toBounds(bounds);
        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max,
            xOverlaps = max2.x > min.x && min2.x < max.x,
            yOverlaps = max2.y > min.y && min2.y < max.y;
        return xOverlaps && yOverlaps;
      },
      isValid: function isValid() {
        return !!(this.min && this.max);
      }
    }; // @factory L.bounds(corner1: Point, corner2: Point)
    // Creates a Bounds object from two corners coordinate pairs.
    // @alternative
    // @factory L.bounds(points: Point[])
    // Creates a Bounds object from the given array of points.

    function toBounds(a, b) {
      if (!a || a instanceof Bounds) {
        return a;
      }

      return new Bounds(a, b);
    }

    /*
     * @class LatLngBounds
     * @aka L.LatLngBounds
     *
     * Represents a rectangular geographical area on a map.
     *
     * @example
     *
     * ```js
     * var corner1 = L.latLng(40.712, -74.227),
     * corner2 = L.latLng(40.774, -74.125),
     * bounds = L.latLngBounds(corner1, corner2);
     * ```
     *
     * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
     *
     * ```js
     * map.fitBounds([
     * 	[40.712, -74.227],
     * 	[40.774, -74.125]
     * ]);
     * ```
     *
     * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
     */

    function LatLngBounds(corner1, corner2) {
      // (LatLng, LatLng) or (LatLng[])
      if (!corner1) {
        return;
      }

      var latlngs = corner2 ? [corner1, corner2] : corner1;

      for (var i = 0, len = latlngs.length; i < len; i++) {
        this.extend(latlngs[i]);
      }
    }
    LatLngBounds.prototype = {
      // @method extend(latlng: LatLng): this
      // Extend the bounds to contain the given point
      // @alternative
      // @method extend(otherBounds: LatLngBounds): this
      // Extend the bounds to contain the given bounds
      extend: function extend(obj) {
        var sw = this._southWest,
            ne = this._northEast,
            sw2,
            ne2;

        if (obj instanceof LatLng) {
          sw2 = obj;
          ne2 = obj;
        } else if (obj instanceof LatLngBounds) {
          sw2 = obj._southWest;
          ne2 = obj._northEast;

          if (!sw2 || !ne2) {
            return this;
          }
        } else {
          return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
        }

        if (!sw && !ne) {
          this._southWest = new LatLng(sw2.lat, sw2.lng);
          this._northEast = new LatLng(ne2.lat, ne2.lng);
        } else {
          sw.lat = Math.min(sw2.lat, sw.lat);
          sw.lng = Math.min(sw2.lng, sw.lng);
          ne.lat = Math.max(ne2.lat, ne.lat);
          ne.lng = Math.max(ne2.lng, ne.lng);
        }

        return this;
      },
      // @method pad(bufferRatio: Number): LatLngBounds
      // Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
      pad: function pad(bufferRatio) {
        var sw = this._southWest,
            ne = this._northEast,
            heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
            widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
        return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
      },
      // @method getCenter(): LatLng
      // Returns the center point of the bounds.
      getCenter: function getCenter() {
        return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
      },
      // @method getSouthWest(): LatLng
      // Returns the south-west point of the bounds.
      getSouthWest: function getSouthWest() {
        return this._southWest;
      },
      // @method getNorthEast(): LatLng
      // Returns the north-east point of the bounds.
      getNorthEast: function getNorthEast() {
        return this._northEast;
      },
      // @method getNorthWest(): LatLng
      // Returns the north-west point of the bounds.
      getNorthWest: function getNorthWest() {
        return new LatLng(this.getNorth(), this.getWest());
      },
      // @method getSouthEast(): LatLng
      // Returns the south-east point of the bounds.
      getSouthEast: function getSouthEast() {
        return new LatLng(this.getSouth(), this.getEast());
      },
      // @method getWest(): Number
      // Returns the west longitude of the bounds
      getWest: function getWest() {
        return this._southWest.lng;
      },
      // @method getSouth(): Number
      // Returns the south latitude of the bounds
      getSouth: function getSouth() {
        return this._southWest.lat;
      },
      // @method getEast(): Number
      // Returns the east longitude of the bounds
      getEast: function getEast() {
        return this._northEast.lng;
      },
      // @method getNorth(): Number
      // Returns the north latitude of the bounds
      getNorth: function getNorth() {
        return this._northEast.lat;
      },
      // @method contains(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle contains the given one.
      // @alternative
      // @method contains (latlng: LatLng): Boolean
      // Returns `true` if the rectangle contains the given point.
      contains: function contains(obj) {
        // (LatLngBounds) or (LatLng) -> Boolean
        if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
          obj = toLatLng(obj);
        } else {
          obj = toLatLngBounds(obj);
        }

        var sw = this._southWest,
            ne = this._northEast,
            sw2,
            ne2;

        if (obj instanceof LatLngBounds) {
          sw2 = obj.getSouthWest();
          ne2 = obj.getNorthEast();
        } else {
          sw2 = ne2 = obj;
        }

        return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
      },
      // @method intersects(otherBounds: LatLngBounds): Boolean
      // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
      intersects: function intersects(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest,
            ne = this._northEast,
            sw2 = bounds.getSouthWest(),
            ne2 = bounds.getNorthEast(),
            latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
            lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
        return latIntersects && lngIntersects;
      },
      // @method overlaps(otherBounds: Bounds): Boolean
      // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
      overlaps: function overlaps(bounds) {
        bounds = toLatLngBounds(bounds);
        var sw = this._southWest,
            ne = this._northEast,
            sw2 = bounds.getSouthWest(),
            ne2 = bounds.getNorthEast(),
            latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
            lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
        return latOverlaps && lngOverlaps;
      },
      // @method toBBoxString(): String
      // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
      toBBoxString: function toBBoxString() {
        return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
      },
      // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
      // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overriden by setting `maxMargin` to a small number.
      equals: function equals(bounds, maxMargin) {
        if (!bounds) {
          return false;
        }

        bounds = toLatLngBounds(bounds);
        return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
      },
      // @method isValid(): Boolean
      // Returns `true` if the bounds are properly initialized.
      isValid: function isValid() {
        return !!(this._southWest && this._northEast);
      }
    }; // TODO International date line?
    // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
    // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.
    // @alternative
    // @factory L.latLngBounds(latlngs: LatLng[])
    // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).

    function toLatLngBounds(a, b) {
      if (a instanceof LatLngBounds) {
        return a;
      }

      return new LatLngBounds(a, b);
    }

    /* @class LatLng
     * @aka L.LatLng
     *
     * Represents a geographical point with a certain latitude and longitude.
     *
     * @example
     *
     * ```
     * var latlng = L.latLng(50.5, 30.5);
     * ```
     *
     * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
     *
     * ```
     * map.panTo([50, 30]);
     * map.panTo({lon: 30, lat: 50});
     * map.panTo({lat: 50, lng: 30});
     * map.panTo(L.latLng(50, 30));
     * ```
     */

    function LatLng(lat, lng, alt) {
      if (isNaN(lat) || isNaN(lng)) {
        throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
      } // @property lat: Number
      // Latitude in degrees


      this.lat = +lat; // @property lng: Number
      // Longitude in degrees

      this.lng = +lng; // @property alt: Number
      // Altitude in meters (optional)

      if (alt !== undefined) {
        this.alt = +alt;
      }
    }
    LatLng.prototype = {
      // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
      // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
      equals: function equals(obj, maxMargin) {
        if (!obj) {
          return false;
        }

        obj = toLatLng(obj);
        var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
        return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
      },
      // @method toString(): String
      // Returns a string representation of the point (for debugging purposes).
      toString: function toString(precision) {
        return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
      },
      // @method distanceTo(otherLatLng: LatLng): Number
      // Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
      distanceTo: function distanceTo(other) {
        return Earth.distance(this, toLatLng(other));
      },
      // @method wrap(): LatLng
      // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
      wrap: function wrap() {
        return Earth.wrapLatLng(this);
      },
      // @method toBounds(sizeInMeters: Number): LatLngBounds
      // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
      toBounds: function toBounds(sizeInMeters) {
        var latAccuracy = 180 * sizeInMeters / 40075017,
            lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
        return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
      },
      clone: function clone() {
        return new LatLng(this.lat, this.lng, this.alt);
      }
    }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
    // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
    // @alternative
    // @factory L.latLng(coords: Array): LatLng
    // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
    // @alternative
    // @factory L.latLng(coords: Object): LatLng
    // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

    function toLatLng(a, b, c) {
      if (a instanceof LatLng) {
        return a;
      }

      if (isArray$2(a) && typeof a[0] !== 'object') {
        if (a.length === 3) {
          return new LatLng(a[0], a[1], a[2]);
        }

        if (a.length === 2) {
          return new LatLng(a[0], a[1]);
        }

        return null;
      }

      if (a === undefined || a === null) {
        return a;
      }

      if (typeof a === 'object' && 'lat' in a) {
        return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
      }

      if (b === undefined) {
        return null;
      }

      return new LatLng(a, b, c);
    }

    /*
     * @namespace CRS
     * @crs L.CRS.Base
     * Object that defines coordinate reference systems for projecting
     * geographical points into pixel (screen) coordinates and back (and to
     * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
     * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
     *
     * Leaflet defines the most usual CRSs by default. If you want to use a
     * CRS not defined by default, take a look at the
     * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
     */

    var CRS = {
      // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
      // Projects geographical coordinates into pixel coordinates for a given zoom.
      latLngToPoint: function latLngToPoint(latlng, zoom) {
        var projectedPoint = this.projection.project(latlng),
            scale = this.scale(zoom);
        return this.transformation._transform(projectedPoint, scale);
      },
      // @method pointToLatLng(point: Point, zoom: Number): LatLng
      // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
      // zoom into geographical coordinates.
      pointToLatLng: function pointToLatLng(point, zoom) {
        var scale = this.scale(zoom),
            untransformedPoint = this.transformation.untransform(point, scale);
        return this.projection.unproject(untransformedPoint);
      },
      // @method project(latlng: LatLng): Point
      // Projects geographical coordinates into coordinates in units accepted for
      // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
      project: function project(latlng) {
        return this.projection.project(latlng);
      },
      // @method unproject(point: Point): LatLng
      // Given a projected coordinate returns the corresponding LatLng.
      // The inverse of `project`.
      unproject: function unproject(point) {
        return this.projection.unproject(point);
      },
      // @method scale(zoom: Number): Number
      // Returns the scale used when transforming projected coordinates into
      // pixel coordinates for a particular zoom. For example, it returns
      // `256 * 2^zoom` for Mercator-based CRS.
      scale: function scale(zoom) {
        return 256 * Math.pow(2, zoom);
      },
      // @method zoom(scale: Number): Number
      // Inverse of `scale()`, returns the zoom level corresponding to a scale
      // factor of `scale`.
      zoom: function zoom(scale) {
        return Math.log(scale / 256) / Math.LN2;
      },
      // @method getProjectedBounds(zoom: Number): Bounds
      // Returns the projection's bounds scaled and transformed for the provided `zoom`.
      getProjectedBounds: function getProjectedBounds(zoom) {
        if (this.infinite) {
          return null;
        }

        var b = this.projection.bounds,
            s = this.scale(zoom),
            min = this.transformation.transform(b.min, s),
            max = this.transformation.transform(b.max, s);
        return new Bounds(min, max);
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates.
      // @property code: String
      // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
      //
      // @property wrapLng: Number[]
      // An array of two numbers defining whether the longitude (horizontal) coordinate
      // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
      // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
      //
      // @property wrapLat: Number[]
      // Like `wrapLng`, but for the latitude (vertical) axis.
      // wrapLng: [min, max],
      // wrapLat: [min, max],
      // @property infinite: Boolean
      // If true, the coordinate space will be unbounded (infinite in both axes)
      infinite: false,
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where lat and lng has been wrapped according to the
      // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
      wrapLatLng: function wrapLatLng(latlng) {
        var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
            lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
            alt = latlng.alt;
        return new LatLng(lat, lng, alt);
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring
      // that its center is within the CRS's bounds.
      // Only accepts actual `L.LatLngBounds` instances, not arrays.
      wrapLatLngBounds: function wrapLatLngBounds(bounds) {
        var center = bounds.getCenter(),
            newCenter = this.wrapLatLng(center),
            latShift = center.lat - newCenter.lat,
            lngShift = center.lng - newCenter.lng;

        if (latShift === 0 && lngShift === 0) {
          return bounds;
        }

        var sw = bounds.getSouthWest(),
            ne = bounds.getNorthEast(),
            newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
            newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
        return new LatLngBounds(newSw, newNe);
      }
    };

    /*
     * @namespace CRS
     * @crs L.CRS.Earth
     *
     * Serves as the base for CRS that are global such that they cover the earth.
     * Can only be used as the base for other CRS and cannot be used directly,
     * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
     * meters.
     */

    var Earth = extend$4({}, CRS, {
      wrapLng: [-180, 180],
      // Mean Earth Radius, as recommended for use by
      // the International Union of Geodesy and Geophysics,
      // see http://rosettacode.org/wiki/Haversine_formula
      R: 6371000,
      // distance between two geographical points using spherical law of cosines approximation
      distance: function distance(latlng1, latlng2) {
        var rad = Math.PI / 180,
            lat1 = latlng1.lat * rad,
            lat2 = latlng2.lat * rad,
            a = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);
        return this.R * Math.acos(Math.min(a, 1));
      }
    });

    /*
     * @namespace Projection
     * @projection L.Projection.Mercator
     *
     * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
     */

    var Mercator = {
      R: 6378137,
      R_MINOR: 6356752.314245179,
      bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
      project: function project(latlng) {
        var d = Math.PI / 180,
            r = this.R,
            y = latlng.lat * d,
            tmp = this.R_MINOR / r,
            e = Math.sqrt(1 - tmp * tmp),
            con = e * Math.sin(y);
        var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
        y = -r * Math.log(Math.max(ts, 1E-10));
        return new Point(latlng.lng * d * r, y);
      },
      unproject: function unproject(point) {
        var d = 180 / Math.PI,
            r = this.R,
            tmp = this.R_MINOR / r,
            e = Math.sqrt(1 - tmp * tmp),
            ts = Math.exp(-point.y / r),
            phi = Math.PI / 2 - 2 * Math.atan(ts);

        for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
          con = e * Math.sin(phi);
          con = Math.pow((1 - con) / (1 + con), e / 2);
          dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
          phi += dphi;
        }

        return new LatLng(phi * d, point.x * d / r);
      }
    };

    /*
     * @class Transformation
     * @aka L.Transformation
     *
     * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
     * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
     * the reverse. Used by Leaflet in its projections code.
     *
     * @example
     *
     * ```js
     * var transformation = L.transformation(2, 5, -1, 10),
     * 	p = L.point(1, 2),
     * 	p2 = transformation.transform(p), //  L.point(7, 8)
     * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
     * ```
     */
    // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
    // Creates a `Transformation` object with the given coefficients.

    function Transformation(a, b, c, d) {
      if (isArray$2(a)) {
        // use array properties
        this._a = a[0];
        this._b = a[1];
        this._c = a[2];
        this._d = a[3];
        return;
      }

      this._a = a;
      this._b = b;
      this._c = c;
      this._d = d;
    }
    Transformation.prototype = {
      // @method transform(point: Point, scale?: Number): Point
      // Returns a transformed point, optionally multiplied by the given scale.
      // Only accepts actual `L.Point` instances, not arrays.
      transform: function transform(point, scale) {
        // (Point, Number) -> Point
        return this._transform(point.clone(), scale);
      },
      // destructive transform (faster)
      _transform: function _transform(point, scale) {
        scale = scale || 1;
        point.x = scale * (this._a * point.x + this._b);
        point.y = scale * (this._c * point.y + this._d);
        return point;
      },
      // @method untransform(point: Point, scale?: Number): Point
      // Returns the reverse transformation of the given point, optionally divided
      // by the given scale. Only accepts actual `L.Point` instances, not arrays.
      untransform: function untransform(point, scale) {
        scale = scale || 1;
        return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
      }
    }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)
    // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
    // Instantiates a Transformation object with the given coefficients.
    // @alternative
    // @factory L.transformation(coefficients: Array): Transformation
    // Expects an coeficients array of the form
    // `[a: Number, b: Number, c: Number, d: Number]`.

    function toTransformation(a, b, c, d) {
      return new Transformation(a, b, c, d);
    }

    /*
     * @namespace CRS
     * @crs L.CRS.EPSG3395
     *
     * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
     */

    var EPSG3395 = extend$4({}, Earth, {
      code: 'EPSG:3395',
      projection: Mercator,
      transformation: function () {
        var scale = 0.5 / (Math.PI * Mercator.R);
        return toTransformation(scale, 0.5, -scale, 0.5);
      }()
    });

    /*
     * @namespace Projection
     * @projection L.Projection.SphericalMercator
     *
     * Spherical Mercator projection — the most common projection for online maps,
     * used by almost all free and commercial tile providers. Assumes that Earth is
     * a sphere. Used by the `EPSG:3857` CRS.
     */

    var SphericalMercator = {
      R: 6378137,
      MAX_LATITUDE: 85.0511287798,
      project: function project(latlng) {
        var d = Math.PI / 180,
            max = this.MAX_LATITUDE,
            lat = Math.max(Math.min(max, latlng.lat), -max),
            sin = Math.sin(lat * d);
        return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
      },
      unproject: function unproject(point) {
        var d = 180 / Math.PI;
        return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
      },
      bounds: function () {
        var d = 6378137 * Math.PI;
        return new Bounds([-d, -d], [d, d]);
      }()
    };

    /*
     * @namespace CRS
     * @crs L.CRS.EPSG3857
     *
     * The most common CRS for online maps, used by almost all free and commercial
     * tile providers. Uses Spherical Mercator projection. Set in by default in
     * Map's `crs` option.
     */

    var EPSG3857 = extend$4({}, Earth, {
      code: 'EPSG:3857',
      projection: SphericalMercator,
      transformation: function () {
        var scale = 0.5 / (Math.PI * SphericalMercator.R);
        return toTransformation(scale, 0.5, -scale, 0.5);
      }()
    });
    var EPSG900913 = extend$4({}, EPSG3857, {
      code: 'EPSG:900913'
    });

    /*
     * @namespace Projection
     * @section
     * Leaflet comes with a set of already defined Projections out of the box:
     *
     * @projection L.Projection.LonLat
     *
     * Equirectangular, or Plate Carree projection — the most simple projection,
     * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
     * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
     * `EPSG:4326` and `Simple` CRS.
     */

    var LonLat = {
      project: function project(latlng) {
        return new Point(latlng.lng, latlng.lat);
      },
      unproject: function unproject(point) {
        return new LatLng(point.y, point.x);
      },
      bounds: new Bounds([-180, -90], [180, 90])
    };

    /*
     * @namespace CRS
     * @crs L.CRS.EPSG4326
     *
     * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
     *
     * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
     * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
     * with this CRS, ensure that there are two 256x256 pixel tiles covering the
     * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
     * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
     */

    var EPSG4326 = extend$4({}, Earth, {
      code: 'EPSG:4326',
      projection: LonLat,
      transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
    });

    /*
     * @namespace CRS
     * @crs L.CRS.Simple
     *
     * A simple CRS that maps longitude and latitude into `x` and `y` directly.
     * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
     * axis should still be inverted (going from bottom to top). `distance()` returns
     * simple euclidean distance.
     */

    var Simple = extend$4({}, CRS, {
      projection: LonLat,
      transformation: toTransformation(1, 0, -1, 0),
      scale: function scale(zoom) {
        return Math.pow(2, zoom);
      },
      zoom: function zoom(scale) {
        return Math.log(scale) / Math.LN2;
      },
      distance: function distance(latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng,
            dy = latlng2.lat - latlng1.lat;
        return Math.sqrt(dx * dx + dy * dy);
      },
      infinite: true
    });

    var CRSHash = {
      Earth: Earth,
      EPSG3395: EPSG3395,
      EPSG3857: EPSG3857,
      EPSG900913: EPSG900913,
      EPSG4326: EPSG4326,
      Simple: Simple
    };
    var getCrs = function getCrs(crs) {
      return CRSHash[crs];
    };
    var getMapCenter = function getMapCenter(_ref) {
      var zoom = _ref.zoom,
          center = _ref.center,
          crs = _ref.crs;
      return getCrs(crs).latLngToPoint(center, zoom);
    };

    // 1. 直接mutate rows像个副作用
    // 2. 依赖的具体value/object还能再具体点，用来memorize；或许数据结构也要调整
    // 3. 在做xxx操作后需要调用这个xxx，出现这样的需要已经要重构了；正确的方法是挂处理钩子/生命周期，要处理的各自判断处理

    /**
     * Note 标签的重叠处理是基于分区的，即开启调整后，同一个分区内的数据点的标签不能重叠，这边应该针对Cell进行处理，同一个cell内调整共享一个boundsManager。
     * Note 所有的layout如mapZoom, pieRotate, scaleZoom在调整了位置之后，获取新的state.rows在dispatch(act.rows.update(newRows))之前，都应该调用该方法处理标签
     * Note 标签的处理逻辑是先calcDataLabelPos 把标签的内容&bounds&pos等计算出来放在row.dataLabel上，然后再判断adjustLabel， 对于forcePoint之类的，adjust在绘制之后
     * @param cells
     * @param enableMap
     * @param mapConfig
     */

    var dealRowDataLabel = function dealRowDataLabel(cells, enableMap, mapConfig) {
      var _ref = enableMap ? getMapCenter(mapConfig) : {},
          cx = _ref.x,
          cy = _ref.y;

      _.each(cells, function (cell) {
        var manager = new BoundsManager();

        _.each(cell.geoms, function (_ref2) {
          var geom = _ref2.geom,
              rows = _ref2.rows;
          var cellBounds = cell.bounds;

          if (enableMap) {
            var _cellBounds = cellBounds,
                x = _cellBounds.x,
                y = _cellBounds.y,
                width = _cellBounds.width,
                height = _cellBounds.height;
            cellBounds = {
              x: x + cx - width / 2,
              y: y + cy - height / 2,
              width: width,
              height: height
            };
          }

          dealLabel({
            cellBounds: cellBounds,
            cell: cell,
            geom: geom,
            rows: rows,
            manager: manager,
            enableMap: enableMap
          });
        });
      });
    };

    var getFacetStops = function getFacetStops(facet) {
      var stopNodes = facet.stopNodes,
          groupMeasureCount = facet.groupMeasureCount,
          unit = facet.unit;

      if (stopNodes.length === 0) {
        return [0];
      }

      var oneGroupByUnit = groupMeasureCount <= 1,
          measureGroupSize = Math.max(1, Math.round(unit / groupMeasureCount));
      var stops = [stopNodes[0].pos];
      var stopIndex = 1;

      for (var i = 0, len = stopNodes.length; i < len; i++) {
        var node = stopNodes[i];

        if (oneGroupByUnit) {
          stops[stopIndex] = stops[stopIndex - 1] + node.length;
          stopIndex++;
        } else {
          for (var j = 0; j < groupMeasureCount; j++) {
            stops[stopIndex] = stops[stopIndex - 1] + measureGroupSize;
            stopIndex++;
          }
        }
      }

      return stops;
    };

    var initCellMap = function initCellMap(facetX, facetY, geoms) {
      var xStops = getFacetStops(facetX),
          yStops = getFacetStops(facetY);
      var cellMap = {};

      _.each(geoms, function (geom) {
        _.each(geom.frames, function (frame) {
          _.each(frame.group, function (idxList, cellId) {
            if (!cellMap[cellId]) {
              var _$map = _.map(cellId.split(GROUP_KEY), function (a) {
                return +a;
              }),
                  i = _$map[0],
                  j = _$map[1],
                  x = xStops[i],
                  y = yStops[j],
                  width = xStops[i + 1] - x,
                  height = yStops[j + 1] - y;

              cellMap[cellId] = {
                geoms: [],
                // 存放分区里面Geom
                bounds: {
                  // 分区的bounds
                  x: x,
                  y: y,
                  width: width,
                  height: height
                },
                trendLines: [],
                xIndex: i,
                // 分区的在横纵轴上的索引
                yIndex: j,
                cellId: cellId
              };
            }
          });
        });
      });

      return cellMap;
    };

    var NULL_VALUE_AES_TYPES = [AesTypes.PIE_ANGLE, AesTypes.SIZE, AesTypes.SYMBOL, AesTypes.COLOR];

    var isNaNValue = function isNaNValue(value) {
      return value !== undefined && isNaN(value);
    };
    /**
     * 有效数据判断, 主要针对size, color, x, y等属性做有意义判断，对于'-'或者Infinity这样的无意义元素过滤
     * @param geom
     * @param frameMeasure
     * @returns {function(*): boolean}
     */


    var createValidRowChecker = function createValidRowChecker(geom, frameMeasure) {
      var measure = geom.measure,
          data = geom.data;
      var detectiveIds = [LAT, LNG];

      var addAnId = function addAnId(id) {
        var field = data.getFieldById(id);

        if (field && field.type === FieldType.MEASURE) {
          detectiveIds.push(id);
        }
      };

      var addDetectiveId = function addDetectiveId(input) {
        if (!input) return; // gauge pointer

        if (_.isArray(input)) {
          _.each(input, addAnId);
        } else {
          var id = input.id ? input.id : input;
          addAnId(id);
        }
      };

      addDetectiveId(measure);
      addDetectiveId(frameMeasure);

      _.each(NULL_VALUE_AES_TYPES, function (type) {
        return addDetectiveId(geom[type]);
      });

      return function (row) {
        return !(_.some(detectiveIds, function (id) {
          return row[id] === void 0 ? false : !isMeaningfulNumericValue(row[id]);
        }) || isNaNValue(row.x) || isNaNValue(row.y));
      };
    };

    var dealTreeGeom = function dealTreeGeom(cellGeoms) {
      var max = Number.MIN_VALUE;

      _.each(cellGeoms, function (_ref) {
        var cell = _ref.cell,
            rows = _ref.rows;

        var sum = cell.percent = _.reduce(rows, function (t, cr) {
          return t + cr.size;
        }, 0);

        max = Math.max(sum, max);
      });

      _.each(cellGeoms, function (_ref2) {
        var cell = _ref2.cell;
        cell.percent /= max;
      });
    };

    /*
     * @class Projection

     * An object with methods for projecting geographical coordinates of the world onto
     * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

     * @property bounds: Bounds
     * The bounds (specified in CRS units) where the projection is valid

     * @method project(latlng: LatLng): Point
     * Projects geographical coordinates into a 2D point.
     * Only accepts actual `L.LatLng` instances, not arrays.

     * @method unproject(point: Point): LatLng
     * The inverse of `project`. Projects a 2D point into a geographical location.
     * Only accepts actual `L.Point` instances, not arrays.

     */

    CRS.Earth = Earth;
    CRS.EPSG3395 = EPSG3395;
    CRS.EPSG3857 = EPSG3857;
    CRS.EPSG900913 = EPSG900913;
    CRS.EPSG4326 = EPSG4326;
    CRS.Simple = Simple;

    // @aka L.Class
    // @section
    // @uninheritable
    // Thanks to John Resig and Dean Edwards for inspiration!

    function Class() {}

    Class.extend = function (props) {
      // @function extend(props: Object): Function
      // [Extends the current class](#class-inheritance) given the properties to be included.
      // Returns a Javascript function that is a class constructor (to be called with `new`).
      var NewClass = function NewClass() {
        // call the constructor
        if (this.initialize) {
          this.initialize.apply(this, arguments);
        } // call all constructor hooks


        this.callInitHooks();
      };

      var parentProto = NewClass.__super__ = this.prototype;
      var proto = create$3(parentProto);
      proto.constructor = NewClass;
      NewClass.prototype = proto; // inherit parent's statics

      for (var i in this) {
        if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
          NewClass[i] = this[i];
        }
      } // mix static properties into the class


      if (props.statics) {
        extend$4(NewClass, props.statics);
        delete props.statics;
      } // mix includes into the prototype


      if (props.includes) {
        checkDeprecatedMixinEvents(props.includes);
        extend$4.apply(null, [proto].concat(props.includes));
        delete props.includes;
      } // merge options


      if (proto.options) {
        props.options = extend$4(create$3(proto.options), props.options);
      } // mix given properties into the prototype


      extend$4(proto, props);
      proto._initHooks = []; // add method for calling all hooks

      proto.callInitHooks = function () {
        if (this._initHooksCalled) {
          return;
        }

        if (parentProto.callInitHooks) {
          parentProto.callInitHooks.call(this);
        }

        this._initHooksCalled = true;

        for (var i = 0, len = proto._initHooks.length; i < len; i++) {
          proto._initHooks[i].call(this);
        }
      };

      return NewClass;
    }; // @function include(properties: Object): this
    // [Includes a mixin](#class-includes) into the current class.


    Class.include = function (props) {
      extend$4(this.prototype, props);
      return this;
    }; // @function mergeOptions(options: Object): this
    // [Merges `options`](#class-options) into the defaults of the class.


    Class.mergeOptions = function (options) {
      extend$4(this.prototype.options, options);
      return this;
    }; // @function addInitHook(fn: Function): this
    // Adds a [constructor hook](#class-constructor-hooks) to the class.


    Class.addInitHook = function (fn) {
      // (Function) || (String, args...)
      var args = Array.prototype.slice.call(arguments, 1);
      var init = typeof fn === 'function' ? fn : function () {
        this[fn].apply(this, args);
      };
      this.prototype._initHooks = this.prototype._initHooks || [];

      this.prototype._initHooks.push(init);

      return this;
    };

    function checkDeprecatedMixinEvents(includes) {
      if (!L || !L.Mixin) {
        return;
      }

      includes = isArray$2(includes) ? includes : [includes];

      for (var i = 0; i < includes.length; i++) {
        if (includes[i] === L.Mixin.Events) {
          console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
        }
      }
    }

    /*
     * @class Evented
     * @aka L.Evented
     * @inherits Class
     *
     * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
     *
     * @example
     *
     * ```js
     * map.on('click', function(e) {
     * 	alert(e.latlng);
     * } );
     * ```
     *
     * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
     *
     * ```js
     * function onClick(e) { ... }
     *
     * map.on('click', onClick);
     * map.off('click', onClick);
     * ```
     */

    var Events = {
      /* @method on(type: String, fn: Function, context?: Object): this
       * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
       *
       * @alternative
       * @method on(eventMap: Object): this
       * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
       */
      on: function on(types, fn, context) {
        // types can be a map of types/handlers
        if (typeof types === 'object') {
          for (var type in types) {
            // we don't process space-separated events here for performance;
            // it's a hot path since Layer uses the on(obj) syntax
            this._on(type, types[type], fn);
          }
        } else {
          // types can be a string of space-separated words
          types = splitWords(types);

          for (var i = 0, len = types.length; i < len; i++) {
            this._on(types[i], fn, context);
          }
        }

        return this;
      },

      /* @method off(type: String, fn?: Function, context?: Object): this
       * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
       *
       * @alternative
       * @method off(eventMap: Object): this
       * Removes a set of type/listener pairs.
       *
       * @alternative
       * @method off: this
       * Removes all listeners to all events on the object.
       */
      off: function off(types, fn, context) {
        if (!types) {
          // clear all listeners if called without arguments
          delete this._events;
        } else if (typeof types === 'object') {
          for (var type in types) {
            this._off(type, types[type], fn);
          }
        } else {
          types = splitWords(types);

          for (var i = 0, len = types.length; i < len; i++) {
            this._off(types[i], fn, context);
          }
        }

        return this;
      },
      // attach listener (without syntactic sugar now)
      _on: function _on(type, fn, context) {
        this._events = this._events || {};
        /* get/init listeners for type */

        var typeListeners = this._events[type];

        if (!typeListeners) {
          typeListeners = [];
          this._events[type] = typeListeners;
        }

        if (context === this) {
          // Less memory footprint.
          context = undefined;
        }

        var newListener = {
          fn: fn,
          ctx: context
        },
            listeners = typeListeners; // check if fn already there

        for (var i = 0, len = listeners.length; i < len; i++) {
          if (listeners[i].fn === fn && listeners[i].ctx === context) {
            return;
          }
        }

        listeners.push(newListener);
      },
      _off: function _off(type, fn, context) {
        var listeners, i, len;

        if (!this._events) {
          return;
        }

        listeners = this._events[type];

        if (!listeners) {
          return;
        }

        if (!fn) {
          // Set all removed listeners to noop so they are not called if remove happens in fire
          for (i = 0, len = listeners.length; i < len; i++) {
            listeners[i].fn = falseFn;
          } // clear all listeners for a type if function isn't specified


          delete this._events[type];
          return;
        }

        if (context === this) {
          context = undefined;
        }

        if (listeners) {
          // find fn and remove it
          for (i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];

            if (l.ctx !== context) {
              continue;
            }

            if (l.fn === fn) {
              // set the removed listener to noop so that's not called if remove happens in fire
              l.fn = falseFn;

              if (this._firingCount) {
                /* copy array in case events are being fired */
                this._events[type] = listeners = listeners.slice();
              }

              listeners.splice(i, 1);
              return;
            }
          }
        }
      },
      // @method fire(type: String, data?: Object, propagate?: Boolean): this
      // Fires an event of the specified type. You can optionally provide an data
      // object — the first argument of the listener function will contain its
      // properties. The event can optionally be propagated to event parents.
      fire: function fire(type, data, propagate) {
        if (!this.listens(type, propagate)) {
          return this;
        }

        var event = extend$4({}, data, {
          type: type,
          target: this
        });

        if (this._events) {
          var listeners = this._events[type];

          if (listeners) {
            this._firingCount = this._firingCount + 1 || 1;

            for (var i = 0, len = listeners.length; i < len; i++) {
              var l = listeners[i];
              l.fn.call(l.ctx || this, event);
            }

            this._firingCount--;
          }
        }

        if (propagate) {
          // propagate the event to parents (set with addEventParent)
          this._propagateEvent(event);
        }

        return this;
      },
      // @method listens(type: String): Boolean
      // Returns `true` if a particular event type has any listeners attached to it.
      listens: function listens(type, propagate) {
        var listeners = this._events && this._events[type];

        if (listeners && listeners.length) {
          return true;
        }

        if (propagate) {
          // also check parents for listeners if event propagates
          for (var id in this._eventParents) {
            if (this._eventParents[id].listens(type, propagate)) {
              return true;
            }
          }
        }

        return false;
      },
      // @method once(…): this
      // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
      once: function once(types, fn, context) {
        if (typeof types === 'object') {
          for (var type in types) {
            this.once(type, types[type], fn);
          }

          return this;
        }

        var handler = bind$1(function () {
          this.off(types, fn, context).off(types, handler, context);
        }, this); // add a listener that's executed once and removed after that

        return this.on(types, fn, context).on(types, handler, context);
      },
      // @method addEventParent(obj: Evented): this
      // Adds an event parent - an `Evented` that will receive propagated events
      addEventParent: function addEventParent(obj) {
        this._eventParents = this._eventParents || {};
        this._eventParents[stamp(obj)] = obj;
        return this;
      },
      // @method removeEventParent(obj: Evented): this
      // Removes an event parent, so it will stop receiving propagated events
      removeEventParent: function removeEventParent(obj) {
        if (this._eventParents) {
          delete this._eventParents[stamp(obj)];
        }

        return this;
      },
      _propagateEvent: function _propagateEvent(e) {
        for (var id in this._eventParents) {
          this._eventParents[id].fire(e.type, extend$4({
            layer: e.target
          }, e), true);
        }
      }
    }; // aliases; we should ditch those eventually
    // @method addEventListener(…): this
    // Alias to [`on(…)`](#evented-on)

    Events.addEventListener = Events.on; // @method removeEventListener(…): this
    // Alias to [`off(…)`](#evented-off)
    // @method clearAllEventListeners(…): this
    // Alias to [`off()`](#evented-off)

    Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this
    // Alias to [`once(…)`](#evented-once)

    Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this
    // Alias to [`fire(…)`](#evented-fire)

    Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean
    // Alias to [`listens(…)`](#evented-listens)

    Events.hasEventListeners = Events.listens;
    var Evented = Class.extend(Events);

    /*
     * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
     */

    var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown',
        POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove',
        POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup',
        POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel',
        TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'],
        _pointers = {},
        _pointerDocListener = false; // DomEvent.DoubleTap needs to know about this

    var _pointersCount = 0; // Provides a touch events wrapper for (ms)pointer events.
    // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

    function addPointerListener(obj, type, handler, id) {
      if (type === 'touchstart') {
        _addPointerStart(obj, handler, id);
      } else if (type === 'touchmove') {
        _addPointerMove(obj, handler, id);
      } else if (type === 'touchend') {
        _addPointerEnd(obj, handler, id);
      }

      return this;
    }
    function removePointerListener(obj, type, id) {
      var handler = obj['_leaflet_' + type + id];

      if (type === 'touchstart') {
        obj.removeEventListener(POINTER_DOWN, handler, false);
      } else if (type === 'touchmove') {
        obj.removeEventListener(POINTER_MOVE, handler, false);
      } else if (type === 'touchend') {
        obj.removeEventListener(POINTER_UP, handler, false);
        obj.removeEventListener(POINTER_CANCEL, handler, false);
      }

      return this;
    }

    function _addPointerStart(obj, handler, id) {
      var onDown = bind$1(function (e) {
        if (e.pointerType !== 'mouse' && e.pointerType !== e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
          // In IE11, some touch events needs to fire for form controls, or
          // the controls will stop working. We keep a whitelist of tag names that
          // need these events. For other target tags, we prevent default on the event.
          if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
            preventDefault(e);
          } else {
            return;
          }
        }

        _handlePointer(e, handler);
      });
      obj['_leaflet_touchstart' + id] = onDown;
      obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation

      if (!_pointerDocListener) {
        // we listen documentElement as any drags that end by moving the touch off the screen get fired there
        document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
        document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
        document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
        document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
        _pointerDocListener = true;
      }
    }

    function _globalPointerDown(e) {
      _pointers[e.pointerId] = e;
      _pointersCount++;
    }

    function _globalPointerMove(e) {
      if (_pointers[e.pointerId]) {
        _pointers[e.pointerId] = e;
      }
    }

    function _globalPointerUp(e) {
      delete _pointers[e.pointerId];
      _pointersCount--;
    }

    function _handlePointer(e, handler) {
      e.touches = [];

      for (var i in _pointers) {
        e.touches.push(_pointers[i]);
      }

      e.changedTouches = [e];
      handler(e);
    }

    function _addPointerMove(obj, handler, id) {
      var onMove = function onMove(e) {
        // don't fire touch moves when mouse isn't down
        if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) {
          return;
        }

        _handlePointer(e, handler);
      };

      obj['_leaflet_touchmove' + id] = onMove;
      obj.addEventListener(POINTER_MOVE, onMove, false);
    }

    function _addPointerEnd(obj, handler, id) {
      var onUp = function onUp(e) {
        _handlePointer(e, handler);
      };

      obj['_leaflet_touchend' + id] = onUp;
      obj.addEventListener(POINTER_UP, onUp, false);
      obj.addEventListener(POINTER_CANCEL, onUp, false);
    }

    /*
     * Extends the event handling code with double tap support for mobile browsers.
     */

    var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart',
        _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend',
        _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs


    function addDoubleTapListener(obj, handler, id) {
      var last,
          touch$$1,
          doubleTap = false,
          delay = 250;

      function onTouchStart(e) {
        var count;

        if (pointer) {
          if (!edge || e.pointerType === 'mouse') {
            return;
          }

          count = _pointersCount;
        } else {
          count = e.touches.length;
        }

        if (count > 1) {
          return;
        }

        var now = Date.now(),
            delta = now - (last || now);
        touch$$1 = e.touches ? e.touches[0] : e;
        doubleTap = delta > 0 && delta <= delay;
        last = now;
      }

      function onTouchEnd(e) {
        if (doubleTap && !touch$$1.cancelBubble) {
          if (pointer) {
            if (!edge || e.pointerType === 'mouse') {
              return;
            } // work around .type being readonly with MSPointer* events


            var newTouch = {},
                prop,
                i;

            for (i in touch$$1) {
              prop = touch$$1[i];
              newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
            }

            touch$$1 = newTouch;
          }

          touch$$1.type = 'dblclick';
          handler(touch$$1);
          last = null;
        }
      }

      obj[_pre + _touchstart + id] = onTouchStart;
      obj[_pre + _touchend + id] = onTouchEnd;
      obj[_pre + 'dblclick' + id] = handler;
      obj.addEventListener(_touchstart, onTouchStart, false);
      obj.addEventListener(_touchend, onTouchEnd, false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
      // the browser doesn't fire touchend/pointerup events but does fire
      // native dblclicks. See #4127.
      // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.

      obj.addEventListener('dblclick', handler, false);
      return this;
    }
    function removeDoubleTapListener(obj, id) {
      var touchstart = obj[_pre + _touchstart + id],
          touchend = obj[_pre + _touchend + id],
          dblclick = obj[_pre + 'dblclick' + id];
      obj.removeEventListener(_touchstart, touchstart, false);
      obj.removeEventListener(_touchend, touchend, false);

      if (!edge) {
        obj.removeEventListener('dblclick', dblclick, false);
      }

      return this;
    }

    /*
     * @namespace DomEvent
     * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
     */
    // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
    // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
    // Adds a listener function (`fn`) to a particular DOM event type of the
    // element `el`. You can optionally specify the context of the listener
    // (object the `this` keyword will point to). You can also pass several
    // space-separated types (e.g. `'click dblclick'`).
    // @alternative
    // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
    // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

    function on(obj, types, fn, context) {
      if (typeof types === 'object') {
        for (var type in types) {
          addOne(obj, type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          addOne(obj, types[i], fn, context);
        }
      }

      return this;
    }
    var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
    // Removes a previously added listener function. If no function is specified,
    // it will remove all the listeners of that particular DOM event from the element.
    // Note that if you passed a custom context to on, you must pass the same
    // context to `off` in order to remove the listener.
    // @alternative
    // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
    // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
    // @alternative
    // @function off(el: HTMLElement): this
    // Removes all known event listeners

    function off(obj, types, fn, context) {
      if (typeof types === 'object') {
        for (var type in types) {
          removeOne(obj, type, types[type], fn);
        }
      } else if (types) {
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          removeOne(obj, types[i], fn, context);
        }
      } else {
        for (var j in obj[eventsKey]) {
          removeOne(obj, j, obj[eventsKey][j]);
        }

        delete obj[eventsKey];
      }

      return this;
    }

    function addOne(obj, type, fn, context) {
      var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

      if (obj[eventsKey] && obj[eventsKey][id]) {
        return this;
      }

      var handler = function handler(e) {
        return fn.call(context || obj, e || window.event);
      };

      var originalHandler = handler;

      if (pointer && type.indexOf('touch') === 0) {
        // Needs DomEvent.Pointer.js
        addPointerListener(obj, type, handler, id);
      } else if (touch && type === 'dblclick' && addDoubleTapListener && !(pointer && chrome)) {
        // Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
        // See #5180
        addDoubleTapListener(obj, handler, id);
      } else if ('addEventListener' in obj) {
        if (type === 'mousewheel') {
          obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
        } else if (type === 'mouseenter' || type === 'mouseleave') {
          handler = function handler(e) {
            e = e || window.event;

            if (isExternalTarget(obj, e)) {
              originalHandler(e);
            }
          };

          obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);
        } else {
          if (type === 'click' && android) {
            handler = function handler(e) {
              filterClick(e, originalHandler);
            };
          }

          obj.addEventListener(type, handler, false);
        }
      } else if ('attachEvent' in obj) {
        obj.attachEvent('on' + type, handler);
      }

      obj[eventsKey] = obj[eventsKey] || {};
      obj[eventsKey][id] = handler;
    }

    function removeOne(obj, type, fn, context) {
      var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
          handler = obj[eventsKey] && obj[eventsKey][id];

      if (!handler) {
        return this;
      }

      if (pointer && type.indexOf('touch') === 0) {
        removePointerListener(obj, type, id);
      } else if (touch && type === 'dblclick' && removeDoubleTapListener) {
        removeDoubleTapListener(obj, id);
      } else if ('removeEventListener' in obj) {
        if (type === 'mousewheel') {
          obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);
        } else {
          obj.removeEventListener(type === 'mouseenter' ? 'mouseover' : type === 'mouseleave' ? 'mouseout' : type, handler, false);
        }
      } else if ('detachEvent' in obj) {
        obj.detachEvent('on' + type, handler);
      }

      obj[eventsKey][id] = null;
    } // @function stopPropagation(ev: DOMEvent): this
    // Stop the given event from propagation to parent elements. Used inside the listener functions:
    // ```js
    // L.DomEvent.on(div, 'click', function (ev) {
    // 	L.DomEvent.stopPropagation(ev);
    // });
    // ```


    function stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else if (e.originalEvent) {
        // In case of Leaflet event.
        e.originalEvent._stopped = true;
      } else {
        e.cancelBubble = true;
      }

      skipped(e);
      return this;
    } // @function disableScrollPropagation(el: HTMLElement): this
    // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
    // `'mousedown'` and `'touchstart'` events (plus browser variants).

    function disableClickPropagation(el) {
      on(el, 'mousedown touchstart dblclick', stopPropagation);
      addOne(el, 'click', fakeStop);
      return this;
    } // @function preventDefault(ev: DOMEvent): this
    // Prevents the default action of the DOM Event `ev` from happening (such as
    // following a link in the href of the a element, or doing a POST request
    // with page reload when a `<form>` is submitted).
    // Use it inside listener functions.

    function preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }

      return this;
    } // @function stop(ev): this
    // Does `stopPropagation` and `preventDefault` at the same time.

    function stop$3(e) {
      preventDefault(e);
      stopPropagation(e);
      return this;
    } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
    // Gets normalized mouse position from a DOM event relative to the
    // `container` or to the whole page if not specified.

    function getMousePosition(e, container) {
      if (!container) {
        return new Point(e.clientX, e.clientY);
      }

      var rect = container.getBoundingClientRect();
      return new Point(e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop);
    } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
    // and Firefox scrolls device pixels, not CSS pixels

    var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number
    // Gets normalized wheel delta from a mousewheel DOM event, in vertical
    // pixels scrolled (negative if scrolling down).
    // Events from pointing devices without precise scrolling are mapped to
    // a best guess of 60 pixels.

    function getWheelDelta(e) {
      return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
      e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
      e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
      e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
      e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
      e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
      e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
      e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
      0;
    }
    var skipEvents = {};
    function fakeStop(e) {
      // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
      skipEvents[e.type] = true;
    }
    function skipped(e) {
      var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map

      skipEvents[e.type] = false;
      return events;
    } // check if element really left/entered the event target (for mouseenter/mouseleave)

    function isExternalTarget(el, e) {
      var related = e.relatedTarget;

      if (!related) {
        return true;
      }

      try {
        while (related && related !== el) {
          related = related.parentNode;
        }
      } catch (err) {
        return false;
      }

      return related !== el;
    }
    var lastClick; // this is a horrible workaround for a bug in Android where a single touch triggers two click events

    function filterClick(e, handler) {
      var timeStamp = e.timeStamp || e.originalEvent && e.originalEvent.timeStamp,
          elapsed = lastClick && timeStamp - lastClick; // are they closer together than 500ms yet more than 100ms?
      // Android typically triggers them ~300ms apart while multiple listeners
      // on the same event should be triggered far faster;
      // or check if click is simulated on the element, and if it is, reject any non-simulated events

      if (elapsed && elapsed > 100 && elapsed < 500 || e.target._simulatedClick && !e._simulated) {
        stop$3(e);
        return;
      }

      lastClick = timeStamp;
      handler(e);
    } // @function addListener(…): this

    /*
     * @namespace DomUtil
     *
     * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
     * tree, used by Leaflet internally.
     *
     * Most functions expecting or returning a `HTMLElement` also work for
     * SVG elements. The only difference is that classes refer to CSS classes
     * in HTML and SVG classes in SVG.
     */
    // @property TRANSFORM: String
    // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).

    var TRANSFORM = testProp(['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do
    // the same for the transitionend event, in particular the Android 4.1 stock browser
    // @property TRANSITION: String
    // Vendor-prefixed transition style name.

    var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String
    // Vendor-prefixed transitionend event name.

    var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement
    // Returns an element given its DOM id, or returns the element itself
    // if it was passed directly.

    function get(id) {
      return typeof id === 'string' ? document.getElementById(id) : id;
    } // @function getStyle(el: HTMLElement, styleAttrib: String): String
    // Returns the value for a certain style attribute on an element,
    // including computed values or values set through CSS.

    function getStyle(el, style) {
      var value = el.style[style] || el.currentStyle && el.currentStyle[style];

      if ((!value || value === 'auto') && document.defaultView) {
        var css = document.defaultView.getComputedStyle(el, null);
        value = css ? css[style] : null;
      }

      return value === 'auto' ? null : value;
    } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
    // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.

    function create$4(tagName, className, container) {
      var el = document.createElement(tagName);
      el.className = className || '';

      if (container) {
        container.appendChild(el);
      }

      return el;
    } // @function remove(el: HTMLElement)
    // Removes `el` from its parent element

    function remove(el) {
      var parent = el.parentNode;

      if (parent) {
        parent.removeChild(el);
      }
    } // @function empty(el: HTMLElement)
    // Makes `el` the last child of its parent, so it renders in front of the other children.

    function toFront(el) {
      var parent = el.parentNode;

      if (parent.lastChild !== el) {
        parent.appendChild(el);
      }
    } // @function toBack(el: HTMLElement)
    // Makes `el` the first child of its parent, so it renders behind the other children.

    function toBack(el) {
      var parent = el.parentNode;

      if (parent.firstChild !== el) {
        parent.insertBefore(el, parent.firstChild);
      }
    } // @function hasClass(el: HTMLElement, name: String): Boolean
    // Returns `true` if the element's class attribute contains `name`.

    function hasClass(el, name) {
      if (el.classList !== undefined) {
        return el.classList.contains(name);
      }

      var className = getClass(el);
      return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
    } // @function addClass(el: HTMLElement, name: String)
    // Adds `name` to the element's class attribute.

    function addClass(el, name) {
      if (el.classList !== undefined) {
        var classes = splitWords(name);

        for (var i = 0, len = classes.length; i < len; i++) {
          el.classList.add(classes[i]);
        }
      } else if (!hasClass(el, name)) {
        var className = getClass(el);
        setClass(el, (className ? className + ' ' : '') + name);
      }
    } // @function removeClass(el: HTMLElement, name: String)
    // Removes `name` from the element's class attribute.

    function removeClass(el, name) {
      if (el.classList !== undefined) {
        el.classList.remove(name);
      } else {
        setClass(el, trim$1((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
      }
    } // @function setClass(el: HTMLElement, name: String)
    // Sets the element's class.

    function setClass(el, name) {
      if (el.className.baseVal === undefined) {
        el.className = name;
      } else {
        // in case of SVG element
        el.className.baseVal = name;
      }
    } // @function getClass(el: HTMLElement): String
    // Returns the element's class.

    function getClass(el) {
      return el.className.baseVal === undefined ? el.className : el.className.baseVal;
    } // @function setOpacity(el: HTMLElement, opacity: Number)
    // Set the opacity of an element (including old IE support).
    // `opacity` must be a number from `0` to `1`.

    function setOpacity(el, value) {
      if ('opacity' in el.style) {
        el.style.opacity = value;
      } else if ('filter' in el.style) {
        _setOpacityIE(el, value);
      }
    }

    function _setOpacityIE(el, value) {
      var filter = false,
          filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist

      try {
        filter = el.filters.item(filterName);
      } catch (e) {
        // don't set opacity to 1 if we haven't already set an opacity,
        // it isn't needed and breaks transparent pngs.
        if (value === 1) {
          return;
        }
      }

      value = Math.round(value * 100);

      if (filter) {
        filter.Enabled = value !== 100;
        filter.Opacity = value;
      } else {
        el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
      }
    } // @function testProp(props: String[]): String|false
    // Goes through the array of style names and returns the first name
    // that is a valid style name for an element. If no such name is found,
    // it returns false. Useful for vendor-prefixed styles like `transform`.


    function testProp(props) {
      var style = document.documentElement.style;

      for (var i = 0; i < props.length; i++) {
        if (props[i] in style) {
          return props[i];
        }
      }

      return false;
    } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
    // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
    // and optionally scaled by `scale`. Does not have an effect if the
    // browser doesn't support 3D CSS transforms.

    function setTransform(el, offset, scale) {
      var pos = offset || new Point(0, 0);
      el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
    } // @function setPosition(el: HTMLElement, position: Point)
    // Sets the position of `el` to coordinates specified by `position`,
    // using CSS translate or top/left positioning depending on the browser
    // (used by Leaflet internally to position its layers).

    function setPosition(el, point) {
      /*eslint-disable */
      el._leaflet_pos = point;
      /*eslint-enable */

      if (any3d) {
        setTransform(el, point);
      } else {
        el.style.left = point.x + 'px';
        el.style.top = point.y + 'px';
      }
    } // @function getPosition(el: HTMLElement): Point
    // Returns the coordinates of an element previously positioned with setPosition.

    function getPosition(el) {
      // this method is only used for elements previously positioned using setPosition,
      // so it's safe to cache the position for performance
      return el._leaflet_pos || new Point(0, 0);
    } // @function disableTextSelection()
    // Prevents the user from generating `selectstart` DOM events, usually generated
    // when the user drags the mouse through a page with text. Used internally
    // by Leaflet to override the behaviour of any click-and-drag interaction on
    // the map. Affects drag interactions on the whole document.
    // @function enableTextSelection()
    // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).

    var disableTextSelection;
    var enableTextSelection;

    var _userSelect;

    if ('onselectstart' in document) {
      disableTextSelection = function disableTextSelection() {
        on(window, 'selectstart', preventDefault);
      };

      enableTextSelection = function enableTextSelection() {
        off(window, 'selectstart', preventDefault);
      };
    } else {
      var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

      disableTextSelection = function disableTextSelection() {
        if (userSelectProperty) {
          var style = document.documentElement.style;
          _userSelect = style[userSelectProperty];
          style[userSelectProperty] = 'none';
        }
      };

      enableTextSelection = function enableTextSelection() {
        if (userSelectProperty) {
          document.documentElement.style[userSelectProperty] = _userSelect;
          _userSelect = undefined;
        }
      };
    } // @function disableImageDrag()
    // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
    // for `dragstart` DOM events, usually generated when the user drags an image.


    function disableImageDrag() {
      on(window, 'dragstart', preventDefault);
    } // @function enableImageDrag()
    // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).

    function enableImageDrag() {
      off(window, 'dragstart', preventDefault);
    }

    var _outlineElement, _outlineStyle; // @function preventOutline(el: HTMLElement)
    // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
    // of the element `el` invisible. Used internally by Leaflet to prevent
    // focusable elements from displaying an outline when the user performs a
    // drag interaction on them.


    function preventOutline(element) {
      while (element.tabIndex === -1) {
        element = element.parentNode;
      }

      if (!element.style) {
        return;
      }

      restoreOutline();
      _outlineElement = element;
      _outlineStyle = element.style.outline;
      element.style.outline = 'none';
      on(window, 'keydown', restoreOutline);
    } // @function restoreOutline()
    // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().

    function restoreOutline() {
      if (!_outlineElement) {
        return;
      }

      _outlineElement.style.outline = _outlineStyle;
      _outlineElement = undefined;
      _outlineStyle = undefined;
      off(window, 'keydown', restoreOutline);
    }

    /*
     * @class PosAnimation
     * @aka L.PosAnimation
     * @inherits Evented
     * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
     *
     * @example
     * ```js
     * var fx = new L.PosAnimation();
     * fx.run(el, [300, 500], 0.5);
     * ```
     *
     * @constructor L.PosAnimation()
     * Creates a `PosAnimation` object.
     *
     */

    var PosAnimation = Evented.extend({
      // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
      // Run an animation of a given element to a new position, optionally setting
      // duration in seconds (`0.25` by default) and easing linearity factor (3rd
      // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
      // `0.5` by default).
      run: function run(el, newPos, duration, easeLinearity) {
        this.stop();
        this._el = el;
        this._inProgress = true;
        this._duration = duration || 0.25;
        this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
        this._startPos = getPosition(el);
        this._offset = newPos.subtract(this._startPos);
        this._startTime = +new Date(); // @event start: Event
        // Fired when the animation starts

        this.fire('start');

        this._animate();
      },
      // @method stop()
      // Stops the animation (if currently running).
      stop: function stop() {
        if (!this._inProgress) {
          return;
        }

        this._step(true);

        this._complete();
      },
      _animate: function _animate() {
        // animation loop
        this._animId = requestAnimFrame(this._animate, this);

        this._step();
      },
      _step: function _step(round) {
        var elapsed = +new Date() - this._startTime,
            duration = this._duration * 1000;

        if (elapsed < duration) {
          this._runFrame(this._easeOut(elapsed / duration), round);
        } else {
          this._runFrame(1);

          this._complete();
        }
      },
      _runFrame: function _runFrame(progress, round) {
        var pos = this._startPos.add(this._offset.multiplyBy(progress));

        if (round) {
          pos._round();
        }

        setPosition(this._el, pos); // @event step: Event
        // Fired continuously during the animation.

        this.fire('step');
      },
      _complete: function _complete() {
        cancelAnimFrame(this._animId);
        this._inProgress = false; // @event end: Event
        // Fired when the animation ends.

        this.fire('end');
      },
      _easeOut: function _easeOut(t) {
        return 1 - Math.pow(1 - t, this._easeOutPower);
      }
    });

    /*
     * @class Map
     * @aka L.Map
     * @inherits Evented
     *
     * The central class of the API — it is used to create a map on a page and manipulate it.
     *
     * @example
     *
     * ```js
     * // initialize the map on the "map" div with a given center and zoom
     * var map = L.map('map', {
     * 	center: [51.505, -0.09],
     * 	zoom: 13
     * });
     * ```
     *
     */

    var Map$2 = Evented.extend({
      options: {
        // @section Map State Options
        // @option crs: CRS = L.CRS.EPSG3857
        // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
        // sure what it means.
        crs: EPSG3857,
        // @option center: LatLng = undefined
        // Initial geographic center of the map
        center: undefined,
        // @option zoom: Number = undefined
        // Initial map zoom level
        zoom: undefined,
        // @option minZoom: Number = *
        // Minimum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the lowest of their `minZoom` options will be used instead.
        minZoom: undefined,
        // @option maxZoom: Number = *
        // Maximum zoom level of the map.
        // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
        // the highest of their `maxZoom` options will be used instead.
        maxZoom: undefined,
        // @option layers: Layer[] = []
        // Array of layers that will be added to the map initially
        layers: [],
        // @option maxBounds: LatLngBounds = null
        // When this option is set, the map restricts the view to the given
        // geographical bounds, bouncing the user back if the user tries to pan
        // outside the view. To set the restriction dynamically, use
        // [`setMaxBounds`](#map-setmaxbounds) method.
        maxBounds: undefined,
        // @option renderer: Renderer = *
        // The default method for drawing vector layers on the map. `L.SVG`
        // or `L.Canvas` by default depending on browser support.
        renderer: undefined,
        // @section Animation Options
        // @option zoomAnimation: Boolean = true
        // Whether the map zoom animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        zoomAnimation: true,
        // @option zoomAnimationThreshold: Number = 4
        // Won't animate zoom if the zoom difference exceeds this value.
        zoomAnimationThreshold: 4,
        // @option fadeAnimation: Boolean = true
        // Whether the tile fade animation is enabled. By default it's enabled
        // in all browsers that support CSS3 Transitions except Android.
        fadeAnimation: true,
        // @option markerZoomAnimation: Boolean = true
        // Whether markers animate their zoom with the zoom animation, if disabled
        // they will disappear for the length of the animation. By default it's
        // enabled in all browsers that support CSS3 Transitions except Android.
        markerZoomAnimation: true,
        // @option transform3DLimit: Number = 2^23
        // Defines the maximum size of a CSS translation transform. The default
        // value should not be changed unless a web browser positions layers in
        // the wrong place after doing a large `panBy`.
        transform3DLimit: 8388608,
        // Precision limit of a 32-bit float
        // @section Interaction Options
        // @option zoomSnap: Number = 1
        // Forces the map's zoom level to always be a multiple of this, particularly
        // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
        // By default, the zoom level snaps to the nearest integer; lower values
        // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
        // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
        zoomSnap: 1,
        // @option zoomDelta: Number = 1
        // Controls how much the map's zoom level will change after a
        // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
        // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
        // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
        zoomDelta: 1,
        // @option trackResize: Boolean = true
        // Whether the map automatically handles browser window resize to update itself.
        trackResize: true
      },
      initialize: function initialize(id, options) {
        // (HTMLElement or String, Object)
        options = setOptions(this, options);

        this._initContainer(id);

        this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980


        this._onResize = bind$1(this._onResize, this);

        this._initEvents();

        if (options.maxBounds) {
          this.setMaxBounds(options.maxBounds);
        }

        if (options.zoom !== undefined) {
          this._zoom = this._limitZoom(options.zoom);
        }

        if (options.center && options.zoom !== undefined) {
          this.setView(toLatLng(options.center), options.zoom, {
            reset: true
          });
        }

        this._handlers = [];
        this._layers = {};
        this._zoomBoundLayers = {};
        this._sizeChanged = true;
        this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera

        this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events
        // happens after starting zoom animation (propagating to the map pane), we know that it ended globally

        if (this._zoomAnimated) {
          this._createAnimProxy();

          on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
        }

        this._addLayers(this.options.layers);
      },
      // @section Methods for modifying map state
      // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) with the given
      // animation options.
      setView: function setView(center, zoom, options) {
        zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
        center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
        options = options || {};

        this._stop();

        if (this._loaded && !options.reset && options !== true) {
          if (options.animate !== undefined) {
            options.zoom = extend$4({
              animate: options.animate
            }, options.zoom);
            options.pan = extend$4({
              animate: options.animate,
              duration: options.duration
            }, options.pan);
          } // try animating pan or zoom


          var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

          if (moved) {
            // prevent resize handler call, the view will refresh after animation anyway
            clearTimeout(this._sizeTimer);
            return this;
          }
        } // animation didn't start, just reset the map view


        this._resetView(center, zoom);

        return this;
      },
      // @method setZoom(zoom: Number, options?: Zoom/pan options): this
      // Sets the zoom of the map.
      setZoom: function setZoom(zoom, options) {
        if (!this._loaded) {
          this._zoom = zoom;
          return this;
        }

        return this.setView(this.getCenter(), zoom, {
          zoom: options
        });
      },
      // @method zoomIn(delta?: Number, options?: Zoom options): this
      // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomIn: function zoomIn(delta, options) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom + delta, options);
      },
      // @method zoomOut(delta?: Number, options?: Zoom options): this
      // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
      zoomOut: function zoomOut(delta, options) {
        delta = delta || (any3d ? this.options.zoomDelta : 1);
        return this.setZoom(this._zoom - delta, options);
      },
      // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified geographical point on the map
      // stationary (e.g. used internally for scroll zoom and double-click zoom).
      // @alternative
      // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
      // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
      setZoomAround: function setZoomAround(latlng, zoom, options) {
        var scale = this.getZoomScale(zoom),
            viewHalf = this.getSize().divideBy(2),
            containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
            centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
            newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
        return this.setView(newCenter, zoom, {
          zoom: options
        });
      },
      _getBoundsCenterZoom: function _getBoundsCenterZoom(bounds, options) {
        options = options || {};
        bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
        var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
            paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
            zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
        zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

        if (zoom === Infinity) {
          return {
            center: bounds.getCenter(),
            zoom: zoom
          };
        }

        var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
            swPoint = this.project(bounds.getSouthWest(), zoom),
            nePoint = this.project(bounds.getNorthEast(), zoom),
            center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
        return {
          center: center,
          zoom: zoom
        };
      },
      // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets a map view that contains the given geographical bounds with the
      // maximum zoom level possible.
      fitBounds: function fitBounds(bounds, options) {
        bounds = toLatLngBounds(bounds);

        if (!bounds.isValid()) {
          throw new Error('Bounds are not valid.');
        }

        var target = this._getBoundsCenterZoom(bounds, options);

        return this.setView(target.center, target.zoom, options);
      },
      // @method fitWorld(options?: fitBounds options): this
      // Sets a map view that mostly contains the whole world with the maximum
      // zoom level possible.
      fitWorld: function fitWorld(options) {
        return this.fitBounds([[-90, -180], [90, 180]], options);
      },
      // @method panTo(latlng: LatLng, options?: Pan options): this
      // Pans the map to a given center.
      panTo: function panTo(center, options) {
        // (LatLng)
        return this.setView(center, this._zoom, {
          pan: options
        });
      },
      // @method panBy(offset: Point, options?: Pan options): this
      // Pans the map by a given number of pixels (animated).
      panBy: function panBy(offset, options) {
        offset = toPoint(offset).round();
        options = options || {};

        if (!offset.x && !offset.y) {
          return this.fire('moveend');
        } // If we pan too far, Chrome gets issues with tiles
        // and makes them disappear or appear in the wrong place (slightly offset) #2602


        if (options.animate !== true && !this.getSize().contains(offset)) {
          this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());

          return this;
        }

        if (!this._panAnim) {
          this._panAnim = new PosAnimation();

          this._panAnim.on({
            'step': this._onPanTransitionStep,
            'end': this._onPanTransitionEnd
          }, this);
        } // don't fire movestart if animating inertia


        if (!options.noMoveStart) {
          this.fire('movestart');
        } // animate pan unless animate: false specified


        if (options.animate !== false) {
          addClass(this._mapPane, 'leaflet-pan-anim');

          var newPos = this._getMapPanePos().subtract(offset).round();

          this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
        } else {
          this._rawPanBy(offset);

          this.fire('move').fire('moveend');
        }

        return this;
      },
      // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
      // Sets the view of the map (geographical center and zoom) performing a smooth
      // pan-zoom animation.
      flyTo: function flyTo(targetCenter, targetZoom, options) {
        options = options || {};

        if (options.animate === false || !any3d) {
          return this.setView(targetCenter, targetZoom, options);
        }

        this._stop();

        var from = this.project(this.getCenter()),
            to = this.project(targetCenter),
            size = this.getSize(),
            startZoom = this._zoom;
        targetCenter = toLatLng(targetCenter);
        targetZoom = targetZoom === undefined ? startZoom : targetZoom;
        var w0 = Math.max(size.x, size.y),
            w1 = w0 * this.getZoomScale(startZoom, targetZoom),
            u1 = to.distanceTo(from) || 1,
            rho = 1.42,
            rho2 = rho * rho;

        function r(i) {
          var s1 = i ? -1 : 1,
              s2 = i ? w1 : w0,
              t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
              b1 = 2 * s2 * rho2 * u1,
              b = t1 / b1,
              sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,
          // thus triggering an infinite loop in flyTo

          var log = sq < 0.000000001 ? -18 : Math.log(sq);
          return log;
        }

        function sinh(n) {
          return (Math.exp(n) - Math.exp(-n)) / 2;
        }

        function cosh(n) {
          return (Math.exp(n) + Math.exp(-n)) / 2;
        }

        function tanh(n) {
          return sinh(n) / cosh(n);
        }

        var r0 = r(0);

        function w(s) {
          return w0 * (cosh(r0) / cosh(r0 + rho * s));
        }

        function u(s) {
          return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
        }

        function easeOut(t) {
          return 1 - Math.pow(1 - t, 1.5);
        }

        var start = Date.now(),
            S = (r(1) - r0) / rho,
            duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

        function frame() {
          var t = (Date.now() - start) / duration,
              s = easeOut(t) * S;

          if (t <= 1) {
            this._flyToFrame = requestAnimFrame(frame, this);

            this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
              flyTo: true
            });
          } else {
            this._move(targetCenter, targetZoom)._moveEnd(true);
          }
        }

        this._moveStart(true);

        frame.call(this);
        return this;
      },
      // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
      // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
      // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
      flyToBounds: function flyToBounds(bounds, options) {
        var target = this._getBoundsCenterZoom(bounds, options);

        return this.flyTo(target.center, target.zoom, options);
      },
      // @method setMaxBounds(bounds: Bounds): this
      // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
      setMaxBounds: function setMaxBounds(bounds) {
        bounds = toLatLngBounds(bounds);

        if (!bounds.isValid()) {
          this.options.maxBounds = null;
          return this.off('moveend', this._panInsideMaxBounds);
        } else if (this.options.maxBounds) {
          this.off('moveend', this._panInsideMaxBounds);
        }

        this.options.maxBounds = bounds;

        if (this._loaded) {
          this._panInsideMaxBounds();
        }

        return this.on('moveend', this._panInsideMaxBounds);
      },
      // @method setMinZoom(zoom: Number): this
      // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
      setMinZoom: function setMinZoom(zoom) {
        this.options.minZoom = zoom;

        if (this._loaded && this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }

        return this;
      },
      // @method setMaxZoom(zoom: Number): this
      // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
      setMaxZoom: function setMaxZoom(zoom) {
        this.options.maxZoom = zoom;

        if (this._loaded && this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }

        return this;
      },
      // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
      // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
      panInsideBounds: function panInsideBounds(bounds, options) {
        this._enforcingBounds = true;

        var center = this.getCenter(),
            newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

        if (!center.equals(newCenter)) {
          this.panTo(newCenter, options);
        }

        this._enforcingBounds = false;
        return this;
      },
      // @method invalidateSize(options: Zoom/Pan options): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default. If `options.pan` is `false`, panning will not occur.
      // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
      // that it doesn't happen often even if the method is called many
      // times in a row.
      // @alternative
      // @method invalidateSize(animate: Boolean): this
      // Checks if the map container size changed and updates the map if so —
      // call it after you've changed the map size dynamically, also animating
      // pan by default.
      invalidateSize: function invalidateSize(options) {
        if (!this._loaded) {
          return this;
        }

        options = extend$4({
          animate: false,
          pan: true
        }, options === true ? {
          animate: true
        } : options);
        var oldSize = this.getSize();
        this._sizeChanged = true;
        this._lastCenter = null;
        var newSize = this.getSize(),
            oldCenter = oldSize.divideBy(2).round(),
            newCenter = newSize.divideBy(2).round(),
            offset = oldCenter.subtract(newCenter);

        if (!offset.x && !offset.y) {
          return this;
        }

        if (options.animate && options.pan) {
          this.panBy(offset);
        } else {
          if (options.pan) {
            this._rawPanBy(offset);
          }

          this.fire('move');

          if (options.debounceMoveend) {
            clearTimeout(this._sizeTimer);
            this._sizeTimer = setTimeout(bind$1(this.fire, this, 'moveend'), 200);
          } else {
            this.fire('moveend');
          }
        } // @section Map state change events
        // @event resize: ResizeEvent
        // Fired when the map is resized.


        return this.fire('resize', {
          oldSize: oldSize,
          newSize: newSize
        });
      },
      // @section Methods for modifying map state
      // @method stop(): this
      // Stops the currently running `panTo` or `flyTo` animation, if any.
      stop: function stop() {
        this.setZoom(this._limitZoom(this._zoom));

        if (!this.options.zoomSnap) {
          this.fire('viewreset');
        }

        return this._stop();
      },
      // @section Geolocation methods
      // @method locate(options?: Locate options): this
      // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
      // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
      // and optionally sets the map view to the user's location with respect to
      // detection accuracy (or to the world view if geolocation failed).
      // Note that, if your page doesn't use HTTPS, this method will fail in
      // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
      // See `Locate options` for more details.
      locate: function locate(options) {
        options = this._locateOptions = extend$4({
          timeout: 10000,
          watch: false // setView: false
          // maxZoom: <Number>
          // maximumAge: 0
          // enableHighAccuracy: false

        }, options);

        if (!('geolocation' in navigator)) {
          this._handleGeolocationError({
            code: 0,
            message: 'Geolocation not supported.'
          });

          return this;
        }

        var onResponse = bind$1(this._handleGeolocationResponse, this),
            onError = bind$1(this._handleGeolocationError, this);

        if (options.watch) {
          this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
        } else {
          navigator.geolocation.getCurrentPosition(onResponse, onError, options);
        }

        return this;
      },
      // @method stopLocate(): this
      // Stops watching location previously initiated by `map.locate({watch: true})`
      // and aborts resetting the map view if map.locate was called with
      // `{setView: true}`.
      stopLocate: function stopLocate() {
        if (navigator.geolocation && navigator.geolocation.clearWatch) {
          navigator.geolocation.clearWatch(this._locationWatchId);
        }

        if (this._locateOptions) {
          this._locateOptions.setView = false;
        }

        return this;
      },
      _handleGeolocationError: function _handleGeolocationError(error) {
        var c = error.code,
            message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

        if (this._locateOptions.setView && !this._loaded) {
          this.fitWorld();
        } // @section Location events
        // @event locationerror: ErrorEvent
        // Fired when geolocation (using the [`locate`](#map-locate) method) failed.


        this.fire('locationerror', {
          code: c,
          message: 'Geolocation error: ' + message + '.'
        });
      },
      _handleGeolocationResponse: function _handleGeolocationResponse(pos) {
        var lat = pos.coords.latitude,
            lng = pos.coords.longitude,
            latlng = new LatLng(lat, lng),
            bounds = latlng.toBounds(pos.coords.accuracy),
            options = this._locateOptions;

        if (options.setView) {
          var zoom = this.getBoundsZoom(bounds);
          this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
        }

        var data = {
          latlng: latlng,
          bounds: bounds,
          timestamp: pos.timestamp
        };

        for (var i in pos.coords) {
          if (typeof pos.coords[i] === 'number') {
            data[i] = pos.coords[i];
          }
        } // @event locationfound: LocationEvent
        // Fired when geolocation (using the [`locate`](#map-locate) method)
        // went successfully.


        this.fire('locationfound', data);
      },
      // TODO handler.addTo
      // TODO Appropiate docs section?
      // @section Other Methods
      // @method addHandler(name: String, HandlerClass: Function): this
      // Adds a new `Handler` to the map, given its name and constructor function.
      addHandler: function addHandler(name, HandlerClass) {
        if (!HandlerClass) {
          return this;
        }

        var handler = this[name] = new HandlerClass(this);

        this._handlers.push(handler);

        if (this.options[name]) {
          handler.enable();
        }

        return this;
      },
      // @method remove(): this
      // Destroys the map and clears all related event listeners.
      remove: function remove$$1() {
        this._initEvents(true);

        if (this._containerId !== this._container._leaflet_id) {
          throw new Error('Map container is being reused by another instance');
        }

        try {
          // throws error in IE6-8
          delete this._container._leaflet_id;
          delete this._containerId;
        } catch (e) {
          /*eslint-disable */
          this._container._leaflet_id = undefined;
          /*eslint-enable */

          this._containerId = undefined;
        }

        remove(this._mapPane);

        if (this._clearControlPos) {
          this._clearControlPos();
        }

        this._clearHandlers();

        if (this._loaded) {
          // @section Map state change events
          // @event unload: Event
          // Fired when the map is destroyed with [remove](#map-remove) method.
          this.fire('unload');
        }

        var i;

        for (i in this._layers) {
          this._layers[i].remove();
        }

        for (i in this._panes) {
          remove(this._panes[i]);
        }

        this._layers = [];
        this._panes = [];
        delete this._mapPane;
        delete this._renderer;
        return this;
      },
      // @section Other Methods
      // @method createPane(name: String, container?: HTMLElement): HTMLElement
      // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
      // then returns it. The pane is created as a child of `container`, or
      // as a child of the main map pane if not set.
      createPane: function createPane(name, container) {
        var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
            pane = create$4('div', className, container || this._mapPane);

        if (name) {
          this._panes[name] = pane;
        }

        return pane;
      },
      // @section Methods for Getting Map State
      // @method getCenter(): LatLng
      // Returns the geographical center of the map view
      getCenter: function getCenter() {
        this._checkIfLoaded();

        if (this._lastCenter && !this._moved()) {
          return this._lastCenter;
        }

        return this.layerPointToLatLng(this._getCenterLayerPoint());
      },
      // @method getZoom(): Number
      // Returns the current zoom level of the map view
      getZoom: function getZoom() {
        return this._zoom;
      },
      // @method getBounds(): LatLngBounds
      // Returns the geographical bounds visible in the current map view
      getBounds: function getBounds() {
        var bounds = this.getPixelBounds(),
            sw = this.unproject(bounds.getBottomLeft()),
            ne = this.unproject(bounds.getTopRight());
        return new LatLngBounds(sw, ne);
      },
      // @method getMinZoom(): Number
      // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
      getMinZoom: function getMinZoom() {
        return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
      },
      // @method getMaxZoom(): Number
      // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
      getMaxZoom: function getMaxZoom() {
        return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
      },
      // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
      // Returns the maximum zoom level on which the given bounds fit to the map
      // view in its entirety. If `inside` (optional) is set to `true`, the method
      // instead returns the minimum zoom level on which the map view fits into
      // the given bounds in its entirety.
      getBoundsZoom: function getBoundsZoom(bounds, inside, padding) {
        // (LatLngBounds[, Boolean, Point]) -> Number
        bounds = toLatLngBounds(bounds);
        padding = toPoint(padding || [0, 0]);
        var zoom = this.getZoom() || 0,
            min = this.getMinZoom(),
            max = this.getMaxZoom(),
            nw = bounds.getNorthWest(),
            se = bounds.getSouthEast(),
            size = this.getSize().subtract(padding),
            boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
            snap = any3d ? this.options.zoomSnap : 1,
            scalex = size.x / boundsSize.x,
            scaley = size.y / boundsSize.y,
            scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
        zoom = this.getScaleZoom(scale, zoom);

        if (snap) {
          zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level

          zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
        }

        return Math.max(min, Math.min(max, zoom));
      },
      // @method getSize(): Point
      // Returns the current size of the map container (in pixels).
      getSize: function getSize() {
        if (!this._size || this._sizeChanged) {
          this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
          this._sizeChanged = false;
        }

        return this._size.clone();
      },
      // @method getPixelBounds(): Bounds
      // Returns the bounds of the current map view in projected pixel
      // coordinates (sometimes useful in layer and overlay implementations).
      getPixelBounds: function getPixelBounds(center, zoom) {
        var topLeftPoint = this._getTopLeftPoint(center, zoom);

        return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
      },
      // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
      // the map pane? "left point of the map layer" can be confusing, specially
      // since there can be negative offsets.
      // @method getPixelOrigin(): Point
      // Returns the projected pixel coordinates of the top left point of
      // the map layer (useful in custom layer and overlay implementations).
      getPixelOrigin: function getPixelOrigin() {
        this._checkIfLoaded();

        return this._pixelOrigin;
      },
      // @method getPixelWorldBounds(zoom?: Number): Bounds
      // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
      // If `zoom` is omitted, the map's current zoom level is used.
      getPixelWorldBounds: function getPixelWorldBounds(zoom) {
        return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
      },
      // @section Other Methods
      // @method getPane(pane: String|HTMLElement): HTMLElement
      // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
      getPane: function getPane(pane) {
        return typeof pane === 'string' ? this._panes[pane] : pane;
      },
      // @method getPanes(): Object
      // Returns a plain object containing the names of all [panes](#map-pane) as keys and
      // the panes as values.
      getPanes: function getPanes() {
        return this._panes;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the map.
      getContainer: function getContainer() {
        return this._container;
      },
      // @section Conversion Methods
      // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
      // Returns the scale factor to be applied to a map transition from zoom level
      // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
      getZoomScale: function getZoomScale(toZoom, fromZoom) {
        // TODO replace with universal implementation after refactoring projections
        var crs = this.options.crs;
        fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
        return crs.scale(toZoom) / crs.scale(fromZoom);
      },
      // @method getScaleZoom(scale: Number, fromZoom: Number): Number
      // Returns the zoom level that the map would end up at, if it is at `fromZoom`
      // level and everything is scaled by a factor of `scale`. Inverse of
      // [`getZoomScale`](#map-getZoomScale).
      getScaleZoom: function getScaleZoom(scale, fromZoom) {
        var crs = this.options.crs;
        fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
        var zoom = crs.zoom(scale * crs.scale(fromZoom));
        return isNaN(zoom) ? Infinity : zoom;
      },
      // @method project(latlng: LatLng, zoom: Number): Point
      // Projects a geographical coordinate `LatLng` according to the projection
      // of the map's CRS, then scales it according to `zoom` and the CRS's
      // `Transformation`. The result is pixel coordinate relative to
      // the CRS origin.
      project: function project(latlng, zoom) {
        zoom = zoom === undefined ? this._zoom : zoom;
        return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
      },
      // @method unproject(point: Point, zoom: Number): LatLng
      // Inverse of [`project`](#map-project).
      unproject: function unproject(point, zoom) {
        zoom = zoom === undefined ? this._zoom : zoom;
        return this.options.crs.pointToLatLng(toPoint(point), zoom);
      },
      // @method layerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding geographical coordinate (for the current zoom level).
      layerPointToLatLng: function layerPointToLatLng(point) {
        var projectedPoint = toPoint(point).add(this.getPixelOrigin());
        return this.unproject(projectedPoint);
      },
      // @method latLngToLayerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the [origin pixel](#map-getpixelorigin).
      latLngToLayerPoint: function latLngToLayerPoint(latlng) {
        var projectedPoint = this.project(toLatLng(latlng))._round();

        return projectedPoint._subtract(this.getPixelOrigin());
      },
      // @method wrapLatLng(latlng: LatLng): LatLng
      // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
      // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
      // CRS's bounds.
      // By default this means longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees.
      wrapLatLng: function wrapLatLng(latlng) {
        return this.options.crs.wrapLatLng(toLatLng(latlng));
      },
      // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
      // Returns a `LatLngBounds` with the same size as the given one, ensuring that
      // its center is within the CRS's bounds.
      // By default this means the center longitude is wrapped around the dateline so its
      // value is between -180 and +180 degrees, and the majority of the bounds
      // overlaps the CRS's bounds.
      wrapLatLngBounds: function wrapLatLngBounds(latlng) {
        return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
      },
      // @method distance(latlng1: LatLng, latlng2: LatLng): Number
      // Returns the distance between two geographical coordinates according to
      // the map's CRS. By default this measures distance in meters.
      distance: function distance(latlng1, latlng2) {
        return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
      },
      // @method containerPointToLayerPoint(point: Point): Point
      // Given a pixel coordinate relative to the map container, returns the corresponding
      // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
      containerPointToLayerPoint: function containerPointToLayerPoint(point) {
        // (Point)
        return toPoint(point).subtract(this._getMapPanePos());
      },
      // @method layerPointToContainerPoint(point: Point): Point
      // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
      // returns the corresponding pixel coordinate relative to the map container.
      layerPointToContainerPoint: function layerPointToContainerPoint(point) {
        // (Point)
        return toPoint(point).add(this._getMapPanePos());
      },
      // @method containerPointToLatLng(point: Point): LatLng
      // Given a pixel coordinate relative to the map container, returns
      // the corresponding geographical coordinate (for the current zoom level).
      containerPointToLatLng: function containerPointToLatLng(point) {
        var layerPoint = this.containerPointToLayerPoint(toPoint(point));
        return this.layerPointToLatLng(layerPoint);
      },
      // @method latLngToContainerPoint(latlng: LatLng): Point
      // Given a geographical coordinate, returns the corresponding pixel coordinate
      // relative to the map container.
      latLngToContainerPoint: function latLngToContainerPoint(latlng) {
        return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
      },
      // @method mouseEventToContainerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to the
      // map container where the event took place.
      mouseEventToContainerPoint: function mouseEventToContainerPoint(e) {
        return getMousePosition(e, this._container);
      },
      // @method mouseEventToLayerPoint(ev: MouseEvent): Point
      // Given a MouseEvent object, returns the pixel coordinate relative to
      // the [origin pixel](#map-getpixelorigin) where the event took place.
      mouseEventToLayerPoint: function mouseEventToLayerPoint(e) {
        return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
      },
      // @method mouseEventToLatLng(ev: MouseEvent): LatLng
      // Given a MouseEvent object, returns geographical coordinate where the
      // event took place.
      mouseEventToLatLng: function mouseEventToLatLng(e) {
        // (MouseEvent)
        return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
      },
      // map initialization methods
      _initContainer: function _initContainer(id) {
        var container = this._container = get(id);

        if (!container) {
          throw new Error('Map container not found.');
        } else if (container._leaflet_id) {
          throw new Error('Map container is already initialized.');
        }

        on(container, 'scroll', this._onScroll, this);
        this._containerId = stamp(container);
      },
      _initLayout: function _initLayout() {
        var container = this._container;
        this._fadeAnimated = this.options.fadeAnimation && any3d;
        addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));
        var position = getStyle(container, 'position');

        if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
          container.style.position = 'relative';
        }

        this._initPanes();

        if (this._initControlPos) {
          this._initControlPos();
        }
      },
      _initPanes: function _initPanes() {
        var panes = this._panes = {};
        this._paneRenderers = {}; // @section
        //
        // Panes are DOM elements used to control the ordering of layers on the map. You
        // can access panes with [`map.getPane`](#map-getpane) or
        // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
        // [`map.createPane`](#map-createpane) method.
        //
        // Every map has the following default panes that differ only in zIndex.
        //
        // @pane mapPane: HTMLElement = 'auto'
        // Pane that contains all other map panes

        this._mapPane = this.createPane('mapPane', this._container);
        setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200
        // Pane for `GridLayer`s and `TileLayer`s

        this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400
        // Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s

        this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500
        // Pane for overlay shadows (e.g. `Marker` shadows)

        this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600
        // Pane for `Icon`s of `Marker`s

        this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650
        // Pane for tooltip.

        this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700
        // Pane for `Popup`s.

        this.createPane('popupPane');

        if (!this.options.markerZoomAnimation) {
          addClass(panes.markerPane, 'leaflet-zoom-hide');
          addClass(panes.shadowPane, 'leaflet-zoom-hide');
        }
      },
      // private methods that modify map state
      // @section Map state change events
      _resetView: function _resetView(center, zoom) {
        setPosition(this._mapPane, new Point(0, 0));
        var loading = !this._loaded;
        this._loaded = true;
        zoom = this._limitZoom(zoom);
        this.fire('viewprereset');
        var zoomChanged = this._zoom !== zoom;

        this._moveStart(zoomChanged)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event
        // Fired when the map needs to redraw its content (this usually happens
        // on map zoom or load). Very useful for creating custom overlays.


        this.fire('viewreset'); // @event load: Event
        // Fired when the map is initialized (when its center and zoom are set
        // for the first time).

        if (loading) {
          this.fire('load');
        }
      },
      _moveStart: function _moveStart(zoomChanged) {
        // @event zoomstart: Event
        // Fired when the map zoom is about to change (e.g. before zoom animation).
        // @event movestart: Event
        // Fired when the view of the map starts changing (e.g. user starts dragging the map).
        if (zoomChanged) {
          this.fire('zoomstart');
        }

        return this.fire('movestart');
      },
      _move: function _move(center, zoom, data) {
        if (zoom === undefined) {
          zoom = this._zoom;
        }

        var zoomChanged = this._zoom !== zoom;
        this._zoom = zoom;
        this._lastCenter = center;
        this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event
        // Fired repeatedly during any change in zoom level, including zoom
        // and fly animations.

        if (zoomChanged || data && data.pinch) {
          // Always fire 'zoom' if pinching because #3530
          this.fire('zoom', data);
        } // @event move: Event
        // Fired repeatedly during any movement of the map, including pan and
        // fly animations.


        return this.fire('move', data);
      },
      _moveEnd: function _moveEnd(zoomChanged) {
        // @event zoomend: Event
        // Fired when the map has changed, after any animations.
        if (zoomChanged) {
          this.fire('zoomend');
        } // @event moveend: Event
        // Fired when the center of the map stops changing (e.g. user stopped
        // dragging the map).


        return this.fire('moveend');
      },
      _stop: function _stop() {
        cancelAnimFrame(this._flyToFrame);

        if (this._panAnim) {
          this._panAnim.stop();
        }

        return this;
      },
      _rawPanBy: function _rawPanBy(offset) {
        setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
      },
      _getZoomSpan: function _getZoomSpan() {
        return this.getMaxZoom() - this.getMinZoom();
      },
      _panInsideMaxBounds: function _panInsideMaxBounds() {
        if (!this._enforcingBounds) {
          this.panInsideBounds(this.options.maxBounds);
        }
      },
      _checkIfLoaded: function _checkIfLoaded() {
        if (!this._loaded) {
          throw new Error('Set map center and zoom first.');
        }
      },
      // DOM event handling
      // @section Interaction events
      _initEvents: function _initEvents(remove$$1) {
        this._targets = {};
        this._targets[stamp(this._container)] = this;
        var onOff = remove$$1 ? off : on; // @event click: MouseEvent
        // Fired when the user clicks (or taps) the map.
        // @event dblclick: MouseEvent
        // Fired when the user double-clicks (or double-taps) the map.
        // @event mousedown: MouseEvent
        // Fired when the user pushes the mouse button on the map.
        // @event mouseup: MouseEvent
        // Fired when the user releases the mouse button on the map.
        // @event mouseover: MouseEvent
        // Fired when the mouse enters the map.
        // @event mouseout: MouseEvent
        // Fired when the mouse leaves the map.
        // @event mousemove: MouseEvent
        // Fired while the mouse moves over the map.
        // @event contextmenu: MouseEvent
        // Fired when the user pushes the right mouse button on the map, prevents
        // default browser context menu from showing if there are listeners on
        // this event. Also fired on mobile when the user holds a single touch
        // for a second (also called long press).
        // @event keypress: KeyboardEvent
        // Fired when the user presses a key from the keyboard while the map is focused.

        onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

        if (this.options.trackResize) {
          onOff(window, 'resize', this._onResize, this);
        }

        if (any3d && this.options.transform3DLimit) {
          (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
        }
      },
      _onResize: function _onResize() {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = requestAnimFrame(function () {
          this.invalidateSize({
            debounceMoveend: true
          });
        }, this);
      },
      _onScroll: function _onScroll() {
        this._container.scrollTop = 0;
        this._container.scrollLeft = 0;
      },
      _onMoveEnd: function _onMoveEnd() {
        var pos = this._getMapPanePos();

        if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
          // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
          this._resetView(this.getCenter(), this.getZoom());
        }
      },
      _findEventTargets: function _findEventTargets(e, type) {
        var targets = [],
            target,
            isHover = type === 'mouseout' || type === 'mouseover',
            src = e.target || e.srcElement,
            dragging = false;

        while (src) {
          target = this._targets[stamp(src)];

          if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
            // Prevent firing click after you just dragged an object.
            dragging = true;
            break;
          }

          if (target && target.listens(type, true)) {
            if (isHover && !isExternalTarget(src, e)) {
              break;
            }

            targets.push(target);

            if (isHover) {
              break;
            }
          }

          if (src === this._container) {
            break;
          }

          src = src.parentNode;
        }

        if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
          targets = [this];
        }

        return targets;
      },
      _handleDOMEvent: function _handleDOMEvent(e) {
        if (!this._loaded || skipped(e)) {
          return;
        }

        var type = e.type;

        if (type === 'mousedown' || type === 'keypress') {
          // prevents outline when clicking on keyboard-focusable element
          preventOutline(e.target || e.srcElement);
        }

        this._fireDOMEvent(e, type);
      },
      _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
      _fireDOMEvent: function _fireDOMEvent(e, type, targets) {
        if (e.type === 'click') {
          // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
          // @event preclick: MouseEvent
          // Fired before mouse click on the map (sometimes useful when you
          // want something to happen on click before any existing click
          // handlers start running).
          var synth = extend$4({}, e);
          synth.type = 'preclick';

          this._fireDOMEvent(synth, synth.type, targets);
        }

        if (e._stopped) {
          return;
        } // Find the layer the event is propagating from and its parents.


        targets = (targets || []).concat(this._findEventTargets(e, type));

        if (!targets.length) {
          return;
        }

        var target = targets[0];

        if (type === 'contextmenu' && target.listens(type, true)) {
          preventDefault(e);
        }

        var data = {
          originalEvent: e
        };

        if (e.type !== 'keypress') {
          var isMarker = target.options && 'icon' in target.options;
          data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
          data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
          data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
        }

        for (var i = 0; i < targets.length; i++) {
          targets[i].fire(type, data, true);

          if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf$1(this._mouseEvents, type) !== -1) {
            return;
          }
        }
      },
      _draggableMoved: function _draggableMoved(obj) {
        obj = obj.dragging && obj.dragging.enabled() ? obj : this;
        return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
      },
      _clearHandlers: function _clearHandlers() {
        for (var i = 0, len = this._handlers.length; i < len; i++) {
          this._handlers[i].disable();
        }
      },
      // @section Other Methods
      // @method whenReady(fn: Function, context?: Object): this
      // Runs the given function `fn` when the map gets initialized with
      // a view (center and zoom) and at least one layer, or immediately
      // if it's already initialized, optionally passing a function context.
      whenReady: function whenReady(callback, context) {
        if (this._loaded) {
          callback.call(context || this, {
            target: this
          });
        } else {
          this.on('load', callback, context);
        }

        return this;
      },
      // private methods for getting map state
      _getMapPanePos: function _getMapPanePos() {
        return getPosition(this._mapPane) || new Point(0, 0);
      },
      _moved: function _moved() {
        var pos = this._getMapPanePos();

        return pos && !pos.equals([0, 0]);
      },
      _getTopLeftPoint: function _getTopLeftPoint(center, zoom) {
        var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
        return pixelOrigin.subtract(this._getMapPanePos());
      },
      _getNewPixelOrigin: function _getNewPixelOrigin(center, zoom) {
        var viewHalf = this.getSize()._divideBy(2);

        return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
      },
      _latLngToNewLayerPoint: function _latLngToNewLayerPoint(latlng, zoom, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom);

        return this.project(latlng, zoom)._subtract(topLeft);
      },
      _latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(latLngBounds, zoom, center) {
        var topLeft = this._getNewPixelOrigin(center, zoom);

        return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
      },
      // layer point of the current center
      _getCenterLayerPoint: function _getCenterLayerPoint() {
        return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
      },
      // offset of the specified place to the current center in pixels
      _getCenterOffset: function _getCenterOffset(latlng) {
        return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
      },
      // adjust center for view to get inside bounds
      _limitCenter: function _limitCenter(center, zoom, bounds) {
        if (!bounds) {
          return center;
        }

        var centerPoint = this.project(center, zoom),
            viewHalf = this.getSize().divideBy(2),
            viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
            offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.
        // This prevents unstable projections from getting into
        // an infinite loop of tiny offsets.


        if (offset.round().equals([0, 0])) {
          return center;
        }

        return this.unproject(centerPoint.add(offset), zoom);
      },
      // adjust offset for view to get inside bounds
      _limitOffset: function _limitOffset(offset, bounds) {
        if (!bounds) {
          return offset;
        }

        var viewBounds = this.getPixelBounds(),
            newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
        return offset.add(this._getBoundsOffset(newBounds, bounds));
      },
      // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
      _getBoundsOffset: function _getBoundsOffset(pxBounds, maxBounds, zoom) {
        var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
            minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
            maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
            dx = this._rebound(minOffset.x, -maxOffset.x),
            dy = this._rebound(minOffset.y, -maxOffset.y);

        return new Point(dx, dy);
      },
      _rebound: function _rebound(left, right) {
        return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
      },
      _limitZoom: function _limitZoom(zoom) {
        var min = this.getMinZoom(),
            max = this.getMaxZoom(),
            snap = any3d ? this.options.zoomSnap : 1;

        if (snap) {
          zoom = Math.round(zoom / snap) * snap;
        }

        return Math.max(min, Math.min(max, zoom));
      },
      _onPanTransitionStep: function _onPanTransitionStep() {
        this.fire('move');
      },
      _onPanTransitionEnd: function _onPanTransitionEnd() {
        removeClass(this._mapPane, 'leaflet-pan-anim');
        this.fire('moveend');
      },
      _tryAnimatedPan: function _tryAnimatedPan(center, options) {
        // difference between the new and current centers in pixels
        var offset = this._getCenterOffset(center)._floor(); // don't animate too far unless animate: true specified in options


        if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
          return false;
        }

        this.panBy(offset, options);
        return true;
      },
      _createAnimProxy: function _createAnimProxy() {
        var proxy = this._proxy = create$4('div', 'leaflet-proxy leaflet-zoom-animated');

        this._panes.mapPane.appendChild(proxy);

        this.on('zoomanim', function (e) {
          var prop = TRANSFORM,
              transform = this._proxy.style[prop];
          setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired

          if (transform === this._proxy.style[prop] && this._animatingZoom) {
            this._onZoomTransitionEnd();
          }
        }, this);
        this.on('load moveend', function () {
          var c = this.getCenter(),
              z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        }, this);

        this._on('unload', this._destroyAnimProxy, this);
      },
      _destroyAnimProxy: function _destroyAnimProxy() {
        remove(this._proxy);
        delete this._proxy;
      },
      _catchTransitionEnd: function _catchTransitionEnd(e) {
        if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
          this._onZoomTransitionEnd();
        }
      },
      _nothingToAnimate: function _nothingToAnimate() {
        return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
      },
      _tryAnimatedZoom: function _tryAnimatedZoom(center, zoom, options) {
        if (this._animatingZoom) {
          return true;
        }

        options = options || {}; // don't animate if disabled, not supported or zoom difference is too large

        if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
          return false;
        } // offset is the pixel coords of the zoom origin relative to the current center


        var scale = this.getZoomScale(zoom),
            offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced


        if (options.animate !== true && !this.getSize().contains(offset)) {
          return false;
        }

        requestAnimFrame(function () {
          this._moveStart(true)._animateZoom(center, zoom, true);
        }, this);
        return true;
      },
      _animateZoom: function _animateZoom(center, zoom, startAnim, noUpdate) {
        if (startAnim) {
          this._animatingZoom = true; // remember what center/zoom to set after animation

          this._animateToCenter = center;
          this._animateToZoom = zoom;
          addClass(this._mapPane, 'leaflet-zoom-anim');
        } // @event zoomanim: ZoomAnimEvent
        // Fired on every frame of a zoom animation


        this.fire('zoomanim', {
          center: center,
          zoom: zoom,
          noUpdate: noUpdate
        }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693

        setTimeout(bind$1(this._onZoomTransitionEnd, this), 250);
      },
      _onZoomTransitionEnd: function _onZoomTransitionEnd() {
        if (!this._animatingZoom) {
          return;
        }

        removeClass(this._mapPane, 'leaflet-zoom-anim');
        this._animatingZoom = false;

        this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.


        requestAnimFrame(function () {
          this._moveEnd(true);
        }, this);
      }
    }); // @section

    /*
     * @class Layer
     * @inherits Evented
     * @aka L.Layer
     * @aka ILayer
     *
     * A set of methods from the Layer base class that all Leaflet layers use.
     * Inherits all methods, options and events from `L.Evented`.
     *
     * @example
     *
     * ```js
     * var layer = L.Marker(latlng).addTo(map);
     * layer.addTo(map);
     * layer.remove();
     * ```
     *
     * @event add: Event
     * Fired after the layer is added to a map
     *
     * @event remove: Event
     * Fired after the layer is removed from a map
     */

    var Layer$1 = Evented.extend({
      // Classes extending `L.Layer` will inherit the following options:
      options: {
        // @option pane: String = 'overlayPane'
        // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
        pane: 'overlayPane',
        // @option attribution: String = null
        // String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
        attribution: null,
        bubblingMouseEvents: true
      },

      /* @section
       * Classes extending `L.Layer` will inherit the following methods:
       *
       * @method addTo(map: Map|LayerGroup): this
       * Adds the layer to the given map or layer group.
       */
      addTo: function addTo(map) {
        map.addLayer(this);
        return this;
      },
      // @method remove: this
      // Removes the layer from the map it is currently active on.
      remove: function remove() {
        return this.removeFrom(this._map || this._mapToAdd);
      },
      // @method removeFrom(map: Map): this
      // Removes the layer from the given map
      removeFrom: function removeFrom(obj) {
        if (obj) {
          obj.removeLayer(this);
        }

        return this;
      },
      // @method getPane(name? : String): HTMLElement
      // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
      getPane: function getPane(name) {
        return this._map.getPane(name ? this.options[name] || name : this.options.pane);
      },
      addInteractiveTarget: function addInteractiveTarget(targetEl) {
        this._map._targets[stamp(targetEl)] = this;
        return this;
      },
      removeInteractiveTarget: function removeInteractiveTarget(targetEl) {
        delete this._map._targets[stamp(targetEl)];
        return this;
      },
      // @method getAttribution: String
      // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
      getAttribution: function getAttribution() {
        return this.options.attribution;
      },
      _layerAdd: function _layerAdd(e) {
        var map = e.target; // check in case layer gets added and then removed before the map is ready

        if (!map.hasLayer(this)) {
          return;
        }

        this._map = map;
        this._zoomAnimated = map._zoomAnimated;

        if (this.getEvents) {
          var events = this.getEvents();
          map.on(events, this);
          this.once('remove', function () {
            map.off(events, this);
          }, this);
        }

        this.onAdd(map);

        if (this.getAttribution && map.attributionControl) {
          map.attributionControl.addAttribution(this.getAttribution());
        }

        this.fire('add');
        map.fire('layeradd', {
          layer: this
        });
      }
    });
    /* @section Extension methods
     * @uninheritable
     *
     * Every layer should extend from `L.Layer` and (re-)implement the following methods.
     *
     * @method onAdd(map: Map): this
     * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
     *
     * @method onRemove(map: Map): this
     * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
     *
     * @method getEvents(): Object
     * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
     *
     * @method getAttribution(): String
     * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
     *
     * @method beforeAdd(map: Map): this
     * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
     */

    /* @namespace Map
     * @section Layer events
     *
     * @event layeradd: LayerEvent
     * Fired when a new layer is added to the map.
     *
     * @event layerremove: LayerEvent
     * Fired when some layer is removed from the map
     *
     * @section Methods for Layers and Controls
     */

    Map$2.include({
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the map
      addLayer: function addLayer(layer) {
        if (!layer._layerAdd) {
          throw new Error('The provided object is not a Layer.');
        }

        var id = stamp(layer);

        if (this._layers[id]) {
          return this;
        }

        this._layers[id] = layer;
        layer._mapToAdd = this;

        if (layer.beforeAdd) {
          layer.beforeAdd(this);
        }

        this.whenReady(layer._layerAdd, layer);
        return this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the map.
      removeLayer: function removeLayer(layer) {
        var id = stamp(layer);

        if (!this._layers[id]) {
          return this;
        }

        if (this._loaded) {
          layer.onRemove(this);
        }

        if (layer.getAttribution && this.attributionControl) {
          this.attributionControl.removeAttribution(layer.getAttribution());
        }

        delete this._layers[id];

        if (this._loaded) {
          this.fire('layerremove', {
            layer: layer
          });
          layer.fire('remove');
        }

        layer._map = layer._mapToAdd = null;
        return this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the map
      hasLayer: function hasLayer(layer) {
        return !!layer && stamp(layer) in this._layers;
      },

      /* @method eachLayer(fn: Function, context?: Object): this
       * Iterates over the layers of the map, optionally specifying context of the iterator function.
       * ```
       * map.eachLayer(function(layer){
       *     layer.bindPopup('Hello');
       * });
       * ```
       */
      eachLayer: function eachLayer(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }

        return this;
      },
      _addLayers: function _addLayers(layers) {
        layers = layers ? isArray$2(layers) ? layers : [layers] : [];

        for (var i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      },
      _addZoomLimit: function _addZoomLimit(layer) {
        if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
          this._zoomBoundLayers[stamp(layer)] = layer;

          this._updateZoomLevels();
        }
      },
      _removeZoomLimit: function _removeZoomLimit(layer) {
        var id = stamp(layer);

        if (this._zoomBoundLayers[id]) {
          delete this._zoomBoundLayers[id];

          this._updateZoomLevels();
        }
      },
      _updateZoomLevels: function _updateZoomLevels() {
        var minZoom = Infinity,
            maxZoom = -Infinity,
            oldZoomSpan = this._getZoomSpan();

        for (var i in this._zoomBoundLayers) {
          var options = this._zoomBoundLayers[i].options;
          minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
          maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
        }

        this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
        this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events
        // @event zoomlevelschange: Event
        // Fired when the number of zoomlevels on the map is changed due
        // to adding or removing a layer.

        if (oldZoomSpan !== this._getZoomSpan()) {
          this.fire('zoomlevelschange');
        }

        if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
          this.setZoom(this._layersMaxZoom);
        }

        if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
          this.setZoom(this._layersMinZoom);
        }
      }
    });

    /*
     * @class LayerGroup
     * @aka L.LayerGroup
     * @inherits Layer
     *
     * Used to group several layers and handle them as one. If you add it to the map,
     * any layers added or removed from the group will be added/removed on the map as
     * well. Extends `Layer`.
     *
     * @example
     *
     * ```js
     * L.layerGroup([marker1, marker2])
     * 	.addLayer(polyline)
     * 	.addTo(map);
     * ```
     */

    var LayerGroup = Layer$1.extend({
      initialize: function initialize(layers) {
        this._layers = {};
        var i, len;

        if (layers) {
          for (i = 0, len = layers.length; i < len; i++) {
            this.addLayer(layers[i]);
          }
        }
      },
      // @method addLayer(layer: Layer): this
      // Adds the given layer to the group.
      addLayer: function addLayer(layer) {
        var id = this.getLayerId(layer);
        this._layers[id] = layer;

        if (this._map) {
          this._map.addLayer(layer);
        }

        return this;
      },
      // @method removeLayer(layer: Layer): this
      // Removes the given layer from the group.
      // @alternative
      // @method removeLayer(id: Number): this
      // Removes the layer with the given internal ID from the group.
      removeLayer: function removeLayer(layer) {
        var id = layer in this._layers ? layer : this.getLayerId(layer);

        if (this._map && this._layers[id]) {
          this._map.removeLayer(this._layers[id]);
        }

        delete this._layers[id];
        return this;
      },
      // @method hasLayer(layer: Layer): Boolean
      // Returns `true` if the given layer is currently added to the group.
      // @alternative
      // @method hasLayer(id: Number): Boolean
      // Returns `true` if the given internal ID is currently added to the group.
      hasLayer: function hasLayer(layer) {
        return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
      },
      // @method clearLayers(): this
      // Removes all the layers from the group.
      clearLayers: function clearLayers() {
        for (var i in this._layers) {
          this.removeLayer(this._layers[i]);
        }

        return this;
      },
      // @method invoke(methodName: String, …): this
      // Calls `methodName` on every layer contained in this group, passing any
      // additional parameters. Has no effect if the layers contained do not
      // implement `methodName`.
      invoke: function invoke(methodName) {
        var args = Array.prototype.slice.call(arguments, 1),
            i,
            layer;

        for (i in this._layers) {
          layer = this._layers[i];

          if (layer[methodName]) {
            layer[methodName].apply(layer, args);
          }
        }

        return this;
      },
      onAdd: function onAdd(map) {
        for (var i in this._layers) {
          map.addLayer(this._layers[i]);
        }
      },
      onRemove: function onRemove(map) {
        for (var i in this._layers) {
          map.removeLayer(this._layers[i]);
        }
      },
      // @method eachLayer(fn: Function, context?: Object): this
      // Iterates over the layers of the group, optionally specifying context of the iterator function.
      // ```js
      // group.eachLayer(function (layer) {
      // 	layer.bindPopup('Hello');
      // });
      // ```
      eachLayer: function eachLayer(method, context) {
        for (var i in this._layers) {
          method.call(context, this._layers[i]);
        }

        return this;
      },
      // @method getLayer(id: Number): Layer
      // Returns the layer with the given internal ID.
      getLayer: function getLayer(id) {
        return this._layers[id];
      },
      // @method getLayers(): Layer[]
      // Returns an array of all the layers added to the group.
      getLayers: function getLayers() {
        var layers = [];

        for (var i in this._layers) {
          layers.push(this._layers[i]);
        }

        return layers;
      },
      // @method setZIndex(zIndex: Number): this
      // Calls `setZIndex` on every layer contained in this group, passing the z-index.
      setZIndex: function setZIndex(zIndex) {
        return this.invoke('setZIndex', zIndex);
      },
      // @method getLayerId(layer: Layer): Number
      // Returns the internal ID for a layer
      getLayerId: function getLayerId(layer) {
        return stamp(layer);
      }
    }); // @factory L.layerGroup(layers?: Layer[])

    /*
     * @class FeatureGroup
     * @aka L.FeatureGroup
     * @inherits LayerGroup
     *
     * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
     *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
     *  * Events are propagated to the `FeatureGroup`, so if the group has an event
     * handler, it will handle events from any of the layers. This includes mouse events
     * and custom events.
     *  * Has `layeradd` and `layerremove` events
     *
     * @example
     *
     * ```js
     * L.featureGroup([marker1, marker2, polyline])
     * 	.bindPopup('Hello world!')
     * 	.on('click', function() { alert('Clicked on a member of the group!'); })
     * 	.addTo(map);
     * ```
     */

    var FeatureGroup = LayerGroup.extend({
      addLayer: function addLayer(layer) {
        if (this.hasLayer(layer)) {
          return this;
        }

        layer.addEventParent(this);
        LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent
        // Fired when a layer is added to this `FeatureGroup`

        return this.fire('layeradd', {
          layer: layer
        });
      },
      removeLayer: function removeLayer(layer) {
        if (!this.hasLayer(layer)) {
          return this;
        }

        if (layer in this._layers) {
          layer = this._layers[layer];
        }

        layer.removeEventParent(this);
        LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent
        // Fired when a layer is removed from this `FeatureGroup`

        return this.fire('layerremove', {
          layer: layer
        });
      },
      // @method setStyle(style: Path options): this
      // Sets the given path options to each layer of the group that has a `setStyle` method.
      setStyle: function setStyle(style) {
        return this.invoke('setStyle', style);
      },
      // @method bringToFront(): this
      // Brings the layer group to the top of all other layers
      bringToFront: function bringToFront() {
        return this.invoke('bringToFront');
      },
      // @method bringToBack(): this
      // Brings the layer group to the top of all other layers
      bringToBack: function bringToBack() {
        return this.invoke('bringToBack');
      },
      // @method getBounds(): LatLngBounds
      // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
      getBounds: function getBounds() {
        var bounds = new LatLngBounds();

        for (var id in this._layers) {
          var layer = this._layers[id];
          bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
        }

        return bounds;
      }
    }); // @factory L.featureGroup(layers: Layer[])

    /*
     * @class Icon
     * @aka L.Icon
     *
     * Represents an icon to provide when creating a marker.
     *
     * @example
     *
     * ```js
     * var myIcon = L.icon({
     *     iconUrl: 'my-icon.png',
     *     iconRetinaUrl: 'my-icon@2x.png',
     *     iconSize: [38, 95],
     *     iconAnchor: [22, 94],
     *     popupAnchor: [-3, -76],
     *     shadowUrl: 'my-icon-shadow.png',
     *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
     *     shadowSize: [68, 95],
     *     shadowAnchor: [22, 94]
     * });
     *
     * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
     * ```
     *
     * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
     *
     */

    var Icon = Class.extend({
      /* @section
       * @aka Icon options
       *
       * @option iconUrl: String = null
       * **(required)** The URL to the icon image (absolute or relative to your script path).
       *
       * @option iconRetinaUrl: String = null
       * The URL to a retina sized version of the icon image (absolute or relative to your
       * script path). Used for Retina screen devices.
       *
       * @option iconSize: Point = null
       * Size of the icon image in pixels.
       *
       * @option iconAnchor: Point = null
       * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
       * will be aligned so that this point is at the marker's geographical location. Centered
       * by default if size is specified, also can be set in CSS with negative margins.
       *
       * @option popupAnchor: Point = null
       * The coordinates of the point from which popups will "open", relative to the icon anchor.
       *
       * @option shadowUrl: String = null
       * The URL to the icon shadow image. If not specified, no shadow image will be created.
       *
       * @option shadowRetinaUrl: String = null
       *
       * @option shadowSize: Point = null
       * Size of the shadow image in pixels.
       *
       * @option shadowAnchor: Point = null
       * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
       * as iconAnchor if not specified).
       *
       * @option className: String = ''
       * A custom class name to assign to both icon and shadow images. Empty by default.
       */
      initialize: function initialize(options) {
        setOptions(this, options);
      },
      // @method createIcon(oldIcon?: HTMLElement): HTMLElement
      // Called internally when the icon has to be shown, returns a `<img>` HTML element
      // styled according to the options.
      createIcon: function createIcon(oldIcon) {
        return this._createIcon('icon', oldIcon);
      },
      // @method createShadow(oldIcon?: HTMLElement): HTMLElement
      // As `createIcon`, but for the shadow beneath it.
      createShadow: function createShadow(oldIcon) {
        return this._createIcon('shadow', oldIcon);
      },
      _createIcon: function _createIcon(name, oldIcon) {
        var src = this._getIconUrl(name);

        if (!src) {
          if (name === 'icon') {
            throw new Error('iconUrl not set in Icon options (see the docs).');
          }

          return null;
        }

        var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);

        this._setIconStyles(img, name);

        return img;
      },
      _setIconStyles: function _setIconStyles(img, name) {
        var options = this.options;
        var sizeOption = options[name + 'Size'];

        if (typeof sizeOption === 'number') {
          sizeOption = [sizeOption, sizeOption];
        }

        var size = toPoint(sizeOption),
            anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
        img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

        if (anchor) {
          img.style.marginLeft = -anchor.x + 'px';
          img.style.marginTop = -anchor.y + 'px';
        }

        if (size) {
          img.style.width = size.x + 'px';
          img.style.height = size.y + 'px';
        }
      },
      _createImg: function _createImg(src, el) {
        el = el || document.createElement('img');
        el.src = src;
        return el;
      },
      _getIconUrl: function _getIconUrl(name) {
        return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
      }
    }); // @factory L.icon(options: Icon options)

    /*
     * @miniclass Icon.Default (Icon)
     * @aka L.Icon.Default
     * @section
     *
     * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
     * no icon is specified. Points to the blue marker image distributed with Leaflet
     * releases.
     *
     * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
     * (which is a set of `Icon options`).
     *
     * If you want to _completely_ replace the default icon, override the
     * `L.Marker.prototype.options.icon` with your own icon instead.
     */

    var IconDefault = Icon.extend({
      options: {
        iconUrl: 'marker-icon.png',
        iconRetinaUrl: 'marker-icon-2x.png',
        shadowUrl: 'marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        tooltipAnchor: [16, -28],
        shadowSize: [41, 41]
      },
      _getIconUrl: function _getIconUrl(name) {
        if (!IconDefault.imagePath) {
          // Deprecated, backwards-compatibility only
          IconDefault.imagePath = this._detectIconPath();
        } // @option imagePath: String
        // `Icon.Default` will try to auto-detect the absolute location of the
        // blue icon images. If you are placing these images in a non-standard
        // way, set this option to point to the right absolute path.


        return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
      },
      _detectIconPath: function _detectIconPath() {
        var el = create$4('div', 'leaflet-default-icon-path', document.body);
        var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

        document.body.removeChild(el);

        if (path === null || path.indexOf('url') !== 0) {
          path = '';
        } else {
          path = path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '');
        }

        return path;
      }
    });

    /*
    	L.Handler is a base class for handler classes that are used internally to inject
    	interaction features like dragging to classes like Map and Marker.
    */
    // @class Handler
    // @aka L.Handler
    // Abstract class for map interaction handlers

    var Handler$1 = Class.extend({
      initialize: function initialize(map) {
        this._map = map;
      },
      // @method enable(): this
      // Enables the handler
      enable: function enable() {
        if (this._enabled) {
          return this;
        }

        this._enabled = true;
        this.addHooks();
        return this;
      },
      // @method disable(): this
      // Disables the handler
      disable: function disable() {
        if (!this._enabled) {
          return this;
        }

        this._enabled = false;
        this.removeHooks();
        return this;
      },
      // @method enabled(): Boolean
      // Returns `true` if the handler is enabled
      enabled: function enabled() {
        return !!this._enabled;
      } // @section Extension methods
      // Classes inheriting from `Handler` must implement the two following methods:
      // @method addHooks()
      // Called when the handler is enabled, should add event hooks.
      // @method removeHooks()
      // Called when the handler is disabled, should remove the event hooks added previously.

    });

    /*
     * @class Draggable
     * @aka L.Draggable
     * @inherits Evented
     *
     * A class for making DOM elements draggable (including touch support).
     * Used internally for map and marker dragging. Only works for elements
     * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
     *
     * @example
     * ```js
     * var draggable = new L.Draggable(elementToDrag);
     * draggable.enable();
     * ```
     */

    var START = touch ? 'touchstart mousedown' : 'mousedown';
    var END = {
      mousedown: 'mouseup',
      touchstart: 'touchend',
      pointerdown: 'touchend',
      MSPointerDown: 'touchend'
    };
    var MOVE = {
      mousedown: 'mousemove',
      touchstart: 'touchmove',
      pointerdown: 'touchmove',
      MSPointerDown: 'touchmove'
    };
    var Draggable$1 = Evented.extend({
      options: {
        // @section
        // @aka Draggable options
        // @option clickTolerance: Number = 3
        // The max number of pixels a user can shift the mouse pointer during a click
        // for it to be considered a valid click (as opposed to a mouse drag).
        clickTolerance: 3
      },
      // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
      // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
      initialize: function initialize(element, dragStartTarget, preventOutline$$1, options) {
        setOptions(this, options);
        this._element = element;
        this._dragStartTarget = dragStartTarget || element;
        this._preventOutline = preventOutline$$1;
      },
      // @method enable()
      // Enables the dragging ability
      enable: function enable() {
        if (this._enabled) {
          return;
        }

        on(this._dragStartTarget, START, this._onDown, this);
        this._enabled = true;
      },
      // @method disable()
      // Disables the dragging ability
      disable: function disable() {
        if (!this._enabled) {
          return;
        } // If we're currently dragging this draggable,
        // disabling it counts as first ending the drag.


        if (Draggable$1._dragging === this) {
          this.finishDrag();
        }

        off(this._dragStartTarget, START, this._onDown, this);
        this._enabled = false;
        this._moved = false;
      },
      _onDown: function _onDown(e) {
        // Ignore simulated events, since we handle both touch and
        // mouse explicitly; otherwise we risk getting duplicates of
        // touch events, see #4315.
        // Also ignore the event if disabled; this happens in IE11
        // under some circumstances, see #3666.
        if (e._simulated || !this._enabled) {
          return;
        }

        this._moved = false;

        if (hasClass(this._element, 'leaflet-zoom-anim')) {
          return;
        }

        if (Draggable$1._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
          return;
        }

        Draggable$1._dragging = this; // Prevent dragging multiple objects at once.

        if (this._preventOutline) {
          preventOutline(this._element);
        }

        disableImageDrag();
        disableTextSelection();

        if (this._moving) {
          return;
        } // @event down: Event
        // Fired when a drag is about to start.


        this.fire('down');
        var first = e.touches ? e.touches[0] : e;
        this._startPoint = new Point(first.clientX, first.clientY);
        on(document, MOVE[e.type], this._onMove, this);
        on(document, END[e.type], this._onUp, this);
      },
      _onMove: function _onMove(e) {
        // Ignore simulated events, since we handle both touch and
        // mouse explicitly; otherwise we risk getting duplicates of
        // touch events, see #4315.
        // Also ignore the event if disabled; this happens in IE11
        // under some circumstances, see #3666.
        if (e._simulated || !this._enabled) {
          return;
        }

        if (e.touches && e.touches.length > 1) {
          this._moved = true;
          return;
        }

        var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
            newPoint = new Point(first.clientX, first.clientY),
            offset = newPoint.subtract(this._startPoint);

        if (!offset.x && !offset.y) {
          return;
        }

        if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
          return;
        }

        preventDefault(e);

        if (!this._moved) {
          // @event dragstart: Event
          // Fired when a drag starts
          this.fire('dragstart');
          this._moved = true;
          this._startPos = getPosition(this._element).subtract(offset);
          addClass(document.body, 'leaflet-dragging');
          this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it
          // if necessary

          if (window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance) {
            this._lastTarget = this._lastTarget.correspondingUseElement;
          }

          addClass(this._lastTarget, 'leaflet-drag-target');
        }

        this._newPos = this._startPos.add(offset);
        this._moving = true;
        cancelAnimFrame(this._animRequest);
        this._lastEvent = e;
        this._animRequest = requestAnimFrame(this._updatePosition, this, true);
      },
      _updatePosition: function _updatePosition() {
        var e = {
          originalEvent: this._lastEvent
        }; // @event predrag: Event
        // Fired continuously during dragging *before* each corresponding
        // update of the element's position.

        this.fire('predrag', e);
        setPosition(this._element, this._newPos); // @event drag: Event
        // Fired continuously during dragging.

        this.fire('drag', e);
      },
      _onUp: function _onUp(e) {
        // Ignore simulated events, since we handle both touch and
        // mouse explicitly; otherwise we risk getting duplicates of
        // touch events, see #4315.
        // Also ignore the event if disabled; this happens in IE11
        // under some circumstances, see #3666.
        if (e._simulated || !this._enabled) {
          return;
        }

        this.finishDrag();
      },
      finishDrag: function finishDrag() {
        removeClass(document.body, 'leaflet-dragging');

        if (this._lastTarget) {
          removeClass(this._lastTarget, 'leaflet-drag-target');
          this._lastTarget = null;
        }

        for (var i in MOVE) {
          off(document, MOVE[i], this._onMove, this);
          off(document, END[i], this._onUp, this);
        }

        enableImageDrag();
        enableTextSelection();

        if (this._moved && this._moving) {
          // ensure drag is not fired after dragend
          cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent
          // Fired when the drag ends.

          this.fire('dragend', {
            distance: this._newPos.distanceTo(this._startPos)
          });
        }

        this._moving = false;
        Draggable$1._dragging = false;
      }
    });

    /*
     * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
     */

    /* @namespace Marker
     * @section Interaction handlers
     *
     * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
     *
     * ```js
     * marker.dragging.disable();
     * ```
     *
     * @property dragging: Handler
     * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
     */

    var MarkerDrag = Handler$1.extend({
      initialize: function initialize(marker) {
        this._marker = marker;
      },
      addHooks: function addHooks() {
        var icon = this._marker._icon;

        if (!this._draggable) {
          this._draggable = new Draggable$1(icon, icon, true);
        }

        this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).enable();

        addClass(icon, 'leaflet-marker-draggable');
      },
      removeHooks: function removeHooks() {
        this._draggable.off({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this).disable();

        if (this._marker._icon) {
          removeClass(this._marker._icon, 'leaflet-marker-draggable');
        }
      },
      moved: function moved() {
        return this._draggable && this._draggable._moved;
      },
      _onDragStart: function _onDragStart() {
        // @section Dragging events
        // @event dragstart: Event
        // Fired when the user starts dragging the marker.
        // @event movestart: Event
        // Fired when the marker starts moving (because of dragging).
        this._oldLatLng = this._marker.getLatLng();

        this._marker.closePopup().fire('movestart').fire('dragstart');
      },
      _onDrag: function _onDrag(e) {
        var marker = this._marker,
            shadow = marker._shadow,
            iconPos = getPosition(marker._icon),
            latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position


        if (shadow) {
          setPosition(shadow, iconPos);
        }

        marker._latlng = latlng;
        e.latlng = latlng;
        e.oldLatLng = this._oldLatLng; // @event drag: Event
        // Fired repeatedly while the user drags the marker.

        marker.fire('move', e).fire('drag', e);
      },
      _onDragEnd: function _onDragEnd(e) {
        // @event dragend: DragEndEvent
        // Fired when the user stops dragging the marker.
        // @event moveend: Event
        // Fired when the marker stops moving (because of dragging).
        delete this._oldLatLng;

        this._marker.fire('moveend').fire('dragend', e);
      }
    });

    /*
     * @class Marker
     * @inherits Interactive layer
     * @aka L.Marker
     * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
     *
     * @example
     *
     * ```js
     * L.marker([50.5, 30.5]).addTo(map);
     * ```
     */

    var Marker = Layer$1.extend({
      // @section
      // @aka Marker options
      options: {
        // @option icon: Icon = *
        // Icon instance to use for rendering the marker.
        // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
        // If not specified, a common instance of `L.Icon.Default` is used.
        icon: new IconDefault(),
        // Option inherited from "Interactive layer" abstract class
        interactive: true,
        // @option draggable: Boolean = false
        // Whether the marker is draggable with mouse/touch or not.
        draggable: false,
        // @option keyboard: Boolean = true
        // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
        keyboard: true,
        // @option title: String = ''
        // Text for the browser tooltip that appear on marker hover (no tooltip by default).
        title: '',
        // @option alt: String = ''
        // Text for the `alt` attribute of the icon image (useful for accessibility).
        alt: '',
        // @option zIndexOffset: Number = 0
        // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
        zIndexOffset: 0,
        // @option opacity: Number = 1.0
        // The opacity of the marker.
        opacity: 1,
        // @option riseOnHover: Boolean = false
        // If `true`, the marker will get on top of others when you hover the mouse over it.
        riseOnHover: false,
        // @option riseOffset: Number = 250
        // The z-index offset used for the `riseOnHover` feature.
        riseOffset: 250,
        // @option pane: String = 'markerPane'
        // `Map pane` where the markers icon will be added.
        pane: 'markerPane',
        // @option bubblingMouseEvents: Boolean = false
        // When `true`, a mouse event on this marker will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: false
      },

      /* @section
       *
       * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
       */
      initialize: function initialize(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng(latlng);
      },
      onAdd: function onAdd(map) {
        this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

        if (this._zoomAnimated) {
          map.on('zoomanim', this._animateZoom, this);
        }

        this._initIcon();

        this.update();
      },
      onRemove: function onRemove(map) {
        if (this.dragging && this.dragging.enabled()) {
          this.options.draggable = true;
          this.dragging.removeHooks();
        }

        delete this.dragging;

        if (this._zoomAnimated) {
          map.off('zoomanim', this._animateZoom, this);
        }

        this._removeIcon();

        this._removeShadow();
      },
      getEvents: function getEvents() {
        return {
          zoom: this.update,
          viewreset: this.update
        };
      },
      // @method getLatLng: LatLng
      // Returns the current geographical position of the marker.
      getLatLng: function getLatLng() {
        return this._latlng;
      },
      // @method setLatLng(latlng: LatLng): this
      // Changes the marker position to the given point.
      setLatLng: function setLatLng(latlng) {
        var oldLatLng = this._latlng;
        this._latlng = toLatLng(latlng);
        this.update(); // @event move: Event
        // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

        return this.fire('move', {
          oldLatLng: oldLatLng,
          latlng: this._latlng
        });
      },
      // @method setZIndexOffset(offset: Number): this
      // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
      setZIndexOffset: function setZIndexOffset(offset) {
        this.options.zIndexOffset = offset;
        return this.update();
      },
      // @method setIcon(icon: Icon): this
      // Changes the marker icon.
      setIcon: function setIcon(icon) {
        this.options.icon = icon;

        if (this._map) {
          this._initIcon();

          this.update();
        }

        if (this._popup) {
          this.bindPopup(this._popup, this._popup.options);
        }

        return this;
      },
      getElement: function getElement() {
        return this._icon;
      },
      update: function update() {
        if (this._icon) {
          var pos = this._map.latLngToLayerPoint(this._latlng).round();

          this._setPos(pos);
        }

        return this;
      },
      _initIcon: function _initIcon() {
        var options = this.options,
            classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
        var icon = options.icon.createIcon(this._icon),
            addIcon = false; // if we're not reusing the icon, remove the old one and init new one

        if (icon !== this._icon) {
          if (this._icon) {
            this._removeIcon();
          }

          addIcon = true;

          if (options.title) {
            icon.title = options.title;
          }

          if (options.alt) {
            icon.alt = options.alt;
          }
        }

        addClass(icon, classToAdd);

        if (options.keyboard) {
          icon.tabIndex = '0';
        }

        this._icon = icon;

        if (options.riseOnHover) {
          this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }

        var newShadow = options.icon.createShadow(this._shadow),
            addShadow = false;

        if (newShadow !== this._shadow) {
          this._removeShadow();

          addShadow = true;
        }

        if (newShadow) {
          addClass(newShadow, classToAdd);
          newShadow.alt = '';
        }

        this._shadow = newShadow;

        if (options.opacity < 1) {
          this._updateOpacity();
        }

        if (addIcon) {
          this.getPane().appendChild(this._icon);
        }

        this._initInteraction();

        if (newShadow && addShadow) {
          this.getPane('shadowPane').appendChild(this._shadow);
        }
      },
      _removeIcon: function _removeIcon() {
        if (this.options.riseOnHover) {
          this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          });
        }

        remove(this._icon);
        this.removeInteractiveTarget(this._icon);
        this._icon = null;
      },
      _removeShadow: function _removeShadow() {
        if (this._shadow) {
          remove(this._shadow);
        }

        this._shadow = null;
      },
      _setPos: function _setPos(pos) {
        setPosition(this._icon, pos);

        if (this._shadow) {
          setPosition(this._shadow, pos);
        }

        this._zIndex = pos.y + this.options.zIndexOffset;

        this._resetZIndex();
      },
      _updateZIndex: function _updateZIndex(offset) {
        this._icon.style.zIndex = this._zIndex + offset;
      },
      _animateZoom: function _animateZoom(opt) {
        var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

        this._setPos(pos);
      },
      _initInteraction: function _initInteraction() {
        if (!this.options.interactive) {
          return;
        }

        addClass(this._icon, 'leaflet-interactive');
        this.addInteractiveTarget(this._icon);

        if (MarkerDrag) {
          var draggable = this.options.draggable;

          if (this.dragging) {
            draggable = this.dragging.enabled();
            this.dragging.disable();
          }

          this.dragging = new MarkerDrag(this);

          if (draggable) {
            this.dragging.enable();
          }
        }
      },
      // @method setOpacity(opacity: Number): this
      // Changes the opacity of the marker.
      setOpacity: function setOpacity$$1(opacity) {
        this.options.opacity = opacity;

        if (this._map) {
          this._updateOpacity();
        }

        return this;
      },
      _updateOpacity: function _updateOpacity() {
        var opacity = this.options.opacity;
        setOpacity(this._icon, opacity);

        if (this._shadow) {
          setOpacity(this._shadow, opacity);
        }
      },
      _bringToFront: function _bringToFront() {
        this._updateZIndex(this.options.riseOffset);
      },
      _resetZIndex: function _resetZIndex() {
        this._updateZIndex(0);
      },
      _getPopupAnchor: function _getPopupAnchor() {
        return this.options.icon.options.popupAnchor || [0, 0];
      },
      _getTooltipAnchor: function _getTooltipAnchor() {
        return this.options.icon.options.tooltipAnchor || [0, 0];
      }
    }); // factory L.marker(latlng: LatLng, options? : Marker options)

    /*
     * @class Path
     * @aka L.Path
     * @inherits Interactive layer
     *
     * An abstract class that contains options and constants shared between vector
     * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
     */

    var Path$2 = Layer$1.extend({
      // @section
      // @aka Path options
      options: {
        // @option stroke: Boolean = true
        // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
        stroke: true,
        // @option color: String = '#3388ff'
        // Stroke color
        color: '#3388ff',
        // @option weight: Number = 3
        // Stroke width in pixels
        weight: 3,
        // @option opacity: Number = 1.0
        // Stroke opacity
        opacity: 1,
        // @option lineCap: String= 'round'
        // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
        lineCap: 'round',
        // @option lineJoin: String = 'round'
        // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
        lineJoin: 'round',
        // @option dashArray: String = null
        // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashArray: null,
        // @option dashOffset: String = null
        // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
        dashOffset: null,
        // @option fill: Boolean = depends
        // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
        fill: false,
        // @option fillColor: String = *
        // Fill color. Defaults to the value of the [`color`](#path-color) option
        fillColor: null,
        // @option fillOpacity: Number = 0.2
        // Fill opacity.
        fillOpacity: 0.2,
        // @option fillRule: String = 'evenodd'
        // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
        fillRule: 'evenodd',
        // className: '',
        // Option inherited from "Interactive layer" abstract class
        interactive: true,
        // @option bubblingMouseEvents: Boolean = true
        // When `true`, a mouse event on this path will trigger the same event on the map
        // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
        bubblingMouseEvents: true
      },
      beforeAdd: function beforeAdd(map) {
        // Renderer is set here because we need to call renderer.getEvents
        // before this.getEvents.
        this._renderer = map.getRenderer(this);
      },
      onAdd: function onAdd() {
        this._renderer._initPath(this);

        this._reset();

        this._renderer._addPath(this);
      },
      onRemove: function onRemove() {
        this._renderer._removePath(this);
      },
      // @method redraw(): this
      // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
      redraw: function redraw() {
        if (this._map) {
          this._renderer._updatePath(this);
        }

        return this;
      },
      // @method setStyle(style: Path options): this
      // Changes the appearance of a Path based on the options in the `Path options` object.
      setStyle: function setStyle(style) {
        setOptions(this, style);

        if (this._renderer) {
          this._renderer._updateStyle(this);
        }

        return this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all path layers.
      bringToFront: function bringToFront() {
        if (this._renderer) {
          this._renderer._bringToFront(this);
        }

        return this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all path layers.
      bringToBack: function bringToBack() {
        if (this._renderer) {
          this._renderer._bringToBack(this);
        }

        return this;
      },
      getElement: function getElement() {
        return this._path;
      },
      _reset: function _reset() {
        // defined in child classes
        this._project();

        this._update();
      },
      _clickTolerance: function _clickTolerance() {
        // used when doing hit detection for Canvas layers
        return (this.options.stroke ? this.options.weight / 2 : 0) + (touch ? 10 : 0);
      }
    });

    /*
     * @class CircleMarker
     * @aka L.CircleMarker
     * @inherits Path
     *
     * A circle of a fixed size with radius specified in pixels. Extends `Path`.
     */

    var CircleMarker = Path$2.extend({
      // @section
      // @aka CircleMarker options
      options: {
        fill: true,
        // @option radius: Number = 10
        // Radius of the circle marker, in pixels
        radius: 10
      },
      initialize: function initialize(latlng, options) {
        setOptions(this, options);
        this._latlng = toLatLng(latlng);
        this._radius = this.options.radius;
      },
      // @method setLatLng(latLng: LatLng): this
      // Sets the position of a circle marker to a new location.
      setLatLng: function setLatLng(latlng) {
        this._latlng = toLatLng(latlng);
        this.redraw();
        return this.fire('move', {
          latlng: this._latlng
        });
      },
      // @method getLatLng(): LatLng
      // Returns the current geographical position of the circle marker
      getLatLng: function getLatLng() {
        return this._latlng;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle marker. Units are in pixels.
      setRadius: function setRadius(radius) {
        this.options.radius = this._radius = radius;
        return this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of the circle
      getRadius: function getRadius() {
        return this._radius;
      },
      setStyle: function setStyle(options) {
        var radius = options && options.radius || this._radius;
        Path$2.prototype.setStyle.call(this, options);
        this.setRadius(radius);
        return this;
      },
      _project: function _project() {
        this._point = this._map.latLngToLayerPoint(this._latlng);

        this._updateBounds();
      },
      _updateBounds: function _updateBounds() {
        var r = this._radius,
            r2 = this._radiusY || r,
            w = this._clickTolerance(),
            p = [r + w, r2 + w];

        this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
      },
      _update: function _update() {
        if (this._map) {
          this._updatePath();
        }
      },
      _updatePath: function _updatePath() {
        this._renderer._updateCircle(this);
      },
      _empty: function _empty() {
        return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function _containsPoint(p) {
        return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
      }
    }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)

    /*
     * @class Circle
     * @aka L.Circle
     * @inherits CircleMarker
     *
     * A class for drawing circle overlays on a map. Extends `CircleMarker`.
     *
     * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
     *
     * @example
     *
     * ```js
     * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
     * ```
     */

    var Circle$1 = CircleMarker.extend({
      initialize: function initialize(latlng, options, legacyOptions) {
        if (typeof options === 'number') {
          // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
          options = extend$4({}, legacyOptions, {
            radius: options
          });
        }

        setOptions(this, options);
        this._latlng = toLatLng(latlng);

        if (isNaN(this.options.radius)) {
          throw new Error('Circle radius cannot be NaN');
        } // @section
        // @aka Circle options
        // @option radius: Number; Radius of the circle, in meters.


        this._mRadius = this.options.radius;
      },
      // @method setRadius(radius: Number): this
      // Sets the radius of a circle. Units are in meters.
      setRadius: function setRadius(radius) {
        this._mRadius = radius;
        return this.redraw();
      },
      // @method getRadius(): Number
      // Returns the current radius of a circle. Units are in meters.
      getRadius: function getRadius() {
        return this._mRadius;
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function getBounds() {
        var half = [this._radius, this._radiusY || this._radius];
        return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
      },
      setStyle: Path$2.prototype.setStyle,
      _project: function _project() {
        var lng = this._latlng.lng,
            lat = this._latlng.lat,
            map = this._map,
            crs = map.options.crs;

        if (crs.distance === Earth.distance) {
          var d = Math.PI / 180,
              latR = this._mRadius / Earth.R / d,
              top = map.project([lat + latR, lng]),
              bottom = map.project([lat - latR, lng]),
              p = top.add(bottom).divideBy(2),
              lat2 = map.unproject(p).lat,
              lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

          if (isNaN(lngR) || lngR === 0) {
            lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
          }

          this._point = p.subtract(map.getPixelOrigin());
          this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
          this._radiusY = Math.max(Math.round(p.y - top.y), 1);
        } else {
          var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
          this._point = map.latLngToLayerPoint(this._latlng);
          this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
        }

        this._updateBounds();
      }
    }); // @factory L.circle(latlng: LatLng, options?: Circle options)

    /*
     * @namespace LineUtil
     *
     * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
     */
    // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
    // Improves rendering performance dramatically by lessening the number of points to draw.
    // @function simplify(points: Point[], tolerance: Number): Point[]
    // Dramatically reduces the number of points in a polyline while retaining
    // its shape and returns a new array of simplified points, using the
    // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
    // Used for a huge performance boost when processing/displaying Leaflet polylines for
    // each zoom level and also reducing visual noise. tolerance affects the amount of
    // simplification (lesser value means higher quality but slower and with more points).
    // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).

    function simplify(points, tolerance) {
      if (!tolerance || !points.length) {
        return points.slice();
      }

      var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction

      points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification

      points = _simplifyDP(points, sqTolerance);
      return points;
    } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
    // Returns the distance between point `p` and segment `p1` to `p2`.

    function pointToSegmentDistance(p, p1, p2) {
      return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
    } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number

    function _simplifyDP(points, sqTolerance) {
      var len = points.length,
          ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
          markers = new ArrayConstructor(len);
      markers[0] = markers[len - 1] = 1;

      _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

      var i,
          newPoints = [];

      for (i = 0; i < len; i++) {
        if (markers[i]) {
          newPoints.push(points[i]);
        }
      }

      return newPoints;
    }

    function _simplifyDPStep(points, markers, sqTolerance, first, last) {
      var maxSqDist = 0,
          index,
          i,
          sqDist;

      for (i = first + 1; i <= last - 1; i++) {
        sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

        if (sqDist > maxSqDist) {
          index = i;
          maxSqDist = sqDist;
        }
      }

      if (maxSqDist > sqTolerance) {
        markers[index] = 1;

        _simplifyDPStep(points, markers, sqTolerance, first, index);

        _simplifyDPStep(points, markers, sqTolerance, index, last);
      }
    } // reduce points that are too close to each other to a single point


    function _reducePoints(points, sqTolerance) {
      var reducedPoints = [points[0]];

      for (var i = 1, prev = 0, len = points.length; i < len; i++) {
        if (_sqDist(points[i], points[prev]) > sqTolerance) {
          reducedPoints.push(points[i]);
          prev = i;
        }
      }

      if (prev < len - 1) {
        reducedPoints.push(points[len - 1]);
      }

      return reducedPoints;
    }

    var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
    // Clips the segment a to b by rectangular bounds with the
    // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
    // (modifying the segment points directly!). Used by Leaflet to only show polyline
    // points that are on the screen or near, increasing performance.


    function clipSegment(a, b, bounds, useLastCode, round) {
      var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
          codeB = _getBitCode(b, bounds),
          codeOut,
          p,
          newCode; // save 2nd code to avoid calculating it on the next segment


      _lastCode = codeB;

      while (true) {
        // if a,b is inside the clip window (trivial accept)
        if (!(codeA | codeB)) {
          return [a, b];
        } // if a,b is outside the clip window (trivial reject)


        if (codeA & codeB) {
          return false;
        } // other cases


        codeOut = codeA || codeB;
        p = _getEdgeIntersection(a, b, codeOut, bounds, round);
        newCode = _getBitCode(p, bounds);

        if (codeOut === codeA) {
          a = p;
          codeA = newCode;
        } else {
          b = p;
          codeB = newCode;
        }
      }
    }
    function _getEdgeIntersection(a, b, code, bounds, round) {
      var dx = b.x - a.x,
          dy = b.y - a.y,
          min = bounds.min,
          max = bounds.max,
          x,
          y;

      if (code & 8) {
        // top
        x = a.x + dx * (max.y - a.y) / dy;
        y = max.y;
      } else if (code & 4) {
        // bottom
        x = a.x + dx * (min.y - a.y) / dy;
        y = min.y;
      } else if (code & 2) {
        // right
        x = max.x;
        y = a.y + dy * (max.x - a.x) / dx;
      } else if (code & 1) {
        // left
        x = min.x;
        y = a.y + dy * (min.x - a.x) / dx;
      }

      return new Point(x, y, round);
    }
    function _getBitCode(p, bounds) {
      var code = 0;

      if (p.x < bounds.min.x) {
        // left
        code |= 1;
      } else if (p.x > bounds.max.x) {
        // right
        code |= 2;
      }

      if (p.y < bounds.min.y) {
        // bottom
        code |= 4;
      } else if (p.y > bounds.max.y) {
        // top
        code |= 8;
      }

      return code;
    } // square distance (to avoid unnecessary Math.sqrt calls)

    function _sqDist(p1, p2) {
      var dx = p2.x - p1.x,
          dy = p2.y - p1.y;
      return dx * dx + dy * dy;
    } // return closest point on segment or distance to that point


    function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
      var x = p1.x,
          y = p1.y,
          dx = p2.x - x,
          dy = p2.y - y,
          dot = dx * dx + dy * dy,
          t;

      if (dot > 0) {
        t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

        if (t > 1) {
          x = p2.x;
          y = p2.y;
        } else if (t > 0) {
          x += dx * t;
          y += dy * t;
        }
      }

      dx = p.x - x;
      dy = p.y - y;
      return sqDist ? dx * dx + dy * dy : new Point(x, y);
    } // @function isFlat(latlngs: LatLng[]): Boolean
    // Returns true if `latlngs` is a flat array, false is nested.

    function isFlat(latlngs) {
      return !isArray$2(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
    }
    function _flat(latlngs) {
      console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
      return isFlat(latlngs);
    }

    /*
     * @class Polyline
     * @aka L.Polyline
     * @inherits Path
     *
     * A class for drawing polyline overlays on a map. Extends `Path`.
     *
     * @example
     *
     * ```js
     * // create a red polyline from an array of LatLng points
     * var latlngs = [
     * 	[45.51, -122.68],
     * 	[37.77, -122.43],
     * 	[34.04, -118.2]
     * ];
     *
     * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
     *
     * // zoom the map to the polyline
     * map.fitBounds(polyline.getBounds());
     * ```
     *
     * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
     *
     * ```js
     * // create a red polyline from an array of arrays of LatLng points
     * var latlngs = [
     * 	[[45.51, -122.68],
     * 	 [37.77, -122.43],
     * 	 [34.04, -118.2]],
     * 	[[40.78, -73.91],
     * 	 [41.83, -87.62],
     * 	 [32.76, -96.72]]
     * ];
     * ```
     */

    var Polyline$1 = Path$2.extend({
      // @section
      // @aka Polyline options
      options: {
        // @option smoothFactor: Number = 1.0
        // How much to simplify the polyline on each zoom level. More means
        // better performance and smoother look, and less means more accurate representation.
        smoothFactor: 1.0,
        // @option noClip: Boolean = false
        // Disable polyline clipping.
        noClip: false
      },
      initialize: function initialize(latlngs, options) {
        setOptions(this, options);

        this._setLatLngs(latlngs);
      },
      // @method getLatLngs(): LatLng[]
      // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
      getLatLngs: function getLatLngs() {
        return this._latlngs;
      },
      // @method setLatLngs(latlngs: LatLng[]): this
      // Replaces all the points in the polyline with the given array of geographical points.
      setLatLngs: function setLatLngs(latlngs) {
        this._setLatLngs(latlngs);

        return this.redraw();
      },
      // @method isEmpty(): Boolean
      // Returns `true` if the Polyline has no LatLngs.
      isEmpty: function isEmpty() {
        return !this._latlngs.length;
      },
      closestLayerPoint: function closestLayerPoint(p) {
        var minDistance = Infinity,
            minPoint = null,
            closest = _sqClosestPointOnSegment,
            p1,
            p2;

        for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
          var points = this._parts[j];

          for (var i = 1, len = points.length; i < len; i++) {
            p1 = points[i - 1];
            p2 = points[i];
            var sqDist = closest(p, p1, p2, true);

            if (sqDist < minDistance) {
              minDistance = sqDist;
              minPoint = closest(p, p1, p2);
            }
          }
        }

        if (minPoint) {
          minPoint.distance = Math.sqrt(minDistance);
        }

        return minPoint;
      },
      // @method getCenter(): LatLng
      // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
      getCenter: function getCenter() {
        // throws error when not yet added to map as this center calculation requires projected coordinates
        if (!this._map) {
          throw new Error('Must add layer to map before using getCenter()');
        }

        var i,
            halfDist,
            segDist,
            dist,
            p1,
            p2,
            ratio,
            points = this._rings[0],
            len = points.length;

        if (!len) {
          return null;
        } // polyline centroid algorithm; only uses the first ring if there are multiple


        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        } // The line is so small in the current view that all points are on the same pixel.


        if (halfDist === 0) {
          return this._map.layerPointToLatLng(points[0]);
        }

        for (i = 0, dist = 0; i < len - 1; i++) {
          p1 = points[i];
          p2 = points[i + 1];
          segDist = p1.distanceTo(p2);
          dist += segDist;

          if (dist > halfDist) {
            ratio = (dist - halfDist) / segDist;
            return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
          }
        }
      },
      // @method getBounds(): LatLngBounds
      // Returns the `LatLngBounds` of the path.
      getBounds: function getBounds() {
        return this._bounds;
      },
      // @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
      // Adds a given point to the polyline. By default, adds to the first ring of
      // the polyline in case of a multi-polyline, but can be overridden by passing
      // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
      addLatLng: function addLatLng(latlng, latlngs) {
        latlngs = latlngs || this._defaultShape();
        latlng = toLatLng(latlng);
        latlngs.push(latlng);

        this._bounds.extend(latlng);

        return this.redraw();
      },
      _setLatLngs: function _setLatLngs(latlngs) {
        this._bounds = new LatLngBounds();
        this._latlngs = this._convertLatLngs(latlngs);
      },
      _defaultShape: function _defaultShape() {
        return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
      },
      // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
      _convertLatLngs: function _convertLatLngs(latlngs) {
        var result = [],
            flat = isFlat(latlngs);

        for (var i = 0, len = latlngs.length; i < len; i++) {
          if (flat) {
            result[i] = toLatLng(latlngs[i]);

            this._bounds.extend(result[i]);
          } else {
            result[i] = this._convertLatLngs(latlngs[i]);
          }
        }

        return result;
      },
      _project: function _project() {
        var pxBounds = new Bounds();
        this._rings = [];

        this._projectLatlngs(this._latlngs, this._rings, pxBounds);

        var w = this._clickTolerance(),
            p = new Point(w, w);

        if (this._bounds.isValid() && pxBounds.isValid()) {
          pxBounds.min._subtract(p);

          pxBounds.max._add(p);

          this._pxBounds = pxBounds;
        }
      },
      // recursively turns latlngs into a set of rings with projected coordinates
      _projectLatlngs: function _projectLatlngs(latlngs, result, projectedBounds) {
        var flat = latlngs[0] instanceof LatLng,
            len = latlngs.length,
            i,
            ring;

        if (flat) {
          ring = [];

          for (i = 0; i < len; i++) {
            ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
            projectedBounds.extend(ring[i]);
          }

          result.push(ring);
        } else {
          for (i = 0; i < len; i++) {
            this._projectLatlngs(latlngs[i], result, projectedBounds);
          }
        }
      },
      // clip polyline by renderer bounds so that we have less to render for performance
      _clipPoints: function _clipPoints() {
        var bounds = this._renderer._bounds;
        this._parts = [];

        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }

        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }

        var parts = this._parts,
            i,
            j,
            k,
            len,
            len2,
            segment,
            points;

        for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
          points = this._rings[i];

          for (j = 0, len2 = points.length; j < len2 - 1; j++) {
            segment = clipSegment(points[j], points[j + 1], bounds, j, true);

            if (!segment) {
              continue;
            }

            parts[k] = parts[k] || [];
            parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part

            if (segment[1] !== points[j + 1] || j === len2 - 2) {
              parts[k].push(segment[1]);
              k++;
            }
          }
        }
      },
      // simplify each clipped part of the polyline for performance
      _simplifyPoints: function _simplifyPoints() {
        var parts = this._parts,
            tolerance = this.options.smoothFactor;

        for (var i = 0, len = parts.length; i < len; i++) {
          parts[i] = simplify(parts[i], tolerance);
        }
      },
      _update: function _update() {
        if (!this._map) {
          return;
        }

        this._clipPoints();

        this._simplifyPoints();

        this._updatePath();
      },
      _updatePath: function _updatePath() {
        this._renderer._updatePoly(this);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function _containsPoint(p, closed) {
        var i,
            j,
            k,
            len,
            len2,
            part,
            w = this._clickTolerance();

        if (!this._pxBounds || !this._pxBounds.contains(p)) {
          return false;
        } // hit detection for polylines


        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];

          for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
            if (!closed && j === 0) {
              continue;
            }

            if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
              return true;
            }
          }
        }

        return false;
      }
    }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)

    Polyline$1._flat = _flat;

    /*
     * @namespace PolyUtil
     * Various utility functions for polygon geometries.
     */

    /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
     * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
     * Used by Leaflet to only show polygon points that are on the screen or near, increasing
     * performance. Note that polygon points needs different algorithm for clipping
     * than polyline, so there's a seperate method for it.
     */

    function clipPolygon(points, bounds, round) {
      var clippedPoints,
          edges = [1, 4, 2, 8],
          i,
          j,
          k,
          a,
          b,
          len,
          edge,
          p;

      for (i = 0, len = points.length; i < len; i++) {
        points[i]._code = _getBitCode(points[i], bounds);
      } // for each edge (left, bottom, right, top)


      for (k = 0; k < 4; k++) {
        edge = edges[k];
        clippedPoints = [];

        for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
          a = points[i];
          b = points[j]; // if a is inside the clip window

          if (!(a._code & edge)) {
            // if b is outside the clip window (a->b goes out of screen)
            if (b._code & edge) {
              p = _getEdgeIntersection(b, a, edge, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }

            clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)
          } else if (!(b._code & edge)) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }
        }

        points = clippedPoints;
      }

      return points;
    }

    /*
     * @class Polygon
     * @aka L.Polygon
     * @inherits Polyline
     *
     * A class for drawing polygon overlays on a map. Extends `Polyline`.
     *
     * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
     *
     *
     * @example
     *
     * ```js
     * // create a red polygon from an array of LatLng points
     * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
     *
     * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
     *
     * // zoom the map to the polygon
     * map.fitBounds(polygon.getBounds());
     * ```
     *
     * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
     *
     * ```js
     * var latlngs = [
     *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
     *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
     * ];
     * ```
     *
     * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
     *
     * ```js
     * var latlngs = [
     *   [ // first polygon
     *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
     *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
     *   ],
     *   [ // second polygon
     *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
     *   ]
     * ];
     * ```
     */

    var Polygon$1 = Polyline$1.extend({
      options: {
        fill: true
      },
      isEmpty: function isEmpty() {
        return !this._latlngs.length || !this._latlngs[0].length;
      },
      getCenter: function getCenter() {
        // throws error when not yet added to map as this center calculation requires projected coordinates
        if (!this._map) {
          throw new Error('Must add layer to map before using getCenter()');
        }

        var i,
            j,
            p1,
            p2,
            f,
            area,
            x,
            y,
            center,
            points = this._rings[0],
            len = points.length;

        if (!len) {
          return null;
        } // polygon centroid algorithm; only uses the first ring if there are multiple


        area = x = y = 0;

        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }

        if (area === 0) {
          // Polygon is so small that all points are on same pixel.
          center = points[0];
        } else {
          center = [x / area, y / area];
        }

        return this._map.layerPointToLatLng(center);
      },
      _convertLatLngs: function _convertLatLngs(latlngs) {
        var result = Polyline$1.prototype._convertLatLngs.call(this, latlngs),
            len = result.length; // remove last point if it equals first one


        if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
          result.pop();
        }

        return result;
      },
      _setLatLngs: function _setLatLngs(latlngs) {
        Polyline$1.prototype._setLatLngs.call(this, latlngs);

        if (isFlat(this._latlngs)) {
          this._latlngs = [this._latlngs];
        }
      },
      _defaultShape: function _defaultShape() {
        return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
      },
      _clipPoints: function _clipPoints() {
        // polygons need a different clipping algorithm so we redefine that
        var bounds = this._renderer._bounds,
            w = this.options.weight,
            p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges

        bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
        this._parts = [];

        if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
          return;
        }

        if (this.options.noClip) {
          this._parts = this._rings;
          return;
        }

        for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
          clipped = clipPolygon(this._rings[i], bounds, true);

          if (clipped.length) {
            this._parts.push(clipped);
          }
        }
      },
      _updatePath: function _updatePath() {
        this._renderer._updatePoly(this, true);
      },
      // Needed by the `Canvas` renderer for interactivity
      _containsPoint: function _containsPoint(p) {
        var inside = false,
            part,
            p1,
            p2,
            i,
            j,
            k,
            len,
            len2;

        if (!this._pxBounds.contains(p)) {
          return false;
        } // ray casting algorithm for detecting if point is in polygon


        for (i = 0, len = this._parts.length; i < len; i++) {
          part = this._parts[i];

          for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
            p1 = part[j];
            p2 = part[k];

            if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
              inside = !inside;
            }
          }
        } // also check if it's on polygon stroke


        return inside || Polyline$1.prototype._containsPoint.call(this, p, true);
      }
    }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)

    /*
     * @class GeoJSON
     * @aka L.GeoJSON
     * @inherits FeatureGroup
     *
     * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
     * GeoJSON data and display it on the map. Extends `FeatureGroup`.
     *
     * @example
     *
     * ```js
     * L.geoJSON(data, {
     * 	style: function (feature) {
     * 		return {color: feature.properties.color};
     * 	}
     * }).bindPopup(function (layer) {
     * 	return layer.feature.properties.description;
     * }).addTo(map);
     * ```
     */

    var GeoJSON = FeatureGroup.extend({
      /* @section
       * @aka GeoJSON options
       *
       * @option pointToLayer: Function = *
       * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
       * called when data is added, passing the GeoJSON point feature and its `LatLng`.
       * The default is to spawn a default `Marker`:
       * ```js
       * function(geoJsonPoint, latlng) {
       * 	return L.marker(latlng);
       * }
       * ```
       *
       * @option style: Function = *
       * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
       * called internally when data is added.
       * The default value is to not override any defaults:
       * ```js
       * function (geoJsonFeature) {
       * 	return {}
       * }
       * ```
       *
       * @option onEachFeature: Function = *
       * A `Function` that will be called once for each created `Feature`, after it has
       * been created and styled. Useful for attaching events and popups to features.
       * The default is to do nothing with the newly created layers:
       * ```js
       * function (feature, layer) {}
       * ```
       *
       * @option filter: Function = *
       * A `Function` that will be used to decide whether to include a feature or not.
       * The default is to include all features:
       * ```js
       * function (geoJsonFeature) {
       * 	return true;
       * }
       * ```
       * Note: dynamically changing the `filter` option will have effect only on newly
       * added data. It will _not_ re-evaluate already included features.
       *
       * @option coordsToLatLng: Function = *
       * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
       * The default is the `coordsToLatLng` static method.
       */
      initialize: function initialize(geojson, options) {
        setOptions(this, options);
        this._layers = {};

        if (geojson) {
          this.addData(geojson);
        }
      },
      // @method addData( <GeoJSON> data ): this
      // Adds a GeoJSON object to the layer.
      addData: function addData(geojson) {
        var features = isArray$2(geojson) ? geojson : geojson.features,
            i,
            len,
            feature;

        if (features) {
          for (i = 0, len = features.length; i < len; i++) {
            // only add this if geometry or geometries are set and not null
            feature = features[i];

            if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
              this.addData(feature);
            }
          }

          return this;
        }

        var options = this.options;

        if (options.filter && !options.filter(geojson)) {
          return this;
        }

        var layer = geometryToLayer(geojson, options);

        if (!layer) {
          return this;
        }

        layer.feature = asFeature(geojson);
        layer.defaultOptions = layer.options;
        this.resetStyle(layer);

        if (options.onEachFeature) {
          options.onEachFeature(geojson, layer);
        }

        return this.addLayer(layer);
      },
      // @method resetStyle( <Path> layer ): this
      // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
      resetStyle: function resetStyle(layer) {
        // reset any custom styles
        layer.options = extend$4({}, layer.defaultOptions);

        this._setLayerStyle(layer, this.options.style);

        return this;
      },
      // @method setStyle( <Function> style ): this
      // Changes styles of GeoJSON vector layers with the given style function.
      setStyle: function setStyle(style) {
        return this.eachLayer(function (layer) {
          this._setLayerStyle(layer, style);
        }, this);
      },
      _setLayerStyle: function _setLayerStyle(layer, style) {
        if (typeof style === 'function') {
          style = style(layer.feature);
        }

        if (layer.setStyle) {
          layer.setStyle(style);
        }
      }
    }); // @section
    // There are several static functions which can be called without instantiating L.GeoJSON:
    // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
    // Creates a `Layer` from a given GeoJSON feature. Can use a custom
    // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
    // functions if provided as options.

    function geometryToLayer(geojson, options) {
      var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
          coords = geometry ? geometry.coordinates : null,
          layers = [],
          pointToLayer = options && options.pointToLayer,
          _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
          latlng,
          latlngs,
          i,
          len;

      if (!coords && !geometry) {
        return null;
      }

      switch (geometry.type) {
        case 'Point':
          latlng = _coordsToLatLng(coords);
          return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

        case 'MultiPoint':
          for (i = 0, len = coords.length; i < len; i++) {
            latlng = _coordsToLatLng(coords[i]);
            layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
          }

          return new FeatureGroup(layers);

        case 'LineString':
        case 'MultiLineString':
          latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
          return new Polyline$1(latlngs, options);

        case 'Polygon':
        case 'MultiPolygon':
          latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
          return new Polygon$1(latlngs, options);

        case 'GeometryCollection':
          for (i = 0, len = geometry.geometries.length; i < len; i++) {
            var layer = geometryToLayer({
              geometry: geometry.geometries[i],
              type: 'Feature',
              properties: geojson.properties
            }, options);

            if (layer) {
              layers.push(layer);
            }
          }

          return new FeatureGroup(layers);

        default:
          throw new Error('Invalid GeoJSON object.');
      }
    } // @function coordsToLatLng(coords: Array): LatLng
    // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
    // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.

    function coordsToLatLng(coords) {
      return new LatLng(coords[1], coords[0], coords[2]);
    } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
    // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
    // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
    // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.

    function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
      var latlngs = [];

      for (var i = 0, len = coords.length, latlng; i < len; i++) {
        latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
        latlngs.push(latlng);
      }

      return latlngs;
    } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array
    // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)

    function latLngToCoords(latlng, precision) {
      precision = typeof precision === 'number' ? precision : 6;
      return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
    } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
    // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
    // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.

    function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
      var coords = [];

      for (var i = 0, len = latlngs.length; i < len; i++) {
        coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
      }

      if (!levelsDeep && closed) {
        coords.push(coords[0]);
      }

      return coords;
    }
    function getFeature(layer, newGeometry) {
      return layer.feature ? extend$4({}, layer.feature, {
        geometry: newGeometry
      }) : asFeature(newGeometry);
    } // @function asFeature(geojson: Object): Object
    // Normalize GeoJSON geometries/features into GeoJSON features.

    function asFeature(geojson) {
      if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
        return geojson;
      }

      return {
        type: 'Feature',
        properties: {},
        geometry: geojson
      };
    }
    var PointToGeoJSON = {
      toGeoJSON: function toGeoJSON(precision) {
        return getFeature(this, {
          type: 'Point',
          coordinates: latLngToCoords(this.getLatLng(), precision)
        });
      }
    }; // @namespace Marker
    // @method toGeoJSON(): Object
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).

    Marker.include(PointToGeoJSON); // @namespace CircleMarker
    // @method toGeoJSON(): Object
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).

    Circle$1.include(PointToGeoJSON);
    CircleMarker.include(PointToGeoJSON); // @namespace Polyline
    // @method toGeoJSON(): Object
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).

    Polyline$1.include({
      toGeoJSON: function toGeoJSON(precision) {
        var multi = !isFlat(this._latlngs);
        var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
        return getFeature(this, {
          type: (multi ? 'Multi' : '') + 'LineString',
          coordinates: coords
        });
      }
    }); // @namespace Polygon
    // @method toGeoJSON(): Object
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).

    Polygon$1.include({
      toGeoJSON: function toGeoJSON(precision) {
        var holes = !isFlat(this._latlngs),
            multi = holes && !isFlat(this._latlngs[0]);
        var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

        if (!holes) {
          coords = [coords];
        }

        return getFeature(this, {
          type: (multi ? 'Multi' : '') + 'Polygon',
          coordinates: coords
        });
      }
    }); // @namespace LayerGroup

    LayerGroup.include({
      toMultiPoint: function toMultiPoint(precision) {
        var coords = [];
        this.eachLayer(function (layer) {
          coords.push(layer.toGeoJSON(precision).geometry.coordinates);
        });
        return getFeature(this, {
          type: 'MultiPoint',
          coordinates: coords
        });
      },
      // @method toGeoJSON(): Object
      // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
      toGeoJSON: function toGeoJSON(precision) {
        var type = this.feature && this.feature.geometry && this.feature.geometry.type;

        if (type === 'MultiPoint') {
          return this.toMultiPoint(precision);
        }

        var isGeometryCollection = type === 'GeometryCollection',
            jsons = [];
        this.eachLayer(function (layer) {
          if (layer.toGeoJSON) {
            var json = layer.toGeoJSON(precision);

            if (isGeometryCollection) {
              jsons.push(json.geometry);
            } else {
              var feature = asFeature(json); // Squash nested feature collections

              if (feature.type === 'FeatureCollection') {
                jsons.push.apply(jsons, feature.features);
              } else {
                jsons.push(feature);
              }
            }
          }
        });

        if (isGeometryCollection) {
          return getFeature(this, {
            geometries: jsons,
            type: 'GeometryCollection'
          });
        }

        return {
          type: 'FeatureCollection',
          features: jsons
        };
      }
    }); // @namespace GeoJSON

    var min$5 = Math.min,
        max$4 = Math.max;

    var compare = function compare(v1, v2, func) {
      return v1 == null ? v2 : func(v1, v2);
    };

    var collectRings = function collectRings(feature, Crs, zoom, scale, needCenter) {
      if (scale === void 0) {
        scale = 1;
      }

      if (needCenter === void 0) {
        needCenter = false;
      }

      var geometry = feature.geometry,
          properties = feature.properties;
      var coordinates = geometry.coordinates,
          type = geometry.type;
      var definedCenter = properties && properties.center; // use center defined in feature.properties

      if (definedCenter) {
        needCenter = false;
      }

      var levels = coordsToLatLngs(coordinates, type === 'Polygon' ? 0 : 1, coordsToLatLngs);
      var left, right, top, bottom;
      var rings = [];

      var projectLatlngs = function projectLatlngs(latlngs, rings) {
        var flat = latlngs[0].length === void 0,
            len = latlngs.length;

        if (flat) {
          var ring = [];

          for (var i = 0; i < len; i++) {
            var _Crs$latLngToPoint = Crs.latLngToPoint(latlngs[i], zoom),
                x = _Crs$latLngToPoint.x,
                y = _Crs$latLngToPoint.y;

            x *= scale;
            y *= scale;

            if (needCenter) {
              left = compare(left, x, min$5);
              right = compare(right, x, max$4);
              top = compare(top, y, min$5);
              bottom = compare(bottom, y, max$4);
            }

            ring.push({
              x: x,
              y: y
            });
          }

          rings.push(ring);
        } else {
          for (var _i = 0; _i < len; _i++) {
            projectLatlngs(latlngs[_i], rings);
          }
        }
      };

      projectLatlngs(levels, rings);
      var output = {
        rings: rings
      };

      if (needCenter) {
        output.x = (left + right) / 2 | 0;
        output.y = (top + bottom) / 2 | 0;
      } else if (definedCenter) {
        var _Crs$latLngToPoint2 = Crs.latLngToPoint(coordsToLatLng(definedCenter), zoom),
            x = _Crs$latLngToPoint2.x,
            y = _Crs$latLngToPoint2.y;

        output.x = x;
        output.y = y;
      }

      return output;
    };

    var createMapRowPosCalculator = function createMapRowPosCalculator(mapConf) {
      var crs = mapConf.crs,
          zoom = mapConf.zoom,
          features = mapConf.features,
          geo = mapConf.geo,
          nameMatched = mapConf.nameMatched,
          imageBackground = mapConf.imageBackground;
      var Crs = CRS[crs];
      var imageScale = imageBackground ? imageBackground.imageScale : 1;
      return function (row, type) {
        var isAreaMap = type === ChartLibrary.AREA_MAP;

        if (isAreaMap && nameMatched) {
          var feature = features[row[geo]];

          if (feature) {
            var _collectRings = collectRings(feature, Crs, zoom, imageScale, true),
                x = _collectRings.x,
                y = _collectRings.y,
                rings = _collectRings.rings;

            row.x = x;
            row.y = y;
            row.rings = rings;
          }
        } else {
          var _Crs$latLngToPoint = Crs.latLngToPoint({
            lng: row[AttrKeys.LNG],
            lat: row[AttrKeys.LAT]
          }, zoom),
              _x = _Crs$latLngToPoint.x,
              _y = _Crs$latLngToPoint.y;

          var _Crs$latLngToPoint2 = Crs.latLngToPoint({
            lng: row[AttrKeys.LNG],
            lat: 0
          }, zoom),
              y0 = _Crs$latLngToPoint2.y;

          row.x = _x * imageScale;
          row.y = _y * imageScale;
          row.y0 = y0 * imageScale;
        }
      };
    };

    function leastSquares(asXsues, asYsues) {
      var reduceSumFunc = function reduceSumFunc(prev, cur) {
        return prev + cur;
      };

      var xBar = asXsues.reduce(reduceSumFunc) * 1.0 / asXsues.length;
      var yBar = asYsues.reduce(reduceSumFunc) * 1.0 / asYsues.length;
      var ssXX = asXsues.map(function (d) {
        return Math.pow(d - xBar, 2);
      }).reduce(reduceSumFunc);
      var ssYY = asYsues.map(function (d) {
        return Math.pow(d - yBar, 2);
      }).reduce(reduceSumFunc);
      var ssXY = asXsues.map(function (d, i) {
        return (d - xBar) * (asYsues[i] - yBar);
      }).reduce(reduceSumFunc);
      var slope = ssXY / ssXX;
      var intercept = yBar - xBar * slope;
      return [slope, intercept];
    } // 线性拟合


    function linear$3(asXs, asYs, extXs) {
      var x1, x2, y1, y2;
      var coeff = leastSquares(asXs, asYs);
      x1 = extXs[0];
      y1 = coeff[0] * x1 + coeff[1];
      x2 = extXs[extXs.length - 1];
      y2 = coeff[0] * x2 + coeff[1];
      return [[x1, y1], [x2, y2]];
    } // 指数拟合


    function logarithmic(asXs, asYs, extXs) {
      var newXs = [],
          newYs = []; // get min X in extendXs

      var minX = Math.min.apply(null, extXs);
      asXs.map(function (val, i) {
        if (minX <= 0) {
          // offset to positive
          val += -minX + 1;
        }

        newXs.push(Math.log(val));
        newYs.push(asYs[i]);
      });
      var coeff = leastSquares(newXs, newYs);
      return extXs.map(function (val) {
        var x = val; // x is the true position

        if (minX <= 0) {
          val += -minX + 1; // value offset is equation's value
        }

        return [x, coeff[0] * Math.log(val) + coeff[1]];
      });
    } // 指数拟合


    function exponential$1(asXs, asYs, extXs) {
      var newXs = [],
          newYs = [];
      var minY = Math.min.apply(null, asYs);
      asXs.map(function (val, i) {
        if (minY <= 0) {
          // offset to positive
          asYs[i] += -minY + 1;
        }

        newXs.push(val);
        newYs.push(Math.log(asYs[i]));
      });
      var coeff = leastSquares(newXs, newYs);
      var tmp = coeff[0];
      coeff[0] = Math.exp(coeff[1]);
      coeff[1] = tmp;
      return extXs.map(function (val) {
        var y = coeff[0] * Math.exp(val * coeff[1]);

        if (minY <= 0) {
          y -= -minY + 1;
        }

        return [val, y];
      });
    } // 多项式拟合


    function polynomial(asXs, asYs, extXs) {
      var M = Math.min(asXs.length - 1, 6);
      M++;
      var t;
      var b = [];
      var A = [];

      for (var i = 0; i < M; i++) {
        b[i] = [];
        A[i] = [];
      }

      var B = [];
      var y = [];
      var coeff = [];
      var i, j, k, l;

      for (i = 0; i < M; i++) {
        for (j = 0; j < asXs.length; j++) {
          t = 1;

          for (l = 0; l < i; l++) {
            t = t * asXs[j];
          }

          b[i][j] = t;
        }
      }

      for (i = 0; i < M; i++) {
        for (k = 0; k < M; k++) {
          t = 0;

          for (j = 0; j < asXs.length; j++) {
            t += b[i][j] * b[k][j];
          }

          A[i][k] = t;
        }
      }

      for (i = 0; i < M; i++) {
        t = 0;

        for (j = 0; j < asXs.length; j++) {
          t += asYs[j] * b[i][j];
        }

        B[i] = t;
      }

      for (i = 1; i < M; i++) {
        A[i][0] = A[i][0] / A[0][0];
      }

      for (i = 1; i < M; i++) {
        for (j = i; j < M; j++) {
          var tmp1 = 0;

          for (k = 0; k < i; k++) {
            tmp1 += A[k][j] * A[i][k];
          }

          A[i][j] = A[i][j] - tmp1;

          if (j + 1 != M) {
            var tmp2 = 0;

            for (k = 0; k < i; k++) {
              tmp2 += A[k][i] * A[j + 1][k];
            }

            A[j + 1][i] = (A[j + 1][i] - tmp2) / A[i][i];
          }
        }
      }

      y[0] = B[0];

      for (i = 1; i < M; i++) {
        t = 0;

        for (j = 0; j < i; j++) {
          t += A[i][j] * y[j];
        }

        y[i] = B[i] - t;
      }

      coeff[M - 1] = y[M - 1] / A[M - 1][M - 1];

      for (i = M - 2; i >= 0; i--) {
        t = 0;

        for (j = i + 1; j < M; j++) {
          t += A[i][j] * coeff[j];
        }

        coeff[i] = (y[i] - t) / A[i][i];
      }

      return extXs.map(function (val) {
        return [val, coeff.reduce(function (prev, curr, i) {
          return prev + curr * Math.pow(val, i);
        }, 0)];
      });
    }

    function getFitFunc(style) {
      switch (style) {
        case 'linear':
          return linear$3;

        case 'exp':
          return exponential$1;

        case 'log':
          return logarithmic;

        case 'poly':
          return polynomial;
      }
    }

    function getSharedAxisName(isHorizontal, isFirstMeasure) {
      if (isHorizontal) {
        return isFirstMeasure ? Direction.BOTTOM : Direction.TOP;
      } else {
        return isFirstMeasure ? Direction.LEFT : Direction.RIGHT;
      }
    }
    function isFacetStackValid(facet, otherFacet) {
      return !facet.base && !otherFacet.hasMeasure;
    }
    var getAllMeasuresOnFacet$1 = function getAllMeasuresOnFacet(facet) {
      var measures = facet.measures;
      return facet.measuresOverlapped ? measures[0].concat(measures[1]) : measures;
    };
    function isFacetHasMeasures(facet) {
      return getAllMeasuresOnFacet$1(facet).length > 0;
    }
    function isFacetHasDimension(facet) {
      return facet.dimensions.length > 0;
    }
    var getDimensionId$1 = function getDimensionId(facet, row) {
      var dimensions = facet.dimensions;
      var useRoot = dimensions.length === 0;
      return useRoot ? NODE_ROOT : _.map(dimensions, function (id) {
        return row[id];
      }).join(SEPARATOR);
    };
    var getGeomInShareAxis = function getGeomInShareAxis(measures, geoms) {
      var shareAxisGeoms = [],
          measureIdSet = {};

      _.each(measures, function (id) {
        return measureIdSet[id] = true;
      });

      _.each(geoms, function (geom) {
        return measureIdSet[geom.measure] && shareAxisGeoms.push(geom);
      });

      return shareAxisGeoms;
    };
    var getSharedDefKeyMap$1 = function getSharedDefKeyMap(facet) {
      if (!facet.measuresOverlapped) {
        return null;
      }

      var keyMap = {};
      var firstAxisKey = Direction.LEFT,
          secondAxisKey = Direction.RIGHT;

      if (facet.horizontal) {
        firstAxisKey = Direction.BOTTOM;
        secondAxisKey = Direction.TOP;
      }

      var _facet$measures = facet.measures,
          firstMeasures = _facet$measures[0],
          secondMeasures = _facet$measures[1];

      _.each(firstMeasures, function (id) {
        return keyMap[id] = firstAxisKey;
      });

      _.each(secondMeasures, function (id) {
        return keyMap[id] = secondAxisKey;
      });

      return keyMap;
    };
    var createGetMeasureDefKeyFunc$1 = function createGetMeasureDefKeyFunc(facet) {
      if (facet.measuresOverlapped) {
        var keyMap = getSharedDefKeyMap$1(facet);
        return function (id) {
          return keyMap[id];
        };
      }

      return function (id) {
        return id;
      };
    };
    var getMeasureDefKey = function getMeasureDefKey(measureId, facet) {
      var getKeyFn = createGetMeasureDefKeyFunc$1(facet);
      return getKeyFn(measureId);
    };
    function isEmptyFacet(facet) {
      var hasMeasure = facet.hasMeasure,
          hasDimension = facet.hasDimension;
      return !(hasMeasure || hasDimension);
    }

    /**
     * 获取值轴的上的tickCount，用于趋势线的周期计算
     * @param facet
     * @param measureId
     * @returns {number}
     */

    var tickCount = function tickCount(facet, measureId) {
      var measureDefKey = getMeasureDefKey(measureId, facet);
      return facet.scaleMap[measureDefKey].ticks.length - 1;
    };
    /**
     * 或者指标对应的趋势线信息集合
     * @param facet
     * @param measure
     * @param defs
     * @returns {Array}
     */


    var getMeasureTrendLineList = function getMeasureTrendLineList(facet, measure, defs) {
      return defs[measure] ? defs[measure].trendLine : [];
    };
    /**
     * 收集轴上趋势线样式集合
     * @param periodFacet
     * @param measureFacet
     * @param cellIndex
     * @param measure
     * @param frameMeasure
     * @param bounds
     * @param horizontal
     * @param rows
     * @param defs
     * @returns {Array}
     */


    var getTrendLinePropsList = function getTrendLinePropsList(_ref) {
      var periodFacet = _ref.periodFacet,
          measureFacet = _ref.measureFacet,
          cellIndex = _ref.cellIndex,
          measure = _ref.measure,
          frameMeasure = _ref.frameMeasure,
          bounds = _ref.bounds,
          horizontal = _ref.horizontal,
          rows = _ref.rows,
          defs = _ref.defs;

      if (!measureFacet.hasMeasure) {
        return [];
      }

      var _nodesMap = measureFacet.nodesMap;

      var _levelNodes = _.filter(_nodesMap, function (node) {
        return node.leaf;
      });

      var node = _levelNodes[cellIndex] || _levelNodes[0];
      var defName = getMeasureDefKey(measure, measureFacet);

      if (!node.measurePosMap[defName]) {
        return [];
      }

      var axisScale = getAxisScale(measureFacet, defName, node);
      var x = bounds.x,
          y = bounds.y,
          width = bounds.width,
          height = bounds.height;
      var totalLength = horizontal ? width : height;
      var xKey = 'x';
      var start = horizontal ? x : y;
      var nodesMap = periodFacet.nodesMap,
          _periodFacet$trendLin = periodFacet.trendLinePeriod,
          forward = _periodFacet$trendLin[0],
          backward = _periodFacet$trendLin[1],
          dimensions = periodFacet.dimensions,
          hasMeasure = periodFacet.hasMeasure;
      var levelNodes = hasMeasure ? [] : _.filter(nodesMap, function (node) {
        return node.level === Math.max(dimensions.length - 1, 0);
      });
      var totalPeriod = frameMeasure ? tickCount(periodFacet, frameMeasure) + forward + backward : levelNodes[cellIndex] ? levelNodes[cellIndex].leafCount : forward + backward;
      var unit = totalLength / totalPeriod;
      var xList = [],
          fList = [],
          bList = [],
          valueList = [];

      for (var i = 0; i < forward; i++) {
        fList[i] = start + (i + 0.5) * unit;
      }

      for (var _i = 0; _i < backward; _i++) {
        bList[backward - 1 - _i] = start + totalLength - (_i + 0.5) * unit;
      }

      rows = rows.slice().sort(function (a, b) {
        return a[xKey] - b[xKey];
      });

      _.each(rows, function (row) {
        xList.push(row[xKey]);
        valueList.push(row[measure]);
      });

      var trendLineStyleList = getMeasureTrendLineList(measureFacet, measure, defs);
      return _.map(trendLineStyleList, function (trendLineStyle) {
        var fitStyle = trendLineStyle.fitStyle,
            period = trendLineStyle.period;
        var _f = period[0],
            _b = period[1];

        var _fList = _f > 0 ? fList.slice(-_f) : [],
            _bList = bList.slice(0, _b);

        var data = getFitFunc(fitStyle)(xList, valueList, [].concat(_fList, xList, _bList)); // value => pos

        data = _.each(data, function (arr) {
          arr[1] = axisScale(arr[1]);
        });
        return _extends({
          data: horizontal ? data : _.map(data, function (d) {
            return d.reverse();
          })
        }, trendLineStyle);
      });
    };

    function dealTrendLine(_ref2) {
      var facetX = _ref2.facetX,
          facetY = _ref2.facetY,
          bounds = _ref2.bounds,
          rows = _ref2.rows,
          gx = _ref2.gx,
          gy = _ref2.gy,
          measure = _ref2.geomMeasure,
          frameMeasure = _ref2.frameMeasure,
          defs = _ref2.defs;
      var inverted = facetX.measuresToGeoms;
      var baseFacet = inverted ? facetY : facetX;
      var geomFacet = inverted ? facetX : facetY;
      var ci1 = inverted ? gx : gy;
      var ci2 = inverted ? gy : gx;
      var horizontal = !inverted; // NOTE 分两次，第一次取图形measure对应的trendLines, 第二次取 frameMeasure对应的trendLines

      var horizontalTrendLinePropsList = getTrendLinePropsList({
        periodFacet: baseFacet,
        // 周期所在轴
        measureFacet: geomFacet,
        // 设置趋势线指标所在的轴
        cellIndex: ci1,
        bounds: bounds,
        measure: measure,
        // 设置趋势线的指标
        frameMeasure: frameMeasure,
        // 图形在周期所在周上对应的指标
        horizontal: horizontal,
        rows: rows,
        defs: defs
      });
      var verticalTrendLinePropsList = getTrendLinePropsList({
        periodFacet: geomFacet,
        measureFacet: baseFacet,
        cellIndex: ci2,
        bounds: bounds,
        measure: frameMeasure,
        frameMeasure: measure,
        horizontal: horizontal,
        rows: rows,
        defs: defs
      });
      return [].concat(horizontalTrendLinePropsList, verticalTrendLinePropsList);
    }

    var CONDITION_SEPARATOR = '*';

    var getGeomReversed = function getGeomReversed(geomFacet, defs) {
      var getMeasureDefKey = createGetMeasureDefKeyFunc(geomFacet);
      return function (id) {
        var axisKey = getMeasureDefKey(id);
        return defs[axisKey] && defs[axisKey].reverse;
      };
    };

    var createId = function createId(row, ids) {
      return _.map(ids, function (id) {
        return row[id];
      }).join(SEPARATOR);
    };

    var getConditionMap = function getConditionMap(condition, name) {
      var conditionMap = {};

      _.each(condition[name], function (list, id) {
        _.each(list, function (value, i) {
          conditionMap[id + CONDITION_SEPARATOR + i] = value;
        });
      });

      return conditionMap;
    };

    var createProcessSelector = function createProcessSelector() {
      return function (state) {
        var facetX = state.facetX,
            facetY = state.facetY,
            geoms = state.geoms,
            enableMap = state.enableMap,
            inverted = state.inverted,
            defs = state.defs,
            condition = state.condition,
            mapConfig = state.mapConfig,
            tagFilter = state.tagFilter;
        var calcMapRowPos = createMapRowPosCalculator(mapConfig);
        var rowMap = {},
            cellMap = initCellMap(facetX, facetY, geoms);
        var vanishChecker = getVanishChecker(tagFilter);

        var _diffFacet = diffFacet(facetX, facetY),
            geomFacet = _diffFacet.geomFacet;

        var isGeomReversed = getGeomReversed(geomFacet, defs);
        var totalRowCount = 0;
        var positionXField = {
          name: 'x',
          id: 'x',
          type: FieldType.ATTR
        };
        var annotationConditionMap = getConditionMap(condition, ANNOTATION);
        var imageFillConditionMap = getConditionMap(condition, IMAGE_FILL);

        _.each(geoms, function (geom, gi) {
          var frames = geom.frames,
              measure = geom.measure,
              _geom$forecastIndex = geom.forecastIndex,
              forecastIndex = _geom$forecastIndex === void 0 ? Number.MAX_VALUE : _geom$forecastIndex,
              data = geom.data,
              metaData = geom.metaData,
              type = geom.type;
          geom.reversed = isGeomReversed(measure);
          geom.inverted = inverted;
          var geomCells = [];
          var Geometry = Geom.getGeom(type, enableMap);

          var geomDimensionIds = _.map(_.filter(data.fields, function (f) {
            return f.isDimension;
          }), function (f) {
            return f.id;
          });

          _.each(frames, function (frame) {
            var group = frame.group,
                value = frame.value,
                frameMeasure = frame.measure;
            var frameData = new Frame().addFrame(data.fields, data.colData);

            if (!enableMap) {
              frameData.addCol(positionXField, value);
            }

            var frameRows = frameData.toRows();
            totalRowCount += frameRows.length;
            var validRowChecker = createValidRowChecker(geom, frameMeasure);

            _.each(group, function (rowIdxList, cellId) {
              var _$map = _.map(cellId.split(GROUP_KEY), Number),
                  gx = _$map[0],
                  gy = _$map[1];

              var cellGeomRows = [],
                  cell = cellMap[cellId],
                  cellGeoms = cell.geoms,
                  bounds = cell.bounds,
                  trendLines = cell.trendLines;
              cellGeoms.push({
                rows: cellGeomRows,
                geom: geom,
                frameMeasure: frameMeasure
              });

              _.each(rowIdxList, function (idx) {
                var row = frameRows[idx];

                if (!validRowChecker(row)) {
                  return;
                }

                var cellRowIndex = cellGeomRows.length;
                var id = createId(row, geomDimensionIds);

                if (frameMeasure) {
                  id += SEPARATOR + frameMeasure;
                }

                if (measure) {
                  id += SEPARATOR + measure;
                }

                id += SEPARATOR + idx;
                var annotation = row.annotation,
                    imageFill = row.imageFill;
                row.id = id;
                row.cellRowIndex = cellRowIndex;
                row.cellId = cellId;
                row.metaId = createId(row, metaData);
                row.geomIndex = gi;
                row.vanish = vanishChecker(row);
                row.oIndex = idx;

                if (idx >= forecastIndex && forecastIndex > 0) {
                  row.fake = true;
                }

                enableMap && calcMapRowPos(row, type);

                if (annotation) {
                  row.annotation = annotationConditionMap[annotation];
                }

                if (imageFill) {
                  row.imageFill = imageFillConditionMap[imageFill];
                }

                rowMap[id] = row;
                cellGeomRows.push(row);
              });

              geomCells.push({
                cell: cell,
                rows: cellGeomRows
              });
              trendLines.push(dealTrendLine({
                defs: defs,
                bounds: bounds,
                facetX: facetX,
                facetY: facetY,
                gx: gx,
                gy: gy,
                geomMeasure: measure,
                frameMeasure: frameMeasure,
                rows: cellGeomRows
              }));
            });
          });

          (type === ChartLibrary.TREE_MAP || type === ChartLibrary.MULTI_PIE) && dealTreeGeom(geomCells);

          _.each(geomCells, function (_ref) {
            var cell = _ref.cell,
                rows = _ref.rows;
            Geometry.layout(rows, {
              cell: cell,
              facetX: facetX,
              facetY: facetY,
              geom: geom,
              inverted: inverted,
              zoom: {}
            });
          });
        });

        state.cellMap = cellMap;
        state.rowMap = rowMap;
        state.totalRowCount = totalRowCount;
        dealRowDataLabel(cellMap, enableMap, mapConfig);
        return state;
      };
    };

    /**
     * 从dataFrames中计算出stackMap: {"张三_POSITIVE": 100, "李四_NEGATIVE": -30}
     * @param frames        GeomData按照dimensionIds划分后得到的dataFrames
     * @param measureId     需要计算domain的指标id
     * @param vanishChecker  对于点击图例等点击消失后的数据, 不参与计算
     */

    function getStackMapFromFrames(frames, measureId, vanishChecker) {
      var stackMap = {};

      if (!_.isFunction(vanishChecker)) {
        vanishChecker = FALSE_FUNCTION;
      } // 遍历frames, 并计算单个frame内对应的measure的domain


      _.each(frames, function (frame, key) {
        _.each(frame.toRows(), function (row) {
          var value = +row[measureId]; // 过滤掉NaN和不参与计算的数据

          if (isNaN(value) || vanishChecker(row)) {
            return;
          } // 对于正负值需要分开计算


          var stackKey = key + (value >= 0 ? POSITIVE_SUFFIX : NEGATIVE_SUFFIX);
          stackMap[stackKey] = (stackMap[stackKey] || 0) + value;
        });
      });

      return stackMap;
    }

    /**
     * 从一组堆积的Map中, 得出最终的值域区间
     * @param stackMap :{"a": 100, "b": -30}
     * @param [min]    自定义的min, 与stackMap中的最小值比较返回更小值
     * @param [max]    自定义的max, 与stackMap中的最大值比较返回更大值
     * @returns {number[]}
     */

    function getDomainFromStackMap(stackMap, min, max) {
      if (min === void 0) {
        min = Number.MAX_VALUE;
      }

      if (max === void 0) {
        max = Number.MIN_VALUE;
      }

      _.each(stackMap, function (value) {
        min = Math.min(value, min);
        max = Math.max(value, max);
      });

      if (min === Number.MAX_VALUE && max === Number.MIN_VALUE) {
        return Frame.getDefaultMinMax();
      }

      return [min, max];
    }
    /**
     * 从共享同一个值轴的Geoms中, 计算出值轴的Domain
     * 同时考虑分区和堆积
     * @param geoms
     * @param stackValid
     * @param vanishChecker
     * @param groupIds
     */

    function getDomainFromGeoms(_ref) {
      var geoms = _ref.geoms,
          stackValid = _ref.stackValid,
          vanishChecker = _ref.vanishChecker,
          groupIds = _ref.groupIds;
      var stackSumMap = {};
      var _min = Number.MAX_VALUE,
          _max = Number.MIN_VALUE;

      _.each(geoms, function (geom) {
        var measure = geom.measure,
            stack = geom.stack;

        if (stack && stackValid) {
          var geomDataFrames = Frame.groupToMap(geom.data, groupIds);
          var geomStackMap = getStackMapFromFrames(geomDataFrames, measure, vanishChecker);

          _.each(geomStackMap, function (value, key) {
            stackSumMap[key] = value + (stackSumMap[key] || 0);
          });
        } else {
          // @BI-38365 BI-38282 当列元素为空时, minMax返回默认的时候, 跳过计算
          var minMax = Frame.minMax(geom, measure, vanishChecker);

          if (!minMax.isDefault) {
            _min = Math.min(_min, minMax[0]);
            _max = Math.max(_max, minMax[1]);
          }
        }
      });

      return getDomainFromStackMap(stackSumMap, _min, _max);
    }

    /**
     * 从一组Geoms的frameMeasure中得出最终的值域, 用于BaseFacet指标聚合时, firstAxis&secondAxis的Domain计算
     * @param measures
     * @param geoms
     * @returns {number[]}
     */

    function getDomainFromFrameMeasures(measures, geoms) {
      var _min = Number.MAX_VALUE,
          _max = Number.MIN_VALUE;

      _.each(measures, function (measureId) {
        _.each(geoms, function (geom) {
          var data = geom.data;

          if (!data.contains(measureId)) {
            return;
          }

          var _data$minMax = data.minMax(measureId),
              min = _data$minMax[0],
              max = _data$minMax[1];

          _min = Math.min(min, _min);
          _max = Math.max(max, _max);
        });
      });

      if (_min === Number.MAX_VALUE && _max === Number.MIN_VALUE) {
        return Frame.getDefaultMinMax();
      }

      return [_min, _max];
    }

    /**
     *
     * @param geoms
     * @param facet
     * @param otherFacet
     * @param vanishChecker
     */

    function getFacetDomainMapWhenMeasureOverlap(_ref) {
      var geoms = _ref.geoms,
          facet = _ref.facet,
          otherFacet = _ref.otherFacet,
          vanishChecker = _ref.vanishChecker;
      var _facet$measures = facet.measures,
          firstMeasures = _facet$measures[0],
          secondMeasures = _facet$measures[1],
          measuresToGeoms = facet.measuresToGeoms,
          horizontal = facet.horizontal;
      var domainMap = {};
      var stackValid = isFacetStackValid(facet, otherFacet);
      var firstAxisKey = getSharedAxisName(horizontal, true);
      var secondAxisKey = getSharedAxisName(horizontal, false);
      var groupIds = [].concat(otherFacet.dimensions, facet.dimensions); // GeomFacet

      if (measuresToGeoms) {
        var firstAxisGeoms = getGeomInShareAxis(firstMeasures, geoms);
        var secondAxisGeoms = getGeomInShareAxis(secondMeasures, geoms); // 对于映射图形的Facet来说, 从GeomMeasure中计算Domain, 需要考虑堆积和vanish

        domainMap[firstAxisKey] = getDomainFromGeoms({
          geoms: firstAxisGeoms,
          stackValid: stackValid,
          vanishChecker: vanishChecker,
          groupIds: groupIds
        });
        domainMap[secondAxisKey] = getDomainFromGeoms({
          geoms: secondAxisGeoms,
          stackValid: stackValid,
          vanishChecker: vanishChecker,
          groupIds: groupIds
        });
      } else {
        // 对于非映射图形的facet, 从所有共享的geoms中计算其FrameMeasure的对应的Domain
        domainMap[firstAxisKey] = getDomainFromFrameMeasures(firstMeasures, geoms);
        domainMap[secondAxisKey] = getDomainFromFrameMeasures(secondMeasures, geoms);
      }

      return domainMap;
    }

    function getFacetDomainMapWhenMeasureApposition(_ref) {
      var geoms = _ref.geoms,
          facet = _ref.facet,
          otherFacet = _ref.otherFacet,
          vanishChecker = _ref.vanishChecker;
      var measuresToGeoms = facet.measuresToGeoms;
      var stackValid = isFacetStackValid(facet, otherFacet);
      var domainMap = {};
      var groupIds = [].concat(facet.dimensions, otherFacet.dimensions);

      if (measuresToGeoms) {
        _.each(geoms, function (geom) {
          var domain;
          var data = geom.data,
              stack = geom.stack,
              measure = geom.measure;

          if (stack && stackValid) {
            var geomFrames = Frame.groupToMap(data, groupIds);
            var geomStackMap = getStackMapFromFrames(geomFrames, measure, vanishChecker);
            domain = getDomainFromStackMap(geomStackMap);
          } else {
            domain = Frame.minMax(geom, measure, vanishChecker);
          }

          domainMap[measure] = domain;
        });
      } else {
        var measures = facet.measures;

        _.each(measures, function (measureId) {
          var min = Number.MAX_VALUE,
              max = Number.MIN_VALUE;

          _.each(geoms, function (geom) {
            var data = geom.data;

            if (!data.contains(measureId)) {
              return;
            }

            var _data$minMax = data.minMax(measureId),
                _min = _data$minMax[0],
                _max = _data$minMax[1];

            min = Math.min(min, _min);
            max = Math.max(max, _max);
          });

          if (min === Number.MAX_VALUE && max === Number.MIN_VALUE) {
            domainMap[measureId] = Frame.getDefaultMinMax();
          }

          domainMap[measureId] = [min, max];
        });
      }

      return domainMap;
    }

    function getScaleMap(state, facet, otherFacet) {
      var measuresOverlapped = facet.measuresOverlapped,
          hasMeasure = facet.hasMeasure;

      if (!hasMeasure) {
        return {};
      }

      var geoms = state.geoms,
          tagFilter = state.tagFilter;
      var vanishChecker = getVanishChecker(tagFilter);
      var domainMapCalculator = measuresOverlapped ? getFacetDomainMapWhenMeasureOverlap : getFacetDomainMapWhenMeasureApposition;
      var domainMap = domainMapCalculator({
        geoms: geoms,
        vanishChecker: vanishChecker,
        facet: facet,
        otherFacet: otherFacet
      });
      return _.mapObject(domainMap, function (domain) {
        return {
          domain: domain
        };
      });
    }

    var initFacetNode = function initFacetNode(_ref) {
      var _ref$id = _ref.id,
          id = _ref$id === void 0 ? '' : _ref$id,
          _ref$pId = _ref.pId,
          pId = _ref$pId === void 0 ? '' : _ref$pId,
          _ref$level = _ref.level,
          level = _ref$level === void 0 ? 0 : _ref$level,
          _ref$text = _ref.text,
          text = _ref$text === void 0 ? '' : _ref$text,
          _ref$path = _ref.path,
          path = _ref$path === void 0 ? [] : _ref$path,
          _ref$dim = _ref.dim,
          dim = _ref$dim === void 0 ? '' : _ref$dim,
          _ref$leafCount = _ref.leafCount,
          leafCount = _ref$leafCount === void 0 ? 0 : _ref$leafCount,
          _ref$leaf = _ref.leaf,
          leaf = _ref$leaf === void 0 ? false : _ref$leaf;
      return {
        isRoot: id === NODE_ROOT,
        length: 0,
        leafIndex: 0,
        pos: 0,
        measurePosMap: {},
        children: [],
        id: id,
        pId: pId,
        level: level,
        text: text,
        path: path,
        dim: dim,
        leafCount: leafCount,
        leaf: leaf
      };
    };

    /**
     * calculate leafFacetNode count under specific FacetNode
     * consider with trend lines
     * @param facet
     * @param dims
     * @param levelsMap
     * @param nodesMap
     */
    var calcFacetNodeLeafCount = function calcFacetNodeLeafCount(facet, dims, levelsMap, nodesMap) {
      // 考虑趋势线对坐标轴的影响
      var trendLinePeriod = facet.trendLinePeriod,
          hasMeasure = facet.hasMeasure;

      var levelsSize = _.keys(levelsMap).length;

      var forward = trendLinePeriod[0],
          backward = trendLinePeriod[1]; // trendLine period affect valueAxis's range while has measure on facet

      if (hasMeasure) {
        forward = backward = 0;
      }

      var _loop = function _loop(i) {
        var currentLevelNodes = levelsMap[i];
        var parentNode = void 0;

        _.each(currentLevelNodes, function (node) {
          parentNode = nodesMap[node.pId];

          if (parentNode) {
            var leafCount = parentNode.leafCount; // 趋势线影响的是最上层

            if (i === dims.length - 1 && leafCount === 0) {
              leafCount = backward + forward;
            }

            parentNode.leafCount = leafCount + node.leafCount;
          }
        });
      };

      for (var i = dims.length - 1; i >= 0 && i < levelsSize; i--) {
        _loop(i);
      }
    };

    /**
     * calculate leaf index for facetNode.
     * leafIndex & leafCount is for calculate node pos & length
     * @param node
     * @param trendLineForwardPeriod
     */
    var calcFacetNodeLeafIndex = function calcFacetNodeLeafIndex(node, trendLineForwardPeriod) {
      var children = node.children;

      for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i]; // first node

        if (i === 0) {
          var forward = child.leaf ? trendLineForwardPeriod : 0;
          child.leafIndex = node.leafIndex + forward;
        } else {
          var previous = children[i - 1];
          child.leafIndex = previous.leafIndex + previous.leafCount;
        }

        calcFacetNodeLeafIndex(child, trendLineForwardPeriod);
      }
    };

    var getNodePath = function getNodePath(dimensionIds, size, row) {
      var keys = [];

      for (var i = 0; i < size; i++) {
        keys[i] = row[dimensionIds[i]] || '';
      }

      return keys;
    };

    /**
     * collect facet Nodes under root Node
     * @param facetData
     * @param nodesMap
     * @param levelsMap
     * @param dimensionIds
     */

    var collectFacetNodes = function collectFacetNodes(facetData, nodesMap, levelsMap, dimensionIds) {
      for (var i = 0, rowCount = facetData.getRowCount(); i < rowCount; i++) {
        var row = facetData.rowObject(i);

        for (var j = 0, len = dimensionIds.length; j < len; j++) {
          var dId = dimensionIds[j],
              text = row[dId] || '',
              initLeafCount = j === len - 1 ? 1 : 0,
              path = getNodePath(dimensionIds, j + 1, row),
              id = path.join(SEPARATOR),
              pId = j === 0 ? NODE_ROOT : path.slice(0, j).join(SEPARATOR);

          if (!nodesMap[id]) {
            var level = j + 1;
            var leaf = level === dimensionIds.length;
            var node = initFacetNode({
              id: id,
              pId: pId,
              level: level,
              text: text,
              path: path,
              dim: dId,
              leafCount: initLeafCount,
              leaf: leaf
            });
            var parentNode = nodesMap[pId];
            parentNode.children.push(node);
            nodesMap[id] = node; // 统计leafCount

            if (!levelsMap[j]) {
              levelsMap[j] = [];
            }

            levelsMap[j].push(node);
          }
        }
      }
    };

    /**
     * for radarChart, leaf dim should not generate facetNode
     * so the tick valid is set to false for leaf dimension in backend.
     * need to reconsider
     * @param facet
     * @param defs
     * @returns {Array}
     */

    var getValidFacetDimensionIds = function getValidFacetDimensionIds(facet, defs) {
      var dims = [];

      _.each(facet.dimensions, function (dId) {
        var _defs$dId$tick$valid = defs[dId].tick.valid,
            valid = _defs$dId$tick$valid === void 0 ? true : _defs$dId$tick$valid;
        valid && dims.push(dId);
      });

      return dims;
    };
    /**
     * create nodesMap on facet, deal child relationship.
     * calculate leafCount & leafIndex etc.
     * @param state
     * @param facet
     */

    function createFacetNodesMap(state, facet) {
      var data = facet.data,
          hasMeasure = facet.hasMeasure,
          trendLinePeriod = facet.trendLinePeriod;
      var defs = state.defs;
      var dimensionIds = getValidFacetDimensionIds(facet, defs);
      var nodesMap = {},
          levelsMap = {};
      var isEmpty = _.isEmpty(dimensionIds) || data.getRowCount() === 0;
      var rootNode = initFacetNode({
        id: NODE_ROOT,
        leafCount: isEmpty ? 1 : 0,
        leaf: isEmpty
      });
      nodesMap[NODE_ROOT] = rootNode;
      collectFacetNodes(data, nodesMap, levelsMap, dimensionIds); // 存在指标时，周期不对nodePos产生影响

      var trendLineForward = hasMeasure ? 0 : trendLinePeriod[0];
      calcFacetNodeLeafCount(facet, dimensionIds, levelsMap, nodesMap);
      calcFacetNodeLeafIndex(rootNode, trendLineForward);
      return nodesMap;
    }

    /**
     *  同一个指标里面可能存在多个trendLine，而不同的trendLine的前推和后推周期设置也不一样，故应该区facet下所有指标的所有trendLine，
     然后找出最大的前推和最大的后推用作计算。
     * @param defs
     * @param facet
     */

    function calcFacetMaxTrendPeriod(defs, facet) {
      var measures = getAllMeasuresOnFacet$1(facet);
      var forward = 0,
          backward = 0;

      _.each(measures, function (dId) {
        var trendLine = defs[dId].trendLine;

        _.each(trendLine, function (trend) {
          var period = trend.period;
          forward = Math.max(forward, period[0]);
          backward = Math.max(backward, period[1]);
        });
      });

      return [forward, backward];
    }

    var _SINGLE_UNIT_CHAT_TYP;
    var SINGLE_UNIT_CHAT_TYPES = (_SINGLE_UNIT_CHAT_TYP = {}, _SINGLE_UNIT_CHAT_TYP[ChartLibrary.AREA_MAP] = 1, _SINGLE_UNIT_CHAT_TYP[ChartLibrary.FORCE_POINT] = 1, _SINGLE_UNIT_CHAT_TYP[ChartLibrary.TREE_MAP] = 1, _SINGLE_UNIT_CHAT_TYP[ChartLibrary.MULTI_PIE] = 1, _SINGLE_UNIT_CHAT_TYP[ChartLibrary.WORD_CLOUD] = 1, _SINGLE_UNIT_CHAT_TYP);

    var isFunnelOrPie = function isFunnelOrPie(type) {
      return type === ChartLibrary.FUNNEL || type === ChartLibrary.PIE;
    };
    /**
     * 判断facet分区基于最后一层dimension还是倒数第二层
     * @param state
     * @returns {boolean}
     */


    var isFacetGroupBySingleUnit = function isFacetGroupBySingleUnit(state) {
      var geoms = state.geoms,
          enableMap = state.enableMap;

      if (geoms.length === 0) {
        return true;
      }

      var _geoms$ = geoms[0],
          type = _geoms$.type,
          measure = _geoms$.measure;

      if (enableMap || SINGLE_UNIT_CHAT_TYPES[type]) {
        return true;
      } // funnel or pie with graphic geom is also by single unit


      return !!(isFunnelOrPie(type) && measure == null);
    };

    /**
     * calculate group measure count. for calculate measure.scale.range in cell
     * @param facet
     * @returns {number}
     */

    var getGroupMeasureCount = function getGroupMeasureCount(facet) {
      return facet.hasMeasure ? facet.measuresOverlapped ? 1 : facet.measures.length : 0;
    };

    var calculateGroupLevel = function calculateGroupLevel(facet, groupByUnit) {
      var hasMeasure = facet.hasMeasure,
          dimensions = facet.dimensions;
      return groupByUnit || hasMeasure ? dimensions.length : Math.max(dimensions.length - 1, 0);
    };
    /**
     * add useful properties to facet.
     * @param facet
     * @param state
     * @param other
     * @param isHorizontal
     */


    var addFacetProperties = function addFacetProperties(facet, state, other, isHorizontal) {
      var inverted = state.inverted,
          defs = state.defs;
      var groupBySingleUnit = isFacetGroupBySingleUnit(state); // setFacetMaxTrendPeriod

      facet.trendLinePeriod = calcFacetMaxTrendPeriod(defs, other); // hasMeasure

      facet.hasMeasure = isFacetHasMeasures(facet); // hasDimension

      facet.hasDimension = isFacetHasDimension(facet); // isHorizontal

      facet.horizontal = isHorizontal; // groupLevel

      facet.groupLevel = calculateGroupLevel(facet, groupBySingleUnit); // is base facet
      // horizontal facet when chart.inverted is false while vertical facet when chart.inverted is true

      facet.base = isHorizontal ^ inverted; // is measures on facet will transform to geometries

      facet.measuresToGeoms = !facet.base; // facetNode map. includes dimension Node info

      facet.nodesMap = createFacetNodesMap(state, facet); // cache some scale info & ticks for measure axis

      facet.scaleMap = getScaleMap(state, facet, other); // 用于计算分区的指标个数, 聚合时为1, 并列时为所有指标数

      facet.groupMeasureCount = getGroupMeasureCount(facet);
      facet.fixUnit = facet.unit != null;
    };

    var createFacetSelector = function createFacetSelector() {
      return function (state) {
        var facetX = state.facetX,
            facetY = state.facetY;
        addFacetProperties(facetX, state, facetY, true);
        addFacetProperties(facetY, state, facetX, false);
        return state;
      };
    };

    var getMetaFields = function getMetaFields(fields) {
      return _.filter(fields, function (_ref) {
        var type = _ref.type;
        return type === FieldType.DIMENSION || type === FieldType.MEASURE;
      });
    };

    var dealAesMapping = function dealAesMapping(geoms) {
      _.each(geoms, function (geom) {
        var dataModel = geom.data;
        geom.metaData = getMetaFields(dataModel.fields);

        _.each(MappingAesTypes, function (v, aesType) {
          var aes = geom[aesType];

          if (aes == null) {
            return;
          }

          aes = getAesInstance(aesType, geom, aes);
          var result = aes && aes.dealMapping(dataModel);

          if (result) {
            var field = {
              name: aesType,
              id: aesType,
              type: FieldType.ATTR,
              constField: aes.isConstField()
            };
            dataModel.addCol(field, result);
          }
        });
      });
    };

    var addLegendItems = function addLegendItems(geoms, legend, tagFilter) {
      // set default empty items
      legend.tags = [];
      legend.sliders = [];

      if (!legend.enabled) {
        return;
      } // cache vanishChecker for check legend item valid


      var vanishChecker = getVanishChecker(tagFilter);

      _.each(LegendAesTypes, function (aesType) {
        var legendNameFieldsMap = {};
        var len = geoms.length;

        _.each(geoms, function (geom, gi) {
          var geomData = geom.data;
          var aes = geom[aesType];

          if (aes == null) {
            return;
          }

          aes = getAesInstance(aesType, geom, aes);

          if (aes.isConstField()) {
            return;
          }

          var _geom$aesType = geom[aesType],
              id = _geom$aesType.id,
              format = _geom$aesType.format,
              domain = _geom$aesType.domain; // 无自定义值且字段对应的数据为空或全为无意义数据时, 不显示图例

          if (!domain && geomData.isEmptyCol(id)) {
            return;
          }

          aes.setValidChecker(vanishChecker);

          var _geomData$getFieldByI = geomData.getFieldById(id),
              name = _geomData$getFieldByI.name;

          if (legendNameFieldsMap[name]) {
            // 同名字段共享一个图例
            var fieldIds = legendNameFieldsMap[name];
            fieldIds[gi] = id;
          } else {
            var _fieldIds = fillArray(len, '');

            _fieldIds[gi] = id;
            legendNameFieldsMap[name] = _fieldIds;
            var legendItem = aes.getLegend(legend, geomData);
            legendItem.format = format;
            legendItem.fieldIds = _fieldIds;
          }
        });
      });
    };

    var createGeomSelector = function createGeomSelector() {
      return function (state) {
        var geoms = state.geoms,
            legend = state.legend,
            tagFilter = state.tagFilter; // mapping aes values

        dealAesMapping(geoms); // add legend items

        addLegendItems(geoms, legend, tagFilter);
        return state;
      };
    };

    var DEFAULT_ZOOM$1 = {
      x: 1,
      y: 1
    };
    var DEFAULT_SELECTED_ROWS = [];
    var getFacetX = function getFacetX(state) {
      return state.facetX;
    };
    var getFacetY = function getFacetY(state) {
      return state.facetY;
    };
    var getLegend = function getLegend(state) {
      return state.legend;
    };
    var getGeoms = function getGeoms(state) {
      return state.geoms;
    };
    var getComputedState = function getComputedState(state) {
      return state.computedState;
    };
    var getDefs = function getDefs(state) {
      return state.defs;
    };
    var getInverted = function getInverted(state) {
      return state.inverted;
    };
    var DefaultTagFilter = {};
    var getTagFilter = function getTagFilter(state) {
      return state.tagFilter || DefaultTagFilter;
    };
    var getSize = function getSize(state) {
      return state.size;
    };
    var getOrientation$1 = function getOrientation(state) {
      return state.orientation;
    };
    var getFocusPosition = function getFocusPosition(state) {
      return state.focusPosition;
    };
    var getMapConfig = function getMapConfig(state) {
      return state.mapConfig;
    };
    var getMobile = function getMobile(state) {
      return state.isMobile;
    };
    var getCondition = function getCondition(state) {
      return state.condition;
    };
    var getZoom = function getZoom(state) {
      return state.zoom || DEFAULT_ZOOM$1;
    };
    var getSelectedRows = function getSelectedRows(state) {
      return state.selectedRows || DEFAULT_SELECTED_ROWS;
    };

    // NOTE 考虑到BI那边维度可以针对指标过滤，就意味着对于geomA & geomB，在过滤后可能二者的dataModel中的维度信息是不一样的
    // NOTE 此时要想让每个geom的数据都可以正常显示，应该判断取维度数据的并集。

    var collectFacetDataWithDimensions = function collectFacetDataWithDimensions(geomDataList, dimensions) {
      if (!geomDataList.length) {
        return new Frame();
      }

      var dimensionMap = {},
          dimensionKeys = [];

      _.each(geomDataList, function (geomData) {
        geomData.each(function (row) {
          var dimensionKey = _.map(dimensions, function (id) {
            return row[id];
          }).join(SEPARATOR);

          if (!dimensionMap[dimensionKey]) {
            dimensionMap[dimensionKey] = 1;
            dimensionKeys.push(dimensionKey);
          }
        });
      });

      var fields = geomDataList[0].fields;

      var dimensionColData = _.map(new Array(dimensions.length), function () {
        return [];
      });

      _.each(dimensionKeys, function (key) {
        _.each(key.split(SEPARATOR), function (t, i) {
          dimensionColData[i].push(t);
        });
      });

      return new Frame(fields, dimensionColData);
    };
    var collectFacetDataFromGeoms = function collectFacetDataFromGeoms(_ref) {
      var facetX = _ref.facetX,
          facetY = _ref.facetY,
          geoms = _ref.geoms;

      var getFacetData = function getFacetData(ids) {
        var geomDataList = _.map(geoms, function (geom) {
          var _geom$data = geom.data,
              fields = _geom$data.fields,
              colData = _geom$data.colData;
          return new Frame(fields, colData).filter(ids);
        });

        return collectFacetDataWithDimensions(geomDataList, ids);
      }; // looks like we don't need measures data in facet


      return {
        facetX: getFacetData(facetX.dimensions),
        facetY: getFacetData(facetY.dimensions)
      };
    };

    function transformData2DataModel(originData) {
      var fields = originData.fields,
          colData = originData.colData; // [...oldData] 方便后面添加新数据

      return new Frame().addFrame(fields, colData);
    }

    var transformDataObject = function transformDataObject(obj, _data) {
      var newObject = _extends({}, obj);

      var _newObject$data = newObject.data,
          data = _newObject$data === void 0 ? _data : _newObject$data;

      if (data) {
        newObject.data = transformData2DataModel(data);
      }

      return newObject;
    };
    /**
     * 地理字段有两种实现方式，一个时名称匹配，一个是使用数据中的经纬度
     * @param facetX
     * @param facetY
     * @param geoms
     * @returns {*}
     */


    var getMapMatchedType = function getMapMatchedType(facetX, facetY, geoms) {
      var xGeo = facetX.geo,
          yGeo = facetY.geo;
      var mapGeom = geoms[0];

      if (!xGeo || !yGeo || !mapGeom) {
        return {};
      }

      var data = mapGeom.data;
      return {
        nameMatched: data.isDimension(xGeo) && data.isDimension(yGeo),
        latLngMatched: data.isMeasure(xGeo) && data.isMeasure(yGeo)
      };
    };
    /**
     * 在这里过滤掉没有框选中的图形的data
     * @param state
     * @returns {*}
     */


    var selectedRowsFilter = function selectedRowsFilter(state) {
      var selectedRows = state.selectedRows;

      if (!selectedRows.length) {
        return state;
      }

      var selectedGeomMap = {},
          geomMeasureMap = {},
          baseMeasureMap = {};
      var geoms = state.geoms,
          facetX = state.facetX,
          facetY = state.facetY,
          inverted = state.inverted;

      var getUniqIdFn = function getUniqIdFn(fields) {
        var ids = _.map(fields, function (field) {
          return field.id;
        });

        return function (row) {
          return _.map(ids, function (id) {
            return row[id];
          }).join(SEPARATOR);
        };
      };

      var geomsMap = _.reduce(geoms, function (hash, geom) {
        hash[geom.measure] = geom;
        return hash;
      }, {});

      _.each(selectedRows, function (_ref) {
        var row = _ref.row,
            measure = _ref.measure,
            frameMeasure = _ref.frameMeasure;
        var geom = geomsMap[measure];
        var getUniqId = getUniqIdFn(geom.data.fields);

        if (!selectedGeomMap[measure]) {
          selectedGeomMap[measure] = {};
        }

        selectedGeomMap[measure][getUniqId(row)] = 1;
        geomMeasureMap[measure] = 1;
        baseMeasureMap[frameMeasure] = 1;
      });

      var newGeoms = _.map(selectedGeomMap, function (idxMap, measure) {
        var geom = geomsMap[measure];
        var _geom$data = geom.data,
            fields = _geom$data.fields,
            colData = _geom$data.colData;
        var getUniqId = getUniqIdFn(geom.data.fields);
        var frame = new Frame(fields, colData);
        var indexArr = [];
        frame.each(function (row, i) {
          return idxMap[getUniqId(row)] && indexArr.push(i);
        });
        return _extends({}, geom, {
          data: {
            fields: fields,
            colData: _.map(colData, function (col) {
              return _.map(indexArr, function (i) {
                return col[i];
              });
            })
          }
        });
      });

      var _ref2 = inverted ? [geomMeasureMap, baseMeasureMap] : [baseMeasureMap, geomMeasureMap],
          xMeasureMap = _ref2[0],
          yMeasureMap = _ref2[1];

      return _extends({}, state, {
        geoms: newGeoms,
        facetX: filterFacetMeasures(facetX, xMeasureMap),
        facetY: filterFacetMeasures(facetY, yMeasureMap)
      });
    };
    /**
     * Convert all the data into dataModel in state.
     */


    var createDataConversionSelector = function createDataConversionSelector() {
      return function (state) {
        state = selectedRowsFilter(state);

        var _collectFacetDataFrom = collectFacetDataFromGeoms(state),
            xData = _collectFacetDataFrom.facetX,
            yData = _collectFacetDataFrom.facetY;

        var facetXSelector = createSelector([getFacetX], function (facetX) {
          return transformDataObject(facetX, xData);
        });
        var facetYSelector = createSelector([getFacetY], function (facetY) {
          return transformDataObject(facetY, yData);
        });
        var geomsSelector = createSelector([getGeoms], function (geoms) {
          var chartDataMap = {};
          return _.map(geoms, function (geom) {
            var transformed = transformDataObject(geom);
            transformed.dataMap = chartDataMap;
            var data = transformed.data,
                measure = transformed.measure;
            chartDataMap[measure] = data;
            return transformed;
          });
        });
        var legendSelector = createSelector([getLegend], function (legend) {
          return _extends({}, legend);
        });

        var _state = state,
            _state$shared = _state.shared,
            shared = _state$shared === void 0 ? {} : _state$shared; // 对于facet, geom这类mutate的第一层，后面的计算结果可以直接丢在上面，尽量不要去修改

        var facetX = facetXSelector(state),
            facetY = facetYSelector(state),
            geoms = geomsSelector(state);
        var mapConfig;

        if (state.mapConfig) {
          mapConfig = _extends({}, state.mapConfig, getMapMatchedType(facetX, facetY, geoms), {
            geo: facetX.geo
          });
        }

        return _extends({}, state, {
          facetX: facetX,
          facetY: facetY,
          geoms: geoms,
          legend: legendSelector(state),
          shared: _extends({}, shared),
          mapConfig: mapConfig
        });
      };
    };

    function setSharedTooltip (state) {
      var geoms = state.geoms,
          facetX = state.facetX,
          facetY = state.facetY;
      var isShared = true;

      _.each(geoms, function (_ref) {
        var tooltip = _ref.tooltip;
        var shared = tooltip.shared;
        isShared = isShared && shared;
      });

      var _diffFacet = diffFacet(facetX, facetY),
          hasMeasure = _diffFacet.geomFacet.hasMeasure; // 存在指标字段且设置了数据点提示共享才生效


      state.tooltipShared = isShared && hasMeasure;
      return state;
    }

    var leafNodesCount = function leafNodesCount(facet) {
      var nodesMap = facet.nodesMap,
          hasDimension = facet.hasDimension,
          dimensions = facet.dimensions;
      return hasDimension ? _.filter(nodesMap, function (node) {
        return node.leaf;
      }).length / dimensions.length : 0;
    };

    var isAllInterval = function isAllInterval(geoms) {
      return _.every(geoms, function (_ref) {
        var type = _ref.type;
        return type === ChartLibrary.INTERVAL;
      });
    }; // 获取所有rows的数量


    var rowsNum = function rowsNum(geoms, measuresOverlapped) {
      var num = 0;

      _.each(geoms, function (_ref2) {
        var data = _ref2.data;
        return num += data.getRowCount();
      });
      /**
       * 指标聚合下柱形图平行排布，看起来在y方向上只有一个图形，但是实际上是两个，特殊处理！
       * 交互文档Bug——DOCDESIGN-781
       * http://ui.finebi.com:7777/UI/06-%E7%A7%BB%E5%8A%A8%E7%AB%AF/start.html#g=1&p=%E9%80%89%E4%B8%AD%E6%95%88%E6%9E%9C-%E5%AE%9A%E4%BD%8D%E5%BD%A2%E5%BC%8F
       */


      return isAllInterval(geoms) && measuresOverlapped ? num / geoms.length : num;
    }; // @MOBILE-12337 TreeMap WordCloud ForcePoint 需要展示十字线


    var isSpecialChart = function isSpecialChart(geoms) {
      return _.any(geoms, function (_ref3) {
        var type = _ref3.type;
        return type === ChartLibrary.TREE_MAP || type === ChartLibrary.FORCE_POINT || type === ChartLibrary.WORD_CLOUD;
      });
    }; // 是否展示十字线flag


    var shouldShowCrossLine = function shouldShowCrossLine(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          geoms = state.geoms;

      var _diffFacet = diffFacet(facetX, facetY),
          measuresOverlapped = _diffFacet.geomFacet.measuresOverlapped; // 一个分区之内 x、y轴方向上的所有的图形数量


      var geomNum = leafNodesCount(facetX) + leafNodesCount(facetY);
      var showCrossLine = isSpecialChart(geoms) || !(isEmptyFacet(facetX) && isEmptyFacet(facetY)) && // some special, such as bubble
      rowsNum(geoms, measuresOverlapped) > geomNum;
      return _extends({}, state, {
        showCrossLine: showCrossLine
      });
    };

    var createMobileFlagsSelector = function createMobileFlagsSelector() {
      return function (state) {
        var _state = state,
            isMobile = _state.isMobile;

        if (!isMobile) {
          return state;
        }

        state = shouldShowCrossLine(state);
        return state;
      };
    };

    /**
     * dataSelector的主要工作，从原有的state里计算出新的facet, geom, legend并处理数据
     * 对于facet, 计算facet.nodes, measureDomains
     * 对于geom, 计算aesMappingData
     * 对于legend, 计算tags&sliders
     * @returns {Function}
     */

    var createDataSelector = function createDataSelector() {
      return function (state) {
        var dataModelSelector = createDataConversionSelector();
        var facetSelector = createFacetSelector();
        var geomSelector = createGeomSelector();
        var mobileFlagsSelector = createMobileFlagsSelector(); // 从这个返回的是一个new Object，可以直接使用newState[key] = property

        var newState = dataModelSelector(state);
        newState = facetSelector(newState);
        newState = geomSelector(newState);
        newState = setSharedTooltip(newState);
        newState = mobileFlagsSelector(newState);
        return newState;
      };
    };

    var PADDING_TOP_BOTTOM_V = 7;
    var PADDING_RIGHT_LEFT_V = 5;
    var PADDING_RIGHT_LEFT_H = 5;
    var PADDING_TOP_BOTTOM_H = 3;
    var LINE_HEIGHT = 1.5;
    var MAX_PERCENT = 0.3;
    var ICON_SIZE = 10;
    var SLIDER_HEIGHT_WITHOUT_LABEL = 16;
    var SLIDER_ONLY_WIDTH = 150;
    var NORMAL_SLIDER_WIDTH_V = 120;
    var NORMAL_LEGEND_FILL_WIDTH_WHEN_NOT_FULL_H = 30;
    var MIN_SLIDER_WIDTH_H = 150;
    var TITLE_ITEMS_GAP_V = 3;
    var LEGEND_GAP_V = 14; // spaces between legends.

    var LEGEND_GAP_H = 8;
    var ICON_TEXT_GAP_V = 4;
    var ITEM_ITEM_GAP_V = 3;
    var TITLE_ITEMS_GAP_H = 15;
    var ICON_TEXT_GAP_H = 4;
    var ITEM_ITEM_GAP_H = 8;
    var PAGE_BTN_GAP = 7;
    var PAGE_BTN_SIZE = 10;
    var THUMB_WIDTH = 6;

    function getVerticalNormalLegendsDims(legendTags, lineHeight, style) {
      var width = 0,
          height = 0;

      _.each(legendTags, function (normalLegend) {
        height += TITLE_ITEMS_GAP_V + lineHeight;
        var title = normalLegend.title,
            formatDef = normalLegend.format,
            items = normalLegend.items;
        var dims = calcTextDim(title, style);
        width = Math.max(width, dims[0]);

        _.each(items, function (item) {
          var name = item.name;
          var dim = calcTextDim(getFormattedText(name, formatDef), style);
          width = Math.max(width, ICON_SIZE + ICON_TEXT_GAP_V + dim[0]);
          height += lineHeight;
        });
      });

      return [width, height];
    }
    /**
     * 计算竖直布局的图例的尺寸
     * @param legend
     * @param plotBounds
     * @returns {*[]}
     */

    function verticalLegendBounds(legend, plotBounds) {
      var tags = legend.tags,
          sliders = legend.sliders,
          style = legend.style,
          fontSize = legend.style.fontSize;
      var singleHeight = fontSize * LINE_HEIGHT;

      var _getVerticalNormalLeg = getVerticalNormalLegendsDims(tags, singleHeight, style),
          width = _getVerticalNormalLeg[0],
          height = _getVerticalNormalLeg[1];

      height += PADDING_TOP_BOTTOM_V * 2;
      height += LEGEND_GAP_V * (tags.length + sliders.length - 1); // slider legend only, set width to 150px.

      if (tags.length === 0) {
        width = SLIDER_ONLY_WIDTH;
      }

      if (sliders.length) {
        width = Math.max(NORMAL_SLIDER_WIDTH_V, width);
        height += (singleHeight * 2 + SLIDER_HEIGHT_WITHOUT_LABEL + ITEM_ITEM_GAP_V) * sliders.length;
      }

      width += PADDING_RIGHT_LEFT_V * 2 + 2; // border && innerRight&Left padding

      width = Math.min(width, plotBounds.width * MAX_PERCENT);
      height = Math.min(height, plotBounds.height);
      return [width, height];
    }

    var TITLE_MAX_EM = 8;
    /**
     * 计算出最大的图例标题的宽度
     */

    function getMaxLegendTitleWidth(tags, sliders, style) {
      var maxWith = 0;

      _.each([].concat(tags, sliders), function (legendItem) {
        var titleDim = calcTextDim(legendItem.title, style);
        maxWith = Math.max(maxWith, titleDim[0]);
      }); // 最多不超过8个字符宽度


      return clamp(maxWith, 0, TITLE_MAX_EM * style.fontSize);
    }

    /**
     * get rows num of legends and single row width of legend.
     */

    function getHorizontalLegendLayoutInfo(normalLegend, style, maxLabelWidth) {
      var items = normalLegend.items;
      var singleLineWidth = 0;
      var num = 1;
      var isFullFillWidth = false;

      _.some(items, function (item, i) {
        var temp = item.size[0] + (i === 0 ? 0 : ITEM_ITEM_GAP_H);

        if (singleLineWidth + temp > maxLabelWidth) {
          num = 2;
          singleLineWidth = maxLabelWidth;
          isFullFillWidth = true;
          return true;
        }

        singleLineWidth += temp;
      });

      return [num, singleLineWidth + (isFullFillWidth ? 0 : NORMAL_LEGEND_FILL_WIDTH_WHEN_NOT_FULL_H)];
    }
    /**
     * 计算出所有的点击图里中最大的一行，从而判断是否需要翻页按钮
     * @param tags
     */


    var getMaxTotalTagLength = function getMaxTotalTagLength(tags) {
      return _.max(_.map(tags, function (tag) {
        return _.reduce(tag.items, function (size, item, i) {
          return size + item.size[0] + (i === 0 ? 0 : ITEM_ITEM_GAP_H);
        }, 0);
      }));
    };
    /**
     * 计算水平布局的图例的尺寸
     * @param legend
     * @param plotBounds
     * @returns {number[]}
     */


    function horizontalLegendBounds(legend, plotBounds) {
      var tags = legend.tags,
          sliders = legend.sliders,
          style = legend.style,
          fontSize = legend.style.fontSize;
      var singleRowHeight = fontSize * LINE_HEIGHT;
      var maxTitleWidth = getMaxLegendTitleWidth(sliders, tags, style);
      var maxTotalTagLength = getMaxTotalTagLength(tags);
      var occupied = PADDING_RIGHT_LEFT_H * 2 + TITLE_ITEMS_GAP_H + maxTitleWidth; // 是否存在翻页按钮: 最大的点击图例的宽度超过两行

      if (maxTotalTagLength / 2 > plotBounds.width - occupied) {
        occupied += PAGE_BTN_GAP * 2 + PAGE_BTN_SIZE;
      }

      var maxLabelWidth = plotBounds.width - occupied;
      var height = PADDING_TOP_BOTTOM_H * 2;
      var maxItemWidth = 0;
      var needWrap = false;
      var legendTagsGroupNum = tags.length;
      height += (legendTagsGroupNum > 0 ? legendTagsGroupNum - 1 : 0) * LEGEND_GAP_H;

      _.each(tags, function (normalLegend) {
        var _getHorizontalLegendL = getHorizontalLegendLayoutInfo(normalLegend, style, maxLabelWidth),
            lineCount = _getHorizontalLegendL[0],
            itemsWidth = _getHorizontalLegendL[1];

        height += lineCount * singleRowHeight;

        if (lineCount > 1) {
          needWrap = true;
          height += LEGEND_GAP_H; // 两行items之间的间隙
        } else {
          maxItemWidth = Math.max(itemsWidth, maxItemWidth);
        }
      });

      var width = needWrap ? plotBounds.width : Math.min(plotBounds.width, Math.max(maxItemWidth, MIN_SLIDER_WIDTH_H) + occupied);
      height += (singleRowHeight + SLIDER_HEIGHT_WITHOUT_LABEL) * sliders.length;
      var maxHeight = plotBounds.height * MAX_PERCENT;
      height = Math.min(height, maxHeight);
      legend.contentWidth = width - occupied - (height > maxHeight ? THUMB_WIDTH : 0);
      legend.titleWidth = maxTitleWidth;
      return [width, height];
    }

    /**
     * 计算单个点击图例文字大小
     * @param text
     * @param format
     * @param style
     * @returns {*[]}
     */

    var calcItemSize = function calcItemSize(text, format, style) {
      return calcTextDim(getFormattedText(text, format), style);
    };
    /**
     * 计算单个点击图例内的所有文字的尺寸
     * @param items
     * @param format
     * @param style
     */


    var calcSizeWithItems = function calcSizeWithItems(items, format, style) {
      return _.each(items, function (item) {
        var dim = item.textDim = calcItemSize(item.name, format, style);
        item.size = [ICON_SIZE + ICON_TEXT_GAP_H + dim[0], dim[1]];
      });
    };
    /**
     * 计算所有的点击图例的文字尺寸
     * @param tags
     * @param style
     */


    var calcItemSizeWithTags = function calcItemSizeWithTags(tags, style) {
      return _.each(tags, function (tag) {
        return calcSizeWithItems(tag.items, tag.format, style);
      });
    };
    /**
     * calculate legend bounding rect.
     * @param legend
     * @param plotBounds
     */

    function calcLegendBounds(legend, plotBounds) {
      var position = legend.position,
          tags = legend.tags,
          style = legend.style; // 统一计算点击图例的文字尺寸

      calcItemSizeWithTags(tags, style);
      var isHorizontalLayout = position === Direction.TOP || position === Direction.BOTTOM;
      var legendDims = isHorizontalLayout ? horizontalLegendBounds(legend, plotBounds) : verticalLegendBounds(legend, plotBounds);
      var width = legendDims[0],
          height = legendDims[1];

      var legendBounds = _extends({}, plotBounds);

      legendBounds.width = width;
      legendBounds.height = height;

      if (position === Direction.RIGHT) {
        legendBounds.x = plotBounds.width + plotBounds.x - width;
      }

      if (position === Direction.BOTTOM) {
        legendBounds.y = plotBounds.y + plotBounds.height - height;
      }

      return legendBounds; // return padding(legendBounds, BORDER_WIDTH);
    }

    var isEmptyLegend = function isEmptyLegend(legend) {
      return _.isEmpty(legend.tags) && _.isEmpty(legend.sliders);
    };

    function clipLegendBounds(legend, plotBounds) {
      var position = legend.position,
          enabled = legend.enabled;
      var isHorizontalLayout = position === Direction.TOP || position === Direction.BOTTOM;

      if (!enabled || isEmptyLegend(legend)) {
        return;
      }

      var bounds = calcLegendBounds(legend, plotBounds);
      var size = bounds.width;

      if (isHorizontalLayout) {
        size = bounds.height;
      }

      plotBounds.clip(position, size + DEFAULT_PADDING * 2); // set legend bounds info.
      // FIXME don't mutate object

      _.extend(legend, bounds);
    }

    var THROTTLE_TIME = 250;
    var VERTICAL$1 = 'vertical';
    var CURSOR = 'ew-resize';
    var LINE_HEIGHT$1 = 1.5;
    var TOUCH_SIZE_ADD = 10; // LABEL_GAP = FONT_SIZE * (LINE_HEIGHT - 1) / 2,
    // Label's align offset to thumb center
    // i.e. the min gap between two label = 4

    var LABEL_OFFSET = 2;

    var getLabelGap = function getLabelGap(fontSize) {
      return fontSize * (LINE_HEIGHT$1 - 1) / 2;
    };

    var TRACK_FILL = modifyAlpha('#b9bfca', 0.25);
    var THUMB_FILL = '#fff',
        THUMB_SHADOW_COLOR = modifyAlpha('#1f4a8a', 0.2),
        THUMB_SHADOW_BLUR = 4;
    var THUMB_STYLE = {
      // opacity: 0.5,
      fill: THUMB_FILL,
      shadowColor: THUMB_SHADOW_COLOR,
      shadowBlur: THUMB_SHADOW_BLUR
    };
    var ON_THUMB_EXTEND = 2; // on: width + 2

    var MIN_LENGTH = 120;
    var MAX_THUMB_WIDTH = 14 + ON_THUMB_EXTEND; // fullHeight: asym = 18 + 14 + 2
    // fullHeight:  sym = 18 + 12 + 2 + 2(additional gap)
    //                  = 34

    var getFullHeight = function getFullHeight(fontSize) {
      return fontSize * LINE_HEIGHT$1 + MAX_THUMB_WIDTH;
    }; // for slider bar's center y
    // baseline = fullHeight - maxThumbWidth/2 = 34 - 16 / 2
    // const getBaseLine = fontSize => getFullHeight(fontSize) - MAX_THUMB_WIDTH / 2;
    // animation


    var THUMB_TRANSITION = {
      duration: 300,
      ease: Ease.EaseOutBack,
      properties: {
        shape: true
      }
    };
    var LABEL_TRANSITION = {
      duration: 300,
      ease: Ease.EaseOutBack,
      properties: {
        position: true
      }
    };
    var HOVER_HIGHLIGHT_RATIO = 0.57; // TODO, get rid of these mixed logic
    // 1. split h & v
    // 2. use relative position: move down = negative delta

    var BasicSlider =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(BasicSlider, _Component);

      function BasicSlider(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        var tmp = BasicSlider.validFromTo(props);
        _this.state = {
          panning: null,
          on: null,
          length: BasicSlider.getLength(props),
          from: tmp.from,
          to: tmp.to
        };
        _this.lastPos = null;
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.throttledCallback = _.throttle(_this.throttledCallback, THROTTLE_TIME, _assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = BasicSlider.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var tmp = BasicSlider.validFromTo(nextProps);
        this.setState({
          length: BasicSlider.getLength(nextProps),
          from: tmp.from,
          to: tmp.to
        });
      };

      _proto.onFromMouseover = function onFromMouseover()
      /* e */
      {
        this.setState({
          on: 'from'
        });
      };

      _proto.onFromMouseout = function onFromMouseout() {
        this.setState({
          on: null
        });
      };

      _proto.onToMouseover = function onToMouseover() {
        this.setState({
          on: 'to'
        });
      };

      _proto.onToMouseout = function onToMouseout() {
        this.setState({
          on: null
        });
      };

      _proto.onFromPan = function onFromPan(e) {
        this.onThumbPan('from', e);
        return true;
      };

      _proto.onToPan = function onToPan(e) {
        this.onThumbPan('to', e);
        return true;
      };

      _proto.onFromThumbPanEnd = function onFromThumbPanEnd(e) {
        this.onThumbPanEnd('from', e);
        return true;
      };

      _proto.onToThumbPanEnd = function onToThumbPanEnd(e) {
        this.onThumbPanEnd('to', e);
        return true;
      };

      _proto.onSwipe = function onSwipe()
      /* e */
      {
        // cancelBubble
        return true;
      };

      _proto.throttledCallback = function throttledCallback(payload) {
        this.props.handleValueChange(payload);
      };

      _proto.getNextState = function getNextState(side, e) {
        stop$2(e);
        var _this$props = this.props,
            direction = _this$props.direction,
            thumbWidth = _this$props.thumbWidth,
            min = _this$props.min,
            max = _this$props.max;
        var _this$state = this.state,
            from = _this$state.from,
            to = _this$state.to,
            length = _this$state.length;
        var isTranspose = direction === VERTICAL$1;
        var getThumbValueByPos = isTranspose ? BasicSlider.getTransposeThumbValueByPos : BasicSlider.getThumbValueByPos;
        var getThumbPosByValue = isTranspose ? BasicSlider.getTransposeThumbPosByValue : BasicSlider.getThumbPosByValue;
        var validMin = min,
            validMax = max;
        var panning = this.state.panning;
        var nextState = {};
        var d = isTranspose ? e.event.deltaY : e.event.deltaX;

        if (!d) {
          return;
        } // side hasn't determined


        if (!panning) {
          // overlap when start, determine(change) side by d
          if (from === to) {
            if (d < 0) {
              panning = isTranspose ? 'to' : 'from';
            } else {
              panning = isTranspose ? 'from' : 'to';
            }
          } else {
            // default
            panning = side;
          }

          nextState.panning = panning;
        }

        if (panning === 'to') {
          validMin = from;
        } else {
          validMax = to;
        }

        if (this.lastPos == null) {
          this.lastPos = getThumbPosByValue(length, thumbWidth, min, max, this.state[panning]);
        }

        var pos = this.lastPos + d;
        this.lastPos = pos;
        var v = getThumbValueByPos(length, thumbWidth, min, max, pos);
        nextState[panning] = clamp(v, validMin, validMax);
        return nextState;
      };

      _proto.getPayload = function getPayload(nextState) {
        var _ref;

        var props = this.props;
        var state = this.state; // todo
        // 1. set the field key, using title now
        // 2. make it a controlled Comp

        return _ref = {}, _ref[encodeFilterKey(props.fieldIds || [props.fieldId])] = _extends({}, state, nextState), _ref;
      };

      _proto.onThumbPan = function onThumbPan(side, e) {
        var nextState = this.getNextState(side, e);
        this.setState(nextState);

        if (this.props.handleValueChange) {
          var payload = this.getPayload(nextState);
          this.throttledCallback(payload);
        }
      };

      _proto.onThumbPanEnd = function onThumbPanEnd(side, e) {
        var nextState = this.getNextState(side, e);
        this.lastPos = null;
        this.setState(_extends({}, nextState, {
          panning: null
        }));
        var payload = this.getPayload(nextState); // @BI-37844: 在滑动的很快的时候, throttle可能尚未执行, 在panEnd的时候手动更新一下

        if (this.props.handleValueChange) {
          this.throttledCallback.cancel();
          this.props.handleValueChange(payload);
        } // 大数据的时候在slider最后请求结果图片


        if (this.props.handleValueChangeEnd) {
          this.props.handleValueChangeEnd(payload);
        }
      };

      _proto.render = function render$$1() {
        var _this$props2 = this.props,
            touch = _this$props2.touch,
            direction = _this$props2.direction,
            colorStops = _this$props2.colorStops,
            style = _this$props2.style,
            min = _this$props2.min,
            max = _this$props2.max,
            thumbWidth = _this$props2.thumbWidth,
            w1 = _this$props2.w1,
            w2 = _this$props2.w2,
            height = _this$props2.height,
            width = _this$props2.width,
            silent = _this$props2.silent;
        var _this$props3 = this.props,
            x = _this$props3.x,
            y = _this$props3.y;
        var textFill = style.textFill;
        var _this$state2 = this.state,
            from = _this$state2.from,
            to = _this$state2.to,
            panning = _this$state2.panning,
            length = _this$state2.length;
        /**
         * direction relevant
         */

        var pathFill, pathClip, trackShape, thumbPos1, thumbPos2, labelAttr1, labelAttr2;
        var font = makeFont(style);
        var fontSize = style.fontSize;
        var fromText = getFormattedText(from, this.props.format),
            toText = getFormattedText(to, this.props.format);
        var labelGap = getLabelGap(fontSize);
        /**
         * static value
         */

        if (direction === VERTICAL$1) {
          x = width - (thumbWidth + ON_THUMB_EXTEND) / 2;
          trackShape = {
            x1: 0,
            y1: length - MAX_THUMB_WIDTH / 2,
            x2: 0,
            y2: MAX_THUMB_WIDTH / 2,
            w1: w1,
            w2: w2
          };
          pathFill = {
            x: 0,
            y: 1,
            x2: 0,
            y2: 0,
            type: 'linear',
            colorStops: colorStops
          };
        } else {
          // group pos
          // x is original x,
          // y is left/top thumb's center y
          var fullHeight = getFullHeight(fontSize); // offset y to thumb center

          y += fullHeight - MAX_THUMB_WIDTH / 2; // adjust the position to bottom if it's taller

          if (height > fullHeight) {
            y += height - fullHeight;
          }

          trackShape = {
            x1: (thumbWidth + ON_THUMB_EXTEND) / 2,
            y1: 0,
            x2: length - (thumbWidth + ON_THUMB_EXTEND) / 2,
            y2: 0,
            w1: w1,
            w2: w2
          };
          pathFill = {
            type: 'linear',
            colorStops: colorStops
          };
        }
        /**
         * dynamic value
         */
        // interaction related
        // panning = turn on


        var on = panning || this.state.on;
        var r1, r2;
        r1 = r2 = thumbWidth / 2;
        var isOnFrom = on === 'from',
            isOnTo = on === 'to';

        if (isOnFrom) {
          r1 += ON_THUMB_EXTEND / 2;
        } else if (isOnTo) {
          r2 += ON_THUMB_EXTEND / 2;
        }

        var getThumbPosByValue = direction === VERTICAL$1 ? BasicSlider.getTransposeThumbPosByValue : BasicSlider.getThumbPosByValue; // dynamic value

        var pos1 = getThumbPosByValue(length, thumbWidth, min, max, from);
        var pos2 = getThumbPosByValue(length, thumbWidth, min, max, to);

        if (direction === VERTICAL$1) {
          pathClip = {
            type: 'rect',
            shape: {
              x: -MAX_THUMB_WIDTH / 2,
              y: pos2,
              width: MAX_THUMB_WIDTH,
              // any value covers the whole height
              height: pos1 - pos2
            }
          };
          var textHeight = getLineHeight(font); // Though it returns `left` pos,
          // we can recognize it as top.
          // If we pos it at top.

          var tmp = BasicSlider.adjustTwoLabels(length, pos2, pos1, textHeight, textHeight);
          thumbPos1 = [0, pos1];
          thumbPos2 = [0, pos2]; // pos.x is right side
          // offset label right side to negative value

          labelAttr2 = {
            position: [-(labelGap + r1), 0],
            x: 0,
            y: tmp.left1,
            textAlign: 'right',
            textVerticalAlign: 'top'
          };
          labelAttr1 = {
            position: [-(labelGap + r2), 0],
            x: 0,
            y: tmp.left2,
            textAlign: 'right',
            textVerticalAlign: 'top'
          };
        } else {
          pathClip = {
            type: 'rect',
            shape: {
              x: pos1,
              y: -MAX_THUMB_WIDTH / 2,
              width: pos2 - pos1,
              height: MAX_THUMB_WIDTH // any value covers the whole height

            }
          };

          var _tmp = BasicSlider.adjustTwoLabels(length, pos1, pos2, getWidth(fromText, font), getWidth(toText, font));

          thumbPos1 = [pos1, 0];
          thumbPos2 = [pos2, 0];
          labelAttr1 = {
            position: [0, -(labelGap + r1)],
            x: _tmp.left1,
            y: 0,
            textAlign: 'left',
            textVerticalAlign: 'bottom'
          };
          labelAttr2 = {
            position: [0, -(labelGap + r2)],
            x: _tmp.left2,
            y: 0,
            textAlign: 'left',
            textVerticalAlign: 'bottom'
          };
        }

        return h('group', {
          position: [x, y],
          onswipe: this.onSwipe
        }, // track
        h('varLine', {
          silent: true,
          shape: trackShape,
          style: {
            fill: TRACK_FILL
          }
        }), // path
        h('varLine', {
          silent: true,
          shape: trackShape,
          style: {
            fill: pathFill
          },
          clip: pathClip
        }), // thumb from
        h('circle', {
          silent: true,
          position: thumbPos1,
          shape: {
            r: r1
          },
          style: THUMB_STYLE,
          transition: THUMB_TRANSITION
        }), h('circle', {
          invisible: true,
          position: thumbPos1,
          cursor: CURSOR,
          silent: silent,
          shape: {
            r: r1 + (touch ? TOUCH_SIZE_ADD : 0)
          },
          style: THUMB_STYLE,
          onmouseover: this.onFromMouseover,
          onmouseout: this.onFromMouseout,
          onpanstart: this.onFromPan,
          onpan: this.onFromPan,
          onpanend: this.onFromThumbPanEnd
        }), // thumb to
        h('circle', {
          silent: true,
          position: thumbPos2,
          shape: {
            r: r2
          },
          style: THUMB_STYLE,
          transition: THUMB_TRANSITION
        }), h('circle', {
          invisible: true,
          silent: silent,
          position: thumbPos2,
          cursor: CURSOR,
          shape: {
            r: r2 + (touch ? TOUCH_SIZE_ADD : 0)
          },
          style: THUMB_STYLE,
          onmouseover: this.onToMouseover,
          onmouseout: this.onToMouseout,
          onpanstart: this.onToPan,
          onpan: this.onToPan,
          onpanend: this.onToThumbPanEnd
        }), // label from
        h('text', {
          silent: true,
          position: labelAttr1.position,
          transition: LABEL_TRANSITION,
          style: _extends({}, style, {
            x: labelAttr1.x,
            y: labelAttr1.y,
            text: fromText,
            textFill: isOnFrom ? textFill : mixColorWithHSB(textFill, 0, 0, HOVER_HIGHLIGHT_RATIO),
            textAlign: labelAttr1.textAlign,
            textVerticalAlign: labelAttr1.textVerticalAlign
          })
        }), // label to
        h('text', {
          silent: true,
          position: labelAttr2.position,
          transition: LABEL_TRANSITION,
          style: _extends({}, style, {
            x: labelAttr2.x,
            y: labelAttr2.y,
            text: toText,
            textFill: isOnTo ? textFill : mixColorWithHSB(textFill, 0, 0, HOVER_HIGHLIGHT_RATIO),
            textAlign: labelAttr2.textAlign,
            textVerticalAlign: labelAttr2.textVerticalAlign
          })
        }));
      };

      return BasicSlider;
    }(Component);
    BasicSlider.getHeight = getFullHeight;

    BasicSlider.getLength = function (_ref2) {
      var direction = _ref2.direction,
          width = _ref2.width,
          height = _ref2.height;

      if (direction === VERTICAL$1) {
        return height;
      } else {
        return clamp(width, MIN_LENGTH);
      }
    };
    /**
     * from to value validation
     * @param from
     * @param to
     * @param min
     * @param max
     * @returns {{from: (number), to: (number)}}
     */


    BasicSlider.validFromTo = function (_ref3) {
      var from = _ref3.from,
          to = _ref3.to,
          min = _ref3.min,
          max = _ref3.max;

      if (!between(from, min, max)) {
        from = min;
      }

      if (!between(to, min, max)) {
        to = max;
      }

      return {
        from: from,
        to: to
      };
    };
    /**
     * calculate value's pos
     * @param length
     * @param thumbWidth
     * @param min
     * @param max
     * @param v
     * @returns {number}
     */


    BasicSlider.getThumbPosByValue = function (length, thumbWidth, min, max, v) {
      v = clamp(v, min, max);
      var end1 = (thumbWidth + ON_THUMB_EXTEND) / 2,
          end2 = length - end1;
      return end1 + (end2 - end1) * percent(v, min, max);
    };

    BasicSlider.getTransposeThumbPosByValue = function (length, thumbWidth, min, max, v) {
      v = clamp(v, min, max);
      var end = (thumbWidth + ON_THUMB_EXTEND) / 2,
          start = length - end;
      return start - (start - end) * percent(v, min, max);
    };
    /**
     * get value in that position
     * @param length
     * @param thumbWidth
     * @param min
     * @param max
     * @param pos
     * @returns {number}
     */


    BasicSlider.getThumbValueByPos = function (length, thumbWidth, min, max, pos) {
      var end1 = (thumbWidth + ON_THUMB_EXTEND) / 2,
          end2 = length - end1;
      pos = clamp(pos, end1, end2); // BI-39027 min max的小数位数很多，极值位置计算精度有问题

      if (pos === end2) {
        return max;
      } else if (pos === end1) {
        return min;
      }

      var unit = accDiv(accAdd(max, -min), 100);
      var pct = accDiv(pos - end1, end2 - end1) * 100 | 0;
      return accAdd(min, accMul(unit, pct)); // return min + (max - min) * percent(pos, end1, end2);
    };
    /**
     * get value in that position while maximum correspond to minimum pos.
     */


    BasicSlider.getTransposeThumbValueByPos = function (length, thumbWidth, min, max, pos) {
      return BasicSlider.getThumbValueByPos(length, thumbWidth, max, min, pos);
    };
    /**
     * handle two labels conflict
     * @param length
     * @param pos1
     * @param pos2
     * @param textWidth1
     * @param textWidth2
     * @returns {{left1: number, left2: number}}
     */


    BasicSlider.adjustTwoLabels = function (length, pos1, pos2, textWidth1, textWidth2) {
      var left1 = pos1 - LABEL_OFFSET - textWidth1,
          left2 = pos2 + LABEL_OFFSET;

      if (left1 < 0) {
        left1 = 0;
      }

      if (left2 + textWidth2 > length) {
        left2 = length - textWidth2;
      } // overlap


      var d = left2 - (left1 + textWidth1) - 2 * LABEL_OFFSET; // min gap = 2 * offset

      if (d < 0) {
        var adjustment = -d;
        var isLeftExceed = left1 - adjustment < 0,
            isRightExceed = left2 + textWidth2 + adjustment > length;

        if (isLeftExceed && isRightExceed) {
          left1 = 0;
          left2 = length - textWidth2;
        } else {
          if (isLeftExceed) {
            left2 += adjustment;
          }

          if (isRightExceed) {
            left1 -= adjustment;
          } // todo, any other case?

        }
      }

      return {
        left1: left1,
        left2: left2
      };
    };

    var SYM_TRACK_W = 6,
        SYM_THUMB_WIDTH = 12;

    var SymmetricSlider = function SymmetricSlider(props) {
      return h(BasicSlider, _extends({
        w1: SYM_TRACK_W,
        w2: SYM_TRACK_W,
        thumbWidth: SYM_THUMB_WIDTH
      }, props));
    };

    assign(SymmetricSlider, BasicSlider);
    SymmetricSlider.propTypes = null;

    /**
     * Created by Jeffrey on 2017/11/13.
     */
    var d = {
      LINE_HEIGHT: 1.5
    };
    d.TEXT_PANDDING_RATIO = (d.LINE_HEIGHT - 1) / 2;

    var BTN_COLOR = '#647185';
    var BTN_COLOR_FAINT = '#d0d4da';
    var BTN_WIDTH = 10;
    var PIXEL_STEP$1 = 10;

    var PageArea =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(PageArea, _Component);

      function PageArea(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.state = {
          offsetX: 0,
          // wrapper offsetX, <= 0
          offsetY: 0 // wrapper offsetY, <= 0,

        };
        _this.onMousewheel = _this.onMousewheel.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.onUpperClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)), -1);
        _this.onDownerClick = _this.onClick.bind(_assertThisInitialized(_assertThisInitialized(_this)), 1);
        return _this;
      }

      var _proto = PageArea.prototype;

      _proto.shouldScroll = function shouldScroll() {
        return this.props.realHeight > this.props.height;
      };

      _proto.onMousewheel = function onMousewheel(e) {
        stop(e.event);
        var d = e.wheelDelta * PIXEL_STEP$1;
        this.setState({
          offsetY: P.limitOffset(this.props.height, this.props.realHeight, this.state.offsetY + d)
        });
      };

      _proto.onClick = function onClick(d) {
        var props = this.props;
        var height = props.height,
            realHeight = props.realHeight;
        this.setState({
          offsetY: P.limitOffset(height, realHeight, P.getOffsetByCurrent(height, realHeight, P.getCurrentByOffset(height, realHeight, this.state.offsetY) + d))
        });
      };

      _proto.render = function render$$1() {
        var props = this.props;
        var state = this.state;
        var width = props.width,
            height = props.height;
        var realWidth = props.realWidth,
            realHeight = props.realHeight;
        var areaSize = {
          x: 0,
          y: 0,
          width: width,
          height: height
        };
        var background = h('rect', {
          cursor: null,
          shape: areaSize,
          style: {
            fill: 'transparent',
            stroke: this.props.borderColor
          }
        }); // give a simple group if no pagination

        if (!this.shouldScroll()) {
          return h('group', {
            position: [props.x, props.y]
          }, background, props.children);
        }

        var current = P.getCurrentByOffset(height, realHeight, state.offsetY);
        var pageNum = P.getPageNum(height, realHeight); // move wrapper to scroll

        var wrapper = h('group', {
          position: [state.offsetX, state.offsetY]
        }, props.children);
        return h('group', {
          position: [props.x, props.y],
          clip: {
            type: 'rect',
            shape: areaSize
          }
        }, background, // main area
        wrapper, // page btn
        // upper
        h('polygon', {
          rectHover: true,
          cursor: current === 1 ? null : 'pointer',
          shape: {
            points: [[width - BTN_WIDTH, height / 2 - 2], [width, height / 2 - 2], [width - BTN_WIDTH / 2, height / 2 - 8]]
          },
          style: {
            fill: current === 1 ? BTN_COLOR_FAINT : BTN_COLOR
          },
          onclick: this.onUpperClick
        }), // downer
        h('polygon', {
          rectHover: true,
          cursor: current === pageNum ? null : 'pointer',
          shape: {
            points: [[width - BTN_WIDTH, height / 2 + 2], [width, height / 2 + 2], [width - BTN_WIDTH / 2, height / 2 + 8]]
          },
          style: {
            fill: current === pageNum ? BTN_COLOR_FAINT : BTN_COLOR
          },
          onclick: this.onDownerClick
        }));
      };

      return PageArea;
    }(Component);

    var P = PageArea;
    P.BTN_WIDTH = BTN_WIDTH;
    /**
     * page total number
     * @param length
     * @param realLength
     * @returns {number}
     */

    P.getPageNum = function (length, realLength) {
      return Math.ceil(realLength / length);
    };
    /**
     * last page may have blank
     * @param length
     * @param pageNum
     * @returns {number}
     * @constructor
     */


    P.RoundRealLength = function (length, pageNum) {
      return pageNum * length;
    };
    /**
     * get inner offset by current page no.
     * @param length
     * @param realLength
     * @param current
     * @returns {number}
     */


    P.getOffsetByCurrent = function (length, realLength, current) {
      var pageNum = P.getPageNum(length, realLength);
      return (length - P.RoundRealLength(length, pageNum)) / (pageNum - 1) * (current - 1);
    };
    /**
     * get current page no. by inner offset
     * @param length
     * @param realLength
     * @param offset
     * @returns {number}
     */


    P.getCurrentByOffset = function (length, realLength, offset) {
      var pageNum = P.getPageNum(length, realLength);
      return Math.round((pageNum - 1) * offset / (length - P.RoundRealLength(length, pageNum)) + 1);
    };

    P.limitOffset = function (length, realLength, offset) {
      var pageNum = P.getPageNum(length, realLength);
      return clamp(offset, length - P.RoundRealLength(length, pageNum), 0);
    };

    var getSliderHeight = SymmetricSlider.getHeight;
    var SLIDER_MIN_WIDTH = 150;
    var SLIDER_WIDTH_RATIO = 0.3; // 0.3 legend width

    var LINE_HEIGHT$2 = d.LINE_HEIGHT;
    var TITLE_LEFT = 5;
    var CONTENT_LEFT = 15,
        CONTENT_RIGHT = 7,
        CONTENT_GAP_V = 8;
    var TAG_GAP_H = 8;
    var PAGE_BTN_WIDTH = P.BTN_WIDTH;
    function horizontalLegendPosition(legend) {
      var tags = legend.tags,
          sliders = legend.sliders,
          fontSize = legend.style.fontSize,
          width = legend.width,
          visibleWidth = legend.contentWidth,
          maxTitleWidth = legend.titleWidth;
      var newTagArr = [],
          newSliderArr = []; // calculate tags layout

      var lineHeight = fontSize * LINE_HEIGHT$2; // vertical offset

      var lineOffsets = [],
          acc = PADDING_TOP_BOTTOM_H;

      var tagsLayout = _.map(tags, function (g) {
        var widths = _.map(g.items, function (t) {
          return t.size[0];
        });

        return floatLayout(visibleWidth, widths, TAG_GAP_H);
      });

      _.each(tagsLayout, function (layout) {
        var rows = layout.rows;
        lineOffsets.push(acc); // todo, 0?

        acc += clamp(rows.length, 0, 2) * lineHeight + (rows.length > 1 ? CONTENT_GAP_V : 0);
      });

      _.each(sliders, function (slider) {
        lineOffsets.push(acc);
        slider.height = Math.max(getSliderHeight(fontSize), lineHeight);
        acc += slider.height;
      });

      acc += PADDING_TOP_BOTTOM_H;

      _.each(lineOffsets, function (height, i) {
        var titleRight = TITLE_LEFT + maxTitleWidth;

        if (i < tags.length) {
          var newTag = _extends({}, tags[i]);

          var rows = tagsLayout[i].rows;
          var lineNum = rows.length;
          newTag.rows = rows;
          newTag.titlePos = height;
          newTag.iconsGroupBounds = {
            x: titleRight + CONTENT_LEFT,
            y: height,
            width: visibleWidth + CONTENT_RIGHT + PAGE_BTN_WIDTH,
            height: clamp(lineNum, 0, 2) * lineHeight,
            realHeight: lineNum * lineHeight
          };
          newTagArr.push(newTag);
        } else {
          var newSlider = _extends({}, sliders[i - tags.length]);

          newSlider.titlePos = height;
          newSlider.iconsGroupBounds = {
            x: titleRight + CONTENT_LEFT,
            y: height,
            width: Math.max(SLIDER_MIN_WIDTH, width * SLIDER_WIDTH_RATIO)
          };
          newSliderArr.push(newSlider);
        }
      }); // 高度超过legend最大高度，滚动条底部与最后一个item加一个间距


      if (legend.height < acc) {
        acc += CONTENT_GAP_V;
      } // FIXME don't mutate object


      _.extend(legend, {
        tags: newTagArr,
        sliders: newSliderArr,
        // for render
        titleRight: TITLE_LEFT + maxTitleWidth,
        legendAreaHeight: acc,
        maxTitleWidth: maxTitleWidth
      });
    }
    /**
     * Put items within an area, like css float: left;
     * @param {Number} areaWidth - visible area width
     * @param {Array}  widths    - items widths
     * @param {Number} gap       - gap between items
     * @returns {Object}
     * returns example
     * {
     *   lineWidths: [..., ..., ...], // line widths array
     *   rows: [
     *     // [offset, truncateWidth]
     *
     *     // row 0
     *     [[0,0],[202,0],[260,0],[318,0],[376,0],[434,0],[492,0],[550,0]],
     *     // row 1
     *     [[0,0],[58,0],[128,0],[186,0],[244,0],[302,0],[360,0],[418,0],[476,0],[534,0]],
     *   ]
     * }
     */

    function floatLayout(areaWidth, widths, gap) {
      if (gap === void 0) {
        gap = 0;
      }

      function newline() {
        ++row;
        rows[row] = [];
        lineWidths[row] = -gap;
        offset = 0;
      }

      function move(w) {
        offset += w;
        lineWidths[row] += w;
      }

      function record(w, truncateWidth) {
        rows[row].push([offset, truncateWidth || w]);
        move(w + gap);
      }

      var row = -1,
          offset = 0;
      var lineWidths = [];
      var rows = [];
      newline(); // simple sum

      if (!areaWidth || areaWidth === Infinity) {
        _.map(widths, function (w) {
          return record(w);
        });
      } else {
        _.map(widths, function (w) {
          // 1. too long, truncate
          if (w > areaWidth) {
            if (offset > 0) {
              // discard this line
              newline();
            }

            record(areaWidth, areaWidth);
          } // 2. normal occupy
          else if (areaWidth - offset >= w) {
              record(w);
            } // 3. newline
            else if (areaWidth - offset < w) {
                newline();
                record(w);
              }
        });
      }

      return {
        lineWidths: lineWidths,
        rows: rows
      };
    }

    var getSliderHeight$1 = SymmetricSlider.getHeight;
    var LINE_HEIGHT$3 = d.LINE_HEIGHT;
    var PADDING_TOP = 7,
        PADDING_BOTTOM = PADDING_TOP,
        PADDING_LEFT = 5,
        PADDING_RIGHT = PADDING_LEFT; // ...content | padding | scrollbar |

    var TITLE_PADDING_BOTTOM = 3;
    var PADDING_H = PADDING_LEFT + PADDING_RIGHT;
    function verticalLegendPosition(legend) {
      var style = legend.style,
          fontSize = legend.style.fontSize,
          sliders = legend.sliders,
          tags = legend.tags,
          width = legend.width,
          height = legend.height;
      var lineHeight = fontSize * LINE_HEIGHT$3;
      var availableHeight = getAvailableHeight(height, fontSize, tags, sliders, style);
      var heights = calculateHeights(availableHeight, lineHeight, _.map(tags, function (tag) {
        return tag.items.length;
      }));
      var acc = 0;
      var newTagArrs = [];
      var newSliderArrs = [];

      var moveDown = function moveDown(px) {
        return acc += px;
      };

      _.each(tags, function (tag) {
        var newTag = _extends({}, tag);

        moveDown(PADDING_TOP); // title

        newTag.titlePos = acc;
        moveDown(lineHeight + TITLE_PADDING_BOTTOM); // iconTag group

        newTag.iconsGroupBounds = {
          x: PADDING_LEFT,
          y: acc,
          width: width - PADDING_LEFT,
          height: heights[0]
        };
        moveDown(heights.shift());
        moveDown(PADDING_BOTTOM);
        newTagArrs.push(newTag);
      });

      _.each(sliders, function (slider) {
        var newSlider = _extends({}, slider);

        moveDown(PADDING_TOP); // title

        newSlider.titlePos = acc;
        moveDown(lineHeight + TITLE_PADDING_BOTTOM);
        newSlider.iconsGroupBounds = {
          x: PADDING_LEFT,
          y: acc,
          width: width - PADDING_H
        };
        moveDown(getSliderHeight$1(fontSize));
        moveDown(PADDING_BOTTOM);
        newSliderArrs.push(newSlider);
      }); // FIXME don't mutate object


      _.extend(legend, {
        tags: newTagArrs,
        sliders: newSliderArrs
      });
    }
    function getAvailableHeight(height, titleFontSize, tags, sliders, style) {
      var total = tags.length + sliders.length;
      var titles = (titleFontSize * LINE_HEIGHT$3 + TITLE_PADDING_BOTTOM) * total;
      var paddings = PADDING_TOP * 2 * total;
      return height - titles - paddings - sum(_.map(sliders, function (s) {
        // todo, slider height depends on whole slider props
        return getSliderHeight$1(style.fontSize);
      }));
    }
    /**
     * auto adjust height for each iconTags
     * 只计算iconTag本身，不包含title、gap
     * @param {Number} availableHeight
     * @param {Number} lineHeight
     * @param {Array} itemsNums - array contains each group's item number, e.g. [2, 3]
     * @returns {Array} height array
     */

    function calculateHeights(availableHeight, lineHeight, itemsNums) {
      var mutableGroups = _.map(itemsNums, function (n, i) {
        return {
          i: i,
          height: n * lineHeight
        };
      });

      function calc(H, stableGroups, mutableGroups) {
        var n = mutableGroups.length;
        var h = H / n;

        if (n === 0) {
          return stableGroups;
        } else {
          var isEveryExcceed = true,
              isEverySparsed = true; // 是否每个都 超过/不足 剩余平均高度

          _.each(mutableGroups, function (g) {
            if (g.height <= h) {
              isEveryExcceed = false;
            } else {
              isEverySparsed = false;
            }
          }); // 每个都超过，则平均分配


          if (isEveryExcceed) {
            return stableGroups.concat(_.map(mutableGroups, function (g) {
              g.height = h;
              return g;
            }));
          } // 每个都不足，则只分配各自高度
          else if (isEverySparsed) {
              return stableGroups.concat(mutableGroups);
            }
        } // 给小于平均高度的分配高度，并计算剩余高度


        var nextH = H;
        var i = -1;

        while (++i < mutableGroups.length) {
          var g = mutableGroups[i];

          if (g.height <= h) {
            stableGroups.push(mutableGroups.splice(i, 1)[0]);
            nextH -= g.height;
            --i;
          }
        }

        return calc(nextH, stableGroups, mutableGroups);
      }

      var stableGroups = calc(availableHeight, [], mutableGroups);
      var heights = [];

      _.map(stableGroups, function (g) {
        heights[g.i] = g.height;
      });

      return heights;
    }

    function calcLegendPosition(legend) {
      var position = legend.position;
      var isHorizontalLayout = position === Direction.TOP || position === Direction.BOTTOM;
      isHorizontalLayout ? horizontalLegendPosition(legend) : verticalLegendPosition(legend);
    }

    var legendLayout = function legendLayout(state) {
      var plotBounds = state.plotBounds,
          legend = state.legend;
      clipLegendBounds(legend, plotBounds);
      calcLegendPosition(legend);
    };

    /**
     * 复杂的形状路径工厂
     */
    var collection = {}; // Trend

    collection[SymbolConstants.TREND_1] = 'M511.957333 64C759.381333 64 960 264.576 960 512S759.381333 960 512 960C264.533333 960 64 759.424 64 512S264.576 64 512 64z m180.906667 537.386667c10.965333-10.88 10.069333-29.354667-1.792-41.258667-11.946667-11.904-29.866667-12.245333-40.832-1.28-0.853333 0.853333-1.664 1.408-2.346667 2.432l-105.472 104.96-0.341333-405.717333c0-14.506667-13.653333-26.154667-30.464-26.154667-16.896 0-29.824 11.648-29.824 26.154667 0 1.109333-0.128 2.133333 0 3.285333l-0.256 402.432-105.344-104.96c-0.768-1.024-1.664-1.578667-2.432-2.432-10.922667-10.965333-28.842667-10.624-40.832 1.28-11.904 11.904-12.672 30.421333-1.834667 41.258667l154.666667 155.093333a29.269333 29.269333 0 0 0 25.216 13.397333c0.341333 0.042667 0.64 0.213333 0.981333 0.213334 0.298667 0 0.512-0.170667 0.768-0.170667a26.325333 26.325333 0 0 0 10.666667-1.877333 29.013333 29.013333 0 0 0 14.677333-11.434667l154.794667-155.221333z';
    collection[SymbolConstants.TREND_2] = 'M512 960C264.533333 960 64 759.424 64 512S264.533333 64 512 64c247.424 0 448 200.576 448 448S759.424 960 512 960z m180.864-537.386667L538.026667 267.392a28.842667 28.842667 0 0 0-14.592-11.477333 26.666667 26.666667 0 0 0-10.752-1.834667c-0.256 0-0.426667-0.213333-0.682667-0.213333-0.426667 0-0.64 0.213333-1.024 0.256a29.269333 29.269333 0 0 0-25.216 13.354666L331.093333 422.656c-10.88 10.88-10.112 29.354667 1.792 41.258667 11.946667 11.904 29.952 12.245333 40.832 1.28 0.853333-0.853333 1.706667-1.408 2.432-2.432l105.344-104.96 0.256 402.432c-0.128 1.152 0 2.176 0 3.242666 0 14.549333 12.928 26.197333 29.824 26.197334 16.810667 0 30.506667-11.648 30.506667-26.197334l0.256-405.674666 105.472 104.96c0.725333 1.024 1.536 1.578667 2.432 2.432 10.88 10.965333 28.885333 10.624 40.789333-1.28 11.818667-11.904 12.714667-30.421333 1.792-41.258667z';
    collection[SymbolConstants.TREND_3] = 'M590.677333 953.728l270.933334-358.4a20.48 20.48 0 0 0 0-18.858667c-3.072-6.272-9.301333-9.429333-15.616-6.272l-180.565334 72.277334C634.24 202.410667 422.442667 111.232 192 64c267.818667 169.813333 305.194667 298.666667 298.965333 578.517333l-180.608-72.32c-6.272 0-12.501333 0-15.573333 6.229334-3.157333 3.157333-3.157333 6.357333-3.157333 9.429333 0 3.2 0 6.357333 3.157333 9.472l270.933333 358.4c3.114667 3.114667 9.386667 6.272 12.501334 6.272 3.072 0 9.301333-3.114667 12.458666-6.272';
    collection[SymbolConstants.TREND_4] = 'M578.261333 64c-3.157333 0-9.386667 3.114667-12.458666 6.272l-271.018667 358.4c-3.157333 3.2-3.157333 6.272-3.157333 9.472 0 3.114667 0 6.272 3.157333 9.386667 3.157333 6.272 9.344 6.272 15.573333 6.272l180.693334-72.277334c6.144 279.765333-31.232 408.661333-299.050667 578.474667 230.485333-47.146667 442.325333-138.368 473.386667-578.517333l180.736 72.32c6.186667 3.157333 12.416 0 15.573333-6.229334a20.138667 20.138667 0 0 0 0-18.901333l-271.061333-358.4c-3.072-3.157333-9.258667-6.272-12.373334-6.272';
    collection[SymbolConstants.TREND_5] = 'M952.32 592.64h-147.626667l4.48 32h136.106667c-49.92 193.365333-225.28 335.36-433.28 335.36-208.64 0-383.36-141.994667-433.194667-335.36h394.154667l35.84-32H71.68A420.096 420.096 0 0 1 64 512c0-56.32 10.24-110.72 30.08-160l196.48 179.84L423.68 413.44l158.08 159.36-112 106.88 315.52 53.12-37.077333-317.44-110.762667 104.96L426.88 307.2l-135.68 121.6L129.28 279.68A446.250667 446.250667 0 0 1 512 64c247.04 0 448 200.96 448 448 0 27.52-2.56 54.4-7.68 80.64';
    collection[SymbolConstants.TREND_6] = 'M952.32 431.36h-147.626667l4.48-32h136.106667C895.36 206.037333 720 64 512 64c-208.64 0-383.36 142.037333-433.194667 335.36h394.154667l35.84 32H71.68A420.096 420.096 0 0 0 64 512c0 56.32 10.24 110.72 30.08 160l196.48-179.84 133.12 118.4 158.08-159.36L469.76 344.32l315.52-53.12-37.077333 317.44-110.762667-104.96-210.56 213.12-135.68-121.6-161.92 149.12A446.250667 446.250667 0 0 0 512 960c247.04 0 448-200.96 448-448 0-27.52-2.56-54.4-7.68-80.64';
    collection[SymbolConstants.TREND_7] = 'M127.274667 256L64 319.36l332.16 332.16 179.2-179.157333 218.624 218.368L691.2 793.6h268.8v-268.885333l-102.784 102.869333L575.36 345.6l-179.2 179.114667L127.402667 256z';
    collection[SymbolConstants.TREND_8] = 'M691.242667 256l102.826666 97.962667-218.709333 207.914666-179.2-170.624L64 707.584 127.36 768l268.8-256.042667 179.2 170.666667 281.856-268.586667L960 512V256z'; // Determine

    collection[SymbolConstants.DET_1] = 'M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zM512 128c-211.754667 0-384 172.245333-384 384s172.245333 384 384 384 384-172.245333 384-384-172.245333-384-384-384z m-18.986667 495.786667a37.205333 37.205333 0 0 1-22.997333-7.893334l-93.098667-72.917333a37.333333 37.333333 0 0 1 45.994667-58.794667l65.408 51.114667 107.648-122.453333a37.333333 37.333333 0 1 1 56.064 49.322666l-130.944 148.992a37.205333 37.205333 0 0 1-28.074667 12.672z';
    collection[SymbolConstants.DET_2] = 'M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zM512 128c-211.754667 0-384 172.245333-384 384s172.245333 384 384 384 384-172.245333 384-384-172.245333-384-384-384z m-128 419.2a35.2 35.2 0 0 1 0-70.4h256a35.2 35.2 0 0 1 0 70.4H384z';
    collection[SymbolConstants.DET_3] = 'M835.84 931.84H188.16a96 96 0 0 1-96-96V188.16a96 96 0 0 1 96-96h647.68a96 96 0 0 1 96 96v647.68a96 96 0 0 1-96 96z m0-64a32 32 0 0 0 32-32V188.16a32 32 0 0 0-32-32H188.16a32 32 0 0 0-32 32v647.68c0 17.706667 14.293333 32 32 32h647.68zM726.101333 363.093333a32 32 0 0 1 0 45.226667l-252.245333 252.330667c-0.128 0.042667-0.128 0.170667-0.170667 0.256a32 32 0 0 1-45.226666 0l-130.389334-130.304a31.914667 31.914667 0 0 1 0-45.226667 31.914667 31.914667 0 0 1 45.226667 0l107.648 107.605333 229.888-229.888a32 32 0 0 1 45.226667 0z';
    collection[SymbolConstants.DET_4] = 'M835.84 931.84H188.16a96 96 0 0 1-96-96V188.16a96 96 0 0 1 96-96h647.68a96 96 0 0 1 96 96v647.68a96 96 0 0 1-96 96z m0-64a32 32 0 0 0 32-32V188.16a32 32 0 0 0-32-32H188.16a32 32 0 0 0-32 32v647.68c0 17.706667 14.293333 32 32 32h647.68zM557.312 512l103.552 103.594667a32 32 0 0 1-45.226667 45.226666L512 557.354667l-103.552 103.552a32 32 0 0 1-45.226667-45.226667l103.509334-103.68-103.552-103.509333a31.914667 31.914667 0 0 1 0-45.226667 31.914667 31.914667 0 0 1 45.226666 0l103.594667 103.509333 103.552-103.552a32 32 0 0 1 45.226667 45.226667L557.269333 512z';
    collection[SymbolConstants.DET_5] = 'M960 512c0 247.424-200.576 448-448 448S64 759.424 64 512 264.576 64 512 64 960 264.576 960 512z m-204.544-129.365333l-67.925333-67.925334-259.712 259.797334-115.968-115.925334-67.84 67.84 115.925333 115.968-0.725333 0.725334 67.84 67.882666 0.768-0.768 0.725333 0.768 67.882667-67.882666-0.768-0.725334 259.797333-259.754666z';
    collection[SymbolConstants.DET_6] = 'M960 512c0 247.424-200.576 448-448 448S64 759.424 64 512 264.576 64 512 64 960 264.576 960 512z m-249.856-129.365333l-67.925333-67.925334L512 445.013333 381.738667 314.709333l-67.84 67.925334 130.261333 130.218666-130.261333 130.261334 67.84 67.882666L512 580.778667l130.218667 130.218666 67.925333-67.882666-130.261333-130.261334 130.261333-130.218666z'; // Light

    collection[SymbolConstants.LIGHT_1] = 'M730.752 784h-448v-269.568a210.986667 210.986667 0 0 1 210.432-210.432h27.221333a210.986667 210.986667 0 0 1 210.346667 210.432v269.568z m-353.28-170.666667h256a21.333333 21.333333 0 1 0 0-42.666666h-256a21.333333 21.333333 0 1 0 0 42.666666z m399.018667 314.453334H232.533333a48.128 48.128 0 0 1-48-48c0-26.453333 21.632-48 48-48H776.533333c26.368 0 48 21.546667 48 48s-21.632 48-48 48zM506.752 224a25.6 25.6 0 0 1-25.557333-25.6V89.6a25.6 25.6 0 0 1 51.157333 0v108.8a25.6 25.6 0 0 1-25.6 25.6zM215.893333 469.888a25.6 25.6 0 0 1-32.853333 15.274667L80.896 448a25.6 25.6 0 1 1 17.493333-48.128l102.272 37.162667a25.6 25.6 0 0 1 15.232 32.853333z m587.221334 0a25.685333 25.685333 0 0 1 15.317333-32.853333l102.186667-37.162667a25.685333 25.685333 0 0 1 32.853333 15.274667 25.728 25.728 0 0 1-15.317333 32.853333l-102.186667 37.162667a25.685333 25.685333 0 0 1-32.853333-15.274667zM314.624 286.250667a25.770667 25.770667 0 0 1-35.712-6.272l-62.336-89.173334a25.685333 25.685333 0 0 1 6.229333-35.626666 25.770667 25.770667 0 0 1 35.712 6.272l62.378667 89.173333a25.685333 25.685333 0 0 1-6.272 35.626667z m389.632 0a25.685333 25.685333 0 0 1-6.272-35.626667l62.378667-89.173333a25.770667 25.770667 0 0 1 35.712-6.272 25.685333 25.685333 0 0 1 6.229333 35.669333l-62.336 89.173333a25.770667 25.770667 0 0 1-35.712 6.229334z';
    collection[SymbolConstants.LIGHT_2] = 'M730.794667 784h-448v-269.568a210.986667 210.986667 0 0 1 210.432-210.432h27.136a210.986667 210.986667 0 0 1 210.432 210.432v269.568z m-146.56-224a78.933333 78.933333 0 1 1-157.866667 0 78.933333 78.933333 0 0 1 157.866667 0z m34.133333 0a113.066667 113.066667 0 1 0-226.133333 0 113.066667 113.066667 0 0 0 226.133333 0z m158.122667 367.786667H232.490667a48.128 48.128 0 0 1-48-48c0-26.453333 21.632-48 48-48h544c26.453333 0 48 21.546667 48 48s-21.589333 48-48 48zM506.794667 224c-14.08 0-25.6-11.52-25.6-25.6V89.6c0-14.08 11.52-25.6 25.6-25.6 14.08 0 25.6 11.52 25.6 25.6v108.8c0 14.08-11.52 25.6-25.6 25.6zM215.893333 469.888a25.642667 25.642667 0 0 1-32.853333 15.274667L80.896 448a25.642667 25.642667 0 0 1-15.36-32.853333 25.728 25.728 0 0 1 32.853333-15.274667l102.272 37.162667a25.6 25.6 0 0 1 15.274667 32.853333z m587.221334 0a25.685333 25.685333 0 0 1 15.274666-32.853333l102.272-37.162667a25.685333 25.685333 0 0 1 32.853334 15.274667 25.728 25.728 0 0 1-15.36 32.853333l-102.229334 37.162667a25.685333 25.685333 0 0 1-32.853333-15.274667zM314.581333 286.250667a25.685333 25.685333 0 0 1-35.626666-6.272l-62.421334-89.173334a25.685333 25.685333 0 0 1 6.272-35.626666 25.685333 25.685333 0 0 1 35.669334 6.272l62.464 89.173333a25.642667 25.642667 0 0 1-6.357334 35.626667z m389.717334 0a25.642667 25.642667 0 0 1-6.357334-35.626667l62.464-89.173333a25.685333 25.685333 0 0 1 35.669334-6.272c11.52 8.064 14.336 24.149333 6.272 35.669333l-62.421334 89.173333a25.685333 25.685333 0 0 1-35.626666 6.229334z';
    collection[SymbolConstants.LIGHT_3] = 'M730.752 784h-448v-269.568a210.986667 210.986667 0 0 1 210.432-210.432h27.221333a210.986667 210.986667 0 0 1 210.346667 210.432v269.568z m-310.656-116.010667a25.6 25.6 0 0 0 32 40.021334l128-102.4a25.6 25.6 0 0 0-6.528-43.776L486.4 526.933333l93.696-74.922666a25.6 25.6 0 0 0-32-40.021334l-128 102.4a25.6 25.6 0 0 0 6.528 43.776l87.210667 34.901334-93.696 74.922666z m356.394667 259.797334H232.533333c-26.453333 0-48-21.589333-48-48 0-26.453333 21.589333-48 48-48H776.533333c26.368 0 48 21.546667 48 48s-21.632 48-48 48zM506.752 224a25.6 25.6 0 0 1-25.514667-25.6V89.6a25.6 25.6 0 0 1 51.114667 0v108.8a25.6 25.6 0 0 1-25.6 25.6zM215.893333 469.888a25.6 25.6 0 0 1-32.853333 15.274667L80.896 448a25.6 25.6 0 1 1 17.493333-48.128l102.272 37.162667a25.6 25.6 0 0 1 15.232 32.853333z m587.221334 0a25.728 25.728 0 0 1 15.232-32.853333l102.272-37.162667a25.685333 25.685333 0 0 1 32.853333 15.274667 25.728 25.728 0 0 1-15.36 32.853333l-102.144 37.162667a25.685333 25.685333 0 0 1-32.853333-15.274667zM314.581333 286.250667a25.685333 25.685333 0 0 1-35.669333-6.272l-62.293333-89.173334a25.685333 25.685333 0 0 1 6.186666-35.626666 25.770667 25.770667 0 0 1 35.712 6.272l62.378667 89.173333a25.642667 25.642667 0 0 1-6.314667 35.626667z m389.674667 0a25.685333 25.685333 0 0 1-6.272-35.626667l62.378667-89.173333a25.770667 25.770667 0 0 1 35.712-6.272 25.685333 25.685333 0 0 1 6.229333 35.669333l-62.336 89.173333a25.770667 25.770667 0 0 1-35.712 6.229334z';
    collection[SymbolConstants.LIGHT_4] = 'M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zM512 128c-211.754667 0-384 172.245333-384 384s172.245333 384 384 384 384-172.245333 384-384-172.245333-384-384-384zM418.005333 418.986667c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0z m317.994667 0c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0z m-62.122667 163.370666a32 32 0 1 1 60.586667 20.48c-29.952 88.832-119.978667 149.76-222.464 149.76-101.888 0-191.616-60.288-222.08-148.394666a32 32 0 0 1 60.501333-20.906667c21.333333 61.610667 86.272 105.301333 161.578667 105.301333 75.690667 0 140.885333-44.117333 161.877333-106.24z';
    collection[SymbolConstants.LIGHT_5] = 'M533.333333 85.333333C780.757333 85.333333 981.333333 285.909333 981.333333 533.333333S780.757333 981.333333 533.333333 981.333333 85.333333 780.757333 85.333333 533.333333 285.909333 85.333333 533.333333 85.333333z m0 64c-211.754667 0-384 172.245333-384 384s172.245333 384 384 384 384-172.245333 384-384-172.245333-384-384-384z m-93.994666 290.986667c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0z m317.994666 0c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0z m-1.493333 291.370667a32 32 0 1 1-60.629333 20.48c-20.992-62.08-86.186667-106.24-161.877334-106.24-75.264 0-140.288 43.690667-161.578666 105.301333a32 32 0 0 1-60.458667-20.906667c30.421333-88.064 120.149333-148.394667 222.037333-148.394666 102.4 0 192.512 61.013333 222.506667 149.76z';
    collection[SymbolConstants.LIGHT_6] = 'M512 64c247.424 0 448 200.576 448 448S759.424 960 512 960 64 759.424 64 512 264.576 64 512 64zM512 128c-211.754667 0-384 172.245333-384 384s172.245333 384 384 384 384-172.245333 384-384-172.245333-384-384-384zM418.005333 418.986667c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0z m317.994667 0c0 35.413333-28.586667 64-64 64s-64-28.586667-64-64a64 64 0 1 1 128 0zM288 704a32 32 0 1 1 0-64h448a32 32 0 1 1 0 64H288z';
    collection[SymbolConstants.MAP] = 'M642.730667 894.634667h-37.888a6.144 6.144 0 0 0-6.144 6.144v18.773333a6.144 6.144 0 0 0 6.144 6.144h2.048l37.546666-12.629333a6.144 6.144 0 0 0 4.096-5.802667v-6.144a6.144 6.144 0 0 0-6.144-6.144zM989.866667 235.861333a16.042667 16.042667 0 0 0 0-6.144 16.384 16.384 0 0 0-16.384-16.384h-34.133334a16.384 16.384 0 0 1-11.605333-4.778666L853.333333 136.533333a16.384 16.384 0 0 0-11.605333-4.778666h-4.096l-49.493333 12.288a16.384 16.384 0 0 0-11.264 10.24l-38.229334 92.842666a16.042667 16.042667 0 0 0 0 6.485334 16.384 16.384 0 0 0 10.922667 15.36 16.384 16.384 0 0 1 3.413333 29.354666L572.074667 409.6a16.042667 16.042667 0 0 1-8.533334 2.389333h-5.12l-139.264-46.421333a16.384 16.384 0 0 1-7.168-4.778667L337.92 300.373333a16.384 16.384 0 0 1-6.144-10.922666l-11.605333-58.026667a16.384 16.384 0 0 0-16.042667-12.970667h-5.12L175.445333 260.778667a16.384 16.384 0 0 0-10.581333 12.288l-11.946667 46.421333a16.384 16.384 0 0 1-13.653333 12.288l-91.136 12.970667a16.384 16.384 0 0 0-13.994667 16.042666v31.744a16.384 16.384 0 0 0 1.706667 7.509334l29.696 59.392a16.042667 16.042667 0 0 1 1.706667 7.168H68.266667v71.68a16.384 16.384 0 0 0 5.461333 12.288l122.88 107.52a16.042667 16.042667 0 0 0 8.192 4.096h73.728a16.042667 16.042667 0 0 1 9.216 2.730666l39.936 26.624a16.042667 16.042667 0 0 0 8.874667 2.730667H341.333333l55.296-11.605333h3.072a16.384 16.384 0 0 1 16.384 16.384v39.936a16.384 16.384 0 0 1-4.778666 11.605333 16.384 16.384 0 0 0 0 21.845333l49.834666 62.122667a16.384 16.384 0 0 0 18.773334 4.778667l64.853333-25.941334a16.042667 16.042667 0 0 1 6.144 0 16.384 16.384 0 0 1 7.509333 1.706667l86.016 43.008a16.384 16.384 0 0 0 13.994667 0l136.533333-61.098667a16.384 16.384 0 0 0 8.533334-9.216l60.074666-119.466666a16.042667 16.042667 0 0 0 1.706667-7.168 16.384 16.384 0 0 0 0-5.802667l-44.714667-119.466667a16.042667 16.042667 0 0 1 0-5.802666 16.384 16.384 0 0 1 1.706667-7.509334l8.192-16.384a16.042667 16.042667 0 0 0 0-7.168 16.384 16.384 0 0 0-4.778667-11.605333l-28.330666-28.330667a16.384 16.384 0 0 1 0-24.576l40.277333-30.037333a16.384 16.384 0 0 1 21.162667 0l11.605333 11.605333a16.384 16.384 0 0 0 22.869333 0l79.530667-77.824a16.384 16.384 0 0 0 3.072-18.773333l-8.192-16.042667a16.042667 16.042667 0 0 1-1.706667-7.168 16.384 16.384 0 0 1 0-6.144z m-174.08 608.597334a8.533333 8.533333 0 0 0-4.778667-4.437334h-3.754667l-34.133333 15.701334a5.461333 5.461333 0 0 0-3.072 4.096 8.533333 8.533333 0 0 0 0 3.754666l3.072 6.826667a7.509333 7.509333 0 0 0 6.826667 4.778667h40.618666c4.096 0 6.485333-5.12 4.437334-9.898667z';
    function getAbstractShapePath(shape) {
      return collection[shape];
    }

    var DEFAULT_SIZE$1 = 512;

    var calcScale = function calcScale(radius, _ref) {
      var sx = _ref[0],
          sy = _ref[1];
      var ratio = radius / DEFAULT_SIZE$1;
      return [ratio * sx, ratio * sy];
    };

    function renderMarker(_ref2) {
      var symbol = _ref2.symbol,
          radius = _ref2.radius,
          _ref2$x = _ref2.x,
          x = _ref2$x === void 0 ? 0 : _ref2$x,
          _ref2$y = _ref2.y,
          y = _ref2$y === void 0 ? 0 : _ref2$y,
          color = _ref2.color,
          shadowColor = _ref2.shadowColor,
          _ref2$shadowBlur = _ref2.shadowBlur,
          shadowBlur = _ref2$shadowBlur === void 0 ? 0 : _ref2$shadowBlur,
          _ref2$opacity = _ref2.opacity,
          opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity,
          _ref2$lineWidth = _ref2.lineWidth,
          lineWidth = _ref2$lineWidth === void 0 ? 1 : _ref2$lineWidth,
          pos = _ref2.pos,
          stroke = _ref2.stroke,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? [1, 1] : _ref2$scale,
          blend = _ref2.blend,
          _ref2$invisible = _ref2.invisible,
          invisible = _ref2$invisible === void 0 ? false : _ref2$invisible,
          rest = _objectWithoutPropertiesLoose(_ref2, ["symbol", "radius", "x", "y", "color", "shadowColor", "shadowBlur", "opacity", "lineWidth", "pos", "stroke", "scale", "blend", "invisible"]);

      // symbol = symbol || "map_point";
      // 抽象形状不考虑描边什么的
      var style = {
        fill: color,
        opacity: opacity,
        shadowColor: shadowColor,
        shadowBlur: shadowBlur,
        stroke: stroke,
        lineWidth: lineWidth,
        blend: blend,
        strokeNoScale: true
      };

      var props = _extends({
        pos: pos || [x, y],
        invisible: invisible
      }, rest);

      return isBasicShape(symbol) ? renderBasicShape(_extends({}, props, {
        color: color,
        radius: radius,
        symbol: symbol,
        scale: scale,
        style: style,
        position: [x, y]
      })) : h('path', _extends({}, props, {
        shape: {
          str: getAbstractShapePath(symbol)
        },
        position: [x - radius, y - radius],
        scale: calcScale(radius, scale),
        style: style,
        translate: [-radius, -radius]
      }));
    }

    var ICON_SIZE$1 = 10;
    var ICON_RADIUS = ICON_SIZE$1 / 2;
    var ICON_TEXT_GAP = 4;
    var DISABLED_COLOR = '#C4C9D1'; // pre-calculated

    var TEXT_OFFSET_X = ICON_SIZE$1 + ICON_TEXT_GAP;

    var IconTag =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(IconTag, _Component);

      function IconTag(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.state = {
          over: false
        };
        _this.onclick = _this.onclick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = IconTag.prototype;

      _proto.onclick = function onclick() {
        var _this$props = this.props,
            fieldIds = _this$props.fieldIds,
            _name = _this$props.name,
            startValue = _this$props.from,
            nextValue = _this$props.to,
            maximum = _this$props.maximum;
        var name = _name; // step legend 最大值+1，filter判断就可以使用[a, b)这样的前闭后开区间了

        if (name.indexOf('~') > -1 && nextValue === maximum) {
          name = startValue + "~" + (maximum + 1);
        }

        this.props.handleClick && this.props.handleClick({
          field: filter(fieldIds, function (id) {
            return id != null;
          }).join(SEPARATOR),
          name: name
        });
      };

      _proto.render = function render$$1() {
        var _this$props2 = this.props,
            on = _this$props2.on,
            radius = _this$props2.radius,
            _this$props2$zlevel = _this$props2.zlevel,
            zlevel = _this$props2$zlevel === void 0 ? 0 : _this$props2$zlevel,
            _this$props2$icon = _this$props2.icon,
            icon = _this$props2$icon === void 0 ? 'rect' : _this$props2$icon,
            position = _this$props2.position,
            color = _this$props2.color,
            text = _this$props2.text,
            fontSize = _this$props2.fontSize,
            fontStyle = _this$props2.fontStyle,
            fontWeight = _this$props2.fontWeight,
            fontFamily = _this$props2.fontFamily,
            textFill = _this$props2.textFill,
            width = _this$props2.width,
            silent = _this$props2.silent,
            _this$props2$valid = _this$props2.valid,
            valid = _this$props2$valid === void 0 ? true : _this$props2$valid;
        var iconRadius = radius || ICON_RADIUS;
        return h('group', {
          position: position,
          silent: silent,
          onclick: this.onclick,
          ontap: this.onclick
        }, // FIXME tag搞得太复杂了
        // 也要重构一波……
        // rect的text位置有点迷，需要花时间整理下用法
        // for event area
        h('rect', {
          invisible: true,
          // style: {
          //     fill: 'red'
          // },
          shape: {
            // expand for touch
            y: -ICON_TEXT_GAP / 2,
            width: width + ICON_TEXT_GAP,
            height: fontSize * d.LINE_HEIGHT + ICON_TEXT_GAP
          }
        }), renderMarker({
          symbol: icon,
          radius: iconRadius,
          color: valid ? color : DISABLED_COLOR,
          x: ICON_SIZE$1 / 2,
          y: fontSize * d.LINE_HEIGHT / 2,
          zlevel: zlevel,
          circumscribed: false
        }), h('text', {
          zlevel: zlevel,
          position: [TEXT_OFFSET_X, 0],
          style: {
            opacity: on ? 1 : 0.5,
            text: text,
            fontStyle: fontStyle,
            fontWeight: fontWeight,
            fontSize: fontSize,
            fontFamily: fontFamily,
            textFill: valid ? textFill : DISABLED_COLOR,
            textPadding: [fontSize * d.TEXT_PANDDING_RATIO, 0],
            textAlign: 'left',
            textVerticalAlign: 'top',
            truncate: width ? {
              outerWidth: getTruncateOuterWidth(width - TEXT_OFFSET_X)
            } : null
          }
        }));
      };

      return IconTag;
    }(Component);

    IconTag.ICON_SIZE = ICON_SIZE$1;
    IconTag.ICON_TEXT_GAP = ICON_TEXT_GAP;
    IconTag.TEXT_OFFSET_X = TEXT_OFFSET_X;

    var PADDING_V = [7, 5];
    var PADDING_H$1 = [5, 3];
    var LINE_HEIGHT$4 = 1.5;
    var LEGEND_GAP_H$1 = 8;
    var SLIDER_HEIGHT_WITHOUT_LABEL$1 = 16;
    var TITLE_LEFT$1 = 5;
    var CONTENT_LEFT$1 = 15,
        CONTENT_RIGHT$1 = 7,
        CONTENT_GAP_V$1 = 8;
    var TAG_GAP_H$1 = 8;
    var PAGE_BTN_WIDTH$1 = 28;
    var ICON_TAG_TEXT_OFFSET_X = IconTag.TEXT_OFFSET_X;

    var isHorizontal = function isHorizontal(position) {
      return position === Direction.TOP || position === Direction.BOTTOM;
    };

    var isEmptyLegend$1 = function isEmptyLegend(legend) {
      return _.isEmpty(legend.tags) && _.isEmpty(legend.sliders);
    }; // ---- horizontal


    var getTagsHeight = function getTagsHeight(lineHeight, n) {
      return Math.max(0, n * (lineHeight + LEGEND_GAP_H$1) - LEGEND_GAP_H$1);
    };

    var getSlidersHeight = function getSlidersHeight(lineHeight, n) {
      return Math.max(0, n * (lineHeight + SLIDER_HEIGHT_WITHOUT_LABEL$1));
    };

    var _getWholeHorizontalHeight = function _getWholeHorizontalHeight(tags, sliders, lineHeight) {
      var tagsHeight = getTagsHeight(lineHeight, tags.length);
      var slidersHeight = getSlidersHeight(lineHeight, sliders.length);
      var height = tagsHeight + slidersHeight;

      if (tagsHeight && slidersHeight) {
        height += LEGEND_GAP_H$1;
      }

      return height;
    };

    var getHorizontalHeight = function getHorizontalHeight(_ref) {
      var tags = _ref.tags,
          sliders = _ref.sliders,
          style = _ref.style;
      var fontSize = style.fontSize;
      var lineHeight = fontSize * LINE_HEIGHT$4;

      var height = _getWholeHorizontalHeight(tags, sliders, lineHeight); // max height: 3 lines


      return Math.min(height, getTagsHeight(lineHeight, 3));
    };

    var calcHorizontalPosition = function calcHorizontalPosition(_ref2) {
      var tags = _ref2.tags,
          sliders = _ref2.sliders,
          style = _ref2.style,
          width = _ref2.width;
      var font = makeFont(style);
      var fontSize = style.fontSize;
      var lineHeight = fontSize * LINE_HEIGHT$4; // todo, inaccurate

      if (_getWholeHorizontalHeight(tags, sliders, lineHeight) - getTagsHeight(lineHeight, 3) > 1) {
        width -= PAGE_BTN_WIDTH$1;
      }

      var newTagArr = [],
          newSliderArr = []; // get titles width

      var maxTitleWidth = getMaxLegendTitleWidth(tags, sliders, style); // content visible width

      var visibleWidth = width - // title
      TITLE_LEFT$1 - maxTitleWidth - // content
      CONTENT_LEFT$1 - CONTENT_RIGHT$1; // calculate tags layout

      var tagsLayout = _.map(tags, function (g) {
        var widths = _.map(g.items, function (t) {
          return getWidth(getFormattedText(t.name, g.format), font) + ICON_TAG_TEXT_OFFSET_X;
        });

        return floatLayout(null, widths, TAG_GAP_H$1);
      }); // vertical offset


      var tagsLineOffsets = [],
          slidersLineOffsets = [],
          acc = 0; // tags only single line in mobile

      _.each(tagsLayout, function () {
        tagsLineOffsets.push(acc);
        acc += lineHeight + CONTENT_GAP_V$1;
      });

      _.each(sliders, function (slider) {
        slidersLineOffsets.push(acc);
        slider.height = lineHeight + SLIDER_HEIGHT_WITHOUT_LABEL$1;
        acc += slider.height;
      });

      var titleRight = TITLE_LEFT$1 + maxTitleWidth;

      _.each(tagsLineOffsets, function (height, i) {
        var newTag = _extends({}, tags[i]);

        var rows = tagsLayout[i].rows;
        newTag.titlePos = height;
        newTag.rows = rows;
        newTag.groupHeight = tagsLayout[i].lineWidths[0];
        newTag.iconsGroupBounds = {
          x: titleRight + CONTENT_LEFT$1,
          y: height,
          width: visibleWidth,
          height: lineHeight + CONTENT_GAP_V$1 - 1,
          realWidth: tagsLayout[i].lineWidths[0]
        };
        newTag.realWidth = tagsLayout[i].lineWidths[0];
        newTagArr.push(newTag);
      });

      _.each(slidersLineOffsets, function (height, i) {
        var newSlider = _extends({}, sliders[i]);

        newSlider.titlePos = height;
        newSlider.iconsGroupBounds = {
          x: titleRight + CONTENT_LEFT$1,
          y: height,
          width: visibleWidth
        };
        newSliderArr.push(newSlider);
      });

      return {
        tags: newTagArr,
        sliders: newSliderArr,
        legendAreaHeight: acc,
        maxTitleWidth: maxTitleWidth
      };
    }; // ---- vertical


    var getVerticalWidth = function getVerticalWidth(_ref3) {
      var tags = _ref3.tags,
          sliders = _ref3.sliders,
          style = _ref3.style;
      var fontSize = style.fontSize;
      var lineHeight = fontSize * LINE_HEIGHT$4;

      var _getVerticalNormalLeg = getVerticalNormalLegendsDims(tags, lineHeight, style),
          tagWidth = _getVerticalNormalLeg[0];

      var sliderWidth = 0;
      sliders.forEach(function (_ref4) {
        var title = _ref4.title,
            min = _ref4.min,
            max = _ref4.max,
            format = _ref4.format;

        var _calcTextDim = calcTextDim(getFormattedText(min, format), style),
            minValueWidth = _calcTextDim[0];

        var _calcTextDim2 = calcTextDim(getFormattedText(max, format), style),
            maxValueWidth = _calcTextDim2[0];

        var _calcTextDim3 = calcTextDim(title, style),
            titleWidth = _calcTextDim3[0];

        var valueWidth = Math.max(minValueWidth, maxValueWidth) + SLIDER_HEIGHT_WITHOUT_LABEL$1;
        sliderWidth = Math.max(sliderWidth, valueWidth, titleWidth);
      });
      return Math.max(tagWidth, sliderWidth);
    }; // --------------------------------------------------------------


    var getSize$1 = function getSize(_ref5) {
      var tags = _ref5.tags,
          sliders = _ref5.sliders,
          style = _ref5.style,
          position = _ref5.position,
          plotBounds = _ref5.plotBounds;

      if (isHorizontal(position)) {
        return {
          width: plotBounds.width - DEFAULT_PADDING * 2,
          height: getHorizontalHeight({
            tags: tags,
            sliders: sliders,
            style: style
          }) + PADDING_H$1[0] * 2
        };
      } else {
        return {
          width: getVerticalWidth({
            tags: tags,
            sliders: sliders,
            style: style
          }) + PADDING_V[1] * 2,
          height: plotBounds.height
        };
      }
    };

    var getTranslation = function getTranslation(plotBounds, bounds, position) {
      if (position === Direction.BOTTOM) {
        return {
          x: plotBounds.x,
          y: plotBounds.y + plotBounds.height - bounds.height
        };
      } else if (position === Direction.RIGHT) {
        return {
          x: plotBounds.x + plotBounds.width - bounds.width,
          y: plotBounds.y
        };
      }
    };

    var calcInnerPosition = function calcInnerPosition(_ref6) {
      var tags = _ref6.tags,
          sliders = _ref6.sliders,
          style = _ref6.style,
          position = _ref6.position,
          width = _ref6.width,
          height = _ref6.height;

      if (isHorizontal(position)) {
        return calcHorizontalPosition({
          tags: tags,
          sliders: sliders,
          style: style,
          width: width
        });
      } else {
        return {};
      }
    }; // Calculate values.
    // Mutate state.legend & state.plotBounds.


    var mobileLegendLayout = function mobileLegendLayout(_ref7) {
      var legend = _ref7.legend,
          plotBounds = _ref7.plotBounds,
          orientation = _ref7.orientation;
      var enabled = legend.enabled,
          tags = legend.tags,
          sliders = legend.sliders,
          style = legend.style;

      if (!enabled || isEmptyLegend$1(legend)) {
        return;
      } // according to orientation


      var position = orientation === 'portrait' ? Direction.BOTTOM : Direction.RIGHT;

      var _getSize = getSize$1({
        tags: tags,
        sliders: sliders,
        style: style,
        position: position,
        plotBounds: plotBounds
      }),
          width = _getSize.width,
          height = _getSize.height;

      var _getTranslation = getTranslation(plotBounds, {
        width: width,
        height: height
      }, position),
          x = _getTranslation.x,
          y = _getTranslation.y;

      var innerPosition = calcInnerPosition({
        tags: tags,
        sliders: sliders,
        style: style,
        position: position,
        width: width,
        height: height
      }); // mutation

      var space = isHorizontal(position) ? height : width;
      plotBounds.clip(position, space + DEFAULT_PADDING * 2);
      assign(legend, innerPosition, {
        position: position,
        x: x,
        y: y,
        width: width,
        height: height
      });
    };

    function onlyOneCell(state) {
      var facetXNodesMap = state.facetX.nodesMap,
          facetYNodesMap = state.facetY.nodesMap;
      var xLeafCount = facetXNodesMap[NODE_ROOT].leafCount,
          yLeafCount = facetYNodesMap[NODE_ROOT].leafCount;
      return xLeafCount === 1 && yLeafCount === 1;
    }

    function getMaxSizeOfDimensionContent(defs, facet) {
      var dIds = facet.dimensions,
          nodesMap = facet.nodesMap,
          horizontal = facet.horizontal;
      var dimLen = dIds.length;

      if (dimLen === 0) {
        return 0;
      }

      var def = defs[dIds[dIds.length - 1]];
      var formatDef = def.format,
          _def$tick = def.tick,
          rotation = _def$tick.rotation,
          fontSize = _def$tick.style.fontSize,
          style = _def$tick.style;
      var maxSize = DEFAULT_PADDING * 2 + fontSize * MAX_TICK_COUNT;
      var labelString = '';

      _.each(nodesMap, function (node) {
        var id = node.id,
            path = node.path,
            text = node.text;

        if (id !== NODE_ROOT && path.length === dimLen) {
          var content = getFormattedText(text, formatDef);
          labelString = labelString.length > content.length ? labelString : content;
        }
      });

      var labelDims = calcTextDim(labelString, style, rotation);
      return Math.min(maxSize, (horizontal ? labelDims[0] : labelDims[1]) + DEFAULT_PADDING * 2);
    }

    function hasOnlyOnePointInCell(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          geoms = state.geoms;
      var dims = [].concat(facetX.dimensions, facetY.dimensions);
      var facetData = new Frame();

      _.each(dims, function (fieldId) {
        _.some(geoms, function (geom) {
          var data = geom.data;

          if (data.contains(fieldId)) {
            facetData.addCol(data.getFieldById(fieldId), data.getColById(fieldId));
            return true;
          }
        });
      });

      var frameMap = Frame.groupToMap(facetData, dims);
      var result = true;

      _.some(frameMap, function (frame) {
        if (frame.getRowCount() > 1) {
          result = false;
          return true;
        }
      });

      return result;
    }

    function isGeomWithSinglePointInCell(state, geomType) {
      var geoms = state.geoms;
      var result = false;

      if (geoms.length === 1) {
        var type = geoms[0].type;
        result = geomType === type && hasOnlyOnePointInCell(state);
      }

      return result;
    }

    var _RULE_ONE_GEOM_TYPES, _RULE_TWO_GEOM_TYPE_U;
    var MAP_MIN_UNIT = 300;
    var RULE_ONE_UNIT = 100;
    var RULE_TWO_UNIT = 180;
    var RULE_THREE_UNIT = 300;
    var RULE_ONE_GEOM_TYPES = (_RULE_ONE_GEOM_TYPES = {}, _RULE_ONE_GEOM_TYPES[ChartLibrary.INTERVAL] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.POINT] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.TEXT] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.SQUARE] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.LINE] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.AREA] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.PIE] = 1, _RULE_ONE_GEOM_TYPES[ChartLibrary.FUNNEL] = 1, _RULE_ONE_GEOM_TYPES);
    var RULE_TWO_GEOM_TYPE_UNIT_MAP = (_RULE_TWO_GEOM_TYPE_U = {}, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.TREE_MAP] = RULE_TWO_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.PIE] = RULE_TWO_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.WORD_CLOUD] = RULE_TWO_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.FORCE_POINT] = RULE_TWO_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.MULTI_PIE] = RULE_TWO_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.POINTER_GAUGE] = RULE_THREE_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.THERMOMETER_GAUGE] = RULE_THREE_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.RING_GAUGE] = RULE_THREE_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.SLOT_GAUGE] = RULE_THREE_UNIT, _RULE_TWO_GEOM_TYPE_U[ChartLibrary.LINE_RADAR] = RULE_THREE_UNIT, _RULE_TWO_GEOM_TYPE_U);

    /**
     * http://ui.finebi.com/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E8%A7%84%E5%88%99
     * 图形显示规则1, 当前轴为空且零一轴上有指标时, 当前轴宽度为固定值100px, 不自适应
     * @param state
     * @param facet
     * @param otherFacet
     * @returns {*}
     */

    function fitFacetWithRuleOne(state, facet, otherFacet) {
      var unit;

      if (facet.hasDimension || !otherFacet.hasMeasure) {
        return;
      }

      var geoms = state.geoms;

      var onlyRuleOneGeom = _.every(geoms, function (g) {
        return RULE_ONE_GEOM_TYPES[g.type];
      });

      var forcePointWidthSinglePointInCell = isGeomWithSinglePointInCell(state, ChartLibrary.FORCE_POINT);

      if (onlyRuleOneGeom || forcePointWidthSinglePointInCell) {
        unit = RULE_ONE_UNIT;
      }

      return unit;
    }

    function fitFacetWithRuleTwo(state, facet, totalSize) {
      var geoms = state.geoms,
          defs = state.defs;
      var nodesMap = facet.nodesMap;
      var unit;
      var geomType = geoms[0].type;

      if (geoms.length && RULE_TWO_GEOM_TYPE_UNIT_MAP[geomType]) {
        var leafCount = nodesMap[NODE_ROOT].leafCount;
        var maxDimLabelSize = getMaxSizeOfDimensionContent(defs, facet);

        if (isGeomWithSinglePointInCell(state, ChartLibrary.FORCE_POINT)) {
          unit = maxDimLabelSize;
        } else {
          var minSize = Math.max(RULE_TWO_GEOM_TYPE_UNIT_MAP[geomType], maxDimLabelSize);
          var leafNodeSize = totalSize / leafCount;
          unit = Math.max(leafNodeSize, minSize);
        }
      }

      return unit;
    }

    function getMaxWordSize(geom, horizontal) {
      var dataModel = geom.data,
          text = geom.rich;
      var size = 0;
      dataModel.each(function (row) {
        var _formatText = formatText(text, row),
            data = _formatText.data;

        var _calcParagraphSize = calcParagraphSize(data),
            width = _calcParagraphSize[0],
            height = _calcParagraphSize[1];

        size = Math.max(size, horizontal ? width : height);
      });
      return size;
    }

    function getMaxPointSize(geom) {
      var data = geom.data;
      var sizeCol = data.getColById(AesTypes.SIZE);
      return Math.max.apply(Math, sizeCol) * 2 || 0;
    }

    var needFitWhenSingleWordCloudOrForcePoint = function needFitWhenSingleWordCloudOrForcePoint(state, facet, otherFacet) {
      if (facet.hasMeasure || otherFacet.hasMeasure) {
        return false;
      }

      return isGeomWithOnlySinglePointInCell(state, ChartLibrary.WORD_CLOUD) || isGeomWithOnlySinglePointInCell(state, ChartLibrary.FORCE_POINT);
    };

    var isGeomWithOnlySinglePointInCell = function isGeomWithOnlySinglePointInCell(state, geomType) {
      var geoms = state.geoms;
      var result = false;

      if (geoms.length === 1) {
        var type = geoms[0].type;
        result = geomType === type && hasOnlyOnePointInCell(state);
      }

      return result;
    };

    var getSingleWordCloudOrForcePointUnit = function getSingleWordCloudOrForcePointUnit(defs, geoms, facet, averageSize) {
      var horizontal = facet.horizontal;
      var geom = geoms[0];
      var type = geom.type;
      var maxSize = type === ChartLibrary.WORD_CLOUD ? getMaxWordSize(geom, horizontal) : getMaxPointSize(geom);
      maxSize += DEFAULT_PADDING * 2;
      return isEmptyFacet(facet) ? Math.max(maxSize, RULE_ONE_UNIT) : Math.max(Math.max(maxSize, getMaxSizeOfDimensionContent(defs, facet)), averageSize);
    };
    /**
     * 是否通过视觉规则1或者视觉规则2来设置facet.unit
     * http://47.104.151.0:8011/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E8%A7%84%E5%88%99
     */


    var getFacetUnitUnderRule = function getFacetUnitUnderRule(state, facet, otherFacet, totalSize) {
      return fitFacetWithRuleOne(state, facet, otherFacet) || fitFacetWithRuleTwo(state, facet, totalSize);
    };
    /**
     * http://47.104.151.0:8011/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E6%A0%87%E5%87%86%E9%80%82%E5%BA%94
     */


    function fitFacet(state, facet, otherFacet, totalSize) {
      var enableMap = state.enableMap,
          defs = state.defs,
          geoms = state.geoms;
      var nodesMap = facet.nodesMap,
          hasMeasure = facet.hasMeasure,
          base = facet.base;
      var unit;
      var leafCount = nodesMap[NODE_ROOT].leafCount,
          averageSize = totalSize / leafCount; // 标准视图下地图最小是300px

      if (enableMap && !onlyOneCell(state)) {
        unit = Math.max(MAP_MIN_UNIT, totalSize / leafCount);
      } // Rule 3 : 横纵轴都无字段时，100%大小
      else if (isEmptyFacet(facet) && isEmptyFacet(otherFacet)) {
          unit = totalSize;
        } // forcePoint wordCloud 根据文字尺寸适应
        else if (needFitWhenSingleWordCloudOrForcePoint(state, facet, otherFacet)) {
            unit = getSingleWordCloudOrForcePointUnit(defs, geoms, facet, averageSize);
          } // 图形规则1&2
          else {
              // 有指标时100%宽度
              if (hasMeasure) {
                var valueCount = base ? hasMeasure : 1;
                var valueSize = Math.max(90, totalSize / leafCount / valueCount);
                unit = valueSize * valueCount;
              } else {
                unit = getFacetUnitUnderRule(state, facet, otherFacet, totalSize);

                if (!unit) {
                  // 有留白时填充满
                  unit = Math.max(getMaxSizeOfDimensionContent(defs, facet), averageSize);
                }
              }
            }

      return unit;
    }

    function fitChart(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          plotBounds = state.plotBounds,
          zoom = state.zoom,
          width = plotBounds.width,
          height = plotBounds.height,
          x = zoom.x,
          y = zoom.y; // todo, zoom 被map zoom覆盖了→_→

      dealFacetFit(state, facetX, facetY, width, x);
      dealFacetFit(state, facetY, facetX, height, y);
    }

    function dealFacetFit(state, facet, otherFacet, totalSize, zoom) {
      if (zoom === void 0) {
        zoom = 1;
      }

      var nodesMap = facet.nodesMap,
          fit = facet.fit,
          fixUnit = facet.fixUnit,
          oldUnit = facet.unit;
      var leafCount = nodesMap[NODE_ROOT].leafCount;
      var unit = oldUnit,
          scrollable;

      if (fit) {
        unit = totalSize / leafCount;
      } // non-customize unit.
      else if (!fixUnit) {
          unit = fitFacet(state, facet, otherFacet, totalSize);
        }

      unit *= zoom; // scrollAble for clipping thumb size

      scrollable = !fit && leafCount * unit > totalSize;
      facet.unit = unit;
      facet.scrollable = scrollable;
    }

    var fitLayout = function fitLayout(state) {
      var isMobile = state.isMobile,
          plotBounds = state.plotBounds,
          facetX = state.facetX,
          facetY = state.facetY;
      fitChart(state);

      if (!isMobile) {
        var xScrollable = facetX.scrollable;
        var yScrollable = facetY.scrollable;
        xScrollable && plotBounds.clip(Direction.BOTTOM, THUMB_SIZE);
        yScrollable && plotBounds.clip(Direction.RIGHT, THUMB_SIZE); // refit chart after clip thumb size

        if (xScrollable || yScrollable) {
          fitChart(state, plotBounds);
        }
      }
    };

    /**
     * sum measure tick & title size, dimension tick & title size on facet for clip.
     * @param facet
     * @returns {number[]}
     */

    var collectFacetTickAndTitleSize = function collectFacetTickAndTitleSize(facet) {
      var measuresOverlapped = facet.measuresOverlapped,
          dimensions = facet.dimensions,
          facetSize = facet.size,
          titleSize = facet.titleSize,
          scaleMap = facet.scaleMap;
      var top = 0,
          bottom = 0;

      if (measuresOverlapped) {
        bottom = facetSize[0];
        top = facetSize[1];
      } else {
        bottom = facetSize;
      }

      _.each(dimensions, function (dId) {
        bottom += scaleMap[dId].size;
      });

      bottom += titleSize;
      return [bottom, top];
    };
    /**
     * clip plotBounds occupied by facet
     * @param facet
     * @param plotBounds
     */

    function clipFacetBounds(facet, plotBounds) {
      var horizontal = facet.horizontal;

      var _collectFacetTickAndT = collectFacetTickAndTitleSize(facet),
          bottom = _collectFacetTickAndT[0],
          top = _collectFacetTickAndT[1];

      plotBounds.clip(horizontal ? Direction.TOP : Direction.RIGHT, top);
      plotBounds.clip(horizontal ? Direction.BOTTOM : Direction.LEFT, bottom);
    }

    function getLogTicks(start, max, step, logBase) {
      var i = start === 1 ? 0 : Math.round(getLogarithm(start, logBase));
      var ticks = [];

      while (start <= max) {
        ticks.push(start);
        i += step;
        start = Math.pow(logBase, i);
      }

      return ticks;
    }

    function getLogarithm(base, value) {
      return value <= 0 ? 0 : accDiv(Math.log(value), Math.log(base));
    } // return newly facet


    function trainLogValueAxisScale(facet, defs, defName) {
      var _defs$defName = defs[defName],
          min = _defs$defName.min,
          max = _defs$defName.max,
          step = _defs$defName.step,
          logBase = _defs$defName.logBase,
          reverse = _defs$defName.reverse;
      var scaleMap = facet.scaleMap,
          scaleDef = scaleMap[defName],
          _scaleDef$domain = scaleDef.domain,
          calcMin = _scaleDef$domain[0],
          calcMax = _scaleDef$domain[1];
      var minValue = min != null ? min : Math.min(calcMin, 1);
      var maxValue = max != null ? max : calcMax;
      var stepValue = step != null ? step : 1;
      minValue = Math.pow(logBase, Math.floor(getLogarithm(logBase, minValue)));
      maxValue = Math.pow(logBase, Math.ceil(getLogarithm(logBase, maxValue)));
      var ticks = getLogTicks(minValue, maxValue, stepValue, logBase);
      return {
        domain: [minValue, maxValue],
        ticks: ticks,
        logBase: logBase,
        reverse: reverse
      };
    }

    // return newly facet
    var MIN_MAX_GAP = 100;
    var DEFAULT_TICK_INTERVAL = 90;
    function getLinearTicks(start, end, step) {
      var ticks = [];

      while (start <= end) {
        ticks.push(start);
        start = accAdd(start, step);
      }

      return ticks;
    }
    /**
     * 判断是否使用自定义的间隔值
     * @param length
     * @param min
     * @param max
     * @param step
     */

    var useCustomStep = function useCustomStep(_ref) {
      var length = _ref.length,
          min = _ref.min,
          max = _ref.max,
          step = _ref.step;

      // 为空或者小于0
      if (!step || step < 0) {
        return false;
      } // 当自定义间隔过小, 导致网格线间隔<1px时, 也不使用


      return length ? step >= (max - min) / length : true;
    };

    function trainValueAxisScale(facet, defs, defName) {
      var _defs$defName = defs[defName],
          min = _defs$defName.min,
          max = _defs$defName.max,
          step = _defs$defName.step,
          reverse = _defs$defName.reverse;
      var scaleMap = facet.scaleMap,
          length = facet.unit,
          _scaleMap$defName$dom = scaleMap[defName].domain,
          calcMin = _scaleMap$defName$dom[0],
          calcMax = _scaleMap$defName$dom[1];
      var isFixedMin = min != null;
      var isFixedMax = max != null;
      var minValue = isFixedMin ? min : Math.min(calcMin, 0);
      var maxValue = isFixedMax ? max : Math.max(calcMax, 0);
      var stepValue;

      if (minValue >= maxValue) {
        maxValue = minValue + MIN_MAX_GAP;
      }

      if (useCustomStep({
        step: step,
        min: minValue,
        max: maxValue,
        length: length
      })) {
        stepValue = step;
      } else {
        var tickCount = Math.max(length / facet.groupMeasureCount / DEFAULT_TICK_INTERVAL + 2, 3);
        stepValue = linearTickInterval(minValue, maxValue, tickCount);
      } // @BI-32864: 考虑到99-100这样柱形图外层标签显示不全，我们把domain放大一些，这样上侧就可以空出一点空间


      var _linearNiceDomainWith = linearNiceDomainWithLabel(minValue, maxValue, stepValue),
          startValue = _linearNiceDomainWith[0],
          endValue = _linearNiceDomainWith[1];

      var domain = [isFixedMin ? minValue : startValue, isFixedMax ? maxValue : endValue]; // 向上取值，使得startValue > min，且startValue是一个nice value

      if (isFixedMin && min > startValue) {
        var diff = min / stepValue;

        var round = function round(v) {
          return v < 0 ? -Math.floor(-v) : Math.ceil(v);
        };

        startValue = accMul(round(diff), stepValue);
      }

      maxValue = isFixedMax ? maxValue : endValue;
      var ticks = getLinearTicks(startValue, maxValue, stepValue);
      return {
        domain: domain,
        ticks: ticks,
        reverse: reverse,
        logBase: 0
      };
    }

    function getLargestWidthTick(facet, defs, defName) {
      var _defs$defName = defs[defName],
          logBase = _defs$defName.logBase,
          format = _defs$defName.format,
          tick = _defs$defName.tick;

      var _ref = logBase ? trainLogValueAxisScale(facet, defs, defName) : trainValueAxisScale(facet, defs, defName),
          _ticks = _ref.ticks; // @BI-38355 先格式化再找最大的一个


      var ticks = _.map(_ticks, function (t) {
        return getFormattedText(t, format);
      });

      var ticksWidth = _.map(ticks, function (t) {
        return calcTextDim(t, tick.style)[0];
      });

      return ticks[ticksWidth.indexOf(Math.max.apply(Math, ticksWidth))];
    }

    var calcMeasureDefSize = function calcMeasureDefSize(def, facet, defName, horizontal) {
      var _def$tick = def.tick,
          enabled = _def$tick.enabled,
          _def$tick$valid = _def$tick.valid,
          valid = _def$tick$valid === void 0 ? true : _def$tick$valid,
          rotation = _def$tick.rotation,
          tickStyle = _def$tick.style,
          _def$title = def.title,
          text = _def$title.text,
          titleStyle = _def$title.style;
      var fontSize = tickStyle.fontSize;
      var tickLabelHeight = 0;

      if (enabled && valid) {
        var _getLargestWidthTick;

        var maxWidthTick = getLargestWidthTick(facet, (_getLargestWidthTick = {}, _getLargestWidthTick[defName] = def, _getLargestWidthTick), defName);
        var padding = horizontal ? fontSize * DEFAULT_LINE_HEIGHT / 2 : DEFAULT_PADDING;
        var dim = calcTextDim(maxWidthTick, tickStyle, toRadian(rotation));
        var measureTickSize = horizontal ? dim[1] : dim[0];
        tickLabelHeight = Math.min(measureTickSize, fontSize * MAX_TICK_COUNT) + padding * 2;
      }

      var titleHeight = 0;

      if (text) {
        var titleFontSize = titleStyle.fontSize,
            titleFontStyle = titleStyle.fontStyle;
        titleHeight = titleFontSize + DEFAULT_PADDING * 2 + (titleFontStyle === 'italic' ? titleFontSize * 0.2 : 0);
      } // 刻度标签最大宽度+指标宽度+标签宽度


      return [tickLabelHeight, titleHeight];
    };

    var setDefSize = function setDefSize(defs, facet, defName, horizontal) {
      // axis size has customized if size property has been set.
      var def = defs[defName],
          size = def.size;
      var scaleMap = facet.scaleMap;
      var defSize = size;

      if (size == null) {
        var tickAndTitleSize = calcMeasureDefSize(def, facet, defName, horizontal);
        defSize = tickAndTitleSize[0] + tickAndTitleSize[1];
      }

      scaleMap[defName].size = defSize;
      return defSize;
    };
    function calcFacetMeasureAxisSize(facet, defs) {
      var measuresOverlapped = facet.measuresOverlapped,
          horizontal = facet.horizontal,
          scaleMap = facet.scaleMap,
          measures = facet.measures;

      if (measuresOverlapped) {
        var firstMeasures = measures[0],
            secondMeasures = measures[1];
        var first = 0,
            second = 0;

        if (firstMeasures.length > 0) {
          var axisName = getSharedAxisName(horizontal, true);
          first = setDefSize(defs, facet, axisName, horizontal);
        }

        if (secondMeasures.length > 0) {
          var _axisName = getSharedAxisName(horizontal, false);

          second = setDefSize(defs, facet, _axisName, horizontal);
        }

        facet.size = [first, second];
      } else {
        var maxTargetHeight = 0,
            maxTitleHeight = 0,
            isFixedSize = false,
            customSize = 0;

        _.each(measures, function (id) {
          var size = defs[id].size;

          if (size != null) {
            isFixedSize = true;
            customSize = Math.max(size, customSize);
          }
        });

        _.each(measures, function (id) {
          // get maximum customize size from defs.
          if (isFixedSize) {
            scaleMap[id].size = customSize;
            return;
          }

          var def = defs[id];
          var tickAndTitleSize = calcMeasureDefSize(def, facet, id, horizontal);
          maxTargetHeight = Math.max(maxTargetHeight, tickAndTitleSize[0]);
          maxTitleHeight = Math.max(maxTitleHeight, tickAndTitleSize[1]);
          scaleMap[id].size = tickAndTitleSize[0] + tickAndTitleSize[1];
        });

        facet.size = isFixedSize ? customSize : maxTargetHeight + maxTitleHeight;
      }
    }

    function getDimensionsMaxSizeMap(nodesMap, dimensions, defs, horizontal) {
      var dimSizeMap = {};

      _.each(nodesMap, function (node) {
        if (node.id === NODE_ROOT) {
          return;
        }

        var dId = dimensions[node.path.length - 1];
        var dimensionDef = defs[dId]; // fixedSize

        if (dimensionDef.size != null) {
          return;
        }

        var _dimensionDef$tick = dimensionDef.tick,
            tickEnabled = _dimensionDef$tick.enabled,
            rotation = _dimensionDef$tick.rotation,
            tickStyle = _dimensionDef$tick.style,
            fontSize = _dimensionDef$tick.style.fontSize,
            formatDef = dimensionDef.format;
        var maxSize = fontSize * MAX_TICK_COUNT;

        if (tickEnabled) {
          var dims = calcTextDim(getFormattedText(node.text, formatDef), tickStyle, toRadian(rotation));
          var size = horizontal ? dims[1] : dims[0];
          size = Math.min(size, maxSize) + DEFAULT_PADDING * 3; // 上6下3

          dimSizeMap[dId] = Math.max(dimSizeMap[dId] || 0, size);
        }
      });

      return dimSizeMap;
    }
    function calcFacetDimensionAxisSize(facet, defs) {
      var dimensions = facet.dimensions,
          nodesMap = facet.nodesMap,
          horizontal = facet.horizontal,
          scaleMap = facet.scaleMap;
      facet.titleSize = 0; // reset title size

      var dimSizeMap = getDimensionsMaxSizeMap(nodesMap, dimensions, defs, horizontal);

      _.each(dimensions, function (dId) {
        var _defs$dId = defs[dId],
            size = _defs$dId.size,
            _defs$dId$title = _defs$dId.title,
            text = _defs$dId$title.text,
            fontSize = _defs$dId$title.style.fontSize;

        if (!scaleMap[dId]) {
          scaleMap[dId] = {};
        }

        scaleMap[dId].size = size != null ? size : dimSizeMap[dId] || 0;

        if (text) {
          var titleSize = fontSize * (1 + DEFAULT_LINE_HEIGHT) + DEFAULT_PADDING * 2;
          facet.titleSize = Math.max(facet.titleSize, titleSize);
        }
      });
    }

    var calcFacetSize = function calcFacetSize(facet, defs) {
      calcFacetMeasureAxisSize(facet, defs);
      calcFacetDimensionAxisSize(facet, defs);
    };

    var facetLayout = function facetLayout(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          defs = state.defs,
          plotBounds = state.plotBounds;
      calcFacetSize(facetX, defs);
      calcFacetSize(facetY, defs);
      clipFacetBounds(facetX, plotBounds);
      clipFacetBounds(facetY, plotBounds);
    };

    var calcFacetStopNodes = function calcFacetStopNodes(facet) {
      var groupLevel = facet.groupLevel,
          nodesMap = facet.nodesMap;
      var nodes = [];

      _.each(nodesMap, function (node) {
        return node.level === groupLevel && nodes.push(node);
      });

      nodes.length === 0 && !_.isEmpty(nodesMap) && nodes.push(nodesMap[NODE_ROOT]);
      return nodes.sort(function (na, nb) {
        return na.pos - nb.pos;
      });
    };

    /**
     * calculate node id that used for group chart by cell.
     * @param facet
     */

    var calcFacetGroupIdIndex = function calcFacetGroupIdIndex(facet) {
      var stopNodes = facet.stopNodes,
          groupMeasureCount = facet.groupMeasureCount;
      var idToIndex = {};
      var groupIndex = 0;

      _.each(stopNodes, function (node) {
        var nodeKey = node.id === NODE_ROOT ? '' : node.id;

        if (groupMeasureCount === 0) {
          idToIndex[nodeKey] = groupIndex++;
        } else {
          for (var i = 0; i < groupMeasureCount; i++) {
            idToIndex[nodeKey + SEPARATOR + i] = groupIndex++;
          }
        }
      });

      return idToIndex;
    };

    function updateFacetNodesPosition(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          _state$plotBounds = state.plotBounds,
          x = _state$plotBounds.x,
          y = _state$plotBounds.y;
      updateSingleFacetNodesPos(facetX, x);
      updateSingleFacetNodesPos(facetY, y);
      return state;
    }
    /**
     * 更新facetNodes对应的位置和长度
     * @param facet
     * @param startPos
     */

    function updateSingleFacetNodesPos(facet, startPos) {
      var nodesMap = facet.nodesMap,
          unit = facet.unit;

      _.each(nodesMap, function (node) {
        node.pos = startPos + node.leafIndex * unit;
        node.length = node.leafCount * unit;
      }); // group nodes


      facet.stopNodes = calcFacetStopNodes(facet); // group id to index

      facet.groupIdMap = calcFacetGroupIdIndex(facet);
    }

    function trainAxisScale(facet, defs, defName) {
      var logBase = defs[defName].logBase;
      var scaleObj = logBase ? trainLogValueAxisScale(facet, defs, defName) : trainValueAxisScale(facet, defs, defName);
      var scaleDef = facet.scaleMap[defName];

      _.each(scaleObj, function (v, k) {
        if (k === 'domain') {
          // 缓存最初的domain，为了值轴调整做准备
          scaleDef.originDomain = scaleDef.domain;
        }

        scaleDef[k] = v;
      });
    }

    function trainFacetScale(state, facet) {
      var defs = state.defs;
      var measuresOverlapped = facet.measuresOverlapped,
          measures = facet.measures,
          horizontal = facet.horizontal;
      var valueCount = measuresOverlapped ? 1 : measures.length;

      if (valueCount === 0) {
        return;
      }

      if (measuresOverlapped) {
        var firstMeasures = measures[0],
            secondMeasures = measures[1];

        if (firstMeasures.length > 0) {
          var defName = getSharedAxisName(horizontal, true);
          trainAxisScale(facet, defs, defName);
        }

        if (secondMeasures.length > 0) {
          var _defName = getSharedAxisName(horizontal, false);

          trainAxisScale(facet, defs, _defName);
        }
      } else {
        _.each(measures, function (id) {
          return trainAxisScale(facet, defs, id);
        });
      }
    }

    function trainScale(state) {
      var facetX = state.facetX,
          facetY = state.facetY;
      trainFacetScale(state, facetX);
      trainFacetScale(state, facetY);
    }

    function calcMeasureAxisScaleRange(facet, defs, defName, start, end) {
      var _facet$trendLinePerio = facet.trendLinePeriod,
          forward = _facet$trendLinePerio[0],
          backward = _facet$trendLinePerio[1],
          horizontal = facet.horizontal,
          scaleMap = facet.scaleMap;

      var _ref = scaleMap[defName] || {},
          _ref$ticks = _ref.ticks,
          ticks = _ref$ticks === void 0 ? [] : _ref$ticks;

      var defReversed = defs[defName].reverse;
      var tickCount = ticks.length + forward + backward;
      var reverse = !horizontal ^ defReversed; // axis reverse

      if (reverse) {
        var _ref2 = [end, start];
        start = _ref2[0];
        end = _ref2[1];
      }

      if (tickCount !== 0) {
        var unit = (end - start) / tickCount;
        start += unit * forward;
        end -= unit * backward;
      }

      return [start, end];
    }

    function updateSingleFacetMeasurePos(state, facet) {
      var nodesMap = facet.nodesMap;
      var defs = state.defs;

      _.each(nodesMap, function (node) {
        updateNodeMeasurePosMap(defs, facet, node);
      });
    }
    /**
     * 更新Node上面的指标对应的range位置
     */


    function updateNodeMeasurePosMap(defs, facet, node) {
      var measuresOverlapped = facet.measuresOverlapped,
          unit = facet.unit,
          measures = facet.measures,
          horizontal = facet.horizontal,
          scaleMap = facet.scaleMap;
      var pos = node.pos;
      var targetUnit = unit / (measuresOverlapped ? 1 : Math.max(measures.length, 1));

      if (!measuresOverlapped && measures.length > 0 && node.leaf) {
        _.each(measures, function (measureId, idx) {
          var start = pos + idx * targetUnit,
              end = start + targetUnit;
          node.measurePosMap[measureId] = calcMeasureAxisScaleRange(facet, defs, measureId, start, end);
        });
      } else if (measuresOverlapped) {
        var start = pos,
            end = start + targetUnit,
            firstMeasureDefName = getSharedAxisName(horizontal, true),
            secondMeasureDefName = getSharedAxisName(horizontal, false); // there is no need to calculate range if ticks property is null.
        // if (isMeasureDefWillRender(defs, firstMeasureDefName, scaleMap)) {

        node.measurePosMap[firstMeasureDefName] = calcMeasureAxisScaleRange(facet, defs, firstMeasureDefName, start, end); // }
        // if (isMeasureDefWillRender(defs, secondMeasureDefName, scaleMap)) {

        node.measurePosMap[secondMeasureDefName] = calcMeasureAxisScaleRange(facet, defs, secondMeasureDefName, start, end); // }
      }
    }

    function updateFacetMeasurePosition(state) {
      var facetX = state.facetX,
          facetY = state.facetY;
      updateSingleFacetMeasurePos(state, facetX);
      updateSingleFacetMeasurePos(state, facetY);
    }

    /**
     *
     */

    var ChartBounds =
    /*#__PURE__*/
    function () {
      function ChartBounds(width, height, x, y) {
        if (x === void 0) {
          x = 0;
        }

        if (y === void 0) {
          y = 0;
        }

        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
      }

      var _proto = ChartBounds.prototype;

      _proto.padding = function padding$$1() {
        var top, bottom, right, left;

        switch (arguments.length) {
          case 1:
            top = bottom = right = left = arguments[0];
            break;

          case 2:
            top = bottom = arguments[0];
            left = right = arguments[1];
            break;

          case 4:
            top = arguments[0];
            right = arguments[1];
            bottom = arguments[2];
            left = arguments[3];
        }

        this.width -= left + right;
        this.height -= top + bottom;
        this.x += left;
        this.y += top;
        return this;
      }
      /**
       * add flexible child
       */
      ;

      _proto.clip = function clip(direction, size) {
        clipBounds(this, direction, size);
        return this;
      };

      _proto.getLeft = function getLeft() {
        return this.x;
      };

      _proto.getRight = function getRight() {
        return this.x + this.width;
      };

      _proto.getTop = function getTop() {
        return this.y;
      };

      _proto.getBottom = function getBottom() {
        return this.y + this.height;
      };

      _proto.xScrollable = function xScrollable() {
        return this.width < this.scrollWidth;
      };

      _proto.yScrollable = function yScrollable() {
        return this.height < this.scrollHeight;
      };

      _proto.scrollSize = function scrollSize() {
        if (arguments.length === 0) {
          return [this.scrollWidth || this.width, this.scrollHeight || this.height];
        }

        var sw = arguments[0],
            sh = arguments[1];
        this.scrollWidth = sw;
        this.scrollHeight = sh; // 同步更新with & height

        this.width = Math.min(sw, this.width);
        this.height = Math.min(sh, this.height);
        return this;
      };

      _proto.clone = function clone() {
        return new ChartBounds(this.width, this.height, this.x, this.y);
      };

      return ChartBounds;
    }();

    var getFacetLength = function getFacetLength(facet) {
      return facet.nodesMap[NODE_ROOT].leafCount * facet.unit;
    };

    /**
     * Created by Jeffrey on 2018/2/7.
     */

    /*
     * @class GridLayer
     * @inherits Layer
     * @aka L.GridLayer
     *
     * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
     * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
     *
     *
     * @section Synchronous usage
     * @example
     *
     * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
     *
     * ```js
     * var CanvasLayer = L.GridLayer.extend({
     *     createTile: function(coords){
     *         // create a <canvas> element for drawing
     *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
     *
     *         // setup tile width and height according to the options
     *         var size = this.getTileSize();
     *         tile.width = size.x;
     *         tile.height = size.y;
     *
     *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
     *         var ctx = tile.getContext('2d');
     *
     *         // return the tile so it can be rendered on screen
     *         return tile;
     *     }
     * });
     * ```
     *
     * @section Asynchronous usage
     * @example
     *
     * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
     *
     * ```js
     * var CanvasLayer = L.GridLayer.extend({
     *     createTile: function(coords, done){
     *         var error;
     *
     *         // create a <canvas> element for drawing
     *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
     *
     *         // setup tile width and height according to the options
     *         var size = this.getTileSize();
     *         tile.width = size.x;
     *         tile.height = size.y;
     *
     *         // draw something asynchronously and pass the tile to the done() callback
     *         setTimeout(function() {
     *             done(error, tile);
     *         }, 1000);
     *
     *         return tile;
     *     }
     * });
     * ```
     *
     * @section
     */

    var GridLayer = Layer$1.extend({
      // @section
      // @aka GridLayer options
      options: {
        // @option tileSize: Number|Point = 256
        // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
        tileSize: 256,
        // @option opacity: Number = 1.0
        // Opacity of the tiles. Can be used in the `createTile()` function.
        opacity: 1,
        // @option updateWhenIdle: Boolean = (depends)
        // Load new tiles only when panning ends.
        // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
        // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
        // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
        updateWhenIdle: mobile,
        // @option updateWhenZooming: Boolean = true
        // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
        updateWhenZooming: true,
        // @option updateInterval: Number = 200
        // Tiles will not update more than once every `updateInterval` milliseconds when panning.
        updateInterval: 200,
        // @option zIndex: Number = 1
        // The explicit zIndex of the tile layer.
        zIndex: 1,
        // @option bounds: LatLngBounds = undefined
        // If set, tiles will only be loaded inside the set `LatLngBounds`.
        bounds: null,
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = undefined
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: undefined,
        // @option maxNativeZoom: Number = undefined
        // Maximum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
        // from `maxNativeZoom` level and auto-scaled.
        maxNativeZoom: undefined,
        // @option minNativeZoom: Number = undefined
        // Minimum zoom number the tile source has available. If it is specified,
        // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
        // from `minNativeZoom` level and auto-scaled.
        minNativeZoom: undefined,
        // @option noWrap: Boolean = false
        // Whether the layer is wrapped around the antimeridian. If `true`, the
        // GridLayer will only be displayed once at low zoom levels. Has no
        // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
        // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
        // tiles outside the CRS limits.
        noWrap: false,
        // @option pane: String = 'tilePane'
        // `Map pane` where the grid layer will be added.
        pane: 'tilePane',
        // @option className: String = ''
        // A custom class name to assign to the tile layer. Empty by default.
        className: '',
        // @option keepBuffer: Number = 2
        // When panning the map, keep this many rows and columns of tiles before unloading them.
        keepBuffer: 2
      },
      initialize: function initialize(options) {
        setOptions(this, options);
      },
      onAdd: function onAdd() {
        this._initContainer();

        this._levels = {};
        this._tiles = {};

        this._resetView();

        this._update();
      },
      beforeAdd: function beforeAdd(map) {
        map._addZoomLimit(this);
      },
      onRemove: function onRemove(map) {
        this._removeAllTiles();

        remove(this._container);

        map._removeZoomLimit(this);

        this._container = null;
        this._tileZoom = null;
      },
      // @method bringToFront: this
      // Brings the tile layer to the top of all tile layers.
      bringToFront: function bringToFront() {
        if (this._map) {
          toFront(this._container);

          this._setAutoZIndex(Math.max);
        }

        return this;
      },
      // @method bringToBack: this
      // Brings the tile layer to the bottom of all tile layers.
      bringToBack: function bringToBack() {
        if (this._map) {
          toBack(this._container);

          this._setAutoZIndex(Math.min);
        }

        return this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTML element that contains the tiles for this layer.
      getContainer: function getContainer() {
        return this._container;
      },
      // @method setOpacity(opacity: Number): this
      // Changes the [opacity](#gridlayer-opacity) of the grid layer.
      setOpacity: function setOpacity$$1(opacity) {
        this.options.opacity = opacity;

        this._updateOpacity();

        return this;
      },
      // @method setZIndex(zIndex: Number): this
      // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
      setZIndex: function setZIndex(zIndex) {
        this.options.zIndex = zIndex;

        this._updateZIndex();

        return this;
      },
      // @method isLoading: Boolean
      // Returns `true` if any tile in the grid layer has not finished loading.
      isLoading: function isLoading() {
        return this._loading;
      },
      // @method redraw: this
      // Causes the layer to clear all the tiles and request them again.
      redraw: function redraw() {
        if (this._map) {
          this._removeAllTiles();

          this._update();
        }

        return this;
      },
      getEvents: function getEvents() {
        var events = {
          viewprereset: this._invalidateAll,
          viewreset: this._resetView,
          zoom: this._resetView,
          moveend: this._onMoveEnd
        };

        if (!this.options.updateWhenIdle) {
          // update tiles on move, but not more often than once per given interval
          if (!this._onMove) {
            this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
          }

          events.move = this._onMove;
        }

        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }

        return events;
      },
      // @section Extension methods
      // Layers extending `GridLayer` shall reimplement the following method.
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, must be overriden by classes extending `GridLayer`.
      // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
      // is specified, it must be called when the tile has finished loading and drawing.
      createTile: function createTile() {
        return document.createElement('div');
      },
      // @section
      // @method getTileSize: Point
      // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
      getTileSize: function getTileSize() {
        var s = this.options.tileSize;
        return s instanceof Point ? s : new Point(s, s);
      },
      _updateZIndex: function _updateZIndex() {
        if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
          this._container.style.zIndex = this.options.zIndex;
        }
      },
      _setAutoZIndex: function _setAutoZIndex(compare) {
        // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
        var layers = this.getPane().children,
            edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

        for (var i = 0, len = layers.length, zIndex; i < len; i++) {
          zIndex = layers[i].style.zIndex;

          if (layers[i] !== this._container && zIndex) {
            edgeZIndex = compare(edgeZIndex, +zIndex);
          }
        }

        if (isFinite(edgeZIndex)) {
          this.options.zIndex = edgeZIndex + compare(-1, 1);

          this._updateZIndex();
        }
      },
      _updateOpacity: function _updateOpacity() {
        if (!this._map) {
          return;
        } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles


        if (ielt9) {
          return;
        }

        setOpacity(this._container, this.options.opacity);
        var now = +new Date(),
            nextFrame = false,
            willPrune = false;

        for (var key in this._tiles) {
          var tile = this._tiles[key];

          if (!tile.current || !tile.loaded) {
            continue;
          }

          var fade = Math.min(1, (now - tile.loaded) / 200);
          setOpacity(tile.el, fade);

          if (fade < 1) {
            nextFrame = true;
          } else {
            if (tile.active) {
              willPrune = true;
            } else {
              this._onOpaqueTile(tile);
            }

            tile.active = true;
          }
        }

        if (willPrune && !this._noPrune) {
          this._pruneTiles();
        }

        if (nextFrame) {
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        }
      },
      _onOpaqueTile: falseFn,
      _initContainer: function _initContainer() {
        if (this._container) {
          return;
        }

        this._container = create$4('div', 'leaflet-layer ' + (this.options.className || ''));

        this._updateZIndex();

        if (this.options.opacity < 1) {
          this._updateOpacity();
        }

        this.getPane().appendChild(this._container);
      },
      _updateLevels: function _updateLevels() {
        var zoom = this._tileZoom,
            maxZoom = this.options.maxZoom;

        if (zoom === undefined) {
          return undefined;
        }

        for (var z in this._levels) {
          if (this._levels[z].el.children.length || z === zoom) {
            this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);

            this._onUpdateLevel(z);
          } else {
            remove(this._levels[z].el);

            this._removeTilesAtZoom(z);

            this._onRemoveLevel(z);

            delete this._levels[z];
          }
        }

        var level = this._levels[zoom],
            map = this._map;

        if (!level) {
          level = this._levels[zoom] = {};
          level.el = create$4('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
          level.el.style.zIndex = maxZoom;
          level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
          level.zoom = zoom;

          this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition


          falseFn(level.el.offsetWidth);

          this._onCreateLevel(level);
        }

        this._level = level;
        return level;
      },
      _onUpdateLevel: falseFn,
      _onRemoveLevel: falseFn,
      _onCreateLevel: falseFn,
      _pruneTiles: function _pruneTiles() {
        if (!this._map) {
          return;
        }

        var key, tile;

        var zoom = this._map.getZoom();

        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
          this._removeAllTiles();

          return;
        }

        for (key in this._tiles) {
          tile = this._tiles[key];
          tile.retain = tile.current;
        }

        for (key in this._tiles) {
          tile = this._tiles[key];

          if (tile.current && !tile.active) {
            var coords = tile.coords;

            if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
              this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
            }
          }
        }

        for (key in this._tiles) {
          if (!this._tiles[key].retain) {
            this._removeTile(key);
          }
        }
      },
      _removeTilesAtZoom: function _removeTilesAtZoom(zoom) {
        for (var key in this._tiles) {
          if (this._tiles[key].coords.z !== zoom) {
            continue;
          }

          this._removeTile(key);
        }
      },
      _removeAllTiles: function _removeAllTiles() {
        for (var key in this._tiles) {
          this._removeTile(key);
        }
      },
      _invalidateAll: function _invalidateAll() {
        for (var z in this._levels) {
          remove(this._levels[z].el);

          this._onRemoveLevel(z);

          delete this._levels[z];
        }

        this._removeAllTiles();

        this._tileZoom = null;
      },
      _retainParent: function _retainParent(x, y, z, minZoom) {
        var x2 = Math.floor(x / 2),
            y2 = Math.floor(y / 2),
            z2 = z - 1,
            coords2 = new Point(+x2, +y2);
        coords2.z = +z2;

        var key = this._tileCoordsToKey(coords2),
            tile = this._tiles[key];

        if (tile && tile.active) {
          tile.retain = true;
          return true;
        } else if (tile && tile.loaded) {
          tile.retain = true;
        }

        if (z2 > minZoom) {
          return this._retainParent(x2, y2, z2, minZoom);
        }

        return false;
      },
      _retainChildren: function _retainChildren(x, y, z, maxZoom) {
        for (var i = 2 * x; i < 2 * x + 2; i++) {
          for (var j = 2 * y; j < 2 * y + 2; j++) {
            var coords = new Point(i, j);
            coords.z = z + 1;

            var key = this._tileCoordsToKey(coords),
                tile = this._tiles[key];

            if (tile && tile.active) {
              tile.retain = true;
              continue;
            } else if (tile && tile.loaded) {
              tile.retain = true;
            }

            if (z + 1 < maxZoom) {
              this._retainChildren(i, j, z + 1, maxZoom);
            }
          }
        }
      },
      _resetView: function _resetView(e) {
        var animating = e && (e.pinch || e.flyTo);

        this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
      },
      _animateZoom: function _animateZoom(e) {
        this._setView(e.center, e.zoom, true, e.noUpdate);
      },
      _clampZoom: function _clampZoom(zoom) {
        var options = this.options;

        if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
          return options.minNativeZoom;
        }

        if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
          return options.maxNativeZoom;
        }

        return zoom;
      },
      _setView: function _setView(center, zoom, noPrune, noUpdate) {
        var tileZoom = this._clampZoom(Math.round(zoom));

        if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
          tileZoom = undefined;
        }

        var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

        if (!noUpdate || tileZoomChanged) {
          this._tileZoom = tileZoom;

          if (this._abortLoading) {
            this._abortLoading();
          }

          this._updateLevels();

          this._resetGrid();

          if (tileZoom !== undefined) {
            this._update(center);
          }

          if (!noPrune) {
            this._pruneTiles();
          } // Flag to prevent _updateOpacity from pruning tiles during
          // a zoom anim or a pinch gesture


          this._noPrune = !!noPrune;
        }

        this._setZoomTransforms(center, zoom);
      },
      _setZoomTransforms: function _setZoomTransforms(center, zoom) {
        for (var i in this._levels) {
          this._setZoomTransform(this._levels[i], center, zoom);
        }
      },
      _setZoomTransform: function _setZoomTransform(level, center, zoom) {
        var scale = this._map.getZoomScale(zoom, level.zoom),
            translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

        if (any3d) {
          setTransform(level.el, translate, scale);
        } else {
          setPosition(level.el, translate);
        }
      },
      _resetGrid: function _resetGrid() {
        var map = this._map,
            crs = map.options.crs,
            tileSize = this._tileSize = this.getTileSize(),
            tileZoom = this._tileZoom;

        var bounds = this._map.getPixelWorldBounds(this._tileZoom);

        if (bounds) {
          this._globalTileRange = this._pxBoundsToTileRange(bounds);
        }

        this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
        this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
      },
      _onMoveEnd: function _onMoveEnd() {
        if (!this._map || this._map._animatingZoom) {
          return;
        }

        this._update();
      },
      _getTiledPixelBounds: function _getTiledPixelBounds(center) {
        var map = this._map,
            mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
            scale = map.getZoomScale(mapZoom, this._tileZoom),
            pixelCenter = map.project(center, this._tileZoom).floor(),
            halfSize = map.getSize().divideBy(scale * 2);
        return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
      },
      // Private method to load tiles in the grid's active zoom level according to map bounds
      _update: function _update(center) {
        var map = this._map;

        if (!map) {
          return;
        }

        var zoom = this._clampZoom(map.getZoom());

        if (center === undefined) {
          center = map.getCenter();
        }

        if (this._tileZoom === undefined) {
          return;
        } // if out of minzoom/maxzoom


        var pixelBounds = this._getTiledPixelBounds(center),
            tileRange = this._pxBoundsToTileRange(pixelBounds),
            tileCenter = tileRange.getCenter(),
            queue = [],
            margin = this.options.keepBuffer,
            noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.


        if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
          throw new Error('Attempted to load an infinite number of tiles');
        }

        for (var key in this._tiles) {
          var c = this._tiles[key].coords;

          if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
            this._tiles[key].current = false;
          }
        } // _update just loads more tiles. If the tile zoom level differs too much
        // from the map's, let _setView reset levels and prune old tiles.


        if (Math.abs(zoom - this._tileZoom) > 1) {
          this._setView(center, zoom);

          return;
        } // create a queue of coordinates to load tiles from


        for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
          for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
            var coords = new Point(i, j);
            coords.z = this._tileZoom;

            if (!this._isValidTile(coords)) {
              continue;
            }

            if (!this._tiles[this._tileCoordsToKey(coords)]) {
              queue.push(coords);
            }
          }
        } // sort tile queue to load tiles in order of their distance to center


        queue.sort(function (a, b) {
          return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
        });

        if (queue.length !== 0) {
          // if it's the first batch of tiles to load
          if (!this._loading) {
            this._loading = true; // @event loading: Event
            // Fired when the grid layer starts loading tiles.

            this.fire('loading');
          } // create DOM fragment to append tiles in one batch


          var fragment = document.createDocumentFragment();

          for (i = 0; i < queue.length; i++) {
            this._addTile(queue[i], fragment);
          }

          this._level.el.appendChild(fragment);
        }
      },
      _isValidTile: function _isValidTile(coords) {
        var crs = this._map.options.crs;

        if (!crs.infinite) {
          // don't load tile if it's out of bounds and not wrapped
          var bounds = this._globalTileRange;

          if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
            return false;
          }
        }

        if (!this.options.bounds) {
          return true;
        } // don't load tile if it doesn't intersect the bounds in options


        var tileBounds = this._tileCoordsToBounds(coords);

        return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
      },
      _keyToBounds: function _keyToBounds(key) {
        return this._tileCoordsToBounds(this._keyToTileCoords(key));
      },
      // converts tile coordinates to its geographical bounds
      _tileCoordsToBounds: function _tileCoordsToBounds(coords) {
        var map = this._map,
            tileSize = this.getTileSize(),
            nwPoint = coords.scaleBy(tileSize),
            sePoint = nwPoint.add(tileSize),
            nw = map.unproject(nwPoint, coords.z),
            se = map.unproject(sePoint, coords.z),
            bounds = new LatLngBounds(nw, se);

        if (!this.options.noWrap) {
          map.wrapLatLngBounds(bounds);
        }

        return bounds;
      },
      // converts tile coordinates to key for the tile cache
      _tileCoordsToKey: function _tileCoordsToKey(coords) {
        return coords.x + ':' + coords.y + ':' + coords.z;
      },
      // converts tile cache key to coordinates
      _keyToTileCoords: function _keyToTileCoords(key) {
        var k = key.split(':'),
            coords = new Point(+k[0], +k[1]);
        coords.z = +k[2];
        return coords;
      },
      _removeTile: function _removeTile(key) {
        var tile = this._tiles[key];

        if (!tile) {
          return;
        }

        remove(tile.el);
        delete this._tiles[key]; // @event tileunload: TileEvent
        // Fired when a tile is removed (e.g. when a tile goes off the screen).

        this.fire('tileunload', {
          tile: tile.el,
          coords: this._keyToTileCoords(key)
        });
      },
      _initTile: function _initTile(tile) {
        addClass(tile, 'leaflet-tile');
        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + 'px';
        tile.style.height = tileSize.y + 'px';
        tile.onselectstart = falseFn;
        tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems

        if (ielt9 && this.options.opacity < 1) {
          setOpacity(tile, this.options.opacity);
        } // without this hack, tiles disappear after zoom on Chrome for Android
        // https://github.com/Leaflet/Leaflet/issues/2078


        if (android && !android23) {
          tile.style.WebkitBackfaceVisibility = 'hidden';
        }
      },
      _addTile: function _addTile(coords, container) {
        var tilePos = this._getTilePos(coords),
            key = this._tileCoordsToKey(coords);

        var tile = this.createTile(this._wrapCoords(coords), bind$1(this._tileReady, this, coords));

        this._initTile(tile); // if createTile is defined with a second argument ("done" callback),
        // we know that tile is async and will be ready later; otherwise


        if (this.createTile.length < 2) {
          // mark tile as ready, but delay one frame for opacity animation to happen
          requestAnimFrame(bind$1(this._tileReady, this, coords, null, tile));
        }

        setPosition(tile, tilePos); // save tile in cache

        this._tiles[key] = {
          el: tile,
          coords: coords,
          current: true
        };
        container.appendChild(tile); // @event tileloadstart: TileEvent
        // Fired when a tile is requested and starts loading.

        this.fire('tileloadstart', {
          tile: tile,
          coords: coords
        });
      },
      _tileReady: function _tileReady(coords, err, tile) {
        if (!this._map) {
          return;
        }

        if (err) {
          // @event tileerror: TileErrorEvent
          // Fired when there is an error loading a tile.
          this.fire('tileerror', {
            error: err,
            tile: tile,
            coords: coords
          });
        }

        var key = this._tileCoordsToKey(coords);

        tile = this._tiles[key];

        if (!tile) {
          return;
        }

        tile.loaded = +new Date();

        if (this._map._fadeAnimated) {
          setOpacity(tile.el, 0);
          cancelAnimFrame(this._fadeFrame);
          this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
        } else {
          tile.active = true;

          this._pruneTiles();
        }

        if (!err) {
          addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent
          // Fired when a tile loads.

          this.fire('tileload', {
            tile: tile.el,
            coords: coords
          });
        }

        if (this._noTilesToLoad()) {
          this._loading = false; // @event load: Event
          // Fired when the grid layer loaded all visible tiles.

          this.fire('load');

          if (ielt9 || !this._map._fadeAnimated) {
            requestAnimFrame(this._pruneTiles, this);
          } else {
            // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
            // to trigger a pruning.
            setTimeout(bind$1(this._pruneTiles, this), 250);
          }
        }
      },
      _getTilePos: function _getTilePos(coords) {
        return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
      },
      _wrapCoords: function _wrapCoords(coords) {
        var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
        newCoords.z = coords.z;
        return newCoords;
      },
      _pxBoundsToTileRange: function _pxBoundsToTileRange(bounds) {
        var tileSize = this.getTileSize();
        return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
      },
      _noTilesToLoad: function _noTilesToLoad() {
        for (var key in this._tiles) {
          if (!this._tiles[key].loaded) {
            return false;
          }
        }

        return true;
      }
    }); // @factory L.gridLayer(options?: GridLayer options)

    /*
     * @class TileLayer
     * @inherits GridLayer
     * @aka L.TileLayer
     * Used to load and display tile layers on the map. Extends `GridLayer`.
     *
     * @example
     *
     * ```js
     * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
     * ```
     *
     * @section URL template
     * @example
     *
     * A string of the following form:
     *
     * ```
     * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
     * ```
     *
     * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
     *
     * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
     *
     * ```
     * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
     * ```
     */

    var TileLayer = GridLayer.extend({
      // @section
      // @aka TileLayer options
      options: {
        // @option minZoom: Number = 0
        // The minimum zoom level down to which this layer will be displayed (inclusive).
        minZoom: 0,
        // @option maxZoom: Number = 18
        // The maximum zoom level up to which this layer will be displayed (inclusive).
        maxZoom: 18,
        // @option subdomains: String|String[] = 'abc'
        // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
        subdomains: 'abc',
        // @option errorTileUrl: String = ''
        // URL to the tile image to show in place of the tile that failed to load.
        errorTileUrl: '',
        // @option zoomOffset: Number = 0
        // The zoom number used in tile URLs will be offset with this value.
        zoomOffset: 0,
        // @option tms: Boolean = false
        // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
        tms: false,
        // @option zoomReverse: Boolean = false
        // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
        zoomReverse: false,
        // @option detectRetina: Boolean = false
        // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
        detectRetina: false,
        // @option crossOrigin: Boolean = false
        // If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
        crossOrigin: false
      },
      initialize: function initialize(url, options) {
        this._url = url;
        options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels

        if (options.detectRetina && retina && options.maxZoom > 0) {
          options.tileSize = Math.floor(options.tileSize / 2);

          if (!options.zoomReverse) {
            options.zoomOffset++;
            options.maxZoom--;
          } else {
            options.zoomOffset--;
            options.minZoom++;
          }

          options.minZoom = Math.max(0, options.minZoom);
        }

        if (typeof options.subdomains === 'string') {
          options.subdomains = options.subdomains.split('');
        } // for https://github.com/Leaflet/Leaflet/issues/137


        if (!android) {
          this.on('tileunload', this._onTileRemove);
        }
      },
      // @method setUrl(url: String, noRedraw?: Boolean): this
      // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
      setUrl: function setUrl(url, noRedraw) {
        this._url = url;

        if (!noRedraw) {
          this.redraw();
        }

        return this;
      },
      // @method createTile(coords: Object, done?: Function): HTMLElement
      // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
      // to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
      // callback is called when the tile has been loaded.
      createTile: function createTile(coords, done) {
        var tile = document.createElement('img');
        on(tile, 'load', bind$1(this._tileOnLoad, this, done, tile));
        on(tile, 'error', bind$1(this._tileOnError, this, done, tile));

        if (this.options.crossOrigin) {
          tile.crossOrigin = '';
        }
        /*
         Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
         http://www.w3.org/TR/WCAG20-TECHS/H67
        */


        tile.alt = '';
        /*
         Set role="presentation" to force screen readers to ignore this
         https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
        */

        tile.setAttribute('role', 'presentation');
        tile.src = this.getTileUrl(coords);
        return tile;
      },
      // @section Extension methods
      // @uninheritable
      // Layers extending `TileLayer` might reimplement the following method.
      // @method getTileUrl(coords: Object): String
      // Called only internally, returns the URL for a tile given its coordinates.
      // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
      getTileUrl: function getTileUrl(coords) {
        var data = {
          r: retina ? '@2x' : '',
          s: this._getSubdomain(coords),
          x: coords.x,
          y: coords.y,
          z: this._getZoomForUrl()
        };

        if (this._map && !this._map.options.crs.infinite) {
          var invertedY = this._globalTileRange.max.y - coords.y;

          if (this.options.tms) {
            data['y'] = invertedY;
          }

          data['-y'] = invertedY;
        }

        return template(this._url, extend$4(data, this.options));
      },
      _tileOnLoad: function _tileOnLoad(done, tile) {
        // For https://github.com/Leaflet/Leaflet/issues/3332
        if (ielt9) {
          setTimeout(bind$1(done, this, null, tile), 0);
        } else {
          done(null, tile);
        }
      },
      _tileOnError: function _tileOnError(done, tile, e) {
        var errorUrl = this.options.errorTileUrl;

        if (errorUrl && tile.src !== errorUrl) {
          tile.src = errorUrl;
        }

        done(e, tile);
      },
      _onTileRemove: function _onTileRemove(e) {
        e.tile.onload = null;
      },
      _getZoomForUrl: function _getZoomForUrl() {
        var zoom = this._tileZoom,
            maxZoom = this.options.maxZoom,
            zoomReverse = this.options.zoomReverse,
            zoomOffset = this.options.zoomOffset;

        if (zoomReverse) {
          zoom = maxZoom - zoom;
        }

        return zoom + zoomOffset;
      },
      _getSubdomain: function _getSubdomain(tilePoint) {
        var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
        return this.options.subdomains[index];
      },
      // stops loading all tiles in the background layer
      _abortLoading: function _abortLoading() {
        var i, tile;

        for (i in this._tiles) {
          if (this._tiles[i].coords.z !== this._tileZoom) {
            tile = this._tiles[i].el;
            tile.onload = falseFn;
            tile.onerror = falseFn;

            if (!tile.complete) {
              tile.src = emptyImageUrl;
              remove(tile);
            }
          }
        }
      }
    }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)

    /*
     * @class TileLayer.WMS
     * @inherits TileLayer
     * @aka L.TileLayer.WMS
     * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
     *
     * @example
     *
     * ```js
     * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
     * 	layers: 'nexrad-n0r-900913',
     * 	format: 'image/png',
     * 	transparent: true,
     * 	attribution: "Weather data © 2012 IEM Nexrad"
     * });
     * ```
     */

    var TileLayerWMS = TileLayer.extend({
      // @section
      // @aka TileLayer.WMS options
      // If any custom options not documented here are used, they will be sent to the
      // WMS server as extra parameters in each request URL. This can be useful for
      // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
      defaultWmsParams: {
        service: 'WMS',
        request: 'GetMap',
        // @option layers: String = ''
        // **(required)** Comma-separated list of WMS layers to show.
        layers: '',
        // @option styles: String = ''
        // Comma-separated list of WMS styles.
        styles: '',
        // @option format: String = 'image/jpeg'
        // WMS image format (use `'image/png'` for layers with transparency).
        format: 'image/jpeg',
        // @option transparent: Boolean = false
        // If `true`, the WMS service will return images with transparency.
        transparent: false,
        // @option version: String = '1.1.1'
        // Version of the WMS service to use
        version: '1.1.1'
      },
      options: {
        // @option crs: CRS = null
        // Coordinate Reference System to use for the WMS requests, defaults to
        // map CRS. Don't change this if you're not sure what it means.
        crs: null,
        // @option uppercase: Boolean = false
        // If `true`, WMS request parameter keys will be uppercase.
        uppercase: false
      },
      initialize: function initialize(url, options) {
        this._url = url;
        var wmsParams = extend$4({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params

        for (var i in options) {
          if (!(i in this.options)) {
            wmsParams[i] = options[i];
          }
        }

        options = setOptions(this, options);
        wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && retina ? 2 : 1);
        this.wmsParams = wmsParams;
      },
      onAdd: function onAdd(map) {
        this._crs = this.options.crs || map.options.crs;
        this._wmsVersion = parseFloat(this.wmsParams.version);
        var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
        this.wmsParams[projectionKey] = this._crs.code;
        TileLayer.prototype.onAdd.call(this, map);
      },
      getTileUrl: function getTileUrl(coords) {
        var tileBounds = this._tileCoordsToBounds(coords),
            nw = this._crs.project(tileBounds.getNorthWest()),
            se = this._crs.project(tileBounds.getSouthEast()),
            bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [se.y, nw.x, nw.y, se.x] : [nw.x, se.y, se.x, nw.y]).join(','),
            url = TileLayer.prototype.getTileUrl.call(this, coords);

        return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
      },
      // @method setParams(params: Object, noRedraw?: Boolean): this
      // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
      setParams: function setParams(params, noRedraw) {
        extend$4(this.wmsParams, params);

        if (!noRedraw) {
          this.redraw();
        }

        return this;
      }
    }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)

    /*
     * @class ImageOverlay
     * @aka L.ImageOverlay
     * @inherits Interactive layer
     *
     * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
     *
     * @example
     *
     * ```js
     * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
     * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
     * L.imageOverlay(imageUrl, imageBounds).addTo(map);
     * ```
     */

    var ImageOverlay = Layer$1.extend({
      // @section
      // @aka ImageOverlay options
      options: {
        // @option opacity: Number = 1.0
        // The opacity of the image overlay.
        opacity: 1,
        // @option alt: String = ''
        // Text for the `alt` attribute of the image (useful for accessibility).
        alt: '',
        // @option interactive: Boolean = false
        // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
        interactive: false,
        // @option crossOrigin: Boolean = false
        // If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
        crossOrigin: false,
        // @option errorOverlayUrl: String = ''
        // URL to the overlay image to show in place of the overlay that failed to load.
        errorOverlayUrl: '',
        // @option zIndex: Number = 1
        // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
        zIndex: 1,
        // @option className: String = ''
        // A custom class name to assign to the image. Empty by default.
        className: ''
      },
      initialize: function initialize(url, bounds, options) {
        // (String, LatLngBounds, Object)
        this._url = url;
        this._bounds = toLatLngBounds(bounds);
        setOptions(this, options);
      },
      onAdd: function onAdd() {
        if (!this._image) {
          this._initImage();

          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
        }

        if (this.options.interactive) {
          addClass(this._image, 'leaflet-interactive');
          this.addInteractiveTarget(this._image);
        }

        this.getPane().appendChild(this._image);

        this._reset();
      },
      onRemove: function onRemove() {
        remove(this._image);

        if (this.options.interactive) {
          this.removeInteractiveTarget(this._image);
        }
      },
      // @method setOpacity(opacity: Number): this
      // Sets the opacity of the overlay.
      setOpacity: function setOpacity$$1(opacity) {
        this.options.opacity = opacity;

        if (this._image) {
          this._updateOpacity();
        }

        return this;
      },
      setStyle: function setStyle(styleOpts) {
        if (styleOpts.opacity) {
          this.setOpacity(styleOpts.opacity);
        }

        return this;
      },
      // @method bringToFront(): this
      // Brings the layer to the top of all overlays.
      bringToFront: function bringToFront() {
        if (this._map) {
          toFront(this._image);
        }

        return this;
      },
      // @method bringToBack(): this
      // Brings the layer to the bottom of all overlays.
      bringToBack: function bringToBack() {
        if (this._map) {
          toBack(this._image);
        }

        return this;
      },
      // @method setUrl(url: String): this
      // Changes the URL of the image.
      setUrl: function setUrl(url) {
        this._url = url;

        if (this._image) {
          this._image.src = url;
        }

        return this;
      },
      // @method setBounds(bounds: LatLngBounds): this
      // Update the bounds that this ImageOverlay covers
      setBounds: function setBounds(bounds) {
        this._bounds = toLatLngBounds(bounds);

        if (this._map) {
          this._reset();
        }

        return this;
      },
      getEvents: function getEvents() {
        var events = {
          zoom: this._reset,
          viewreset: this._reset
        };

        if (this._zoomAnimated) {
          events.zoomanim = this._animateZoom;
        }

        return events;
      },
      // @method: setZIndex(value: Number) : this
      // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
      setZIndex: function setZIndex(value) {
        this.options.zIndex = value;

        this._updateZIndex();

        return this;
      },
      // @method getBounds(): LatLngBounds
      // Get the bounds that this ImageOverlay covers
      getBounds: function getBounds() {
        return this._bounds;
      },
      // @method getElement(): HTMLElement
      // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
      // used by this overlay.
      getElement: function getElement() {
        return this._image;
      },
      _initImage: function _initImage() {
        var img = this._image = create$4('img', 'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : '') + (this.options.className || ''));
        img.onselectstart = falseFn;
        img.onmousemove = falseFn; // @event load: Event
        // Fired when the ImageOverlay layer has loaded its image

        img.onload = bind$1(this.fire, this, 'load');
        img.onerror = bind$1(this._overlayOnError, this, 'error');

        if (this.options.crossOrigin) {
          img.crossOrigin = '';
        }

        if (this.options.zIndex) {
          this._updateZIndex();
        }

        img.src = this._url;
        img.alt = this.options.alt;
      },
      _animateZoom: function _animateZoom(e) {
        var scale = this._map.getZoomScale(e.zoom),
            offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

        setTransform(this._image, offset, scale);
      },
      _reset: function _reset() {
        var image = this._image,
            bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
            size = bounds.getSize();
        setPosition(image, bounds.min);
        image.style.width = size.x + 'px';
        image.style.height = size.y + 'px';
      },
      _updateOpacity: function _updateOpacity() {
        setOpacity(this._image, this.options.opacity);
      },
      _updateZIndex: function _updateZIndex() {
        if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
          this._image.style.zIndex = this.options.zIndex;
        }
      },
      _overlayOnError: function _overlayOnError() {
        // @event error: Event
        // Fired when the ImageOverlay layer has loaded its image
        this.fire('error');
        var errorUrl = this.options.errorOverlayUrl;

        if (errorUrl && this._url !== errorUrl) {
          this._url = errorUrl;
          this._image.src = errorUrl;
        }
      }
    }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)

    /**
     * Created by Jeffrey on 2017/12/28.
     */
    /**
     * Prepare a wrapper overlay to put zr's canvas.
     * Effect leaflet's move animation.
     */

    var Wrapper = Layer$1.extend({
      options: {},
      initialize: function initialize(options) {
        setOptions(this, options);
        this._container = null;
      },
      onAdd: function onAdd() {
        if (!this._container) {
          var container = this._container = create$4('div', 'leaflet-vanchart-overlay');
          var originProp = testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
          container.style[originProp] = '50% 50%';

          var size = this._map.getSize();

          container.style.width = size.x + 'px';
          container.style.height = size.y + 'px'; // @CHART-4258, ImageBackgroundLayer和this._container都在leaflet-overlay-pane里面
          // 这里指定一下zIndex, 使得默认this._container在ImageBackgroundLayer上面

          container.style.zIndex = 2;
          container.style.position = 'relative';

          if (this._zoomAnimated) {
            addClass(container, 'leaflet-zoom-animated');
          }
        }

        this.getPane().appendChild(this._container);
      },
      onRemove: function onRemove() {
        remove(this._container);
      },
      getContainer: function getContainer() {
        return this._container;
      },
      // Recover canvas wrapper pos after moving.
      // Put dom in the new right position when refresh.
      // https://github.com/Leaflet/Leaflet.heat/blob/5885ec0ec2442876b67725c64dc537cb12c52c73/src/HeatLayer.js#L113-L114
      syncContainerPos: function syncContainerPos() {
        var topLeft = this._map.containerPointToLayerPoint([0, 0]);

        setPosition(this._container, topLeft);
      },
      getEvents: function getEvents() {
        return {
          resize: this._resize,
          zoom: this._zoom,
          zoomanim: this._zoomanim,
          vanpinch: this._vanpinch
        };
      },
      _resize: function _resize(e) {
        var size = e.newSize;
        var container = this._container;
        container.style.width = size.x + 'px';
        container.style.height = size.y + 'px';
      },
      // Though it's `zoom` event, not `zoomend`,
      // It's fired right after css transition end.
      // This timing is what we need.
      _zoom: function _zoom() {
        this.syncContainerPos();
      },
      // animation start
      _zoomanim: function _zoomanim(e) {
        // FIXME startZoom logic
        var scale = 1;

        if (this._startZoom) {
          scale = this._map.getZoomScale(e.zoom, this._startZoom);
          this._startZoom = null;
        } else {
          scale = this._map.getZoomScale(e.zoom);
        }

        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        setTransform(this._container, offset, scale);
      },
      _vanpinch: function _vanpinch(e) {
        this._startZoom = e.data.startZoom;

        var scale = this._map.getZoomScale(e.zoom, this._startZoom),
            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        setTransform(this._container, offset, scale);
      }
    });

    // https://github.com/ecomfe/echarts/blob/f6c7215e105fd04c64b2f6b9f6bef5e62e4a43d5/src/component/helper/RoamController.js
    // https://github.com/Leaflet/Leaflet/blob/eb9572800df7a6703423e31defebde04e638c6d7/src/dom/Draggable.js
    // 1. move `mirrorDom` below the top layer
    // 2. move Leaflet's dom to mirrorDom
    // 3. insert mirror canvas to mirrorDom-leafletMap-wrapperDom
    // 4. moving
    // 5. recover (hide mirror)
    // Lock to ensure shift canvas only if it has been recovered.
    // Only one interaction at the same time, so we can use one lock.

    var mirrorLock = false;
    /**
     * Shift the target leaflet dom,
     * use mirror canvas to show move animation
     * @param map
     * @param zr
     * @param wrapperDom
     * @param mirrorDom
     * @param bounds
     */

    function mirrorCanvas(map, zr, wrapperDom, mirrorDom, bounds) {
      if (mirrorLock) {
        return;
      }

      mirrorLock = true;
      var mapDom = map.getContainer();
      zr.painter.eachLayer(function (layer, z) {
        if (ShadowLayerZ <= z && z < StaticLayerZ) {
          var m = zr.painter.getLayer(GetMirrorLayerZ(z));
          m.ctx.globalCompositeOperation = 'copy';
          var dpr = layer.dpr;
          var x = bounds.x * dpr,
              y = bounds.y * dpr,
              width = bounds.width * dpr,
              height = bounds.height * dpr;
          m.ctx.drawImage(layer.dom, // source
          x, y, width, height, // destination
          x, y, width, height);
          m.dom.style.visibility = ''; // m.dom.style.background = 'rgba(0, 187, 153, 0.3)';
          // move into view

          setPosition(m.dom, {
            x: -bounds.marginLeft,
            y: -bounds.marginTop
          });

          if (z === -1) {
            addClass(m.dom, 'van-shadow');
          }

          wrapperDom.appendChild(m.dom);
        } else if (z >= StaticLayerZ) {
          mirrorDom.parentNode.insertBefore(mirrorDom, layer.dom);
        }
      });
      mirrorDom.style.visibility = '';
      mirrorDom.appendChild(mapDom);
    }
    /**
     * Recover leaflet dom
     * Hide the mirror canvas
     * @param map
     * @param zr
     * @param container - all maps' container
     */


    function recoverMirrorCanvas(map, zr, container, mirrorDom) {
      var mapDom = map.getContainer();
      container.appendChild(mapDom);
      mirrorDom.style.visibility = 'hidden'; // left mirror canvas in leaflet map wrapper overlay but hide it

      zr.painter.eachLayer(function (layer, z) {
        if (ShadowLayerZ <= z && z < StaticLayerZ) {
          var m = zr.painter.getLayer(GetMirrorLayerZ(z));
          m.dom.style.visibility = 'hidden';
        }
      });
      setTimeout(function () {
        mirrorLock = false;
      }, 0);
    }
    /**
     * Global roam handler
     * For no specific element pan or zoom.
     * e.g. map pan.
     * @param {Object} options
     * @param {ZRender} options.zr - ZRender instance
     * @param {Leaflet} options.map - Leaflet instance
     * @param {Leaflet/Overlay} [options.wrapper] - Leaflet overlay wraps canvas
     * @param {String|Boolean} [options.controlType] - pan / zoom
     * @returns {Function}
     */


    function mapRoam(options) {
      var zr = options.zr,
          map = options.map,
          wrapperDom = options.wrapperDom,
          container = options.container,
          mirrorDom = options.mirrorDom,
          getBounds = options.getBounds,
          dispatch = options.dispatch,
          minZoom = options.minZoom,
          maxZoom = options.maxZoom,
          cellId = options.cellId;

      var _panning, _zooming, _centerPoint, _startLatLng, _pinchStartLatLng, _startZoom, _moved, _zoom, _center, _animRequest; // During panning, capture all mouse events


      var evCover = zr.__vanEvCover || graphic.rect({
        silent: true,
        invisible: true,
        cursor: '-webkit-grabbing',
        z: 10000,
        // todo, how to ensure it's on top?
        style: {
          opacity: 0.5,
          fill: '#0bd'
        }
      });
      zr.add(evCover);
      zr.__vanEvCover = evCover;

      var getCoverShape = function getCoverShape() {
        return {
          x: 0,
          y: 0,
          width: zr.getWidth(),
          height: zr.getHeight()
        };
      };

      function disableHover() {
        if (env$2.touchEventsSupported) {
          return;
        }

        evCover.attr({
          silent: false,
          // invisible: false,
          shape: getCoverShape()
        });
      }

      function enableHover() {
        evCover.attr({
          silent: true,
          // invisible: true,
          shape: getCoverShape()
        });
      }

      function moveDoms() {
        /**
         * Note: 之前的requestAnimationFrame(clearRect)在拖拽图形的时候, handler.hoverTarget变更回导致dispatch(mouseout)给原来的target
         * Note: 从而导致interaction.hide进而plot重新render，所以clearRect无效
         * Note: 然后改成Layer.dom.style.visibility, 又导致得一个问题是, 整个canvas都不可见，那么对应的图例，坐标轴都没了
         * Note: 现在我们来重新理一下，拖拽的时候，只需要复制对应cell中的图形，并清除原有的layer中对应cell中的像素信息
         * Note: 同时要避免hoverTarget变更导致的重绘，这里直接用一个reducer，来控制cellVisible, 当plotVisible为false的时候, 当前拖拽的cell里面的元素不可见
         */
        dispatch(Act.panningCell(cellId));
        mirrorCanvas(map, zr, wrapperDom, mirrorDom, getBounds());
      }

      function recoverDoms() {
        dispatch(Act.panningCell(null));
        recoverMirrorCanvas(map, zr, container, mirrorDom);
      } // fires when zoom animation end


      map.on('zoom', mapZoomHandler);

      function panStartHandler(e) {
        stop$2(e);

        if (_zooming || _panning || mirrorLock) {
          return true;
        }

        _panning = true; // if (notLeftMouse(e)
        //     || !containsPoint(getBounds(), {x: e.offsetX, y: e.offsetY })
        //     || (e.target && (e.target.draggable || e.target.pannable))
        // ) {
        //     return;
        // }

        disableHover();
        moveDoms();
        return true;
      }

      function panMoveHandler(e) {
        stop$2(e);

        if (!_panning) {
          return true;
        } // if (
        //     notLeftMouse(e)
        //     || !panning
        //     || e.gestureEvent === 'pinch'
        // ) {
        //     return;
        // }


        var event = e.event;
        var d = {
          x: -event.deltaX,
          y: -event.deltaY
        };

        if (d.x || d.y) {
          map.panBy(d, {
            animate: false
          });
        }

        return true;
      }

      function panEndHandler(e) {
        if (!_panning) {
          return;
        }

        _panning = false; // if (notLeftMouse(e)) {
        //     return;
        // }

        enableHover();
        syncMapView();
        recoverDoms();
      }

      function mousewheelHandler(e) {
        stop$2(e); // wheelDelta maybe -0 in chrome mac.

        var _e$wheelDelta = e.wheelDelta,
            wheelDelta = _e$wheelDelta === void 0 ? 0 : _e$wheelDelta;
        var _zoom = map._zoom;

        if (wheelDelta === 0 || wheelDelta < 0 && _zoom <= minZoom || wheelDelta > 0 && _zoom >= maxZoom // || !containsPoint(getBounds(), {x: e.offsetX, y: e.offsetY })
        ) {
            return;
          }

        moveDoms(); // leaflet has debounce

        map.scrollWheelZoom._onWheelScroll(e.event);

        return true;
      }

      function pinchStartHandler(e) {
        e = e.event;

        if (!e.touches || e.touches.length !== 2 || map._animatingZoom || _zooming || _panning || mirrorLock) {
          return;
        }

        stop$2(e);
        _centerPoint = map.getSize()._divideBy(2);
        _startLatLng = map.containerPointToLatLng(_centerPoint);

        if (map.options.touchZoom !== 'center') {
          var p1 = map.mouseEventToContainerPoint(e.touches[0]),
              p2 = map.mouseEventToContainerPoint(e.touches[1]);
          _pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
        }

        _startZoom = map.getZoom();
        _moved = false;
        _zooming = true;

        map._stop();

        moveDoms();
        return true;
      }

      function pinchHandler(e) {
        e = e.event;

        if (!e.touches || e.touches.length !== 2 || !_zooming) {
          return;
        }

        stop$2(e);
        var scale = e.zoom;
        _zoom = map.getScaleZoom(scale, _startZoom);

        if (!map.options.bounceAtZoomLimits && (_zoom < map.getMinZoom() && scale < 1 || _zoom > map.getMaxZoom() && scale > 1)) {
          _zoom = map._limitZoom(_zoom);
        }

        if (map.options.touchZoom === 'center') {
          _center = _startLatLng;

          if (scale === 1) {
            return;
          }
        } else {
          var p1 = map.mouseEventToContainerPoint(e.touches[0]),
              p2 = map.mouseEventToContainerPoint(e.touches[1]); // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng

          var delta = p1._add(p2)._divideBy(2)._subtract(_centerPoint);

          if (scale === 1 && delta.x === 0 && delta.y === 0) {
            return;
          }

          _center = map.unproject(map.project(_pinchStartLatLng, _zoom).subtract(delta), _zoom);
        }

        if (!_moved) {
          map._moveStart(true);

          _moved = true;
        }

        cancelAnimFrame(_animRequest);
        var moveFn = bind$1(function (center, zoom, data) {
          this._move(center, zoom, data);

          this.fire('vanpinch', {
            center: center,
            zoom: zoom,
            data: data
          });
        }, map, _center, _zoom, {
          pinch: true,
          round: false,
          startZoom: _startZoom,
          centerPoint: _centerPoint,
          startLatLng: _startLatLng
        });
        _animRequest = requestAnimFrame(moveFn, this, true);
        return true;
      }

      function pinchEndHandler(e) {
        if (!_moved || !_zooming) {
          _zooming = false;
          return;
        }

        _zooming = false;
        cancelAnimFrame(_animRequest);

        var limitedZoom = map._limitZoom(_zoom);

        if (limitedZoom === _zoom) {
          // no zoom
          mapZoomHandler();
        } else {
          // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
          if (map.options.zoomAnimation) {
            map._animateZoom(_center, limitedZoom, true, map.options.zoomSnap);
          } else {
            map._resetView(_center, limitedZoom);
          }
        }

        return true;
      }

      function mapZoomHandler() {
        // FIXME
        if (_zooming) {
          return;
        }

        syncMapView();
        recoverDoms();
      }

      function syncMapView() {
        dispatch(Act.mapChangeView({
          center: _extends({}, map.getCenter()),
          zoom: map.getZoom()
        }));
      } // const debouncedAction = debounce(function (zoomDelta, zoomX, zoomY) {
      //     const global = getState().global;
      //     dispatch('zoom', {
      //         delta: zoomDelta,
      //         x: zoomX,
      //         y: zoomY,
      //         width: global.width,
      //         height: global.height
      //     });
      // }, WHEEL_DEBOUNCE_TIME, true);
      //
      // function zoom(e, zoomDelta, zoomX, zoomY) {
      //     // if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) {
      //     //     // When mouse is out of roamController rect,
      //     //     // default befavoius should not be be disabled, otherwise
      //     //     // page sliding is disabled, contrary to expectation.
      //     //     eventTool.stop(e.event);
      //     //
      //     //     this.trigger('zoom', zoomDelta, zoomX, zoomY);
      //     // }
      //
      //     stop(e.event);
      //     debouncedAction(zoomDelta, zoomX, zoomY);
      // }


      function dispose() {
        map.off('zoom', mapZoomHandler);
      }

      return {
        onpanstart: panStartHandler,
        onpan: panMoveHandler,
        onpanend: panEndHandler,
        onmousewheel: mousewheelHandler,
        onmultipointstart: pinchStartHandler,
        onpinch: pinchHandler,
        ontouchend: pinchEndHandler,
        dispose: dispose,
        moveDoms: moveDoms
      };
    }

    /**
     * Created by Jeffrey on 2017/12/5.
     */

    /*
     * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
     */
    // @namespace Map
    // @section Interaction Options

    Map$2.mergeOptions({
      // @section Mousewheel options
      // @option scrollWheelZoom: Boolean|String = true
      // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
      // it will zoom to the center of the view regardless of where the mouse was.
      scrollWheelZoom: true,
      // @option wheelDebounceTime: Number = 40
      // Limits the rate at which a wheel can fire (in milliseconds). By default
      // user can't zoom via wheel more often than once per 40 ms.
      wheelDebounceTime: 40,
      // @option wheelPxPerZoomLevel: Number = 60
      // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
      // mean a change of one full zoom level. Smaller values will make wheel-zooming
      // faster (and vice versa).
      wheelPxPerZoomLevel: 60
    });
    var ScrollWheelZoom = Handler$1.extend({
      addHooks: function addHooks() {
        on(this._map._container, 'mousewheel', this._onWheelScroll, this);
        this._delta = 0;
      },
      removeHooks: function removeHooks() {
        off(this._map._container, 'mousewheel', this._onWheelScroll, this);
      },
      _onWheelScroll: function _onWheelScroll(e) {
        var delta = getWheelDelta(e);
        var debounce = this._map.options.wheelDebounceTime;
        this._delta += delta;
        this._lastMousePos = this._map.mouseEventToContainerPoint(e);

        if (!this._startTime) {
          this._startTime = +new Date();
        }

        var left = Math.max(debounce - (+new Date() - this._startTime), 0);
        clearTimeout(this._timer);
        this._timer = setTimeout(bind$1(this._performZoom, this), left);
        stop$3(e);
      },
      _performZoom: function _performZoom() {
        var map = this._map,
            zoom = map.getZoom(),
            snap = this._map.options.zoomSnap || 0;

        map._stop(); // stop panning and fly animations if any
        // map the delta with a sigmoid function to -4..4 range leaning on -1..1


        var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
            d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
            d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
            delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
        this._delta = 0;
        this._startTime = null;

        if (!delta) {
          return;
        }

        if (map.options.scrollWheelZoom === 'center') {
          map.setZoom(zoom + delta);
        } else {
          map.setZoomAround(this._lastMousePos, zoom + delta);
        }
      }
    }); // @section Handlers
    // @property scrollWheelZoom: Handler
    // Scroll wheel zoom handler.

    Map$2.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

    /*
     * @class Control
     * @aka L.Control
     * @inherits Class
     *
     * L.Control is a base class for implementing map controls. Handles positioning.
     * All other controls extend from this class.
     */

    var Control = Class.extend({
      // @section
      // @aka Control options
      options: {
        // @option position: String = 'topright'
        // The position of the control (one of the map corners). Possible values are `'topleft'`,
        // `'topright'`, `'bottomleft'` or `'bottomright'`
        position: 'topright'
      },
      initialize: function initialize(options) {
        setOptions(this, options);
      },

      /* @section
       * Classes extending L.Control will inherit the following methods:
       *
       * @method getPosition: string
       * Returns the position of the control.
       */
      getPosition: function getPosition$$1() {
        return this.options.position;
      },
      // @method setPosition(position: string): this
      // Sets the position of the control.
      setPosition: function setPosition$$1(position) {
        var map = this._map;

        if (map) {
          map.removeControl(this);
        }

        this.options.position = position;

        if (map) {
          map.addControl(this);
        }

        return this;
      },
      // @method getContainer: HTMLElement
      // Returns the HTMLElement that contains the control.
      getContainer: function getContainer() {
        return this._container;
      },
      // @method addTo(map: Map): this
      // Adds the control to the given map.
      addTo: function addTo(map) {
        this.remove();
        this._map = map;
        var container = this._container = this.onAdd(map),
            pos = this.getPosition(),
            corner = map._controlCorners[pos];
        addClass(container, 'leaflet-control');

        if (pos.indexOf('bottom') !== -1) {
          corner.insertBefore(container, corner.firstChild);
        } else {
          corner.appendChild(container);
        }

        return this;
      },
      // @method remove: this
      // Removes the control from the map it is currently active on.
      remove: function remove$$1() {
        if (!this._map) {
          return this;
        }

        remove(this._container);

        if (this.onRemove) {
          this.onRemove(this._map);
        }

        this._map = null;
        return this;
      },
      _refocusOnMap: function _refocusOnMap(e) {
        // if map exists and event is not a keyboard event
        if (this._map && e && e.screenX > 0 && e.screenY > 0) {
          this._map.getContainer().focus();
        }
      }
    });
    /* @section Extension methods
     * @uninheritable
     *
     * Every control should extend from `L.Control` and (re-)implement the following methods.
     *
     * @method onAdd(map: Map): HTMLElement
     * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
     *
     * @method onRemove(map: Map)
     * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
     */

    /* @namespace Map
     * @section Methods for Layers and Controls
     */

    Map$2.include({
      // @method addControl(control: Control): this
      // Adds the given control to the map
      addControl: function addControl(control) {
        control.addTo(this);
        return this;
      },
      // @method removeControl(control: Control): this
      // Removes the given control from the map
      removeControl: function removeControl(control) {
        control.remove();
        return this;
      },
      _initControlPos: function _initControlPos() {
        var corners = this._controlCorners = {},
            l = 'leaflet-',
            container = this._controlContainer = create$4('div', l + 'control-container', this._container);

        function createCorner(vSide, hSide) {
          var className = l + vSide + ' ' + l + hSide;
          corners[vSide + hSide] = create$4('div', className, container);
        }

        createCorner('top', 'left');
        createCorner('top', 'right');
        createCorner('bottom', 'left');
        createCorner('bottom', 'right');
      },
      _clearControlPos: function _clearControlPos() {
        for (var i in this._controlCorners) {
          remove(this._controlCorners[i]);
        }

        remove(this._controlContainer);
        delete this._controlCorners;
        delete this._controlContainer;
      }
    });

    /*
     * @class Control.Zoom
     * @aka L.Control.Zoom
     * @inherits Control
     *
     * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
     */

    var Zoom = Control.extend({
      // @section
      // @aka Control.Zoom options
      options: {
        position: 'topleft',
        // @option zoomInText: String = '+'
        // The text set on the 'zoom in' button.
        zoomInText: '+',
        // @option zoomInTitle: String = 'Zoom in'
        // The title set on the 'zoom in' button.
        zoomInTitle: 'Zoom in',
        // @option zoomOutText: String = '&#x2212;'
        // The text set on the 'zoom out' button.
        zoomOutText: '&#x2212;',
        // @option zoomOutTitle: String = 'Zoom out'
        // The title set on the 'zoom out' button.
        zoomOutTitle: 'Zoom out'
      },
      onAdd: function onAdd(map) {
        var zoomName = 'leaflet-control-zoom',
            container = create$4('div', zoomName + ' leaflet-bar'),
            options = this.options;
        this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

        this._updateDisabled();

        map.on('zoomend zoomlevelschange', this._updateDisabled, this);
        return container;
      },
      onRemove: function onRemove(map) {
        map.off('zoomend zoomlevelschange', this._updateDisabled, this);
      },
      disable: function disable() {
        this._disabled = true;

        this._updateDisabled();

        return this;
      },
      enable: function enable() {
        this._disabled = false;

        this._updateDisabled();

        return this;
      },
      _zoomIn: function _zoomIn(e) {
        if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
          this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        }
      },
      _zoomOut: function _zoomOut(e) {
        if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
          this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
        }
      },
      _createButton: function _createButton(html, title, className, container, fn) {
        var link = create$4('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;
        /*
         * Will force screen readers like VoiceOver to read this as "Zoom in - button"
         */

        link.setAttribute('role', 'button');
        link.setAttribute('aria-label', title);
        disableClickPropagation(link);
        on(link, 'click', stop$3);
        on(link, 'click', fn, this);
        on(link, 'click', this._refocusOnMap, this);
        return link;
      },
      _updateDisabled: function _updateDisabled() {
        var map = this._map,
            className = 'leaflet-disabled';
        removeClass(this._zoomInButton, className);
        removeClass(this._zoomOutButton, className);

        if (this._disabled || map._zoom === map.getMinZoom()) {
          addClass(this._zoomOutButton, className);
        }

        if (this._disabled || map._zoom === map.getMaxZoom()) {
          addClass(this._zoomInButton, className);
        }
      }
    }); // @namespace Map
    // @section Control options
    // @option zoomControl: Boolean = true
    // Whether a [zoom control](#control-zoom) is added to the map by default.

    Map$2.mergeOptions({
      zoomControl: true
    });
    Map$2.addInitHook(function () {
      if (this.options.zoomControl) {
        this.zoomControl = new Zoom();
        this.addControl(this.zoomControl);
      }
    }); // @namespace Control.Zoom

    var originalInitTile = GridLayer.prototype._initTile; // NOTE GIS瓦片在.5zoom时在chrome下会有间隙，参考BI-16817

    GridLayer.include({
      _initTile: function _initTile(tile) {
        originalInitTile.call(this, tile);
        var tileSize = this.getTileSize();
        tile.style.width = tileSize.x + 1 + 'px';
        tile.style.height = tileSize.y + 1 + 'px';
      }
    });

    var originZoomIn = _.debounce(Zoom.prototype._zoomIn, 40);

    var originZoomOut = _.debounce(Zoom.prototype._zoomOut, 40);

    Zoom.include({
      _zoomIn: function _zoomIn(e) {
        this.options.beforeZoomIn && this.options.beforeZoomIn.call(this, e);
        originZoomIn.call(this, e);
      },
      _zoomOut: function _zoomOut(e) {
        this.options.beforeZoomOut && this.options.beforeZoomOut.call(this, e);
        originZoomOut.call(this, e);
      }
    });

    /**
     * Created by Jeffrey on 2018/7/12.
     */
    var EMPTY_FN = function EMPTY_FN() {
      return {};
    };
    /**
     * keep a shared object `Van.Request` for global use & implement
     */
    // http://www.finedevelop.com/pages/viewpage.action?pageId=29530322
    // 需要扩展的接口


    var Request = {
      getSetting: EMPTY_FN,
      requestData: EMPTY_FN,
      getCompleteUrl: EMPTY_FN
    }; // 图表内部调用

    Request.services = {
      refresh: EMPTY_FN,
      filter: EMPTY_FN,
      tooltipInfo: EMPTY_FN
    }; // 图表内部调用

    Request.urls = {
      image: EMPTY_FN,
      tileImage: EMPTY_FN
    };

    /*

    地图整合
    关键：
    leaflet只是底图，我们控制交互，通过触发L的事件实现移动、缩放地图。
    文件：
    `Pane.js` 是leaflet map的包装。利用react的生命周期初始化，更新，销毁。
    `Wrapper.js` 是一个leaflet overlay。准备这样一个overlay用来放置zr canvas，便于控制。
    `mapRoam.js` 是交互控制器。除事件处理外，还包含了交互过程中dom处理。
    实现：
    麻烦在于，要同时考虑抽象view和实际dom，最终达到视觉效果无缝衔接。
    Pane初始化map，把map dom插入root dom。
    准备好map dom（与wrapper overlay）后，加上我们的控制器。这里为了和model统一，写成dispatch effect。
    以pan为例
    -- mousedown
    -> 判断处理pan
    -> panstart
       覆盖一层rect，防止拖动时错误hover（因为拖动过 程中zr仍然认为图形在原位置上）
       处理dom：1. 把目标区域L dom放置到zr canvas之上，但在图例canvas下面。
               2. 从zr获得新layer（mirror canvas），复制目标区域图像。放置到map wrapper overlay中。
    -> panning
       `map.panBy`，这样map的dom是一起移动的，覆盖的mirror canvas也一起移动。
    -> panend
       隐藏覆盖层rect
       刷新重绘，同步其他分区
       处理dom：恢复map dom到root下，zIndex = -1。隐藏mirror canvas。
    注意timing，dispatch action后触发render是异步的；并且zr刷新在下一帧。需要考虑到这一点。

    zoom类似。但zoom的配合需要更紧密。
    `zoomanim`(start) wrapper 改变transform 以实现缩放动画以鼠标为中心。
    `zoom`时已经结束zoom动画，恢复，刷新。时间没配合好就会看见闪烁。

    */

    /**
     * get leaflet container
     * @param root
     * @param width
     * @param height
     * @returns {HTMLDivElement}
     */

    function getDom(root, width, height) {
      var dom = document.createElement('div');
      var s = dom.style;
      s.position = 'absolute';
      s.width = width + 'px';
      s.height = height + 'px';
      s.margin = '0';
      s.padding = '0';
      s.border = 'none';
      root.appendChild(dom);
      return dom;
    }

    var ZOOM_IN = 'zoom In';
    var ZOOM_OUT = 'zoom Out';
    var ZOOM_DELTA = 0.2;
    var ZOOM_SNAP = 0.1;
    var Pane =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Pane, _Component);

      function Pane(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        _this.dom = null; // leaflet container

        _this.map = null; // leaflet

        _this.zrWrapper = null; // a leaflet overlay wraps zr's canvas dom

        _this._unsubscribeRoam = null;
        return _this;
      }

      var _proto = Pane.prototype;

      _proto.componentWillMount = function componentWillMount() {
        var _this2 = this;

        var _this$props = this.props,
            _this$props$bounds = _this$props.bounds,
            width = _this$props$bounds.width,
            height = _this$props$bounds.height,
            _this$props$mapConfig = _this$props.mapConfig,
            crs = _this$props$mapConfig.crs,
            center = _this$props$mapConfig.center,
            zoom = _this$props$mapConfig.zoom,
            _this$props$mapConfig2 = _this$props$mapConfig.zoomInTitle,
            zoomInTitle = _this$props$mapConfig2 === void 0 ? ZOOM_IN : _this$props$mapConfig2,
            _this$props$mapConfig3 = _this$props$mapConfig.zoomOutTitle,
            zoomOutTitle = _this$props$mapConfig3 === void 0 ? ZOOM_OUT : _this$props$mapConfig3,
            _this$props$mapConfig4 = _this$props$mapConfig.minZoom,
            minZoom = _this$props$mapConfig4 === void 0 ? DEFAULT_MIN_ZOOM : _this$props$mapConfig4,
            _this$props$mapConfig5 = _this$props$mapConfig.maxZoom,
            maxZoom = _this$props$mapConfig5 === void 0 ? DEFAULT_MAX_ZOOM : _this$props$mapConfig5,
            gis = _this$props$mapConfig.gis,
            isMobile = _this$props.isMobile,
            root = _this$props.root,
            dispatch = _this$props.dispatch,
            zr = _this$props.zr,
            xIndex = _this$props.xIndex,
            yIndex = _this$props.yIndex,
            cellId = _this$props.cellId;
        this.dom = getDom(root, width, height);
        this.zrWrapper = new Wrapper();
        this.map = new Map$2(this.dom, {
          layers: [this.zrWrapper],
          crs: CRS[crs],
          // inertia: false,
          zoomControl: false,
          center: center,
          zoom: zoom,
          touchZoom: 'center',
          attributionControl: false,
          trackResize: false,
          fadeAnimation: false,
          minZoom: gis.enabled ? minZoom : DEFAULT_MIN_ZOOM,
          maxZoom: gis.enabled ? maxZoom : DEFAULT_MAX_ZOOM,
          zoomDelta: ZOOM_DELTA,
          zoomSnap: ZOOM_SNAP
        });

        if (isMobile) {
          addClass(this.map._container, 'leaflet-touch-zoom');
        } // FixME


        if (!isMobile && xIndex + yIndex === 0) {
          // window._map = this.map;
          this.zoomControl = new Zoom({
            zoomInTitle: zoomInTitle,
            zoomOutTitle: zoomOutTitle,
            beforeZoomIn: function beforeZoomIn(e) {
              stop$2(e);
              zoom < maxZoom && _this2.moveDoms && _this2.moveDoms();
            },
            beforeZoomOut: function beforeZoomOut(e) {
              stop$2(e);
              zoom > minZoom && _this2.moveDoms && _this2.moveDoms();
            }
          }).addTo(this.map);

          zr.painter._domRoot.appendChild(this.map._controlContainer);
        }

        this.updateMapLayer(this.props);
        this.updateTileAndControlDomPos(this.props); // integrate ZRender & Leaflet
        // todo, put in container?

        var handler = mapRoam({
          dispatch: dispatch,
          getBounds: function getBounds() {
            var _this2$props = _this2.props,
                _this2$props$bounds = _this2$props.bounds,
                x = _this2$props$bounds.x,
                y = _this2$props$bounds.y,
                width = _this2$props$bounds.width,
                height = _this2$props$bounds.height,
                _this2$props$shifting = _this2$props.shifting,
                tx = _this2$props$shifting[0],
                ty = _this2$props$shifting[1],
                plot = _this2$props.plot;
            var cell = {
              x: x + tx,
              y: y + ty,
              width: width,
              height: height
            };
            var visible = {
              x: plot.x,
              y: plot.y,
              width: plot.width,
              height: plot.height
            }; // FIXME
            // 各种bounds、offset违反了SSOT原则，互相一堆扯不清的冗余信息 →_→
            // 减去边框线1px
            // 防止拖动时候连边框一起动
            // 精细判断的话还要判断是不是在边界……搞不动了先这么搞吧

            var d = 1; // intersect

            var visibleCellBoundsX = Math.max(cell.x, visible.x),
                visibleCellBoundsY = Math.max(cell.y, visible.y);
            return {
              x: visibleCellBoundsX + d,
              y: visibleCellBoundsY + d,
              width: Math.min(cell.x + cell.width, visible.x + visible.width) - visibleCellBoundsX - 2 * d,
              height: Math.min(cell.y + cell.height, visible.y + visible.height) - visibleCellBoundsY - 2 * d,
              // 放在tile dom中的mirror dom需要偏移，以保证可视范围
              marginLeft: cell.x,
              marginTop: cell.y
            };
          },
          container: root,
          wrapperDom: this.zrWrapper.getContainer(),
          map: this.map,
          mirrorDom: this.props.mirrorDom,
          zr: zr,
          minZoom: minZoom,
          maxZoom: maxZoom,
          cellId: cellId
        });
        assign(this, handler);
      };

      _proto.updateMapLayer = function updateMapLayer(props) {
        var mapConfig = props.mapConfig;
        var _mapConfig$gis = mapConfig.gis,
            url = _mapConfig$gis.url,
            enabled = _mapConfig$gis.enabled,
            type = _mapConfig$gis.type,
            _mapConfig$gis$wmslay = _mapConfig$gis.wmslayers,
            wmslayers = _mapConfig$gis$wmslay === void 0 ? {} : _mapConfig$gis$wmslay,
            imageBackground = mapConfig.imageBackground;
        var lastLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;
        this._imageBackgroundLayer = this._tileLayer = this._wmsLayer = null;

        if (!enabled) {
          lastLayer && lastLayer.remove();
          return;
        }

        this._imageMap = !!imageBackground;

        if (this._imageMap) {
          var id = imageBackground.id,
              width = imageBackground.width,
              height = imageBackground.height,
              imageScale = imageBackground.imageScale;
          var imageUrl = Request.urls.image(id);

          var w = width * imageScale,
              _h = height * imageScale;

          var bounds = [[0, 0], [_h, w]];
          var sameUrl = lastLayer && lastLayer._url === imageUrl;
          var sameSize = this._imageBackgroundSize && w === this._imageBackgroundSize[0] && _h === this._imageBackgroundSize[1];

          if (sameUrl && sameSize) {
            this._imageBackgroundLayer = lastLayer;
          } else {
            this._imageBackgroundLayer = new ImageOverlay(imageUrl, bounds).addTo(this.map);
            this._imageBackgroundSize = [w, _h];
          }
        } else if (url) {
          if (type === 'tileLayer') {
            this._tileLayer = lastLayer && lastLayer._url === url ? lastLayer : new TileLayer(url, {
              interactive: false
            }).addTo(this.map);
          } else if (type === 'wmsLayer') {
            var layers = _.reduce(wmslayers, function (selected, v, k) {
              v && selected.push(k);
              return selected;
            }, []).join();

            if (lastLayer && lastLayer._url === url && lastLayer.options.layers === layers) {
              this._wmsLayer = lastLayer;
            } else {
              this._wmsLayer = new TileLayerWMS(url, {
                layers: layers
              }).addTo(this.map);
            }
          }
        }

        var currentLayer = this._imageBackgroundLayer || this._tileLayer || this._wmsLayer;

        if (currentLayer !== lastLayer) {
          lastLayer && lastLayer.remove();
        }
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var bounds = nextProps.bounds,
            mapConfig = nextProps.mapConfig; // resize

        if (!shallowEqual(this.props.bounds, bounds)) {
          var width = bounds.width,
              height = bounds.height;
          var s = this.dom.style;
          s.width = width + 'px';
          s.height = height + 'px';
          this.map.invalidateSize();
        }

        var enabled = mapConfig.gis.enabled,
            _mapConfig$minZoom = mapConfig.minZoom,
            minZoom = _mapConfig$minZoom === void 0 ? DEFAULT_MIN_ZOOM : _mapConfig$minZoom,
            _mapConfig$maxZoom = mapConfig.maxZoom,
            maxZoom = _mapConfig$maxZoom === void 0 ? DEFAULT_MAX_ZOOM : _mapConfig$maxZoom;
        this.map.setMinZoom(enabled ? minZoom : DEFAULT_MIN_ZOOM);
        this.map.setMaxZoom(enabled ? maxZoom : DEFAULT_MAX_ZOOM);
        this.updateMapLayer(nextProps);
        this.updateTileAndControlDomPos(nextProps);
        this.updateZoomControlTitle(mapConfig);
      };

      _proto.updateTileAndControlDomPos = function updateTileAndControlDomPos(_ref) {
        var _ref$bounds = _ref.bounds,
            x = _ref$bounds.x,
            y = _ref$bounds.y,
            width = _ref$bounds.width,
            height = _ref$bounds.height,
            _ref$shifting = _ref.shifting,
            tx = _ref$shifting[0],
            ty = _ref$shifting[1],
            _ref$plot = _ref.plot,
            px = _ref$plot.x,
            py = _ref$plot.y,
            darkTheme = _ref.darkTheme;
        var s = this.dom.style;
        s.width = width + 'px';
        s.height = height + 'px'; // 要考虑的东西比较多........

        x += tx - px;
        y += ty - py;
        setPosition(this.dom, {
          x: x,
          y: y
        });

        if (this.zoomControl) {
          setPosition(this.map._controlContainer, {
            x: px,
            y: py
          });
          this.map._controlContainer.className = 'leaflet-control-container' + (darkTheme ? ' leaflet-control-dark' : '');
        }
      };

      _proto.updateZoomControlTitle = function updateZoomControlTitle(_ref2) {
        var _ref2$zoomInTitle = _ref2.zoomInTitle,
            zoomInTitle = _ref2$zoomInTitle === void 0 ? ZOOM_IN : _ref2$zoomInTitle,
            _ref2$zoomOutTitle = _ref2.zoomOutTitle,
            zoomOutTitle = _ref2$zoomOutTitle === void 0 ? ZOOM_OUT : _ref2$zoomOutTitle;

        if (this.zoomControl) {
          this.zoomControl._zoomInButton.title = zoomInTitle;
          this.zoomControl._zoomOutButton.title = zoomOutTitle;
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.dispose(); // todo, recycle it

        this.map.remove();
        this.dom.parentElement.removeChild(this.dom);
      };

      _proto.render = function render$$1() {
        var _this$props2 = this.props,
            _this$props2$bounds = _this$props2.bounds,
            x = _this$props2$bounds.x,
            y = _this$props2$bounds.y,
            width = _this$props2$bounds.width,
            height = _this$props2$bounds.height,
            _this$props2$mapConfi = _this$props2.mapConfig,
            zoom = _this$props2$mapConfi.zoom,
            center = _this$props2$mapConfi.center,
            crs = _this$props2$mapConfi.crs; // 1. sync map view if not equal

        this.map.setView(center, zoom, {
          animate: false
        }); // 2. after sync view

        this.zrWrapper.syncContainerPos(); // TODO, 结合MapCell里面，简化map的各种偏移

        var c = CRS[crs],
            _c$latLngToPoint = c.latLngToPoint(center, zoom),
            cx = _c$latLngToPoint.x,
            cy = _c$latLngToPoint.y;

        var position = [x + width / 2 - cx, y + height / 2 - cy]; // give it a normal Node to enable render

        return h('group', {
          position: position,
          onpanstart: this.onpanstart,
          onpan: this.onpan,
          onpanend: this.onpanend,
          onmousewheel: this.onmousewheel,
          onmultipointstart: this.onmultipointstart,
          onpinch: this.onpinch,
          ontouchend: this.ontouchend
        }, h('rect', {
          invisible: true,
          // style: {
          //     opacity: 0.5,
          //     fill: this.props.xIndex ? '#0b9' : '#e55'
          // },
          shape: {
            // →_→已经搞不清怎么偏的了，面向bug编程
            x: cx - width / 2,
            y: cy - height / 2,
            width: width,
            height: height
          }
        }), this.props.children);
      };

      return Pane;
    }(Component);

    var getScaleZoom = function getScaleZoom(Crs, scale, fromZoom) {
      var zoom = Crs.zoom(scale * Crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    };

    var calcMapAutoZoom = function calcMapAutoZoom(state) {
      var mapConfig = state.mapConfig,
          facetX = state.facetX,
          facetY = state.facetY;
      var crs = mapConfig.crs,
          _mapConfig$minZoom = mapConfig.minZoom,
          minZoom = _mapConfig$minZoom === void 0 ? DEFAULT_MIN_ZOOM : _mapConfig$minZoom,
          _mapConfig$maxZoom = mapConfig.maxZoom,
          maxZoom = _mapConfig$maxZoom === void 0 ? DEFAULT_MAX_ZOOM : _mapConfig$maxZoom;
      var Crs = getCrs(crs);
      var _mapConfig$bounds = mapConfig.bounds,
          northEast = _mapConfig$bounds.northEast,
          southWest = _mapConfig$bounds.southWest;

      var _Crs$latLngToPoint = Crs.latLngToPoint(southWest, DEFAULT_ZOOM),
          x1 = _Crs$latLngToPoint.x,
          y1 = _Crs$latLngToPoint.y;

      var _Crs$latLngToPoint2 = Crs.latLngToPoint(northEast, DEFAULT_ZOOM),
          x2 = _Crs$latLngToPoint2.x,
          y2 = _Crs$latLngToPoint2.y;

      var width = Math.abs(x1 - x2),
          height = Math.abs(y1 - y2);
      var snap = env$2.any3d ? ZOOM_SNAP : 1;
      var _ref = [facetX.unit, facetY.unit],
          cw = _ref[0],
          ch = _ref[1];
      var scale = Math.min(cw / width, ch / height);

      var _zoom = getScaleZoom(Crs, scale, DEFAULT_ZOOM);

      if (snap) {
        _zoom = Math.round(_zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level

        _zoom = Math.floor(_zoom / snap) * snap;
      }

      _zoom = isFinite(_zoom) ? Math.min(Math.max(_zoom, minZoom), maxZoom) : DEFAULT_ZOOM; // recalculate Center

      var _Crs$latLngToPoint3 = Crs.latLngToPoint(southWest, DEFAULT_ZOOM),
          swx = _Crs$latLngToPoint3.x,
          swy = _Crs$latLngToPoint3.y,
          _Crs$latLngToPoint4 = Crs.latLngToPoint(northEast, DEFAULT_ZOOM),
          nex = _Crs$latLngToPoint4.x,
          ney = _Crs$latLngToPoint4.y;

      if (!mapConfig.center) {
        mapConfig.center = Crs.pointToLatLng({
          x: (swx + nex) / 2,
          y: (swy + ney) / 2
        }, DEFAULT_ZOOM);
      }

      return _zoom;
    };

    function createLatLngBounds(southWest, northEast) {
      return {
        southWest: southWest,
        northEast: northEast
      };
    }

    function createLatLng(lat, lng) {
      return {
        lat: lat,
        lng: lng
      };
    }

    var WORLD_BOUNDS = createLatLngBounds(createLatLng(SOUTH, WEST), createLatLng(NORTH, EAST));

    /**
     * 从一组边界中计算出最大的边界范围
     * @param boundsList
     * @returns {{southWest, northEast}}
     */

    function getBoundingBounds(boundsList) {
      if (!boundsList.length) {
        return WORLD_BOUNDS;
      }

      var west = EAST,
          east = WEST,
          south = NORTH,
          north = SOUTH,
          southWest,
          northEast;

      for (var i = 0, len = boundsList.length; i < len; i++) {
        var _boundsList$i = boundsList[i];
        southWest = _boundsList$i.southWest;
        northEast = _boundsList$i.northEast;
        south = Math.min(south, southWest.lat);
        west = Math.min(west, southWest.lng);
        north = Math.max(north, northEast.lat);
        east = Math.max(east, northEast.lng);
      }

      return createLatLngBounds(createLatLng(south, west), createLatLng(north, east));
    }

    /**
     * 一维经纬度数组边界计算
     * @param coordinates
     * @param limit
     * @returns {{southWest, northEast}}
     */

    function getPointsLatLngBounds(coordinates) {
      var west = EAST,
          east = WEST,
          south = NORTH,
          north = SOUTH;

      for (var i = 0, len = coordinates.length, lng, lat; i < len; i++) {
        var _coordinates$i = coordinates[i];
        lng = _coordinates$i[0];
        lat = _coordinates$i[1];
        west = Math.min(west, lng);
        east = Math.max(east, lng);
        south = Math.min(south, lat);
        north = Math.max(north, lat);
      }

      return createLatLngBounds(createLatLng(south, west), createLatLng(north, east));
    }

    /**
     *  二维维经纬度数组
     * @param coordinates
     * @param limit
     * @returns {{southWest, northEast}}
     */

    var calcPolygonBounds = function calcPolygonBounds(coordinates) {
      return getBoundingBounds(_.map(coordinates, function (coordinate) {
        return getPointsLatLngBounds(coordinate);
      }));
    };
    /**
     * 从Geometry中计算边界范围
     * @param geometry
     * @param properties
     * @returns {{southWest, northEast}}
     */


    function calcGeometryBounds(geometry, properties) {
      if (properties === void 0) {
        properties = {};
      }

      var type = geometry.type,
          coordinates = geometry.coordinates;
      var _properties = properties,
          bbox = _properties.bbox;

      if (bbox && bbox.length) {
        var west = bbox[0],
            south = bbox[1],
            east = bbox[2],
            north = bbox[3];
        return createLatLngBounds(createLatLng(south, west), createLatLng(north, east));
      }

      var latLng;

      switch (type) {
        // 3维经纬度数组
        case MULTI_POLYGON:
          return getBoundingBounds(_.map(coordinates, function (coord) {
            return calcPolygonBounds(coord);
          }));

        case POLYGON:
        case MULTI_LINE_STRING:
          return calcPolygonBounds(coordinates);

        case LINE_STRING:
        case MULTI_POINT:
          return getPointsLatLngBounds(coordinates);

        case POINT:
          latLng = createLatLng(coordinates[0], coordinates[1]);
          return createLatLngBounds(createLatLng(latLng, latLng));

        case GEOMETRY_COLLECTION:
          return getBoundingBounds(_.map(geometry.geometries, function (geo) {
            return calcGeometryBounds(geo, properties);
          }));

        default:
          return WORLD_BOUNDS;
      }
    }

    /**
     * 点地图的边界范围从geomData中的lat&lng列数据中计算
     * @param geoms
     */

    var getPointMapBounds = function getPointMapBounds(geoms) {
      var east = WEST,
          west = EAST,
          north = SOUTH,
          south = NORTH;

      _.each(geoms, function (geom) {
        var latCol = geom.data.getColById(LAT),
            lngCol = geom.data.getColById(LNG);

        _.each(latCol, function (v) {
          if (v !== NULL_VALUE) {
            north = Math.max(v, north);
            south = Math.min(v, south);
          }
        });

        _.each(lngCol, function (v) {
          if (v !== NULL_VALUE) {
            east = Math.max(v, east);
            west = Math.min(v, west);
          }
        });
      });

      return createLatLngBounds(createLatLng(south, west), createLatLng(north, east));
    };
    /**
     * 从features中计算出地图的边界范围
     * @param features
     * @returns {{southWest, northEast}}
     */


    var calcFeaturesMapBounds = function calcFeaturesMapBounds(features) {
      return getBoundingBounds(_.map(features, function (feature) {
        return calcGeometryBounds(feature.geometry, feature.properties);
      }));
    };

    var calcMapBounds = function calcMapBounds(state) {
      var geoms = state.geoms,
          mapConfig = state.mapConfig;
      var nameMatched = mapConfig.nameMatched,
          imageBackground = mapConfig.imageBackground;

      if (imageBackground) {
        var _imageBackground$imag = imageBackground.imageScale,
            imageScale = _imageBackground$imag === void 0 ? 1 : _imageBackground$imag,
            width = imageBackground.width,
            height = imageBackground.height;
        return {
          southWest: {
            lat: 0,
            lng: 0
          },
          northEast: {
            lat: height * imageScale,
            lng: width * imageScale
          }
        };
      } // NOTE 当且仅当名称匹配的区域地图，才需要从features里面计算bounds


      var useAreaFeatures = nameMatched && geoms.length && geoms[0].type === ChartLibrary.AREA_MAP;
      return useAreaFeatures ? calcFeaturesMapBounds(mapConfig.features) : getPointMapBounds(geoms);
    };

    function dealMapChartLayout(state) {
      var mapConfig = state.mapConfig,
          enableMap = state.enableMap,
          size = state.size;

      if (!mapConfig || !enableMap) {
        return;
      }

      var imageBackground = mapConfig.imageBackground;

      if (imageBackground) {
        var width = size.width,
            height = size.height;
        mapConfig.imageBackground = _extends({}, mapConfig.imageBackground, {
          imageScale: Math.min(height / imageBackground.height, width / imageBackground.width)
        });
      }

      mapConfig.bounds = calcMapBounds(state);

      if (!mapConfig.fixedZoom) {
        mapConfig.zoom = calcMapAutoZoom(state);
      }
    }

    var TOP_GAP = 3;
    var GAP = 7;
    function trainFacetScale$1(state) {
      trainScale(state);
      updateFacetMeasurePosition(state);
    }

    function getChartBounds(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          plotBounds = state.plotBounds;

      var _collectFacetTickAndT = collectFacetTickAndTitleSize(facetX),
          bottom = _collectFacetTickAndT[0],
          top = _collectFacetTickAndT[1];

      var _collectFacetTickAndT2 = collectFacetTickAndTitleSize(facetY),
          left = _collectFacetTickAndT2[0],
          right = _collectFacetTickAndT2[1]; // chartBounds = plotBounds + facetSize


      return plotBounds.clone().padding(-top, -right, -bottom, -left);
    }
    /**
     * layout & bounds calculation
     * @returns {function(*=): *}
     */


    var createLayoutSelector = function createLayoutSelector() {
      return function (state) {
        var isMobile = state.isMobile,
            _state$size = state.size,
            width = _state$size.width,
            height = _state$size.height; // Note 这里我们只考虑plot即绘图区, 对于其他的辅助性的bounds计算, 在clipPlotBounds的过程中确定下来

        /**
         * bounds: size - padding
         * clipBounds: bounds - legend
         * plotBounds: overflow:hidden graphic area
         * scrollBounds: overflow:auto graphic area
         * chartBounds: plotBounds + facet
         */

        var bounds = state.bounds = new ChartBounds(width, height).padding(TOP_GAP, GAP, GAP, GAP);
        var plotBounds = state.plotBounds = bounds.clone(); // 计算图例, 并裁剪图例占用的尺寸

        isMobile ? mobileLegendLayout(state) : legendLayout(state); // 这里记录一下clipBounds, 即去除图例的尺寸, 用于轴区间交互时, 计算轴线最大拖动位置

        state.clipBounds = plotBounds.clone(); // facet的size计算，涵盖指标和维度字段生成的标签和标题的大小，即横向计算height,纵向计算width
        // 然后在对应的方向上裁剪facet占用的尺寸

        facetLayout(state); // 在剩下的区间内做自适应的处理，计算出facet.unit

        fitLayout(state);
        plotBounds.width = Math.min(plotBounds.width, getFacetLength(state.facetX));
        plotBounds.height = Math.min(plotBounds.height, getFacetLength(state.facetY)); // update facet node pos & length when facet unit is calculated

        updateFacetNodesPosition(state);
        state.chartBounds = getChartBounds(state);
        trainFacetScale$1(state); // update map.bounds & auto zoom

        dealMapChartLayout(state);
        return state;
      };
    };

    var getForecastUpperId = function getForecastUpperId(m) {
      return m + UPPER_LIMIT;
    };
    var getForecastLowerId = function getForecastLowerId(m) {
      return m + LOWER_LIMIT;
    };

    var STACK_START = 0;
    var LOG_STACK_START = 1;
    var getValueAxisStartValue = function getValueAxisStartValue(logBase) {
      return logBase ? LOG_STACK_START : STACK_START;
    }; // cache scale

    var linearScale = linear$2(),
        logScale = log$2();
    /**
     * 位置计算的Scale
     * @param domain
     * @param range
     * @param logBase
     * @returns {Function}
     */

    var getPositionScale = function getPositionScale(domain, range, logBase) {
      var scale = logBase ? logScale.base(logBase) : linearScale;
      scale.domain(domain).range(range);
      return function (value) {
        if (logBase && value <= 0) {
          return NaN;
        }

        if (!isMeaningfulNumericValue(value)) {
          return NaN;
        }

        return scale(value);
      };
    };

    function calculatePosition(_ref) {
      var row = _ref.row,
          measure = _ref.measure,
          measureDef = _ref.measureDef,
          geomFacet = _ref.geomFacet,
          baseFacet = _ref.baseFacet,
          stackMap = _ref.stackMap,
          domain = _ref.domain,
          filter = _ref.filter,
          measureDefKey = _ref.measureDefKey,
          noPrev = _ref.noPrev,
          forecast = _ref.forecast;
      var vanishChecker = getVanishChecker(filter);
      var nodesMap = geomFacet.nodesMap;
      var geomDimId = getDimensionId$1(geomFacet, row),
          geomNode = nodesMap[geomDimId] || nodesMap[NODE_ROOT];

      if (!measureDef) {
        var center = geomNode.pos + geomNode.length / 2;
        return noPrev ? center : [center, center];
      }

      var logBase = measureDef.logBase;
      var value = +row[measure],
          stackStart = getValueAxisStartValue(logBase),
          preSum = stackStart;

      if (stackMap) {
        var baseDimId = getDimensionId$1(baseFacet, row),
            stackId = baseDimId + SEPARATOR + geomDimId + (value > 0 ? POSITIVE_SUFFIX : NEGATIVE_SUFFIX);
        preSum = stackMap[stackId] == null ? stackStart : stackMap[stackId];
        stackMap[stackId] = preSum + (vanishChecker(row) ? 0 : value);
        preSum -= logBase && preSum > 1 ? stackStart : 0;
        value += preSum;
      }

      var range = geomNode.measurePosMap[measureDefKey];
      var scale = getPositionScale(domain, range, logBase); // x pos

      if (noPrev) {
        return scale(value);
      } else {
        // y & y0
        var output = [scale(value), scale(preSum)]; // upper && lower

        if (forecast) {
          output.push(scale(+row[getForecastUpperId(measure)]));
          output.push(scale(+row[getForecastLowerId(measure)]));
        }

        return output;
      }
    }

    var POSITION_Y = 'y';
    var POSITION_Y0 = 'y0';

    var getAxisDomain = function getAxisDomain(facet, measureDefKey) {
      return facet.scaleMap[measureDefKey] && facet.scaleMap[measureDefKey].domain;
    };

    function dealPositionOnGeom(geoms, baseFacet, geomFacet, state) {
      var filter = state.tagFilter,
          defs = state.defs;
      var frameMeasures = getAllMeasuresOnFacet$1(baseFacet),
          frameCount = frameMeasures.length || 1; // for sharedAxis stack

      var sumStackMap = {};
      var frameMeasureCache = {},
          getFrameMeasureDefKey = createGetMeasureDefKeyFunc$1(baseFacet);

      for (var i = 0; i < frameCount; i++) {
        var id = frameMeasures[i];

        if (id != null) {
          var measureDefKey = getFrameMeasureDefKey(id);
          frameMeasureCache[id] = {
            def: defs[measureDefKey],
            frameMeasureDefKey: measureDefKey,
            domain: getAxisDomain(baseFacet, measureDefKey)
          };
        }
      }

      _.each(geoms, function (geom) {
        var data = geom.data,
            stack = geom.stack,
            measure = geom.measure,
            frames = geom.frames,
            forecastIndex = geom.forecastIndex;
        var getGeomMeasureDefKey = createGetMeasureDefKeyFunc$1(geomFacet);
        var measureDefKey = getGeomMeasureDefKey(measure),
            measureDef = defs[measureDefKey],
            domain = getAxisDomain(geomFacet, measureDefKey); // check stack valid & set stackMap for stack values

        var stackMap = stack ? geomFacet.measuresOverlapped && !baseFacet.hasMeasure ? sumStackMap : {} : null;
        var yList = [],
            y0List = [],
            upperList = [],
            lowerList = [];
        var forecastValid = data.getRowCount() > forecastIndex;

        _.each(data.toRows(), function (row, ri) {
          var _calculatePosition = calculatePosition({
            row: row,
            domain: domain,
            measure: measure,
            measureDef: measureDef,
            geomFacet: geomFacet,
            baseFacet: baseFacet,
            filter: filter,
            measureDefKey: measureDefKey,
            stackMap: stackMap,
            forecast: ri >= forecastIndex
          }),
              y = _calculatePosition[0],
              y0 = _calculatePosition[1],
              upper = _calculatePosition[2],
              lower = _calculatePosition[3];

          yList.push(y);
          y0List.push(y0);

          if (forecastValid) {
            upperList.push(upper);
            lowerList.push(lower);
          }

          for (var _i = 0; _i < frameCount; _i++) {
            var _measure = frameMeasures[_i];

            var _ref = frameMeasureCache[_measure] || {},
                _measureDef = _ref.def,
                _domain = _ref.domain,
                frameMeasureDefKey = _ref.frameMeasureDefKey;

            frames[_i].value.push(calculatePosition({
              row: row,
              measure: _measure,
              measureDef: _measureDef,
              domain: _domain,
              measureDefKey: frameMeasureDefKey,
              baseFacet: geomFacet,
              geomFacet: baseFacet,
              noPrev: true
            }));
          }
        });

        data.addCol({
          id: POSITION_Y,
          name: POSITION_Y,
          type: FieldType.ATTR
        }, yList);
        data.addCol({
          id: POSITION_Y0,
          name: POSITION_Y0,
          type: FieldType.ATTR
        }, y0List);

        if (forecastValid) {
          data.addCol({
            id: 'upper',
            name: 'upper',
            type: FieldType.ATTR
          }, upperList);
          data.addCol({
            id: 'lower',
            name: 'lower',
            type: FieldType.ATTR
          }, lowerList);
        }
      });
    }

    function cartesianPosition(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          inverted = state.inverted,
          geoms = state.geoms;

      var _ref = inverted ? [facetY, facetX] : [facetX, facetY],
          baseFacet = _ref[0],
          geomFacet = _ref[1];

      if (geomFacet.hasMeasure && geomFacet.measuresOverlapped) {
        var _geomFacet$measures = geomFacet.measures,
            firstMeasures = _geomFacet$measures[0],
            secondMeasures = _geomFacet$measures[1];
        dealPositionOnGeom(getGeomInShareAxis(firstMeasures, geoms), baseFacet, geomFacet, state);
        dealPositionOnGeom(getGeomInShareAxis(secondMeasures, geoms), baseFacet, geomFacet, state);
      } else {
        dealPositionOnGeom(geoms, baseFacet, geomFacet, state);
      }

      _.each(geoms, function (geom) {
        return Geom.getGeom(geom.type).adjust(geom, state);
      });

      _.each(geoms, function (geom) {
        return Geom.getGeom(geom.type).dealData(geom, state);
      });
    }

    var getGroupDims = function getGroupDims(facet) {
      return facet.dimensions.slice(0, facet.groupLevel);
    };

    var generateGroupId = function generateGroupId(row, measureIndex, groupDims, hasMeasure) {
      return _.map(groupDims, function (id) {
        return row[id];
      }).join(SEPARATOR) + (hasMeasure ? SEPARATOR + measureIndex : '');
    };
    /**
     * http://kms.finedevelop.com/pages/viewpage.action?pageId=45368001
     * create geom frame & calculate group row index map
     * @param state
     */


    var calculateGeomGroup = function calculateGeomGroup(state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          inverted = state.inverted,
          geoms = state.geoms;
      var xIdMap = facetX.groupIdMap,
          xHasMeasure = facetX.hasMeasure;
      var yIdMap = facetY.groupIdMap,
          yHasMeasure = facetY.hasMeasure;

      var _diffFacet = diffFacet(state),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      var geomMeasureOverlapped = geomFacet.measuresOverlapped,
          baseMeasureOverlapped = baseFacet.measuresOverlapped;
      var frameMeasures = getAllMeasuresOnFacet(baseFacet),
          frameCount = frameMeasures.length || 1;
      var xDims = getGroupDims(facetX),
          yDims = getGroupDims(facetY);
      var frameMeasureIndex, xId, yId, key;

      _.each(geoms, function (geom, gi) {
        var data = geom.data,
            frames = geom.frames;
        var measureIndex = geomMeasureOverlapped ? 0 : gi;
        data.each(function (row, ri) {
          _.each(frames, function (frame, fi) {
            var group = frame.group;
            frameMeasureIndex = baseMeasureOverlapped ? 0 : fi;
            xId = generateGroupId(row, inverted ? measureIndex : frameMeasureIndex, xDims, xHasMeasure);
            yId = generateGroupId(row, inverted ? frameMeasureIndex : measureIndex, yDims, yHasMeasure);
            key = xIdMap[xId] + GROUP_KEY + yIdMap[yId];
            group[key] = group[key] || [];
            group[key].push(ri);
          });
        });
      });
    };

    var prepareGeomFrames = function prepareGeomFrames(geoms, facetX, facetY) {
      var _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet;

      var frameMeasures = getAllMeasuresOnFacet(baseFacet),
          frameCount = frameMeasures.length || 1;

      _.each(geoms, function (geom) {
        var frames = [];

        for (var fi = 0; fi < frameCount; fi++) {
          frames.push({
            value: [],
            group: {},
            measure: frameMeasures[fi]
          });
        }

        geom.frames = frames;
      });
    };

    var createPositionSelector = function createPositionSelector() {
      return function (state) {
        var enableMap = state.enableMap,
            geoms = state.geoms,
            facetX = state.facetX,
            facetY = state.facetY;
        prepareGeomFrames(geoms, facetX, facetY);
        !enableMap && cartesianPosition(state);
        calculateGeomGroup(state);
        return state;
      };
    };

    function calcScrollBounds(_ref) {
      var focusPosition = _ref.focusPosition,
          plotBounds = _ref.plotBounds,
          facetX = _ref.facetX,
          facetY = _ref.facetY;
      var plotWidth = plotBounds.width,
          plotHeight = plotBounds.height;
      var width = getFacetLength(facetX),
          height = getFacetLength(facetY);
      var scroll = focusPosition.scroll,
          plot = focusPosition.plot;
      return {
        x: clamp(plot[0] * plotWidth - scroll[0] * width, plotWidth - width, 0),
        y: clamp(plot[1] * plotHeight - scroll[1] * height, plotHeight - height, 0),
        width: width,
        height: height
      };
    }

    function setSquareWidth (geom, facetX, facetY) {
      var data = geom.data,
          size = geom.size;

      var _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      var sizeAes = getAesInstance(AesTypes.SIZE, geom, size),
          sizeAesCol = sizeAes.dealMapping(data);

      if (sizeAesCol.length === 0) {
        return;
      }

      var unit = isGeomUsePercentSize(baseFacet, geomFacet) ? baseFacet.unit : 1;
      geom.width = sizeAes.isConstField() ? sizeAesCol[0] * unit : size.range[1] * unit;
    }

    function getRowsBoundsInCell(geom, idList, frame, inverted, vanishChecker, validRowChecker, facetX, facetY) {
      var dataModel = geom.data,
          type = geom.type; // 计算square的rowBounds之前需要先计算geom.width

      if (type === ChartLibrary.SQUARE && geom.width == null) {
        setSquareWidth(geom, facetX, facetY);
      }

      var value = frame.value;
      var boundsList = [];

      _.each(idList, function (idx) {
        var row = dataModel.rowObject(idx);

        if (vanishChecker(row) || !validRowChecker(row)) {
          return;
        }

        var geomIns = Geom.getGeom(type);
        var bounds = geomIns.getRowBounds(row, value[idx], inverted, geom);
        var x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height;

        if (isNaN(x) || isNaN(y) || isNaN(width) || isNaN(height)) {
          return;
        }

        boundsList.push(bounds);
      });

      return boundsList;
    }

    /**
     * 计算分区在横纵轴上的下标
     */
    function getCellGroupIndex (groupKey) {
      return _.map(groupKey.split('+'), function (v) {
        return +v || 0;
      });
    }

    /**
     *  计算分区在某个方向的尺寸范围
     */
    function getCellRange (cellIndex, stops) {
      return [stops[cellIndex], stops[cellIndex + 1]];
    }

    function getLowerPos(bounds, horizontal) {
      return horizontal ? bounds.x : bounds.y;
    }

    function getUpperPos(bounds, horizontal) {
      return horizontal ? bounds.x + bounds.width : bounds.y + bounds.height;
    }

    function getLowerAndUpperPosFromRowsBounds(rowsBounds, horizontal) {
      var lower, upper;

      _.each(rowsBounds, function (bounds) {
        var tempLower = getLowerPos(bounds, horizontal);
        var tempUpper = getUpperPos(bounds, horizontal);

        if (!lower) {
          lower = tempLower;
          upper = tempUpper;
        } else {
          lower = Math.min(lower, tempLower);
          upper = Math.max(upper, tempUpper);
        }
      });

      return [lower, upper];
    } // 合并多个数值区间，返回一个包含所有区间的的区间


    function mergeRange() {
      var range = null;

      _.each(arguments, function (r) {
        if (range == null) {
          range = r;
        } else {
          var temp = [].concat(r, range);
          range = [Math.min.apply(Math, temp), Math.max.apply(Math, temp)];
        }
      });

      return range;
    }
    /**
     * 计算node上具体的指标的range，考虑趋势线周期&轴逆序的影响
     */

    function calculateMeasureRange(facet, defName, start, end) {
      var _facet$trendLinePerio = facet.trendLinePeriod,
          forward = _facet$trendLinePerio[0],
          backward = _facet$trendLinePerio[1],
          _facet$scaleMap$defNa = facet.scaleMap[defName],
          _facet$scaleMap$defNa2 = _facet$scaleMap$defNa.ticks,
          ticks = _facet$scaleMap$defNa2 === void 0 ? [] : _facet$scaleMap$defNa2,
          reverse = _facet$scaleMap$defNa.reverse,
          horizontal = facet.horizontal;
      var invertAxis = !horizontal ^ reverse;

      if (invertAxis) {
        var _ref = [end, start];
        start = _ref[0];
        end = _ref[1];
      }

      var ticksCount = ticks.length + forward + backward;

      if (ticksCount > 0) {
        var unit = (end - start) / ticksCount;
        start += unit * forward;
        end -= unit * backward;
      }

      return [start, end];
    }
    /**
     * 整值轴的值域范围
     * @param facet
     * @param geom
     * @param defs
     * @param frame
     * @param rowsBound
     * @param cellRange
     * @param domainCached 缓存调整后的domain
     * @returns {boolean}
     */


    function adjustAxisDomain (facet, geom, defs, frame, rowsBound, cellRange, domainCached) {
      if (!facet.hasMeasure || !rowsBound.length) {
        return false;
      }

      var measuresToGeoms = facet.measuresToGeoms,
          horizontal = facet.horizontal,
          measuresOverlapped = facet.measuresOverlapped,
          measures = facet.measures,
          scaleMap = facet.scaleMap;
      var geomType = geom.type;
      var dId = measuresToGeoms ? geom.measure : frame.measure;
      var defName = dId;

      if (measuresOverlapped) {
        var isFirstMeasure = measures[0].indexOf(dId) > -1;
        defName = getSharedAxisName(horizontal, isFirstMeasure);
      }

      var _defs$defName = defs[defName],
          min = _defs$defName.min,
          max = _defs$defName.max; // fix min max, do not need adjust.

      if (min != null && max != null) {
        return false;
      }

      var _getLowerAndUpperPosF = getLowerAndUpperPosFromRowsBounds(rowsBound, horizontal),
          lower = _getLowerAndUpperPosF[0],
          upper = _getLowerAndUpperPosF[1];

      var axisRange = calculateMeasureRange(facet, defName, cellRange[0], cellRange[1]);
      var minPos = Math.min.apply(Math, axisRange),
          maxPos = Math.max.apply(Math, axisRange); // interval & square 使用lineSubPixelOpt计算rowBounds，跟cellRange有至多1px的误差,
      // 所以在这里加上，避免因为0.5之类的误差而调整值轴。

      if (geomType === ChartLibrary.INTERVAL || geomType === ChartLibrary.SQUARE) {
        minPos -= 1;
        maxPos += 1;
      }

      if (lower >= minPos && upper <= maxPos) {
        return false;
      }

      var cachedDomain = domainCached[defName] || scaleMap[defName].domain;
      var newDomain = [].concat(cachedDomain);
      var scale = linear$2().domain(axisRange).range(newDomain);
      var b1 = scale(lower);
      var b2 = scale(upper);

      if (min == null) {
        newDomain[0] = Math.min(b1, b2);
      }

      if (max == null) {
        newDomain[1] = Math.max(b1, b2);
      } // originDomain是所有可视的数据的[min, max]


      newDomain = mergeRange(newDomain, cachedDomain, scaleMap[defName].originDomain);

      if (!domainCached[defName]) {
        domainCached[defName] = newDomain;
      }

      scaleMap[defName].domain = newDomain;
      return true;
    }

    function isNeedAdjustDomain (state) {
      var facetX = state.facetX,
          facetY = state.facetY,
          geoms = state.geoms,
          tagFilter = state.tagFilter,
          _state$facetX = state.facetX,
          xHasMeasure = _state$facetX.hasMeasure,
          base = _state$facetX.base,
          yHasMeasure = state.facetY.hasMeasure,
          defs = state.defs;
      var xStops = getFacetStops(facetX);
      var yStops = getFacetStops(facetY);

      if (!xHasMeasure && !yHasMeasure) {
        return false;
      }

      var inverted = !base;
      var isNeedAdjust = false; // 用于缓存调整后的domain

      var xDomain = {};
      var yDomain = {};
      var vanishChecker = getVanishChecker(tagFilter);

      _.each(geoms, function (geom) {
        var frames = geom.frames;

        _.each(frames, function (frame) {
          var group = frame.group,
              frameMeasure = frame.measure;
          var validRowChecker = createValidRowChecker(geom, frameMeasure);

          _.each(group, function (rowIndexList, groupKey) {
            var rowsBound = getRowsBoundsInCell(geom, rowIndexList, frame, inverted, vanishChecker, validRowChecker, facetX, facetY);
            var groupIndex = getCellGroupIndex(groupKey);
            var cellXRange = getCellRange(groupIndex[0], xStops);
            var cellYRange = getCellRange(groupIndex[1], yStops);
            var isxAxisNeedAdjust = adjustAxisDomain(facetX, geom, defs, frame, rowsBound, cellXRange, xDomain);
            var isYAxisNeedAdjust = adjustAxisDomain(facetY, geom, defs, frame, rowsBound, cellYRange, yDomain);

            if (!isNeedAdjust) {
              isNeedAdjust = isxAxisNeedAdjust || isYAxisNeedAdjust;
            }
          });
        });
      });

      return isNeedAdjust;
    }

    /**
     * description: 值轴区间调整，保证所有的图形都恰好展示而不会溢出。
     */

    var createAdjustSelector = function createAdjustSelector() {
      var positionSelector = createPositionSelector();
      return function (state) {
        var isNeedAdjust = isNeedAdjustDomain(state);

        if (isNeedAdjust) {
          trainFacetScale$1(state); // @BI-40396: 重新计算映射

          dealAesMapping(state.geoms); // 重新计算位置

          state = positionSelector(state);
        }

        return state;
      };
    };

    var createResizeSelector = function createResizeSelector() {
      var dataSelector = createDataSelector();
      var layoutSelector = createLayoutSelector();
      var positionSelector = createPositionSelector();
      var adjustSelector = createAdjustSelector();
      return function (state) {
        var computedState = dataSelector(state);
        computedState = layoutSelector(computedState);
        computedState = positionSelector(computedState);
        computedState = adjustSelector(computedState);
        return computedState;
      };
    };

    var createComputedSelector = function createComputedSelector() {
      var resizeSelector = createResizeSelector();
      var processSelector = createProcessSelector();
      var computedSelector = createSelector([getGeoms, getFacetX, getFacetY, getDefs, getLegend, getTagFilter, getMapConfig, getSize, getOrientation$1, getInverted, getMobile, getCondition, getZoom, getComputedState, getSelectedRows], function (geoms, facetX, facetY, defs, legend, tagFilter, mapConfig, size, orientation, inverted, isMobile, condition, zoom, computedState, selectedRows) {
        var state = {
          geoms: geoms,
          facetX: facetX,
          facetY: facetY,
          defs: defs,
          legend: legend,
          tagFilter: tagFilter,
          mapConfig: mapConfig,
          size: size,
          orientation: orientation,
          inverted: inverted,
          isMobile: isMobile,
          condition: condition,
          enableMap: mapConfig.enabled,
          zoom: zoom,
          selectedRows: selectedRows
        }; // 后台的js引擎解析过一遍的结果，暂时先直接返回好像就够用
        // 加上交互有问题再考虑下

        if (computedState) {
          return computedState;
        }

        return processSelector(resizeSelector(state));
      });
      var scrollBoundsSelector = createSelector([computedSelector, getFocusPosition], function (computedState, focusPosition) {
        var facetX = computedState.facetX,
            facetY = computedState.facetY,
            plotBounds = computedState.plotBounds;
        return _extends({}, computedState, {
          scrollBounds: calcScrollBounds({
            focusPosition: focusPosition,
            plotBounds: plotBounds,
            facetX: facetX,
            facetY: facetY
          })
        });
      });
      return function (state) {
        var computed = scrollBoundsSelector(state);
        return _extends({}, state, computed);
      };
    };

    var computedSelectorHash = {};
    function addComputedSelector(chartId) {
      computedSelectorHash[chartId] = createComputedSelector();
    }
    function disposeComputedSelector(chartId) {
      computedSelectorHash[chartId] = null;
    }
    function computedSelect(state) {
      return computedSelectorHash[state.chartId](state);
    }

    //     if (rootState.hoverStage === payload) {
    //         return rootState;
    //     } else {
    //         // FIXME
    //         if (rootState.hoverStage & ~STAGES.SELECT) {
    //             return {
    //                 ...rootState,
    //                 hoverStage: payload,
    //                 targets: {},
    //                 highlightNode: null
    //             };
    //         }
    //     }
    // }

    function scrollByPx(focusPosition, _ref, rootState) {
      var deltaX = _ref.deltaX,
          deltaY = _ref.deltaY;
      // todo, get bounds from payload
      var derived = computedSelect(rootState);
      var plotBounds = derived.plotBounds,
          scrollBounds = derived.scrollBounds;
      var x = scrollBounds.x,
          y = scrollBounds.y,
          width = scrollBounds.width,
          height = scrollBounds.height;
      var nextX = clamp(x + deltaX, plotBounds.width - width, 0),
          nextY = clamp(y + deltaY, plotBounds.height - height, 0);

      if (nextX === x && nextY === y) {
        return focusPosition;
      } else {
        return {
          scroll: [-nextX / width, -nextY / height],
          plot: [0, 0]
        };
      }
    } // todo highlight 简化
    // 看上去highlight还是要组织到一起

    function highlightMatchedTarget(rootState, _ref2) {
      var payload = _ref2.payload;
      var pos = payload.pos,
          tooltip = payload.tooltip,
          targets = payload.targets,
          highlightNode = payload.highlightNode,
          targetCenter = payload.targetCenter;

      if (targetEqual(rootState.targets, targets)) {
        return rootState;
      } else {
        return _extends({}, rootState, {
          pos: pos,
          tooltip: tooltip,
          targets: targets,
          highlightNode: highlightNode,
          targetCenter: targetCenter
        });
      }
    }

    var limitMapZoom = function limitMapZoom(state, payload) {
      var _state$minZoom = state.minZoom,
          minZoom = _state$minZoom === void 0 ? DEFAULT_MIN_ZOOM : _state$minZoom,
          _state$maxZoom = state.maxZoom,
          maxZoom = _state$maxZoom === void 0 ? DEFAULT_MAX_ZOOM : _state$maxZoom;
      var zoom = payload.zoom;

      if (zoom) {
        payload.zoom = Math.max(Math.min(zoom, maxZoom), minZoom);
      }

      return payload;
    };
    /**
     * 地图配置相关
     * @param state
     * @param type
     * @param payload
     * @returns {{}}
     */


    function mapConfig(state, _ref3) {
      var type = _ref3.type,
          payload = _ref3.payload;
      return type === ActionTypes.mapChangeView ? _extends({}, state, limitMapZoom(state, payload), {
        fixedZoom: true // setFixed, for no auto zoom when other interaction like legend item toggle

      }) : state;
    } // --------- normal reducer ----------

    function eventPos(state, _ref4) {
      var type = _ref4.type,
          payload = _ref4.payload;
      return type === ActionTypes.eventPos ? payload : state;
    }
    function zoom$2(state, _ref5) {
      var type = _ref5.type,
          payload = _ref5.payload;
      return type === ActionTypes.zoom ? payload : state;
    }
    function size(state, _ref6) {
      var type = _ref6.type,
          payload = _ref6.payload;
      return type === ActionTypes.resize ? payload : state;
    } // 可以去掉rootState, 通过payload传

    function focusPosition(state, _ref7, rootState) {
      var type = _ref7.type,
          payload = _ref7.payload;

      switch (type) {
        case ActionTypes.scrollByPx:
          return scrollByPx(state, payload, rootState);

        case ActionTypes.zoomStart:
          return payload;

        default:
          return state;
      }
    }
    function highlight$1(state, _ref8) {
      var payload = _ref8.payload;
      return _extends({}, state, payload);
    } // comes from toggle

    function tagFilter(state, _ref9) {
      var _extends2;

      var type = _ref9.type,
          payload = _ref9.payload;

      switch (type) {
        case ActionTypes.tagFilter:
          var field = payload.field,
              name = payload.name;
          var clicked = state[field] || [];

          var index = _.indexOf(clicked, name);

          if (index === -1) {
            clicked = clicked.concat(name);
          } else {
            clicked = clicked.slice();
            clicked.splice(index, 1);
          }

          return _extends({}, state, (_extends2 = {}, _extends2[field] = clicked, _extends2));

        default:
          return state;
      }
    }
    function sliderFilter(state, _ref10) {
      var type = _ref10.type,
          payload = _ref10.payload;
      return type === ActionTypes.sliderFilter ? _extends({}, state, payload) : state;
    }
    function selectedRows(state, _ref11) {
      var type = _ref11.type,
          payload = _ref11.payload;
      return type === ActionTypes.selectedRows ? payload : state;
    }
    function panningCell(state, _ref12) {
      var type = _ref12.type,
          payload = _ref12.payload;
      return type === ActionTypes.panningCell ? payload : state;
    }

    /**
     * Created by Jeffrey on 2018/12/14.
     */
    var mergeStateReducer = function mergeStateReducer(reducers) {
      return function (state, action) {
        var hasChanged = false;

        var nextState = _.mapObject(reducers, function (fn, k) {
          var prevStateForKey = state[k];
          var nextStateForKey = fn(prevStateForKey, action, state);
          hasChanged = hasChanged || nextStateForKey !== prevStateForKey;
          return nextStateForKey;
        });

        return hasChanged ? _extends({}, state, nextState) : state;
      };
    };

    var mobileHoverInit = {
      hoverStage: STAGES.NORMAL,
      eventPos: {
        x: -1000,
        y: -1000
      },
      targetCenter: {},
      targets: {},
      targetId: null,
      highlightNode: null,
      panningCell: null
    };
    var mobileState = _extends({}, basicState, mobileHoverInit, {
      isMobile: true,
      rotation: null
    }); // hover stage 名字过时了

    function hoverStage(state, _ref) {
      var type = _ref.type,
          payload = _ref.payload;

      switch (type) {
        // case ActionTypes.changeStage:
        //     return payload;
        case ActionTypes.scrollStart:
          return STAGES.SCROLLING;

        case ActionTypes.scrollEnd:
          return STAGES.NORMAL;

        case ActionTypes.zoomStart:
          return STAGES.ZOOMING;

        case ActionTypes.zoomEnd:
          return STAGES.NORMAL;

        case ActionTypes.holdSelect:
          return STAGES.SELECT;

        case ActionTypes.selecting:
          return STAGES.SELECTING;

        case ActionTypes.edgeMoving:
          return STAGES.EDGE_MOVING;

        default:
          return state;
      }
    }

    function eventPos$1(state, _ref2) {
      var type = _ref2.type,
          payload = _ref2.payload;

      if (!payload) {
        return state;
      }

      var x = payload.x,
          y = payload.y;

      switch (type) {
        case ActionTypes.holdSelect:
        case ActionTypes.selecting:
        case ActionTypes.edgeMoving:
          if (state.x !== x || state.y !== y) {
            return {
              x: x,
              y: y
            };
          } else {
            return state;
          }

        default:
          return state;
      }
    }

    function rotation(state, _ref3) {
      var type = _ref3.type,
          payload = _ref3.payload;
      return type === ActionTypes.pieRotate ? payload : state;
    }
    var normalReducer = mergeStateReducer({
      hoverStage: hoverStage,
      eventPos: eventPos$1,
      zoom: zoom$2,
      size: size,
      focusPosition: focusPosition,
      // highlight,
      tagFilter: tagFilter,
      sliderFilter: sliderFilter,
      mapConfig: mapConfig,
      rotation: rotation,
      panningCell: panningCell
    });

    function highlightMatchedTarget$1(rootState, _ref4) {
      var payload = _ref4.payload;
      var pos = payload.pos,
          tooltip = payload.tooltip,
          targets = payload.targets,
          targetId = payload.targetId,
          highlightNode = payload.highlightNode,
          targetCenter = payload.targetCenter;

      if (rootState.targetId === targetId) {
        return rootState;
      } else {
        return _extends({}, rootState, {
          pos: pos,
          tooltip: tooltip,
          targets: targets,
          targetId: targetId,
          highlightNode: highlightNode,
          targetCenter: targetCenter
        });
      }
    }

    function highlight$2(rootState, _ref5) {
      var payload = _ref5.payload;
      var pos = payload.pos,
          tooltip = payload.tooltip,
          targetId = payload.targetId,
          targetCenter = payload.targetCenter;

      if (rootState.targetId === targetId) {
        return rootState;
      } else {
        return _extends({}, rootState, {
          pos: pos,
          tooltip: tooltip,
          targetId: targetId,
          targetCenter: targetCenter
        });
      }
    }

    function reducer(state, action) {
      var type = action.type,
          payload = action.payload; // console.log(`%c${type}`, 'background: #ee5', payload);

      switch (type) {
        case ActionTypes.init:
          return _extends({}, mobileState, payload);

        case ActionTypes.resize:
          var _size = state.size;
          var width = payload.width,
              height = payload.height,
              _payload$orientation = payload.orientation,
              orientation = _payload$orientation === void 0 ? state.orientation : _payload$orientation;

          if (_size.width === width && _size.height === height && orientation && state.orientation === orientation) {
            return state;
          }

          var next = {
            orientation: orientation
          };

          if (_size.width !== width || _size.height !== height) {
            next.size = {
              width: width,
              height: height
            };
          }

          return _extends({}, state, next);

        case ActionTypes.unhover:
          return _extends({}, state, mobileHoverInit);

        case ActionTypes.highlightMatchedTarget:
          return highlightMatchedTarget$1(state, action);

        case ActionTypes.highlight:
          return highlight$2(state, action);

        default:
          return normalReducer(state, action);
      }
    }

    var pcState = _extends({}, basicState, {
      isEditing: false,
      onKey: null,
      onBounds: null,
      onPos: null,
      direction: 'none',
      isPanning: false,
      panningCell: null,
      mousePos: {
        x: -1000,
        y: -1000
      },
      dashPos: null,
      // 框选中的图形rows
      selectedRows: []
    }); // hover stage 名字过时了

    function hoverStage$1(state, _ref) {
      var type = _ref.type;

      switch (type) {
        case ActionTypes.plotPanEnd:
          return STAGES.NORMAL;
        // case ActionTypes.changeStage:
        //     return payload;
        // case ActionTypes.touchEnd:
        //     return s & ~STAGES.INTERACTING;
        //
        // case ActionTypes.scrollStart:
        //     return STAGES.SCROLLING;
        //
        // case ActionTypes.scrollEnd:
        //     return STAGES.NORMAL;
        //
        // case ActionTypes.zoomStart:
        //     return STAGES.ZOOMING;
        //
        // case ActionTypes.zoomEnd:
        //     return STAGES.NORMAL;

        default:
          return state;
      }
    }

    var normalReducer$1 = mergeStateReducer({
      hoverStage: hoverStage$1,
      eventPos: eventPos,
      zoom: zoom$2,
      size: size,
      focusPosition: focusPosition,
      highlight: highlight$1,
      tagFilter: tagFilter,
      sliderFilter: sliderFilter,
      mapConfig: mapConfig,
      selectedRows: selectedRows,
      panningCell: panningCell
    });
    function reducer$1(state, action) {
      var type = action.type,
          payload = action.payload; // console.log(`%c${type}`, 'background: #ee5', payload);

      switch (type) {
        case ActionTypes.init:
          return _extends({}, pcState, payload);

        case ActionTypes.resize:
          return state.size.width === payload.width && state.size.height === payload.height ? state : _extends({}, state, {
            size: payload
          });

        case ActionTypes.unhover:
          return _extends({}, state, {
            targets: basicState.targets,
            tooltip: basicState.tooltip,
            highlightNode: null,
            hoverStage: STAGES.NORMAL
          });

        case ActionTypes.plotPanStart:
          return _extends({}, state, {
            targets: {},
            initPos: payload.pos,
            pos: payload.pos,
            hoverStage: payload.hoverStage
          });

        case ActionTypes.plotPanMove:
          return _extends({}, state, {
            pos: payload.pos,
            targets: payload.targets
          });

        case ActionTypes.plotPanEnd:
          return _extends({}, state, {
            facetX: payload.facetX || state.facetX,
            facetY: payload.facetY || state.facetY,
            geoms: payload.geoms || state.geoms,
            targets: {},
            hoverStage: STAGES.NORMAL,
            initPos: null
          });

        case ActionTypes.facetResize:
          return _extends({}, state, {
            resizeLine: payload
          });

        case ActionTypes.highlightMatchedTarget:
          return highlightMatchedTarget(state, action);

        case ActionTypes.highlight:
          return highlight$1(state, action);

        default:
          return normalReducer$1(state, action);
      }
    }

    /**
     * Created by Jeffrey on 2018/12/4.
     */

    var emitAction = function emitAction(_ref) {
      var emitter = _ref.emitter,
          isSpecialInteractionMode = _ref.isSpecialInteractionMode;
      var prevState = {};
      return function (_ref2) {
        var getState = _ref2.getState;
        return function (next) {
          return function (action) {
            var result = next(action);
            var state = getState();

            if (!isSpecialInteractionMode()) {
              var hoverStage = state.hoverStage;
              var isSelect = hoverStage & STAGES.SELECT;

              if (prevState.isSelect !== isSelect) {
                emitter.trigger('interactionModeChange', {
                  mode: isSelect ? 'select' : null
                });
                prevState = _extends({}, prevState, {
                  isSelect: isSelect
                });
              }
            }

            switch (action.type) {
              case ActionTypes.tagFilter:
                emitter.trigger('legend:toggle', action.payload);
                break;

              case ActionTypes.sliderFilter:
                emitter.trigger('legend:rangeChange', action.payload);
                break;

              case ActionTypes.init:
              case ActionTypes.resize:
              case ActionTypes.zoomEnd:
              case ActionTypes.scrollEnd:
              case ActionTypes.syncScroll:
                var derived = computedSelect(state);
                var plotBounds = derived.plotBounds,
                    scrollBounds = derived.scrollBounds;

                if (prevState.plotBounds !== plotBounds || prevState.scrollBounds !== scrollBounds) {
                  var bounds = [_extends({}, plotBounds, {
                    contentSize: {
                      width: scrollBounds.width,
                      height: scrollBounds.height
                    },
                    contentOffset: {
                      x: scrollBounds.x,
                      y: scrollBounds.y
                    }
                  })];
                  emitter.trigger('scrollBoundsChange', {
                    bounds: bounds
                  });
                  prevState = _extends({}, prevState, {
                    plotBounds: plotBounds,
                    scrollBounds: scrollBounds
                  });
                }

            }

            return result;
          };
        };
      };
    };

    function initStore(_ref3) {
      var mobile = _ref3.mobile,
          preloadedState = _ref3.preloadedState,
          extra = _ref3.extra;
      preloadedState = preloadedState || (mobile ? mobileState : pcState);
      var finalReducer = enableBatching(mobile ? reducer : reducer$1);
      var middleware = applyMiddleware(thunk.withExtraArgument(extra), emitAction(extra));
      var composeEnhancers = _.compose;
      var store = createStore(finalReducer, preloadedState, composeEnhancers(middleware));
      return store;
    }

    /**
     * Created by Jeffrey on 2018/1/29.
     */

    /**
     * Created by Jeffrey on 2018/12/21.
     */

    var Timer$1 =
    /*#__PURE__*/
    function () {
      function Timer() {
        this.timers = {};
      }

      var _proto = Timer.prototype;

      _proto.timeout = function timeout(key, callback, delay) {
        this.stop(key);
        this.timers[key] = timeout$1(callback, delay);
      };

      _proto.interval = function interval(key, callback, delay) {
        this.stop(key);
        this.timers[key] = interval$1(callback, delay);
      };

      _proto.stop = function stop(key) {
        if (this.timers[key]) {
          this.timers[key].stop();
          this.timers[key] = undefined;
        }
      };

      _proto.clear = function clear() {
        var _this = this;

        Object.keys(this.timers).forEach(function (k) {
          return _this.stop(k);
        });
      };

      return Timer;
    }();

    /**
     * 数据点提示框位置调整，保证数据点提示可以全部显示，不溢出到plot之外
     */
    var max$5 = Math.max;
    /**
     * 按照方向重新计算tooltip的x和y
     * @param bounds
     * @param direction
     */

    function position(bounds, direction) {
      var height = bounds.height,
          width = bounds.width;

      var _direction$split = direction.split(Direction.SEPARATOR),
          h = _direction$split[0],
          v = _direction$split[1];

      bounds.x -= h === Direction.LEFT ? width : 0;
      bounds.y -= v === Direction.TOP ? height : 0;
    }
    /**
     * 根据bounds的位置和大小以及plot的位置和大小，调整bounds的位置，保证不溢出Plot
     * @param bounds
     * @param plot
     */

    function adjust(bounds, plot) {
      var bx = bounds.x,
          by = bounds.y,
          _bw = bounds.width,
          _bh = bounds.height;
      var px = plot.x,
          py = plot.y,
          pw = plot.width,
          ph = plot.height;
      bounds.x = max$5(bx, px);
      bounds.y = max$5(by, py); // 宽度最大为绘图区的2 / 3, 高度为100%

      var bw = Math.min(_bw, pw * TOOLTIP_MAX_WIDTH),
          bh = Math.min(_bh, ph);
      var right = px + pw,
          bottom = py + ph;

      if (bx + bw > right) {
        bounds.x = right - bw;
      }

      if (by + bh > bottom) {
        bounds.y = bottom - bh;
      }
    }

    var PI$7 = Math.PI;
    var appear$1 = function appear(_ref) {
      var shape = _ref.shape;
      var startAngle = shape.startAngle,
          endAngle = shape.endAngle;
      var middleAngle = (startAngle + endAngle) / 2;
      return {
        shape: _extends({}, shape, {
          startAngle: middleAngle,
          endAngle: middleAngle
        })
      };
    };
    var getGroupInitTransition = function getGroupInitTransition() {
      return {
        duration: 1000,
        ease: Ease.EaseOutCubic,
        appear: function appear() {
          return {
            scale: [0, 0],
            rotation: PI$7 * 2
          };
        }
      };
    };
    var PIE_ROTATE_DURATION = 400;
    var getSinglePieGroupTransition = function getSinglePieGroupTransition() {
      return {
        duration: PIE_ROTATE_DURATION,
        ease: Ease.Ease
      };
    };
    var Timing = {
      SHOW_ENTER: {
        duration: 1000,
        ease: Ease.EaseOutBounce,
        appear: appear$1
      },
      HOVER: {
        duration: 300,
        ease: Ease.EaseOutBack
      },
      SHOW_UPDATE: {
        duration: 1000,
        ease: Ease.EaseOutBounce
      },
      HIDE_LEAVE: {
        duration: 1000,
        ease: Ease.EaseInBack
      },
      HIDE_UPDATE: {
        duration: 1000,
        ease: Ease.EaseOutBounce
      }
    };

    var HOVER_PCT$1 = 1.1;
    var MIN_PIE_RADIUS = 2; // 考虑1px边框

    function calcAnnotatePosAndDirection(_ref, rotation) {
      var startAngle = _ref.startAngle,
          endAngle = _ref.endAngle,
          r = _ref.r,
          r0 = _ref.r0;

      if (rotation === void 0) {
        rotation = 0;
      }

      var angle = normalRadian((startAngle + endAngle) / 2 + rotation),
          radius = (r + r0) / 2;
      var startPos = calcPolarPos(radius, angle);
      var direction;

      switch (calcAngleQuadrant(angle)) {
        case 1:
          direction = Direction.RIGHT_TOP;
          break;

        case 2:
          direction = Direction.LEFT_TOP;
          break;

        case 3:
          direction = Direction.LEFT_BOTTOM;
          break;

        default:
          direction = Direction.RIGHT_BOTTOM;
      }

      return {
        startPos: startPos,
        direction: direction
      };
    }
    var calcHoverTranslate = function calcHoverTranslate(row, multiPie, outSide) {
      if (multiPie === void 0) {
        multiPie = false;
      }

      if (outSide === void 0) {
        outSide = false;
      }

      var _row$shape = row.shape,
          r = _row$shape.r,
          startAngle = _row$shape.startAngle,
          endAngle = _row$shape.endAngle;
      var addR = r * ((multiPie ? HOVER_PCT : HOVER_PCT$1) - 1) * (outSide ? 1 : 0.5);
      return calcPolarPos(addR, (startAngle + endAngle) / 2);
    };
    var renderPieDataLabel = function renderPieDataLabel(refer) {
      var _refer$node = refer.node,
          row = _refer$node.data,
          condition = _refer$node.condition,
          multiPie = refer.multiPie;
      var dataLabel = row.dataLabel,
          id = row.id,
          x = row.x,
          y = row.y;

      if (!dataLabel || !dataLabel.text) {
        return null;
      }

      var _dataLabel$points = dataLabel.points,
          points = _dataLabel$points === void 0 ? [] : _dataLabel$points;
      var translate = [-x, -y],
          hx = 0,
          hy = 0;

      if (condition === HOVER) {
        var _calcHoverTranslate = calcHoverTranslate(row, multiPie, points.length);

        hx = _calcHoverTranslate[0];
        hy = _calcHoverTranslate[1];
        translate[0] += hx;
        translate[1] += hy;
      }

      return renderDataLabel$$1(_extends({}, refer, {
        translate: translate,
        tractLine: points.length && {
          key: id + '_tractLine',
          position: [hx, hy],
          shape: {
            points: _.map(points, function (point) {
              return [].concat(point);
            })
          },
          silent: true
        }
      }));
    };
    var PI_2 = Math.PI * 2;
    /**
     * find the sector which needs adjustment
     * @param rows
     * @param rotation
     * @returns {*}
     */

    var findPointedSector = function findPointedSector(rows, rotation) {
      // no or single doesn't need adjustment
      if (rows.length === 0) {
        return null;
      }

      if (rows.length === 1) {
        return rows[0];
      } // [0, 360]


      rotation = (rotation % PI_2 + PI_2) % PI_2;
      return _.find(rows, function (_ref2) {
        var shape = _ref2.shape;
        return between(rotation, shape.startAngle, shape.endAngle);
      });
    };
    /**
     * regular rotation to put pointer at the center of sector
     * @param sector
     */

    var calcFineRotation = function calcFineRotation(sector) {
      var _sector$shape = sector.shape,
          startAngle = _sector$shape.startAngle,
          endAngle = _sector$shape.endAngle;
      return (startAngle + endAngle) / 2;
    };
    var getAnticlockwiseEventRadian = function getAnticlockwiseEventRadian(_ref3, _ref4) {
      var offsetX = _ref3.offsetX,
          offsetY = _ref3.offsetY;
      var x = _ref4[0],
          y = _ref4[1];
      return Math.atan2(y - offsetY, offsetX - x);
    };

    var getUnitSize = function getUnitSize(facet) {
      return facet.hasMeasure ? Number.MAX_VALUE : facet.unit;
    };

    var getPieGroupKey = function getPieGroupKey(x, y) {
      return x + SEPARATOR + y;
    };

    var calculateSharedRadius = function calculateSharedRadius(geom) {
      var innerRadius = geom.innerRadius,
          maxRadius = geom.maxRadius,
          frames = geom.frames,
          data = geom.data;
      var rowCount = data.getRowCount();
      var xCol = frames[0].value,
          yCol = data.getColById('y'),
          sizeCol = data.getColById('size');
      var sectors = [],
          pieRadiusSumMap = {};
      var maxRadiusSum = 0;
      var r0 = maxRadius * innerRadius,
          r = maxRadius - r0;

      for (var i = 0; i < rowCount; i++) {
        var x = xCol[i],
            y = yCol[i],
            radius = Math.max(sizeCol[i] - r0, MIN_PIE_RADIUS);
        var sector = {
          i: i,
          radius: radius,
          x: x,
          y: y
        };
        var key = getPieGroupKey(x, y);

        if (!pieRadiusSumMap[key]) {
          pieRadiusSumMap[key] = 0;
        }

        var pieRadiusSum = pieRadiusSumMap[key] + radius;
        pieRadiusSumMap[key] = pieRadiusSum;
        maxRadiusSum = Math.max(maxRadiusSum, pieRadiusSum);
        sectors.push(sector);
      }

      _.each(sectors, function (sector) {
        var key = getPieGroupKey(sector.x, sector.y);
        sizeCol[sector.i] = (maxRadiusSum === 0 ? 0 : r * pieRadiusSumMap[key] / maxRadiusSum) + r0;
      });
    };
    var adjust$1 = function adjust(geom, chart) {
      var data = geom.data,
          shareRadius = geom.shareRadius,
          size = geom.size;

      var _diffFacet = diffFacet(chart),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      var sizeAes = getAesInstance(AesTypes.SIZE, geom, size);
      var sizeAesCol = data.getColById(AesTypes.SIZE);
      var rangeMax = sizeAes.isConstField() ? size : size.range[1];

      if (isGeomUsePercentSize(baseFacet, geomFacet)) {
        var unit = Math.min(getUnitSize(baseFacet), getUnitSize(geomFacet)) / 2;
        geom.maxRadius = unit * rangeMax;
        data.replaceCol(AesTypes.SIZE, _.map(sizeAesCol, function (v) {
          return rangeMax === 0 ? 0 : v * unit;
        }));
      } else {
        geom.maxRadius = rangeMax;
      } // todo unit test


      shareRadius && calculateSharedRadius(geom);
    };

    var layout$1 = function layout(rows, _ref) {
      var geom = _ref.geom,
          inverted = _ref.inverted;
      var maxRadius = geom.maxRadius,
          innerRadius = geom.innerRadius,
          _geom$sizeScale = geom.sizeScale,
          sizeScale = _geom$sizeScale === void 0 ? 1 : _geom$sizeScale;
      var innerR = maxRadius * innerRadius;

      var getPieAngle = function getPieAngle(row) {
        return row.vanish ? 0 : row[AttrKeys.PIE_ANGLE];
      };

      groupRowsByPos(rows, function (grouped, groupId, center) {
        center = inverted ? center.reverse() : center;
        var totalAngle = grouped.reduce(function (total, current) {
          return total + getPieAngle(current);
        }, 0);
        var startAngle = -Math.PI / 2;

        _.each(grouped, function (row) {
          var extent = getPieAngle(row) / totalAngle * (2 * Math.PI);
          row.size *= sizeScale;
          var endAngle = extent + startAngle;
          row.shape = {
            startAngle: startAngle,
            endAngle: endAngle,
            r: Math.max(row.size, MIN_PIE_RADIUS),
            r0: innerR
          };
          startAngle = endAngle;
          row.groupId = groupId;
          row.center = center;
        });
      });
    };

    var H = 13,
        W = 16,
        POINTER_COLOR = 'rgba(255, 255, 255, 0.6)';

    var pointerSideY = function pointerSideY(r) {
      return -Math.sqrt(r * r - W / 2 * (W / 2));
    };

    var TouchIndicator = function TouchIndicator(_ref) {
      var position = _ref.position,
          r = _ref.r,
          panning = _ref.panning;
      var dy = pointerSideY(r);
      return h(Animate$$1, {
        show: panning,
        start: {
          opacity: 1
        },
        leave: {
          opacity: [0],
          timing: {
            delay: 500 + PIE_ROTATE_DURATION,
            duration: 200
          }
        }
      }, function (_ref2) {
        var opacity = _ref2.opacity;
        return h("group", {
          silent: true,
          position: position,
          clip: {
            type: 'circle',
            shape: {
              r: r
            }
          }
        }, h("polygon", {
          silent: true,
          z: StaticLayerZ,
          shape: {
            points: [[0, dy + H], // bottom
            [-W / 2, dy], // left
            [-W / 2, dy - 10], [W / 2, dy - 10], [W / 2, dy] // right
            ]
          },
          style: {
            fill: POINTER_COLOR,
            opacity: opacity
          }
        }));
      });
    };

    var R_STEP = 3;
    var ANGLE_STEP = Math.PI / 180;
    var OUT_RADIUS = 1.1;
    var TRACT_LINE_SIZE$1 = 0.05;
    function adjustLabel$1(_ref) {
      var rows = _ref.rows,
          geom = _ref.geom,
          manager = _ref.manager,
          adjust = _ref.adjust,
          position = _ref.position,
          maxRadius = _ref.maxRadius;

      if (rows.length === 0) {
        return;
      }

      maxRadius = maxRadius || geom.maxRadius || rows[0].maxRadius;
      var _geom$rotation = geom.rotation,
          rotation = _geom$rotation === void 0 ? 0 : _geom$rotation; // 隐藏重叠

      if (adjust === DataLabel.HIDE) {
        forEach(rows, function (row) {
          var bounds = row.dataLabel.bounds;

          if (manager.isOverlapped(bounds)) {
            row.dataLabel = null;
          } else {
            manager.addBounds(bounds);
          }
        });
      } // 自动调整，极限数据情况下，无论怎么调整标签肯定会重叠，这边只是做一下尝试，即调整到一定的界限值，并停止调整计算：
      // 1. 标签在内部时： 标签中心点在r-r0上偏移，然后判断重叠，优先向r方向位移
      // 1. 标签在外部时： 牵引线向一个方向旋转
      else {
          if (position === DataLabel.INSIDE) {
            forEach(rows, function (row) {
              var x = row.x,
                  y = row.y,
                  bounds = row.dataLabel.bounds,
                  shape = row.shape,
                  _row$center = row.center,
                  center = _row$center === void 0 ? [x, y] : _row$center;

              if (manager.isOverlapped(bounds)) {
                var r = shape.r,
                    r0 = shape.r0,
                    startAngle = shape.startAngle,
                    endAngle = shape.endAngle;
                var angle = normalRadian((startAngle + endAngle) / 2 + rotation);
                !innerLabelPositionAdjust({
                  angle: angle,
                  r: r,
                  r0: r0,
                  manager: manager,
                  bounds: bounds,
                  center: center
                }) && (row.dataLabel = null);
              } else {
                manager.addBounds(bounds);
              }
            });
          } else {
            var positionLabelGroups = {
              '1': [],
              '2': [],
              '3': [],
              '4': []
            };
            forEach(rows, function (row) {
              var _row$shape = row.shape,
                  startAngle = _row$shape.startAngle,
                  endAngle = _row$shape.endAngle;
              var angle = normalRadian((startAngle + endAngle) / 2 + rotation);
              var quadrant = calcAngleQuadrant(angle);
              positionLabelGroups[quadrant].push({
                row: row,
                angle: angle
              });
            });
            forOwn(positionLabelGroups, function (group, quadrant) {
              group.sort(function (r1, r2) {
                return r1.angle - r2.angle;
              });
              outerLabelPositionAdjust(true, group, maxRadius, quadrant, manager) || outerLabelPositionAdjust(false, group, maxRadius, quadrant, manager, true);
            });
          }
        }
    }

    function innerLabelPositionAdjust(_ref2) {
      var angle = _ref2.angle,
          r = _ref2.r,
          r0 = _ref2.r0,
          manager = _ref2.manager,
          bounds = _ref2.bounds,
          _ref2$center = _ref2.center,
          cx = _ref2$center[0],
          cy = _ref2$center[1];

      var _r = (r + r0) / 2;

      var step = R_STEP;
      var width = bounds.width,
          height = bounds.height;

      var attempt = function attempt(step) {
        for (var s = _r; step > 0 ? s < r : s > r0; s += step) {
          var _calcPolarPos = calcPolarPos(s, angle),
              x = _calcPolarPos[0],
              y = _calcPolarPos[1];

          x += cx;
          y += cy;

          if (!manager.isOverlapped({
            x: x - width / 2,
            y: y - height / 2,
            width: width,
            height: height
          })) {
            setCenter(bounds, [x, y]);
            manager.addBounds(bounds);
            return true;
          }
        }
      };

      return attempt(step) || attempt(-step);
    }

    function outerLabelPositionAdjust(isAngleIncrease, labels, radius, quadrant, manager, ignore) {
      var outerR = radius * OUT_RADIUS;
      var hWidth = radius * TRACT_LINE_SIZE$1;

      var _getAngleRange = getAngleRange(quadrant),
          startAngle = _getAngleRange[0],
          endAngle = _getAngleRange[1];

      var searchEnd = isAngleIncrease ? endAngle : startAngle;
      var step = isAngleIncrease ? ANGLE_STEP : -ANGLE_STEP;
      var preBounds, preArc;

      for (var i = 0, len = labels.length; i < len; i++) {
        var index = isAngleIncrease ? i : len - 1 - i;
        var compare = isAngleIncrease ? Math.max : Math.min;
        var _labels$index = labels[index],
            row = _labels$index.row,
            dataLabel = _labels$index.row.dataLabel,
            angle = _labels$index.angle;
        var labelBounds = dataLabel.bounds,
            points = dataLabel.points;
        var width = labelBounds.width,
            height = labelBounds.height;
        var currentArc = preArc ? compare(angle, preArc) : angle;
        var found = false,
            bounds = void 0,
            cx = void 0,
            cy = void 0;

        for (var arc = currentArc; isAngleIncrease ? arc <= searchEnd : arc >= searchEnd; arc += step) {
          var _calcPolarPos2 = calcPolarPos(outerR, arc);

          cx = _calcPolarPos2[0];
          cy = _calcPolarPos2[1];
          bounds = getOuterLabelBounds(quadrant, [cx, cy], [width, height], hWidth);

          if (manager.isOverlapped(bounds)) {
            continue;
          }

          if (preBounds ? !isBoundsOverlapped(preBounds, bounds) : true) {
            found = true;
            preArc = arc;
            ignore && manager.addBounds(bounds);
            break;
          }
        }

        if (!found) {
          if (ignore) {
            row.dataLabel = null;
            var j = index;

            while (isAngleIncrease ? ++j < len : --j >= 0) {
              var _ref3 = labels[j] || {},
                  _row = _ref3.row;

              _row && (_row.dataLabel = null);
            }
          }

          return false;
        }

        preBounds = bounds;
        labelBounds.x = bounds.x + row.x;
        labelBounds.y = bounds.y + row.y;

        if (points) {
          var p2 = points[1],
              p3 = points[2];
          p2[1] = p3[1] = cy;
          var isLeft = isLeftQuadrant(quadrant);
          p3[0] = bounds.x + (isLeft ? 0 : width);
          p2[0] = p3[0] + (isLeft ? -1 : 1) * hWidth;
        }
      }

      return true;
    }

    function isLeftQuadrant(quadrant) {
      quadrant -= 0;
      return quadrant === 1 || quadrant === 4;
    }

    function getOuterLabelBounds(quadrant, center, _ref4, hWidth) {
      var width = _ref4[0],
          height = _ref4[1];
      var bounds = {
        width: width,
        height: height
      };
      setCenter(bounds, center);
      bounds.x += (isLeftQuadrant(quadrant) ? 1 : -1) * (width / 2 + hWidth);
      return bounds;
    }

    function getAngleRange(quadrant) {
      var PI = Math.PI;

      switch (quadrant) {
        case '1':
          return [1.5 * PI, 2 * PI];

        case '2':
          return [PI, 1.5 * PI];

        case '3':
          return [PI / 2, PI];

        default:
          return [0, PI / 2];
      }
    }

    var distance$3 = function distance(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    var progressFn = function progressFn(points, _ref) {
      var start = _ref[0],
          end = _ref[1];
      var stops = [];
      var total = 0;

      for (var i = start; i < end; i++) {
        var dis = distance$3(points[i], points[i + 1]);
        stops.push([total, total += dis]);
      }

      _.forEach(stops, function (stop) {
        stop[0] /= total;
        stop[1] /= total;
      });

      return function (t) {
        for (var _i = 0, len = stops.length; _i < len; _i++) {
          var _stops$_i = stops[_i],
              s = _stops$_i[0],
              e = _stops$_i[1];

          if (s <= t && t <= e) {
            return start + _i + (t - s) / (e - s);
          }
        }
      };
    };

    var renderLineEffect = function renderLineEffect(_ref2) {
      var points = _ref2.points,
          duration = _ref2.duration,
          effectStops = _ref2.effectStops,
          style = _ref2.style,
          horizontal = _ref2.horizontal,
          stroke = _ref2.stroke,
          lineWidth = _ref2.lineWidth,
          _ref2$opacity = _ref2.opacity,
          opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity,
          isVarLine = _ref2.isVarLine,
          size = _ref2.size;
      duration *= 1000;
      var getProgress = progressFn(points, effectStops);
      return h('effectLine', {
        zlevel: EffectLineZLevel,
        shape: {
          points: _.map(points, function (p) {
            return {
              x: p.x,
              y: p.y,
              size: size || p.size
            };
          }),
          process: 0,
          style: style,
          stroke: stroke,
          horizontal: horizontal,
          isVarLine: isVarLine
        },
        ref: function ref(el) {
          if (!el) {
            return;
          }

          if (el.animator) {
            el.animator.stop();
            el.animator = null;
          }

          var domain = [],
              colors = [];

          _.each(points, function (p, i) {
            domain.push(i);
            colors.push(p.color);
          });

          var scale = scaleColor(domain, colors);
          el._t = 0;
          el.animate('', true).when(duration, {
            _t: 1
          }).during(function () {
            var progress = getProgress(el._t);
            var color = scale(progress);
            el.setStyle('fill', color);
            el.shape.progress = progress;
            el.dirty(true);
          }).start();
        },
        style: {
          lineWidth: stroke ? lineWidth || points[0].size : 0,
          opacity: opacity
        }
      });
    };

    var getEffectScale = function getEffectScale(pct, maxScaleCoefficient) {
      pct -= 0.5;
      return 1 + maxScaleCoefficient * (1 - 4 * pct * pct);
    };
    var EFFECT_SCALE_COEFFICIENT_ONE = 0.05;
    /**
     * 抽象方法用于实现缩放类闪烁动画
     * @param id
     * @param effect
     * @param maxScaleCoefficient
     */

    function showScaledEffect(id, effect, maxScaleCoefficient) {
      if (maxScaleCoefficient === void 0) {
        maxScaleCoefficient = EFFECT_SCALE_COEFFICIENT_ONE;
      }

      var animator = this.createEffectAni(id, effect, effect * 1000);
      var rect = this.getZNode(id);
      animator.during(function (_ref) {
        var pct = _ref.pct;
        var s = getEffectScale(pct, maxScaleCoefficient);
        rect.attr('scale', [s, s]);
      }).start();
    }

    var hoverShape = function hoverShape(shape) {
      shape.r *= HOVER_PCT$1;
      return shape;
    };

    var EFFECT_SCALE_COEFFICIENT_ONE$1 = 0.05;
    var getTransitionProps = getGeomTransitionProps(Timing);
    var getShowEnterAppearFn = function getShowEnterAppearFn(node) {
      var shape = node.data.shape;
      var startAngle = shape.startAngle,
          endAngle = shape.endAngle;
      var ma = (startAngle + endAngle) / 2;

      if (node.lastData) {
        ma = node.lastData.shape.endAngle;
      }

      return function () {
        return {
          shape: _extends({}, shape, {
            startAngle: ma,
            endAngle: ma
          })
        };
      };
    };

    var Pie =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Pie, _Geometry);

      function Pie(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.state = {
          panning: false,
          touch: false,
          rotatable: false,
          rotation: 0,
          nextRotation: 0,
          groupRotation: 0,
          rotating: false
        };
        _this.startRotation = 0;
        _this.relativeRotation = 0;
        _this.lastSelected = null;
        _this.getTransitionProps = getTransitionProps;

        _this.handleTap = function (e) {
          var rotation = _this.state.rotation;

          if (_this.rotating) {
            return true;
          }

          var rows = _this.props.rows;
          var nextRotation = -rotation - getAnticlockwiseEventRadian(e, _this.getCenter());
          var sector = findPointedSector(_this.props.rows, nextRotation);
          var groupRotation = 0;

          if (sector) {
            if (_this.state.rotatable) {
              var fineRotation = Pie._getRotationWithSector(sector);

              groupRotation = _this._getGroupRotation(rotation - fineRotation);

              _this.setState({
                panning: true
              }, function () {
                _this.setState({
                  panning: false,
                  rotating: true,
                  nextRotation: fineRotation,
                  groupRotation: groupRotation,
                  data: _this._getRotatedRows(fineRotation, _this.props)
                });
              });

              _this._updateRelativeRotation(fineRotation);
            } // MOBILE-17750
            // consider tapping the same sector again


            _this.props.interaction.pieSelect({
              target: sector
            });

            _this.props.interaction.delayHide();
          } // prevent normal select logic


          return true;
        };

        _this.handlePanSelect = function (e) {
          stop$2(e);
          var rotation = _this.state.rotation;
          var nextRotation = -rotation - getAnticlockwiseEventRadian(e, _this.getCenter());
          var sector = findPointedSector(_this.props.rows, nextRotation);

          if (sector) {
            _this.selectSector(sector);
          }

          return true;
        };

        _this.handlePanSelectEnd = function () {
          _this.props.interaction.delayHide();
        };

        _this.handlePanStart = function (e) {
          stop$2(e);
          var _this$state = _this.state,
              rotatable = _this$state.rotatable,
              rotating = _this$state.rotating;

          if (rotating || !rotatable) {
            return true;
          } // anticlockwise


          var rotation = _this.state.rotation;
          _this.startRotation = rotation + Math.PI / 2 + getAnticlockwiseEventRadian(e, _this.getCenter());

          _this.setState({
            panning: true
          });

          return true;
        };

        _this.handlePan = function (e) {
          stop$2(e);

          if (!_this.state.panning) {
            return true;
          }

          var rotated = getAnticlockwiseEventRadian(e, _this.getCenter()) - _this.startRotation;

          var sector = findPointedSector(_this.props.rows, rotated);

          if (sector) {
            _this.selectSector(sector);
          }

          _this.setState({
            rotation: -rotated - Math.PI / 2
          });

          return true;
        };

        _this.handlePanEnd = function (e) {
          stop$2(e);

          if (!_this.state.panning) {
            return true;
          }

          var nextRotation = getAnticlockwiseEventRadian(e, _this.getCenter()) - _this.startRotation;

          var sector = findPointedSector(_this.props.rows, nextRotation);
          var rows = _this.props.rows;
          var rotation = _this.state.rotation;
          var groupRotation = 0;

          if (sector) {
            var fineRotation = Pie._getRotationWithSector(sector);

            groupRotation = _this._getGroupRotation(rotation - fineRotation);
            rotation = fineRotation;

            _this._updateRelativeRotation(rotation);

            _this.selectSector(sector);

            _this.lastSelected = null;
          }

          _this.props.interaction.delayHide();

          _this.setState({
            panning: false,
            data: _this._getRotatedRows(rotation, _this.props),
            nextRotation: rotation,
            groupRotation: groupRotation,
            rotating: true
          });
        };

        _this.state = _this.getDerivedState(props);
        return _this;
      }
      /**
       * @returns {{touch: boolean, rotatable: (boolean|*), rotation: number, data: *}}
       */


      var _proto = Pie.prototype;

      _proto.getDerivedState = function getDerivedState(props) {
        var specialMode = props.specialMode,
            rows = props.rows;
        var touch = specialMode === SpecialMode.SINGLE_PIE;
        var rotatable = touch && rows.length > 1 && rows.every(function (row) {
          return row.shape.r === rows[0].shape.r;
        });
        var _this$state2 = this.state,
            lastRotation = _this$state2.rotation,
            panning = _this$state2.panning,
            rotating = _this$state2.rotating,
            nextRotation = _this$state2.nextRotation;
        var rotation = rotating ? nextRotation : lastRotation;

        if (rotatable && !panning) {
          var sector = findPointedSector(rows, this.relativeRotation);
          rotation = Pie._getRotationWithSector(sector);
        }

        return {
          touch: touch,
          rotatable: rotatable,
          rotation: rotation,
          data: rotatable && !panning ? this._getRotatedRows(rotation, props) : rows
        };
      } // 旋转后内部调整标签
      ;

      _proto._getRotatedRows = function _getRotatedRows(rotation, props) {
        var dataLabel = props.dataLabel,
            bounds = props.bounds,
            maxRadius = props.maxRadius,
            rows = props.rows;
        var geom = {
          maxRadius: maxRadius,
          dataLabel: dataLabel,
          type: ChartLibrary.PIE,
          rotation: rotation
        };

        var newRows = _.map(rows, function (row) {
          return _extends({}, row);
        });

        dealLabel({
          geom: geom,
          rows: newRows,
          cellBounds: bounds,
          manager: new BoundsManager()
        });
        return newRows;
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(next) {
        this.setState(this.getDerivedState(next));
      };

      _proto.getCenter = function getCenter() {
        var _this$props = this.props,
            inverted = _this$props.inverted,
            rows = _this$props.rows;
        var _rows$ = rows[0],
            x = _rows$.x,
            y = _rows$.y;
        return inverted ? [y, x] : [x, y];
      };

      _proto.selectSector = function selectSector(sector) {
        if (sector.id !== this.lastSelected) {
          this.lastSelected = sector.id;
          this.props.interaction.pieSelect({
            target: sector
          });
        }
      };

      _proto._updateRelativeRotation = function _updateRelativeRotation(rotation) {
        this.relativeRotation = -rotation - Math.PI / 2;
      };

      _proto._getGroupRotation = function _getGroupRotation(groupRotation) {
        groupRotation = normalRadian(groupRotation);
        groupRotation -= groupRotation > Math.PI ? Math.PI * 2 : 0;

        var pieGroupNode = this._getGroup();

        pieGroupNode && pieGroupNode.attrKV('rotation', 0);
        return groupRotation;
      };

      _proto.getGroupProps = function getGroupProps() {
        var _this2 = this;

        var props = _Geometry.prototype.getGroupProps.call(this);

        props.position = this.getCenter();
        props.scale = [1, 1]; // anticlockwise

        props.rotation = 0;

        if (this.state.rotating) {
          var _this$state3 = this.state,
              _this$state3$groupRot = _this$state3.groupRotation,
              groupRotation = _this$state3$groupRot === void 0 ? 0 : _this$state3$groupRot,
              rotation = _this$state3.rotation,
              _this$state3$nextRota = _this$state3.nextRotation,
              nextRotation = _this$state3$nextRota === void 0 ? rotation : _this$state3$nextRota;
          props.rotation = groupRotation;
          var _transitionEnd = props.transitionEnd; // todo 似乎有一点复杂

          props.transitionEnd = function () {
            _transitionEnd && _transitionEnd();

            _this2.setState({
              rotation: nextRotation,
              groupRotation: 0,
              nextRotation: null,
              rotating: false
            });
          };
        }

        return props;
      };

      _proto.getGroupTransition = function getGroupTransition() {
        var _this$props2 = this.props,
            specialMode = _this$props2.specialMode,
            animation = _this$props2.animation;

        if (!animation) {
          return null;
        } // rotate group 应该在每次init的时候执行


        if (this._init) {
          return getGroupInitTransition();
        } else if (specialMode === SpecialMode.SINGLE_PIE && !this.state.panning && this.state.rotating) {
          return getSinglePieGroupTransition();
        }
      };

      _proto.render = function render(_ref) {
        var inverted = _ref.inverted,
            rows = _ref.rows,
            bounds = _ref.bounds,
            specialMode = _ref.specialMode,
            process = _ref.process;
        var _this$state4 = this.state,
            touch = _this$state4.touch,
            rotatable = _this$state4.rotatable,
            panning = _this$state4.panning;
        var attrs = null;

        if (rotatable) {
          attrs = {
            ontap: this.handleTap,
            onpanstart: this.handlePanStart,
            onpan: this.handlePan,
            onpanend: this.handlePanEnd
          };
        } else if (touch) {
          attrs = {
            ontap: this.handleTap,
            onpanstart: this.handlePanSelect,
            onpan: this.handlePanSelect,
            onpanend: this.handlePanSelectEnd
          };
        }

        return h("group", attrs, touch && h("rect", {
          invisible: true,
          shape: bounds
        }), _Geometry.prototype.render.call(this)
        /*FIXME, anti-pattern*/
        , rotatable && h(TouchIndicator, {
          position: this.getCenter(),
          r: rows[0].shape.r,
          panning: panning
        }));
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            data = node.data;
        var _this$state5 = this.state,
            _this$state5$rotation = _this$state5.rotation,
            rotation = _this$state5$rotation === void 0 ? 0 : _this$state5$rotation,
            rotatable = _this$state5.rotatable;
        var _this$props3 = this.props,
            process = _this$props3.process,
            borderColor = _this$props3.borderColor,
            gradual = _this$props3.gradual,
            opacity = _this$props3.opacity;
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            silent = transitionProps.silent,
            z = transitionProps.z,
            isHover = transitionProps.isHover,
            isFade = transitionProps.isFade,
            isEnter = transitionProps.isEnter;

        if (isEnter && process === SHOW) {
          transition.appear = getShowEnterAppearFn(node);
        }

        var sectorShape = data.shape,
            color = data.color,
            fake = data.fake;
        var r = sectorShape.r,
            r0 = sectorShape.r0,
            startAngle = sectorShape.startAngle,
            endAngle = sectorShape.endAngle;
        if (r === r0) return;
        var shape = {
          r: r,
          r0: r0,
          startAngle: startAngle + rotation,
          endAngle: endAngle + rotation
        };
        var style = {
          color: color,
          fill: color,
          shadowBlur: 0,
          shadowColor: 'transparent',
          opacity: opacity,
          stroke: borderColor || color
        };
        fake && fakeStyle(style);
        isFade && fadeStyle(style);
        var fill = isHover ? highlight(color) : color;

        if (gradual && !isFade) {
          style.fill = getRadialGradualColor(fill, r, r0);
        } // shape & style related to end state


        if (isHover) {
          if (!rotatable) {
            hoverShape(shape);
          } // keep touch pie size


          hoverStyle(style);
          style.shadowBlur = 0;
        } // 内外径一样大时，理论上扇形是不可见的，然而chrome上还是能看到断断续续的弧线，这边判断一下一致时直接不绘制


        return h('sector', {
          key: key,
          id: key,
          z: z,
          silent: silent,
          // FixME zr现在的手势流程有点问题
          radius: r,
          transition: isHover ? null : transition,
          transitionEnd: transitionEnd,
          shape: shape,
          style: style
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        if (this._groupTransition) {
          refer.transition = this._groupTransition;
        }

        var bounds = this.props.bounds;
        var rotation = this.state.rotation;
        var data = node.data; // 相对中心位置

        refer.cellBounds = _extends({}, bounds, {
          x: -bounds.width / 2,
          y: -bounds.height / 2
        });

        if (data.annotation) {
          var _calcAnnotatePosAndDi = calcAnnotatePosAndDirection(data.shape, rotation),
              startPos = _calcAnnotatePosAndDi.startPos,
              direction = _calcAnnotatePosAndDi.direction;

          refer.startPos = startPos;
          refer.direction = direction;
        }
      };

      _proto.renderGuides = function renderGuides(refer) {
        var _this$state6 = this.state,
            panning = _this$state6.panning,
            rotating = _this$state6.rotating;

        if (panning || rotating) {
          return null;
        }

        return [renderPieDataLabel(refer), renderAnnotation(refer)];
      };

      _proto.showEffect = function showEffect(id, effect) {
        var _this3 = this;

        var sector = this.getZNode(id);
        var animator = this.createEffectAni(id, effect, effect * 1000);
        animator.during(function (_ref2) {
          var pct = _ref2.pct;

          var row = _this3.getRow(id);

          var _row$shape = row.shape,
              r = _row$shape.r,
              r0 = _row$shape.r0,
              startAngle = _row$shape.startAngle,
              endAngle = _row$shape.endAngle;
          var rotation = _this3.state.rotation;
          startAngle += rotation;
          endAngle += rotation;
          r *= getEffectScale(pct, EFFECT_SCALE_COEFFICIENT_ONE$1);
          sector.attrKV('shape', {
            r: r,
            r0: r0,
            startAngle: startAngle,
            endAngle: endAngle
          });
        }).start();
      };

      Pie._getRotationWithSector = function _getRotationWithSector(sector) {
        if (!sector) {
          return 0;
        }

        return -calcFineRotation(sector) - Math.PI / 2;
      };

      return Pie;
    }(Geometry);

    var PieGroup = Geom.createGeomGroup(ChartLibrary.PIE, Pie);
    PieGroup.layout = layout$1;
    PieGroup.calcDataLabelPos = calcDataLabelPos;

    PieGroup.adjustDataLabel = function (_ref3) {
      var cellRows = _ref3.rows,
          rest = _objectWithoutPropertiesLoose(_ref3, ["rows"]);

      _.each(_.groupBy(cellRows, function (row) {
        return row.groupId;
      }), function (rows) {
        adjustLabel$1(_extends({
          rows: rows
        }, rest));
      });
    };

    PieGroup.usePercentSize = isGeomUsePercentSize;

    PieGroup.updateGeometryWhileZoomScale = function (_ref4) {
      var geom = _ref4.geom,
          facetX = _ref4.facetX,
          facetY = _ref4.facetY,
          zoom = _ref4.zoom;
      // 这里必须同时使用zoom.x 和zoom.y才能确定出最终的maxRadius
      var maxRadius = geom.maxRadius,
          xUnit = facetX.unit,
          yUnit = facetY.unit; // sizeScale for update row.size

      geom.sizeScale = Math.min(zoom.x * xUnit, zoom.y * yUnit) / Math.min(xUnit, yUnit);
      geom.maxRadius = maxRadius * geom.sizeScale;
    };

    PieGroup.adjust = adjust$1;

    var adjustDataLabel = function adjustDataLabel(_ref) {
      var rows = _ref.rows,
          cell = _ref.cell,
          rest = _objectWithoutPropertiesLoose(_ref, ["rows", "cell"]);

      var innerRows = [],
          outerRows = [];
      var maxRadius = cell.maxRadius;

      for (var i = rows.length - 1; i >= 0; i--) {
        var row = rows[i];
        (row.level === 1 ? outerRows : innerRows).push(row);
      }

      adjustLabel$1(_extends({}, rest, {
        rows: innerRows,
        position: DataLabel.INSIDE,
        maxRadius: maxRadius
      }));
      adjustLabel$1(_extends({}, rest, {
        rows: outerRows,
        maxRadius: maxRadius
      }));
    };

    var sumCol = function sumCol(col) {
      return _.reduce(col, function (sum, v) {
        return sum + +v;
      }, 0);
    };
    var isValueField = function isValueField(field) {
      return field.type === FieldType.MEASURE || field.id === AesTypes.SIZE;
    };
    var getLevelDataFrame = function getLevelDataFrame(fields, frame) {
      var _fieldMap;

      var colCount = frame.colCount();
      var groupFrameMap = Frame.group(frame, fields);

      var colData = _.map(new Array(colCount), function () {
        return [];
      });

      var fieldMap = (_fieldMap = {}, _fieldMap[AesTypes.COLOR] = 1, _fieldMap[AttrKeys.Y] = 1, _fieldMap[AttrKeys.Y0] = 1, _fieldMap);

      var fieldIdMap = _.reduce(frame.fields, function (map, field) {
        map[field.id] = field.groupId;
        return map;
      }, {});

      var groupIdMap = _.groupBy(frame.fields, function (field) {
        return field.groupId;
      }); // @CHART-9032 考虑同名字段


      _.each(fields, function (id) {
        var sameNameFields = groupIdMap[fieldIdMap[id]];

        _.each(sameNameFields, function (field) {
          fieldMap[field.id] = 1;
        });
      });

      _.each(groupFrameMap, function (groupFrame) {
        var _colData = groupFrame.colData;

        _.each(groupFrame.fields, function (field, colIndex) {
          var col = colData[colIndex],
              originCol = _colData[colIndex];

          if (fieldMap[field.id]) {
            col.push(originCol[0]);
          } else {
            col.push(isValueField(field) ? sumCol(originCol) : null);
          }
        });
      });

      return {
        fields: frame.fields,
        colData: colData
      };
    };
    var prepareMultiPieData = function prepareMultiPieData(geom, options) {
      var facetX = options.facetX,
          facetY = options.facetY;
      var dimensions = [].concat(facetX.dimensions, facetY.dimensions);
      var hierarchy = geom.hierarchy,
          dataModel = geom.data;

      if (hierarchy.length <= 1) {
        return;
      } // @BI-40417
      // NOTE Special condition:
      // 当多层饼图当且仅当颜色和大小里存在不同维度字段时
      // 此时的最外层大小全为null, 故多层饼图应该只有一层
      // if (isNullSizeMultiPie(geom)) {
      //     hierarchy.shift();
      // }


      var dataFrame = new Frame(dataModel.fields, dataModel.colData);
      var cellDataMap = Frame.group(dataFrame, dimensions);
      var levelDataFrames = [];

      _.each(cellDataMap, function (frame) {
        for (var i = 0, len = hierarchy.length - 1; i < len; i++) {
          var gFields = hierarchy.slice(0, i + 1);
          var fields = dimensions.concat(gFields);
          levelDataFrames.push(getLevelDataFrame(fields, frame));
        }
      });

      var levelColDataNum = 0;

      _.each(levelDataFrames, function (levelData) {
        var colData = dataFrame.colData;
        var levelColData = levelData.colData;

        _.each(colData, function (col, colIndex) {
          colData[colIndex] = col.concat(levelColData[colIndex]);
          levelColDataNum += levelColData.length;
        });
      });

      _.each(geom.frames, function (frame) {
        var x = frame.value[0];

        for (var i = 0; i < levelColDataNum; i++) {
          frame.value.push(x);
        }
      });
    };

    /**
     * 获取所有的parentRow对应的leafRows
     * @param rows
     */
    function getLeafRowsMap(rows) {
      var leafRowsMap = {};

      _.each(_.filter(rows, function (row) {
        return row.level === 1;
      }), function (row) {
        var pids = row.pids;

        _.each(pids, function (pid, index) {
          if (index === 0) {
            return;
          }

          if (!leafRowsMap[pid]) {
            leafRowsMap[pid] = [];
          }

          leafRowsMap[pid].push(row);
        });
      });

      return leafRowsMap;
    }

    var getTransitionProps$1 = getGeomTransitionProps(Timing);

    var MultiPie =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(MultiPie, _Geometry);

      function MultiPie(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.fadeParentRowMap = {};
        _this.handleSectorOn = _this.handleSectorOn.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.getTransitionProps = getTransitionProps$1;

        _this.updateState(props);

        return _this;
      }

      var _proto = MultiPie.prototype;

      _proto.handleSectorOn = function handleSectorOn(ev) {
        var id = ev.target.id;

        if (!id) {
          return;
        }

        this.props.onmousemove(ev);
      };

      _proto.getGroupProps = function getGroupProps() {
        var _this2 = this;

        var props = _Geometry.prototype.getGroupProps.call(this);

        var _this$props = this.props,
            bounds = _this$props.bounds,
            animation = _this$props.animation;
        props.onmouseover = props.onmousemove = this.handleSectorOn;

        if (this._init && animation) {
          props.transition = getGroupInitTransition();

          props.transitionEnd = function () {
            return _this2.triggerGroupEffects();
          };
        }

        props.position = getBoundsCenter(bounds);
        props.scale = [1, 1];
        props.rotation = 0;
        return props;
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.updateState(nextProps);
      };

      _proto.updateState = function updateState(_ref) {
        var rows = _ref.rows,
            bounds = _ref.bounds;
        this.setState({
          data: rows.slice().sort(function (r1, r2) {
            return r1.level - r2.level;
          }),
          center: getBoundsCenter(bounds),
          leafRowsMap: getLeafRowsMap(rows)
        });
      };

      _proto.render = function render(_ref2) {
        var _this3 = this;

        var bounds = _ref2.bounds,
            rows = _ref2.rows,
            highlights = _ref2.highlights;
        this.fadeParentRowMap = {};
        var leafRowsMap = this.state.leafRowsMap;
        var fadeChecker = this.props.fadeChecker; // FixME, 这里我们的parentRow是虚构的, 从设计角度来说, 这些parentRow的fade状态不应该由fadeChecker来决定, 因为fadeChecker使用的数据源是最外层的leafRows,
        // Note: 这里我们获取所有的parentRow对应的leafRows， 然后缓存parentRow的fade状态, 再addGuideRefer和renderGraphic的时候使用
        // Note: 注意, 只有当所有的LeafRows都为fade状态时, parentRow.isFade才为true

        _.each(rows, function (row) {
          if (row.level === 1) {
            return;
          }

          var leafRows = leafRowsMap[row.id];
          _this3.fadeParentRowMap[row.id] = leafRows && _.every(leafRows, function (row) {
            return fadeChecker(row);
          });
        });

        this.center = getBoundsCenter(bounds);
        this.hoverIds = dealHighlight(rows, highlights);
        return _Geometry.prototype.render.call(this);
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            row = node.data;
        var hoverIds = this.hoverIds;
        var color = row.color,
            id = row.id,
            depth = row.depth,
            _row$shape = row.shape,
            startAngle = _row$shape.startAngle,
            endAngle = _row$shape.endAngle,
            r = _row$shape.r,
            r0 = _row$shape.r0;
        var hover = false;

        if (hoverIds[id]) {
          hover = true;
          node.condition = HOVER;
        }

        var _this$props2 = this.props,
            process = _this$props2.process,
            borderColor = _this$props2.borderColor,
            opacity = _this$props2.opacity,
            hierarchy = _this$props2.hierarchy;
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isEnter = transitionProps.isEnter;
        var isFade = transitionProps.isFade,
            silent = transitionProps.silent; // Note: parentRow的fade状态判断需要特殊对待

        if (row.level > 1) {
          isFade = this.fadeParentRowMap[id];
          silent = isFade ? false : silent;
        }

        var shape = {
          startAngle: startAngle,
          endAngle: endAngle,
          r: r * (hover ? HOVER_PCT : 1),
          r0: r0
        };
        var style = {
          fill: hover ? color : getHSLFill(color, hierarchy.length ? (depth - 1) / hierarchy.length : 0),
          shadowBlur: 0,
          lineWidth: 1,
          opacity: hover ? 1 : opacity,
          // BI-30599
          stroke: borderColor
        }; // 悬浮时，只有形状做动画

        if (hover && transition) {
          transition.properties = {
            shape: 1
          };
        }

        if (isEnter && process === SHOW) {
          transition.appear = getShowEnterAppearFn(node);
        }

        isFade && fadeStyle(style);
        return h('sector', {
          key: key,
          id: key,
          silent: silent,
          transition: transition,
          transitionEnd: transitionEnd,
          shape: shape,
          style: style
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        if (this._groupTransition) {
          refer.transition = this._groupTransition;
        }

        var row = node.data;

        if (row.level > 1) {
          refer.isFade = this.fadeParentRowMap[row.id];
        }

        var _calcAnnotatePosAndDi = calcAnnotatePosAndDirection(row.shape),
            startPos = _calcAnnotatePosAndDi.startPos,
            direction = _calcAnnotatePosAndDi.direction;

        refer.startPos = startPos;
        refer.direction = direction;
        refer.multiPie = true;
        refer.applyTheme = row.level !== 1;
      };

      _proto.renderGuides = function renderGuides(refer) {
        return [renderPieDataLabel(refer), renderAnnotation(refer)];
      };

      _proto.showEffect = function showEffect(id, effect) {
        var _this4 = this;

        var sector = this.getZNode(id);
        var animator = this.createEffectAni(id, effect, effect * 1000);
        animator.during(function (_ref3) {
          var pct = _ref3.pct;

          var row = _this4.getRow(id);

          var _row$shape2 = row.shape,
              r = _row$shape2.r,
              r0 = _row$shape2.r0,
              startAngle = _row$shape2.startAngle,
              endAngle = _row$shape2.endAngle;
          r *= getEffectScale(pct, EFFECT_SCALE_COEFFICIENT_ONE$1);
          sector.attrKV('shape', {
            r: r,
            r0: r0,
            startAngle: startAngle,
            endAngle: endAngle
          });
        }).start();
      };

      return MultiPie;
    }(Geometry);

    MultiPie.layout = layout;
    MultiPie.calcDataLabelPos = calcDataLabelPos$1;
    MultiPie.adjustDataLabel = adjustDataLabel;
    /**
     * 现在的多层饼图吧
     * 怎么都不合理
     * 在和王军扯了一堆之后, 得出结论
     * 按照5.0的逻辑来, 处理映射用最细粒度数据(因为上层对应的维度汇总为null, 此时如果映射大小是无意义的)
     * 那么, 在流程处理上, 我们需要先用最外层的数据去计算映射关系等等
     * 然后再生成层级结构, 对于像角度大小这样的映射属性就可以直接取汇总而不是映射值(否则维度下说不通)
     * 这样就会导致一个问题, 图例的交互(因为默认图例取得是映射是得domain, 此时层级数据尚未生成), 滑块图例只对最外层数据生效
     * 对此, 暂定给出得方案是, 图例只对最外层生效, 内层的图形得状态取决于children的状态(即如果所有的child都灰化, 那么父元素才灰化)
     * 这个方案也不是很好, 但暂时也没有更好的方案
     * @type {prepareMultiPieData}
     */

    MultiPie.dealData = prepareMultiPieData;
    Geom.registerGeom('multiPie', MultiPie);

    function calcTooltipPos(type, instance) {
      var pos;

      if (instance.tooltipPos) {
        var _instance$tooltipPos = instance.tooltipPos,
            x = _instance$tooltipPos[0],
            y = _instance$tooltipPos[1];
        pos = {
          x: x,
          y: y
        };
      } else {
        switch (type) {
          case ChartLibrary.INTERVAL:
          case ChartLibrary.SQUARE:
          case ChartLibrary.TREE_MAP:
            pos = rect(instance);
            break;

          case ChartLibrary.PIE:
          case ChartLibrary.MULTI_PIE:
            pos = sector(instance, type === ChartLibrary.MULTI_PIE);
            break;

          default:
            pos = dot$2(instance);
        }
      } // for zrInstance, apply translate from transform


      if (instance.transform && instance.transform.length === 6) {
        var transform = instance.transform;
        pos.x += transform[4];
        pos.y += transform[5];
      }

      return pos;
    } // 矩形
    // function rect({shape:{x, y, width}}){

    function rect(_ref) {
      var _ref$shape = _ref.shape,
          x = _ref$shape.x,
          y = _ref$shape.y,
          width = _ref$shape.width;
      return {
        x: x + width,
        y: y,
        direction: Direction.RIGHT_BOTTOM
      };
    } // 扇形


    function sector(_ref2, multiPie) {
      var _ref2$shape = _ref2.shape,
          startAngle = _ref2$shape.startAngle,
          endAngle = _ref2$shape.endAngle,
          r = _ref2$shape.r,
          _ref2$shape$cx = _ref2$shape.cx,
          cx = _ref2$shape$cx === void 0 ? 0 : _ref2$shape$cx,
          _ref2$shape$cy = _ref2$shape.cy,
          cy = _ref2$shape$cy === void 0 ? 0 : _ref2$shape$cy,
          _ref2$radius = _ref2.radius,
          radius = _ref2$radius === void 0 ? r : _ref2$radius;
      radius *= multiPie ? HOVER_PCT : HOVER_PCT$1;
      var PI = Math.PI,
          doublePI = PI * 2,
          halfPI = PI / 2;
      var middleAngle = (startAngle + endAngle) / 2,
          residual = normalRadian(middleAngle);
      var direction;

      if (residual >= PI * 1.5 && residual <= doublePI) {
        direction = Direction.RIGHT_TOP;
      } else if (residual > 0 && residual <= halfPI) {
        direction = Direction.RIGHT_BOTTOM;
      } else if (residual > halfPI && residual < PI) {
        direction = Direction.LEFT_BOTTOM;
      } else {
        direction = Direction.LEFT_TOP;
      }

      return {
        x: cx + radius * Math.cos(residual),
        y: cy + radius * Math.sin(residual),
        direction: direction
      };
    }
    /**
     *
     * @param shape
     * @returns {{x: *, y: *, direction: string}}
     */


    function dot$2(_ref3) {
      var shape = _ref3.shape;
      var _shape$cx = shape.cx,
          cx = _shape$cx === void 0 ? 0 : _shape$cx,
          _shape$cy = shape.cy,
          cy = _shape$cy === void 0 ? 0 : _shape$cy;
      return {
        x: cx,
        y: cy
      };
    }

    var HIDE_DELAY = 500;
    var BORDER_RADIUS = 2;
    var TIMING = {
      ease: Ease.Swing,
      duration: 250
    };
    var DARK_COLOR = '#fff';
    var LIGHT_COLOR = '#5987F4';
    var OUTER_OPACITY = 0.3;

    var Prompt =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Prompt, _Component);

      function Prompt() {
        var _this;

        _this = _Component.apply(this, arguments) || this;
        _this.setHideTimer = _this.setHideTimer.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.clearHideTimer = _this.clearHideTimer.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.count = 0;
        return _this;
      }

      var _proto = Prompt.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var isHover = nextProps.isHover;

        if (!this.state || isHover) {
          this.state = _extends({}, nextProps);
        }

        isHover && this.count++;
      };

      _proto.setHideTimer = function setHideTimer() {
        var _this2 = this;

        this.clearHideTimer();
        this._timer = setTimeout(function () {
          _this2.setState({
            content: [],
            hide: true
          });

          _this2.count = 0;
        }, HIDE_DELAY);
      };

      _proto.clearHideTimer = function clearHideTimer() {
        clearTimeout(this._timer);
        this._timer = null;
      };

      _proto.render = function render$$1() {
        var _this3 = this;

        var _this$props = this.props,
            isHover = _this$props.isHover,
            limitBounds = _this$props.limitBounds;
        var isEnter = this.count === 1; // 第一次hover为true即count为1的时候，才认为是enter，此时不需要做位移过渡

        var _this$state = this.state,
            _this$state$content = _this$state.content,
            content = _this$state$content === void 0 ? [] : _this$state$content,
            _this$state$bounds = _this$state.bounds,
            bounds = _this$state$bounds === void 0 ? {} : _this$state$bounds,
            _this$state$hide = _this$state.hide,
            hide = _this$state$hide === void 0 ? false : _this$state$hide,
            _this$state$forecastL = _this$state.forecastLineHeight,
            forecastLineHeight = _this$state$forecastL === void 0 ? 0 : _this$state$forecastL;
        var pw = limitBounds.width,
            ph = limitBounds.height;
        isHover && this._timer && this.clearHideTimer();
        !isHover && !hide && this.setHideTimer();
        var _bounds$x = bounds.x,
            x = _bounds$x === void 0 ? 0 : _bounds$x,
            _bounds$y = bounds.y,
            y = _bounds$y === void 0 ? 0 : _bounds$y;
        return h(Animate$$1, {
          enter: {
            x: x,
            y: y
          },
          update: {
            x: isEnter ? x : [x],
            y: isEnter ? y : [y],
            timing: TIMING
          }
        }, function (_ref) {
          var x = _ref.x,
              y = _ref.y;
          return h('group', {
            position: [x, y + forecastLineHeight],
            silent: true,
            clip: {
              type: 'rect',
              shape: {
                x: 0,
                y: -forecastLineHeight,
                width: pw * TOOLTIP_MAX_WIDTH,
                height: ph
              }
            }
          }, // background
          _this3.renderBackground(), // contents
          content, _this3.renderForecastNote());
        });
      };

      _proto.renderBackground = function renderBackground() {
        var _this$state2 = this.state,
            _this$state2$content = _this$state2.content,
            content = _this$state2$content === void 0 ? [] : _this$state2$content,
            _this$state2$bounds = _this$state2.bounds,
            bounds = _this$state2$bounds === void 0 ? {} : _this$state2$bounds,
            style = _this$state2.style,
            forecastLineHeight = _this$state2.forecastLineHeight;

        if (content.length === 0) {
          return null;
        }

        var _bounds$width = bounds.width,
            width = _bounds$width === void 0 ? 0 : _bounds$width,
            _bounds$height = bounds.height,
            height = _bounds$height === void 0 ? 0 : _bounds$height;
        return h('rect', {
          shape: {
            width: width,
            height: height - forecastLineHeight,
            r: BORDER_RADIUS
          },
          z: z,
          zlevel: zLevel,
          style: style
        });
      } // 预测提示
      ;

      _proto.renderForecastNote = function renderForecastNote() {
        var _this$state3 = this.state,
            _this$state3$forecast = _this$state3.forecastLineHeight,
            forecastLineHeight = _this$state3$forecast === void 0 ? 0 : _this$state3$forecast,
            _this$state3$forecast2 = _this$state3.forecastKey,
            forecastKey = _this$state3$forecast2 === void 0 ? '' : _this$state3$forecast2,
            darkTheme = _this$state3.darkTheme,
            _this$state3$content = _this$state3.content,
            content = _this$state3$content === void 0 ? [] : _this$state3$content;

        if (forecastLineHeight === 0 || content.length === 0) {
          return null;
        }

        var color = darkTheme ? DARK_COLOR : LIGHT_COLOR;
        var yTranslate = -FORECAST_OUTER_RADIUS - FORECAST_MARGIN_BOTTOM;
        var text = h('text', {
          z: z,
          zlevel: zLevel,
          position: [FORECAST_OUTER_RADIUS * 2 + FORECAST_INNER_PADDING, yTranslate],
          style: {
            text: forecastKey,
            textFill: color,
            textAlign: 'left',
            textVerticalAlign: 'middle',
            fontSize: FORECAST_FONT_SIZE,
            fontFamily: FORECAST_FONT_FAMILY
          }
        });
        var outerCircle = h('circle', {
          z: z,
          zlevel: zLevel,
          position: [FORECAST_OUTER_RADIUS, yTranslate],
          shape: {
            r: FORECAST_OUTER_RADIUS
          },
          style: {
            fill: color,
            opacity: OUTER_OPACITY
          }
        });
        var innerCircle = h('circle', {
          z: z,
          zlevel: zLevel,
          position: [FORECAST_OUTER_RADIUS, yTranslate],
          shape: {
            r: FORECAST_INNER_RADIUS
          },
          style: {
            fill: color
          }
        });
        return [outerCircle, innerCircle, text];
      };

      return Prompt;
    }(Component);

    var DEFAULT_BACKGROUND = '#000';
    var DEFAULT_OPACITY = 0.65;
    var TOOLTIP_MAX_WIDTH = 2 / 3;
    var z = StaticLayerZ;
    var zLevel = TooltipZLevel; // http://47.104.151.0:8011/git/视觉/vidocuments/8-图表视觉规则/index.html#g=1&p=时序预测

    var FORECAST_INNER_RADIUS = 3;
    var FORECAST_OUTER_RADIUS = 6;
    var FORECAST_MARGIN_BOTTOM = 3;
    var FORECAST_INNER_PADDING = 5;
    var FORECAST_FONT_SIZE = 12;
    var FORECAST_FONT_FAMILY = 'PingFang SC, Microsoft Yahei Light, Monaco, Arial';
    var Tooltip$1 = function Tooltip$$1(_ref) {
      var pos = _ref.pos,
          tooltipConfig = _ref.tooltip,
          limitBounds = _ref.bounds,
          darkTheme = _ref.darkTheme,
          panningCell = _ref.panningCell;

      var _ref2 = tooltipConfig || {},
          geom = _ref2.geom,
          row = _ref2.row,
          instance = _ref2.instance;

      var isHover = geom && row; // !isBlank(targets);
      // no target element

      if (!isHover) {
        return h(Prompt, {
          isHover: isHover,
          content: [],
          limitBounds: limitBounds
        });
      }

      var _geom$tooltip = geom.tooltip,
          background = _geom$tooltip.background,
          borderColor = _geom$tooltip.borderColor,
          opacity = _geom$tooltip.opacity,
          _geom$tooltip$forecas = _geom$tooltip.forecastKey,
          forecastKey = _geom$tooltip$forecas === void 0 ? '' : _geom$tooltip$forecas; // 用instance的好处是不用考虑translate了, 没有instance的我们认为row是构造的，那么row.shape上面对应的形状位置应该也是完整且正确的

      var _ref3 = calcTooltipPos(geom.type, instance || row) || pos,
          x = _ref3.x,
          y = _ref3.y,
          _ref3$direction = _ref3.direction,
          direction = _ref3$direction === void 0 ? Direction.RIGHT_BOTTOM : _ref3$direction; // apply translate


      var style = {
        fill: background || DEFAULT_BACKGROUND,
        stroke: borderColor,
        lineWidth: 1,
        opacity: opacity || DEFAULT_OPACITY
      };

      var _getPromptProps = getPromptProps(row, buildRichForTooltip(tooltipConfig, darkTheme)),
          width = _getPromptProps.width,
          height = _getPromptProps.height,
          textNodes = _getPromptProps.textNodes,
          _getPromptProps$empty = _getPromptProps.empty,
          empty = _getPromptProps$empty === void 0 ? false : _getPromptProps$empty;

      if (empty || panningCell) {
        return h('group');
      }

      var forecastLineHeight = 0;

      if (row.fake) {
        var _calcTextDim = calcTextDim(forecastKey, {
          fontSize: FORECAST_FONT_SIZE
        }),
            textWidth = _calcTextDim[0];

        width = Math.max(width, textWidth);
        forecastLineHeight += FORECAST_FONT_SIZE + FORECAST_MARGIN_BOTTOM;
        height += forecastLineHeight;
      }

      var bounds = {
        x: x,
        y: y,
        width: width,
        height: height
      }; // 根据方向调整位置

      position(bounds, direction); // 根据位置和plotBounds再调整位置，保证不溢出

      adjust(bounds, limitBounds);
      return h(Prompt, {
        darkTheme: darkTheme,
        forecastKey: forecastKey,
        forecastLineHeight: forecastLineHeight,
        isHover: isHover,
        content: textNodes,
        style: style,
        bounds: bounds,
        limitBounds: limitBounds
      });
    };
    var Tooltip$2 = connect(function (state) {
      var _computedSelect = computedSelect(state),
          bounds = _computedSelect.bounds,
          tooltip = _computedSelect.tooltip,
          darkTheme = _computedSelect.darkTheme,
          mousePos = _computedSelect.mousePos,
          panningCell = _computedSelect.panningCell;

      return {
        pos: mousePos,
        tooltip: tooltip,
        darkTheme: darkTheme,
        panningCell: panningCell,
        bounds: bounds
      };
    })(Tooltip$1);

    var PADDING = 6;
    var DOUBLE_PADDING = PADDING * 2;
    var SHARE_FONT_SIZE = 14;
    var DARK_THEME_SHARE_COLOR = '#1A1A1A';
    var LIGHT_THEME_SHARE_COLOR = '#FFFFFF';
    var SHARE_FONT_FAMILY = 'Verdana,PingFangSC-Light,Microsoft YaHei,sans-serif';
    var LANE_GAP = 0.5;

    var addLine = function addLine(content, newLine) {
      return (content === '' ? '' : content + "\n") + ("{1|" + newLine + "}");
    };

    var buildRichForSharedTooltip = function buildRichForSharedTooltip(_ref, defaultColor) {
      var row = _ref.row,
          geoms = _ref.geoms,
          dims = _ref.dims;
      var style = {
        '1': {
          fontSize: SHARE_FONT_SIZE,
          color: defaultColor,
          fontFamily: SHARE_FONT_FAMILY
        }
      };
      var formatter = ''; // http://www.finedevelop.com/pages/viewpage.action?pageId=16683643

      _.each(dims, function (_ref2) {
        var name = _ref2.name,
            id = _ref2.id,
            format = _ref2.format;
        return formatter = addLine(formatter, name + ":" + getFormattedText(row[id], format));
      });

      _.each(geoms, function (_ref3, id) {
        var name = _ref3.name,
            rows = _ref3.rows,
            format = _ref3.format;
        return formatter = addLine(formatter, name + ":" + (rows.length > 1 ? '*' : getFormattedText(rows[0][id], format)));
      });

      return {
        formatter: formatter,
        fields: [],
        style: style
      };
    };

    var buildRichForTooltip = function buildRichForTooltip(tooltipConfig, darkTheme) {
      var tooltip = tooltipConfig.geom.tooltip,
          _tooltipConfig$dims = tooltipConfig.dims,
          dims = _tooltipConfig$dims === void 0 ? [] : _tooltipConfig$dims,
          tooltipShared = tooltipConfig.tooltipShared;
      var _tooltip$color = tooltip.color,
          color = _tooltip$color === void 0 ? darkTheme ? DARK_THEME_SHARE_COLOR : LIGHT_THEME_SHARE_COLOR : _tooltip$color;
      return tooltipShared && dims.length ? buildRichForSharedTooltip(tooltipConfig, color) : tooltip;
    };
    var getPromptProps = function getPromptProps(row, rich) {
      var prop = rowToParagraphProp({
        row: row,
        rich: rich,
        lineGap: LANE_GAP
      });
      var bounds = prop.bounds,
          data = prop.data;
      bounds.x = bounds.y = PADDING;
      var width = bounds.width,
          height = bounds.height;
      return {
        textNodes: data.length ? [h(Paragraph, _extends({}, prop, {
          z: z,
          zlevel: zLevel
        }))] : [],
        width: width + DOUBLE_PADDING,
        height: height + DOUBLE_PADDING,
        empty: width === 0 || height === 0
      };
    };
    var formatTooltipLines = function formatTooltipLines(tooltipConfig) {
      var row = tooltipConfig.row;
      var rich = buildRichForTooltip(tooltipConfig);

      var _formatText = formatText(rich, row),
          lines = _formatText.data;

      return _.map(lines, function (line) {
        return line; // let content = "";
        // _.each(line, textObj => content += textObj.text);
        //
        // return content;
      });
    };

    /**
     * 理论上我们通过pure data能做所有事情，所有都是由初始数据衍生出来的
     * 但是交互时，如果我们从data开始处理需要的点，中间就要许多复杂计算
     * 而这些计算结果其实都在render结果里 (比如shape包围盒大小)
     * 所以把交互的各种处理搞成外部副作用，绕过store直接从render结果取
     */

    var filterSameGroupIdMeasure = function filterSameGroupIdMeasure(metaData) {
      var groupIdMap = {};
      return _.reduce(metaData, function (output, field) {
        if (field.isDimension) {
          output.push(field);
        } else if (field.isMeasure && !groupIdMap[field.groupId]) {
          groupIdMap[field.groupId] = 1;
          output.push(field);
        }

        return output;
      }, []);
    };

    var isForecastField = function isForecastField(id) {
      return id.indexOf(FORECAST_SUFFIX) >= 0 || id.indexOf(UPPER_LIMIT) >= 0 || id.indexOf(LOWER_LIMIT) >= 0;
    };

    var Base =
    /*#__PURE__*/
    function () {
      function Base(_ref) {
        var store = _ref.store,
            emitter = _ref.emitter,
            zr = _ref.zr;
        this.store = store;
        this.emitter = emitter;
        this.timer = new Timer$1();
        this.stage = this.getStage(); // todo, 实际上，只要storage
        // 从storage里面找对象

        this.zr = zr;

        if (this.handleChange) {
          this.unsubscribe = this.store.subscribe(this._handleChange.bind(this));
        }
      }

      var _proto = Base.prototype;

      _proto.setZr = function setZr(zr) {
        this.zr = zr;
      };

      _proto._handleChange = function _handleChange() {
        if (!this.unsubscribe) {
          return;
        }

        this.handleChange();
      };

      _proto.getDerived = function getDerived() {
        return computedSelect(this.store.getState());
      };

      _proto.getStage = function getStage() {
        return this.store.getState().hoverStage;
      };

      _proto.hasStage = function hasStage(v) {
        return this.getStage() & v;
      } // TODO, refactor highlight & tooltip logic
      // Differentiate:
      // highlight points & tooltip info, tooltip pos, and big data.
      // For example, pos change doesn't result in info change.
      ;

      _proto.getHighlightAction = function getHighlightAction(_ref2, computedState) {
        var target = _ref2.target,
            id = _ref2.id,
            pos = _ref2.pos;

        if (computedState === void 0) {
          computedState = this.getDerived();
        }

        // todo, split normal & bigData
        var _computedState = computedState,
            totalRowCount = _computedState.totalRowCount; // todo, when is the target empty ?

        var instance = target || getZRInstanceById(id, this.zr);

        var _dealTooltipAndHighli = dealTooltipAndHighlights(id, computedState),
            tooltip = _dealTooltipAndHighli.tooltip,
            targets = _dealTooltipAndHighli.targets,
            highlightNode = _dealTooltipAndHighli.highlightNode;

        var nextState = {
          pos: pos,
          tooltip: _extends({}, tooltip, {
            instance: instance
          }),
          highlightNode: highlightNode
        }; // workaround for linear

        if (totalRowCount > BIG_DATA_LIMIT) {
          return Act.highlight(nextState);
        }

        nextState.targets = targets;
        return Act.highlightMatchedTarget(nextState);
      };

      _proto._getPointInfo = function _getPointInfo(_ref3, computedState) {
        var id = _ref3.id;

        if (computedState === void 0) {
          computedState = this.getDerived();
        }

        var _computedState2 = computedState,
            rowMap = _computedState2.rowMap,
            geoms = _computedState2.geoms,
            facetX = _computedState2.facetX,
            enableMap = _computedState2.enableMap;
        var row = rowMap[id],
            geom = geoms[row.geomIndex];
        var measure = geom.measure,
            metaData = geom.metaData; // 同名指标字段去重

        metaData = filterSameGroupIdMeasure(metaData); // @BI-31948
        // 这个问题比较有意思了
        // BI那边的钻取需要钻取字段信息+其他关联维度信息
        // 如果关联维度信息里面有Value为NULL就直接返回空表
        // 而数据库里面的NULL在引擎取数之后都是做空字符串处理的
        // 所以图表这边拿到的数据应该不存在NULL
        // 但是在多层饼图的上层构建中, 对于下层维度字段都是取的NULL(因为维度没办法汇总嘛)
        // 这就导致了多层饼图上层有钻取目录的时候,点击钻取关联字段会传NULL
        // 就GG了
        // interesting🙂🙂🙂🙂
        // BI-38007&&BI-39195 联动不需要把预测的字段传递过去

        metaData = _.filter(metaData, function (metaField) {
          return !isForecastField(metaField.id);
        });

        if (enableMap) {
          metaData = _.filter(metaData, function (_ref4) {
            var id = _ref4.id;
            return !(id === LNG || id === LAT);
          });
        }

        return {
          row: row,
          measure: measure,
          metaData: metaData
        };
      };

      _proto.selectPoint = function selectPoint(_ref5, computedState) {
        var id = _ref5.id,
            pos = _ref5.pos;

        if (computedState === void 0) {
          computedState = this.getDerived();
        }

        var _this$_getPointInfo = this._getPointInfo({
          id: id
        }, computedState),
            row = _this$_getPointInfo.row,
            measure = _this$_getPointInfo.measure,
            metaData = _this$_getPointInfo.metaData;

        var _dealTooltipAndHighli2 = dealTooltipAndHighlights(id, computedState),
            tooltip = _dealTooltipAndHighli2.tooltip;

        var tooltipText = formatTooltipLines(tooltip);
        this.emitter.trigger('pointSelected', {
          tooltipText: tooltipText,
          row: row,
          measure: measure,
          metaData: metaData,
          pos: pos
        });
      };

      _proto.selectDimension = function selectDimension(payload) {
        var dimensions = payload.facet.dimensions,
            id = payload.id;
        var names = id.split(SEPARATOR);

        var value = _.map(names, function (text, index) {
          return {
            dId: dimensions[index],
            text: text
          };
        });

        this.emitter.trigger('dimensionSelected', {
          dId: dimensions[names.length - 1],
          value: value
        });
      };

      _proto.dispose = function dispose() {
        this.timer.clear();
        this.unsubscribe && this.unsubscribe();
        this.unsubscribe = null;
      };

      return Base;
    }();

    var EDGE_MOVE_RATE = 50;
    var EDGE_MOVE_DELTA = 2;
    var HIDE_MOBILE_TOOLTIP = 'hideMobileTooltip'; // 2s由移动端在tooltip card展开后开始计时

    var getScrollDelta = function getScrollDelta(side) {
      var deltaX = 0,
          deltaY = 0;

      switch (side) {
        case 'top':
          deltaY = EDGE_MOVE_DELTA;
          break;

        case 'bottom':
          deltaY = -EDGE_MOVE_DELTA;
          break;

        case 'left':
          deltaX = EDGE_MOVE_DELTA;
          break;

        case 'right':
          deltaX = -EDGE_MOVE_DELTA;
          break;
      }

      return {
        deltaX: deltaX,
        deltaY: deltaY,
        vanSynth: true
      };
    };

    var isEmptyFacet$1 = function isEmptyFacet(facet) {
      var dimensions = facet.dimensions;
      var measures = getAllMeasuresOnFacet(facet);
      return dimensions.length === 0 && measures.length === 0;
    };

    var shouldZoom = function shouldZoom(state) {
      var facetX = state.facetX,
          facetY = state.facetY;
      return !(isEmptyFacet$1(facetX) && isEmptyFacet$1(facetY));
    };

    var Touch =
    /*#__PURE__*/
    function (_Base) {
      _inheritsLoose(Touch, _Base);

      function Touch() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Base.call.apply(_Base, [this].concat(args)) || this;
        _this.edgeMovingSide = null;
        _this.pinchStartZoom = {};
        _this.zoomLimit = {};
        _this.targetId = null;
        _this.focusPosition = {};

        _this.hide = function (e) {
          _this.store.dispatch(Act.unhover());

          _this.emitter.trigger(HIDE_MOBILE_TOOLTIP, {
            delay: false
          });
        };

        _this.delayHide = function (e) {
          _this.emitter.trigger(HIDE_MOBILE_TOOLTIP, {
            delay: true
          });
        };

        _this.tap = function (e) {
          // if not in selecting, enter selecting
          if (!_this.hasStage(STAGES.SELECT)) {
            _this.enterSelect({
              pos: {
                x: e.offsetX,
                y: e.offsetY
              }
            });
          } // cancel bubble


          return true;
        };

        _this.dimensionTap = function (payload) {
          _this.selectDimension(payload);
        };

        _this.touchStart = function (e) {
          if (_this.hasStage(STAGES.SELECT)) {
            _this.select({
              pos: {
                x: e.offsetX,
                y: e.offsetY
              }
            });

            return true;
          }
        };

        _this.touchEnd = function (e) {
          if (_this.hasStage(STAGES.SELECT)) {
            _this.leaveSelect({
              pos: {
                x: e.offsetX,
                y: e.offsetY
              }
            });
          }
        };

        _this.panStart = function (e) {
          stop$2(e);

          if (_this.hasStage(STAGES.SELECT)) {
            _this.select({
              pos: {
                x: e.offsetX,
                y: e.offsetY
              }
            });

            return true;
          } else if (_this.hasStage(STAGES.NORMAL)) {
            // 开始手动处理set flag
            // 还是scroll时候一起set呢……
            _this.store.dispatch(Act.scrollStart());
          }
        };

        _this.pan = function (e) {
          stop$2(e);

          if (_this.hasStage(STAGES.SELECT)) {
            var derived = _this.getDerived();

            var pos = {
              x: e.offsetX,
              y: e.offsetY
            };
            var side = sideOfBounds(derived.plotBounds, pos);

            if (side) {
              _this.edgeMovingSide = side;

              _this.store.dispatch(Act.edgeMoving(pos));
            } else {
              _this.select({
                pos: pos
              });
            }

            return true;
          } else if (_this.hasStage(STAGES.SCROLL)) {
            _this.store.dispatch(Act.scrollByPx(e.event));
          }
        };

        _this.panEnd = function () {
          if (_this.hasStage(STAGES.SELECT)) {
            _this.store.dispatch(Act.syncScroll());
          } else if (_this.hasStage(STAGES.SCROLL)) {
            // recover flag
            _this.store.dispatch(Act.scrollEnd());
          }
        };

        _this.multipointStart = function (e) {
          if (e.event.touches.length !== 2) {
            return;
          }

          stop$2(e); // @MOBILE-12268 无分类轴、值轴的图表不可缩放

          if (!shouldZoom(_this.store.getState())) {
            return;
          }

          var state = _this.getDerived();

          var plotBounds = state.plotBounds,
              scrollBounds = state.scrollBounds; // 计算放reducer里面好像也可以
          // 甚至复杂的action也可以

          var t1 = e.event.touches[0],
              t2 = e.event.touches[1];
          var p1 = toPoint(t1.x, t1.y),
              p2 = toPoint(t2.x, t2.y);
          var plotFocusPoint = p1.add(p2).divideBy(2).subtract(plotBounds);
          var scrollFocusPoint = plotFocusPoint.subtract(scrollBounds);
          var plotFocus = plotFocusPoint.unscaleBy({
            x: plotBounds.width,
            y: plotBounds.height
          });
          var scrollFocus = scrollFocusPoint.unscaleBy({
            x: scrollBounds.width,
            y: scrollBounds.height
          });
          _this.pinchStartZoom = state.zoom;
          _this.zoomLimit = getZoomLimit(state);

          _this.store.dispatch(Act.zoomStart({
            scroll: [scrollFocus.x, scrollFocus.y],
            plot: [plotFocus.x, plotFocus.y]
          }));
        };

        _this.pinch = function (e) {
          if (_this.getStage() !== STAGES.ZOOMING) {
            return;
          } // = raw zoom factor * last zoom


          var _toPoint$scaleBy = toPoint(e.event.zoomX, e.event.zoomY).scaleBy(_this.pinchStartZoom),
              x = _toPoint$scaleBy.x,
              y = _toPoint$scaleBy.y;

          x = clamp.apply(void 0, [x].concat(_this.zoomLimit.x));
          y = clamp.apply(void 0, [y].concat(_this.zoomLimit.y));

          _this.store.dispatch(Act.zoom({
            x: x,
            y: y
          }));
        };

        _this.multipointEnd = function () {
          if (_this.getStage() !== STAGES.ZOOMING) {
            return;
          }

          _this.store.dispatch(Act.zoomEnd());
        };

        _this.handleBlankTap = function (e) {
          _this.emitter.trigger('background:tap', e);

          _this.hide(e);
        };

        _this.plotTouchStart = function (e) {
          _this.emitter.trigger('plot:touchstart', e);

          return _this.touchStart(e);
        };

        _this.plotTouchMove = function (e) {
          _this.emitter.trigger('plot:touchmove', e);
        };

        _this.plotTouchEnd = function (e) {
          _this.emitter.trigger('plot:touchend', e);

          return _this.touchEnd(e);
        };

        _this.plotTap = function (e) {
          return _this.tap(e);
        };

        _this.plotPanStart = function (e) {
          return _this.panStart(e);
        };

        _this.plotPan = function (e) {
          return _this.pan(e);
        };

        _this.plotPanEnd = function (e) {
          return _this.panEnd(e);
        };

        _this.plotMultipointStart = function (e) {
          return _this.multipointStart(e);
        };

        _this.plotPinch = function (e) {
          return _this.pinch(e);
        };

        _this.plotMultipointEnd = function (e) {
          return _this.multipointEnd(e);
        };

        _this.axisTouchStart = function (e) {
          _this.emitter.trigger('axis:touchstart', e);
        };

        _this.axisTouchMove = function (e) {
          _this.emitter.trigger('axis:touchmove', e);
        };

        _this.axisTouchEnd = function (e) {
          _this.emitter.trigger('axis:touchend', e);
        };

        _this.axisTap = function (e) {};

        _this.axisPanStart = function (e) {
          return _this.panStart(e);
        };

        _this.axisPan = function (e) {
          return _this.pan(e);
        };

        _this.axisPanEnd = function (e) {
          return _this.panEnd(e);
        };

        _this.axisMultipointStart = function (e) {
          return _this.multipointStart(e);
        };

        _this.axisPinch = function (e) {
          return _this.pinch(e);
        };

        _this.axisMultipointEnd = function (e) {
          return _this.multipointEnd(e);
        };

        _this.legendTouchStart = function (e) {
          _this.emitter.trigger('legend:touchstart', e);
        };

        _this.legendTouchMove = function (e) {
          _this.emitter.trigger('legend:touchmove', e);
        };

        _this.legendTouchEnd = function (e) {
          _this.emitter.trigger('legend:touchend', e);
        };

        return _this;
      }

      var _proto = Touch.prototype;

      _proto.getHighlightActionByPos = function getHighlightActionByPos(pos, force) {
        var derived = this.getDerived();
        var target = findTarget({
          pos: pos
        }, derived, this.zr); // optimize

        if (!target || !force && this.targetId === target.id) {
          return;
        }

        var tmp = target.id.substr(0, 4);

        if (tmp === 'Line' || tmp === 'Area' || tmp === 'line') {
          return;
        }

        var action = this.getHighlightAction({
          target: target,
          id: target.id,
          pos: pos
        }, derived);
        var center = target.getBoundingCenter();
        action.payload.targetCenter = {
          x: center[0],
          y: center[1]
        };
        return action;
      };

      _proto.getHighlightAction = function getHighlightAction(props, derived) {
        var action = _Base.prototype.getHighlightAction.call(this, props, derived);

        var target = props.target;
        action.payload.targetId = target.id;
        return action;
      } // --- action
      ;

      _proto.pieSelect = function pieSelect(payload) {
        var target = payload.target; // todo, select sector = rotate

        this.store.dispatch(this.getHighlightAction({
          target: target,
          id: target.id
        }));
      };

      _proto.enterSelect = function enterSelect(payload) {
        var pos = payload.pos; // FIXME, no batch ?

        this.store.dispatch(_.compact([Act.holdSelect(pos), this.getHighlightActionByPos(pos)]));
      };

      _proto.select = function select(payload) {
        var pos = payload.pos;
        this.store.dispatch(_.compact([Act.selecting(pos), this.getHighlightActionByPos(pos)]));
      };

      _proto.edgeSelect = function edgeSelect(payload) {
        var pos = payload.pos;
        this.store.dispatch(_.compact([Act.edgeMoving(pos), this.getHighlightActionByPos(pos)]));
      };

      _proto.leaveSelect = function leaveSelect(_ref) {
        var pos = _ref.pos;
        this.store.dispatch(Act.holdSelect(pos));
      } // --- listener
      ;

      _proto.edgeMover = function edgeMover(state) {
        var _this2 = this;

        if (state.hoverStage === STAGES.EDGE_MOVING) {
          // I wonder how it could worked before.
          // However we should rethink the event flow now...
          this.timer.timeout('edgeSelect', function () {
            _this2.edgeSelect({
              pos: state.eventPos
            });
          }, 1);
          var side = this.edgeMovingSide;
          this.timer.timeout(EDGE_MOVE_KEY, function () {
            _this2.store.dispatch(Act.scrollByPx(getScrollDelta(side)));
          }, EDGE_MOVE_RATE);
        } else {
          // optimize: if (this.stage === STAGES.EDGE_MOVING && state !== STAGES.EDGE_MOVING)
          this.timer.stop(EDGE_MOVE_KEY);
        }
      };

      _proto.readyToHide = function readyToHide(state) {
        if (state.hoverStage === STAGES.SELECT) {
          this.delayHide();
        }
      };

      _proto.pointSelected = function pointSelected(state) {
        if (this.targetId !== state.targetId) {
          var id = state.targetId;

          if (id) {
            var _this$_getPointInfo = this._getPointInfo({
              id: id
            }),
                row = _this$_getPointInfo.row,
                measure = _this$_getPointInfo.measure,
                metaData = _this$_getPointInfo.metaData;

            this.emitter.trigger('pointSelected', {
              tooltipText: formatTooltipLines(state.tooltip),
              row: row,
              measure: measure,
              metaData: metaData,
              pos: state.eventPos
            });
          }

          this.targetId = state.targetId;
        }
      };

      _proto.handleChange = function handleChange() {
        var storeState = this.store.getState();

        if (this.stage !== storeState.hoverStage || this.focusPosition !== storeState.focusPosition || this.eventPos !== storeState.eventPos) {
          this.readyToHide(storeState);
          this.edgeMover(storeState);
          this.stage = storeState.hoverStage;
          this.focusPosition = storeState.focusPosition;
          this.eventPos = storeState.eventPos;
        }

        this.pointSelected(storeState);
      };

      return Touch;
    }(Base);

    var MIN_ZOOM_DISTANCE$1 = 5;

    var Mouse =
    /*#__PURE__*/
    function (_Base) {
      _inheritsLoose(Mouse, _Base);

      function Mouse(props) {
        var _this;

        _this = _Base.call(this, props) || this;
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }
      /**
       * highlight & showTooltip
       * @param ev
       */


      var _proto = Mouse.prototype;

      _proto.show = function show(ev) {
        if (this.hasStage(STAGES.BOX_SELECT)) {
          return;
        }

        var target = ev.target,
            x = ev.offsetX,
            y = ev.offsetY;
        var id = target.id; // @BI-40019

        var _this$getDerived = this.getDerived(),
            rowMap = _this$getDerived.rowMap;

        if (!id || typeof id !== 'string' || !rowMap[id]) {
          return;
        }

        this.store.dispatch(this.getHighlightAction({
          target: target,
          id: id,
          pos: {
            x: x,
            y: y
          }
        }));
      };

      _proto.hide = function hide() {
        if (this.hasStage(STAGES.BOX_SELECT)) {
          return;
        }

        this.store.dispatch(Act.unhover());
      }
      /**
       * on point click
       * @param ev
       */
      ;

      _proto.click = function click(ev) {
        var id = ev.target.id;

        if (!id || typeof id !== 'string') {
          return;
        }

        var x = ev.offsetX,
            y = ev.offsetY;
        this.selectPoint({
          id: id,
          pos: {
            x: x,
            y: y
          }
        });
      };

      _proto.dimensionClick = function dimensionClick(payload) {
        this.selectDimension(payload);
      };

      _proto.legendFilterEnd = function legendFilterEnd() {
        var state = this.store.getState();

        if (state.bigData) {
          var tagFilter = state.tagFilter,
              sliderFilter = state.sliderFilter;
          this.emitter.trigger('filter', {
            tagFilter: tagFilter,
            sliderFilter: sliderFilter
          });
        }
      };

      _proto._plotScrollMove = function _plotScrollMove(_ref) {
        var pctX = _ref.pctX,
            pctY = _ref.pctY;
        var dispatch = this.store.dispatch;

        var _this$getDerived2 = this.getDerived(),
            plotBounds = _this$getDerived2.plotBounds,
            scrollBounds = _this$getDerived2.scrollBounds;

        var width = plotBounds.width,
            height = plotBounds.height;
        var scrollWidth = scrollBounds.width,
            scrollHeight = scrollBounds.height,
            offsetX = scrollBounds.x,
            offsetY = scrollBounds.y;
        var x = offsetX,
            y = offsetY;

        if (pctY == null) {
          x = getOffsetByPct(width, scrollWidth, pctX);
        } else {
          y = getOffsetByPct(height, scrollHeight, pctY);
        }

        dispatch(Act.scrollByPx({
          deltaX: x - offsetX,
          deltaY: y - offsetY
        }));
      };

      _proto.plotScrollMoveX = function plotScrollMoveX(pctX) {
        this._plotScrollMove({
          pctX: pctX
        });
      };

      _proto.plotScrollMoveY = function plotScrollMoveY(pctY) {
        this._plotScrollMove({
          pctY: pctY
        });
      };

      _proto.plotPanStart = function plotPanStart(e) {
        var _this$getDerived3 = this.getDerived(),
            isMobile = _this$getDerived3.isMobile,
            enableMap = _this$getDerived3.enableMap,
            isEditing = _this$getDerived3.isEditing,
            hoverStage = _this$getDerived3.hoverStage;

        var dispatch = this.store.dispatch;

        if (!(isMobile || enableMap || isEditing)) {
          var pos = {
            x: e.offsetX,
            y: e.offsetY
          };
          this.store.dispatch(Act.plotPanStart({
            hoverStage: hoverStage | STAGES.BOX_SELECT,
            pos: pos
          }));
          return;
        }

        if (hoverStage & STAGES.SELECT) {
          stop$2(e);
        } else if (hoverStage === STAGES.NORMAL) {
          dispatch(Act.scrollStart());
        }
      };

      _proto.plotPan = function plotPan(e) {
        var computedState = this.getDerived();
        var hoverStage = computedState.hoverStage,
            initPos = computedState.initPos;
        var dispatch = this.store.dispatch;

        if (hoverStage & STAGES.BOX_SELECT) {
          var x = e.offsetX,
              y = e.offsetY;
          var rect = boundsOfDiagonalPoints(initPos, {
            x: x,
            y: y
          });

          if (rect.width > MIN_ZOOM_DISTANCE$1 || rect.height > MIN_ZOOM_DISTANCE$1) {
            var selected = selectionFilter$$1(rect, computedState, this.zr.storage.getDisplayList());
            var targets = {};

            _.each(selected, function (_ref2) {
              var row = _ref2.row;
              targets[row.id] = true;
            });

            dispatch(Act.plotPanMove({
              pos: {
                x: x,
                y: y
              },
              targets: targets
            }));
          }

          return true;
        } else {
          // pan move scroll area
          // return it because `cancelBubble` is its return value
          return dispatch(Act.scrollByPx(e.event));
        }
      }
      /**
       * 滚动区域拖动End事件处理
       * @param e
       * @ignore
       * @returns {boolean}
       */
      ;

      _proto.plotPanEnd = function plotPanEnd(e) {
        var computedState = this.getDerived();
        var hoverStage = computedState.hoverStage,
            initPos = computedState.initPos,
            stampId = computedState.stampId,
            bigData = computedState.bigData;
        var dispatch = this.store.dispatch;

        if (hoverStage & STAGES.BOX_SELECT) {
          var rect = boundsOfDiagonalPoints(initPos, {
            x: e.offsetX,
            y: e.offsetY
          });
          var newState = {};

          if (rect.width > MIN_ZOOM_DISTANCE$1 || rect.height > MIN_ZOOM_DISTANCE$1) {
            bigData && this.emitter.trigger('boxSelected', {
              range: rect,
              stampId: stampId
            });
            var selectedRows = selectionFilter$$1(rect, computedState, this.zr.storage.getDisplayList());
            selectedRows.length > 0 && dispatch(Act.selectedRows(selectedRows));
          }

          dispatch(Act.plotPanEnd(newState));
          return true;
        } else if (hoverStage & STAGES.SELECT) {
          this.delay.cancel(EDGE_MOVE_KEY); // don't call delay hide here, but in `touchend`
        }
      }
      /**
       * 滚动区鼠标滚轮滚动事件处理
       * @ignore
       * mouseWheel handler
       * @param e
       */
      ;

      _proto.mouseWheel = function mouseWheel(e) {
        var _this$getDerived4 = this.getDerived(),
            plotBounds = _this$getDerived4.plotBounds,
            scrollBounds = _this$getDerived4.scrollBounds;

        var width = plotBounds.width,
            height = plotBounds.height;
        var x = scrollBounds.x,
            y = scrollBounds.y,
            scrollWidth = scrollBounds.width,
            scrollHeight = scrollBounds.height; // no scroll area

        if (height === scrollHeight && width === scrollWidth) {
          return;
        }

        normalizeWheel(e.event);
        var d = {
          deltaX: e.event.vanDeltaX,
          deltaY: e.event.vanDeltaY
        };
        var upLimited = y === 0 && d.deltaY >= 0,
            downLimited = scrollHeight + y === height && d.deltaY <= 0,
            leftLimited = x === 0 && d.deltaX >= 0,
            rightLimited = scrollWidth + x === width && d.deltaX <= 0; // @BI-33565  这里我们判断如果已经滚动到边界，则不做处理，直接返回，保证事件能抛到上面去

        if ((upLimited || downLimited) && (leftLimited || rightLimited)) return;
        stop$2(e);
        this.store.dispatch(Act.scrollByPx(d));
      };

      _proto.facetResizeMove = function facetResizeMove(_ref3) {
        var resizeLine = _ref3.resizeLine;
        this.store.dispatch(Act.facetResize(resizeLine));
      };

      _proto.facetResizeEnd = function facetResizeEnd(data) {
        this.emitter.trigger('axisResize', data);
        this.store.dispatch(Act.facetResize(null));
      };

      return Mouse;
    }(Base);

    /**
     * Created by Jeffrey on 2018/11/14.
     */

    var getIds = function getIds(fields) {
      return _.map(fields, function (f) {
        return f.id;
      });
    };

    var transformSingleFacet = function transformSingleFacet(facet, props, newDefs, horizontal) {
      var defs = facet.defs,
          fixedUnit = facet.fixedUnit,
          fixedSize = facet.fixedSize,
          customUnit = facet.customUnit,
          customSize = facet.customSize,
          gridLine = facet.gridLineStyle,
          fit = facet.fit,
          firstMeasures = facet.firstMeasures,
          secondMeasures = facet.secondMeasures,
          measuresOverlapped = facet.measuresOverlapped,
          dimensions = facet.dimensionIds,
          groupLevel = facet.groupLevel,
          geoField = facet.geoField;
      var axisDirection = measuresOverlapped ? horizontal ? {
        '0': Direction.BOTTOM,
        '1': Direction.TOP
      } : {
        '0': Direction.LEFT,
        '1': Direction.RIGHT
      } : {};

      _.each(defs, function (def, id) {
        id = axisDirection[id] || id;
        var cordon = def.cordonStyleList,
            customSize = def.customSize,
            fixedSize = def.fixedSize,
            fixedMin = def.fixedMin,
            fixedMax = def.fixedMax,
            fixedStep = def.fixedStep,
            trendLine = def.trendLineStyleList,
            _def$config = def.config,
            min = _def$config.min,
            max = _def$config.max,
            step = _def$config.step,
            format = def.format,
            rotation = def.rotation,
            logBase = def.logBase,
            reverse = def.reverse,
            style = def.style,
            title = def.title,
            titleStyle = def.title.style,
            enableTick = def.enableTick,
            tickValid = def.tickValid;
        var newTrendLine = [];

        _.each(trendLine, function (trend) {
          var forward = trend.forward,
              back = trend.back,
              style = trend.fontStyle,
              rest = _objectWithoutPropertiesLoose(trend, ["forward", "back", "fontStyle"]);

          newTrendLine.push(_extends({
            period: [forward, back],
            style: style
          }, rest));
        });

        newDefs[id] = {
          size: fixedSize ? customSize : null,
          step: fixedStep ? step : null,
          min: fixedMin ? min : null,
          max: fixedMax ? max : null,
          cordon: cordon,
          trendLine: newTrendLine,
          format: format,
          logBase: logBase,
          reverse: reverse,
          tick: {
            enabled: enableTick,
            valid: tickValid,
            style: style,
            rotation: rotation
          },
          title: {
            text: title.text,
            enabled: title.visible,
            style: titleStyle
          }
        };
      });

      var measures = measuresOverlapped ? [getIds(firstMeasures), getIds(secondMeasures)] : getIds(facet.measures);
      return _extends({}, props, {
        unit: fixedUnit ? customUnit : null,
        size: fixedSize ? customSize : null,
        gridLine: gridLine,
        fit: fit,
        measuresOverlapped: measuresOverlapped,
        measures: measures,
        dimensions: dimensions,
        groupLevel: groupLevel,
        geo: geoField && geoField.id
      });
    };

    var transformFacet = function transformFacet(options) {
      var facetX = options.facetX,
          facetY = options.facetY,
          style = options.style;
      var axisLineStyle = style.axisLineStyle;
      var props = {
        axisLine: axisLineStyle
      };
      var defs = {};
      var newFacetX = transformSingleFacet(facetX, props, defs, true);
      var newFacetY = transformSingleFacet(facetY, props, defs, false);
      return {
        facetX: newFacetX,
        facetY: newFacetY,
        defs: defs
      };
    };

    var releaseAes = function releaseAes(aesthetics, geomType) {
      var output = {};

      _.each(aesthetics, function (aes) {
        var _type = aes.type,
            constField = aes.constField,
            constValue = aes.constValue,
            range = aes.range,
            fields = aes.fields,
            mappingField = aes.mappingField,
            format = aes.legendFormat,
            domain = aes.domain,
            rest = _objectWithoutPropertiesLoose(aes, ["type", "constField", "constValue", "range", "fields", "mappingField", "legendFormat", "domain"]);

        var type = _type;

        if (type === 'gaugePointer') {
          type = AesTypes.POINTERS;
        }

        if (type === 'gaugeTarget') {
          type = AesTypes.TARGET;
        } // 非Mapping field的aes，只需要记录fieldIds即可


        if (!MappingAesTypes[type] || type === AesTypes.POINTERS) {
          output[type] = _.map(fields, function (field) {
            return field.id;
          });
          return;
        }

        if (type === AesTypes.TARGET) {
          output[type] = fields[0] ? fields[0].id : null;
          return;
        }

        var id = mappingField && mappingField.id;
        var groupId = mappingField && mappingField.groupId; // 热力图无字段的时候应该是渐变色

        if (geomType === ChartLibrary.HEAT_MAP && type === AesTypes.COLOR && constField) {
          output[type] = _extends({}, rest, {
            range: range,
            constValue: constValue
          });
        } else if (constField) {
          output[type] = constValue;
        } else if (mappingField.isDimension || mappingField.isMeasureName) {
          output[type] = _extends({}, rest, {
            domain: domain,
            range: range,
            id: id,
            format: format,
            groupId: groupId
          });
        } else if (mappingField.isMeasure) {
          output[type] = _extends({}, rest, {
            domain: domain,
            range: range,
            format: format,
            id: id,
            groupId: groupId
          });
        }
      });

      return output;
    };

    var _LINE_CONNECT_AES_ORD;

    var lastValue = function lastValue(arr) {
      return arr.length > 0 ? arr[arr.length - 1] : null;
    };

    var LINE_CONNECT_AES_ORDER = (_LINE_CONNECT_AES_ORD = {}, _LINE_CONNECT_AES_ORD[AesTypes.COLOR] = 1, _LINE_CONNECT_AES_ORD[AesTypes.SIZE] = 2, _LINE_CONNECT_AES_ORD[AesTypes.LABEL] = 3, _LINE_CONNECT_AES_ORD[AesTypes.TOOLTIP] = 4, _LINE_CONNECT_AES_ORD[AesTypes.GRANULARITY] = 5, _LINE_CONNECT_AES_ORD);
    var getSortedDimFieldsInAesthetics = function getSortedDimFieldsInAesthetics(aesthetics) {
      return _.reduce(aesthetics.sort(function (a, b) {
        return LINE_CONNECT_AES_ORDER[a.type] - LINE_CONNECT_AES_ORDER[b.type];
      }), function (arr, aes) {
        return arr.concat(_.filter(aes.fields, function (f) {
          return f.fieldType !== FieldType.MEASURE;
        }));
      }, []);
    };
    var addLineGroupId = function addLineGroupId(field, lineGroupIds, groupIdMap, connectGroupId) {
      if (field == null || field.fieldType === FieldType.MEASURE) {
        return;
      }

      var groupId = field.groupId,
          id = field.id;

      if (groupId === connectGroupId || groupIdMap[groupId]) {
        return;
      }

      groupIdMap[groupId] = 1;
      lineGroupIds.push(id);
    };
    var prepareLineGroupIds = function prepareLineGroupIds(geom, options) {
      var aesthetics = geom.aesthetics;

      var _diffFacet = diffFacet(options),
          baseFacet = _diffFacet.baseFacet;

      var dimFields = baseFacet.dimFields;
      var connectField = getFieldsInAes(aesthetics, AesTypes.LINE_CONNECT)[0];
      var unValidConnect = connectField == null || connectField.fieldType === FieldType.MEASURE;
      var aesDimFields = getSortedDimFieldsInAesthetics(aesthetics);
      var lastDimField = lastValue(dimFields);
      var defaultConnectField = unValidConnect ? lastDimField == null ? lastValue(aesDimFields) : lastDimField : connectField;

      if (defaultConnectField == null) {
        geom.groupLineIds = [];
        return;
      }

      var groupIds = [],
          groupIdMap = {};
      var connectGroupId = defaultConnectField.groupId;

      _.each(aesDimFields, function (field) {
        return addLineGroupId(field, groupIds, groupIdMap, connectGroupId);
      });

      addLineGroupId(lastDimField, groupIds, groupIdMap, connectGroupId);
      addLineGroupId(connectField, groupIds, groupIdMap, connectGroupId);
      geom.groupLineIds = groupIds;
    };

    var TARGET_NAME = 'target_name_field_id';

    var isTargetNameField = function isTargetNameField(groupId) {
      return groupId.indexOf(TARGET_NAME) >= 0;
    };
    /**
     * 特殊数据得图形数据预处理
     * @param geom
     * @param options
     * @returns {*}
     */


    function prepareGeomData(geom, options) {
      switch (geom.type) {
        case ChartLibrary.LINE:
        case ChartLibrary.LINE_RADAR:
        case ChartLibrary.AREA:
          prepareLineGroupIds(geom, options);
          break;

        default:
          return geom;
      }
    }
    /**
     * 分发SharedData时, 从横纵轴中获取属于Geom的字段, 包括
     * baseFacet上的所有字段 & GeomFacet上的Dimensions
     * @param facetX
     * @param facetY
     * @returns {...*[]}
     */


    var collectFacetFields = function collectFacetFields(facetX, facetY) {
      var _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      return [].concat(baseFacet.dimFields, baseFacet.measures, geomFacet.dimFields);
    };
    /**
     * 根据geomFields创建geomData
     * @param geomFields
     * @param measure
     * @param sharedData
     * @returns {{fields: *, colData, rowCount: number}}
     */

    var createGeomData = function createGeomData(geomFields, measure, sharedData) {
      var fields = sharedData.fields,
          colData = sharedData.colData;

      var groupId2IndexMap = _.reduce(fields, function (idxMap, field, index) {
        idxMap[field.groupId] = index;
        return idxMap;
      }, {});

      var rowCount = colData[0] ? colData[0].length : 0; // 指标名称对应的序列

      var targetCol = fillArray(rowCount, measure.name); // 遍历GeomFields, 对于指标名称

      var geomColData = _.map(geomFields, function (_ref) {
        var groupId = _ref.groupId;
        return isTargetNameField(groupId) ? targetCol : colData[groupId2IndexMap[groupId]];
      });

      return {
        fields: geomFields,
        colData: geomColData,
        rowCount: rowCount
      };
    };
    /**
     * 从sharedData中分发数据到Geom上
     * @param geom
     * @param options
     */

    var dispenseGeomData = function dispenseGeomData(geom, options) {
      var facetX = options.facetX,
          facetY = options.facetY,
          shared = options.shared;

      if (!shared.data) {
        return;
      }

      var measure = geom.measure,
          aesthetics = geom.aesthetics; // GeomData中使用到的字段为, 横纵轴 + 自身指标 + 属性面板

      var geomFields = collectFacetFields(facetX, facetY);
      geomFields.push(measure);

      _.each(aesthetics, function (aes) {
        return geomFields.push.apply(geomFields, aes.fields);
      });

      geom.dataModel = createGeomData(geomFields, measure, shared.data);
    };
    /**
     * 添加条件属性到GeomDataModel中
     * @param geom
     */


    var addConditionData = function addConditionData(geom) {
      var conditionProps = geom.conditionProps,
          dataModel = geom.dataModel;

      if (!conditionProps) {
        return;
      }

      var fields = dataModel.fields,
          colData = dataModel.colData;

      _.each(conditionProps, function (col, conditionName) {
        fields.push({
          id: conditionName,
          name: conditionName,
          type: FieldType.ATTR
        });
        colData.push(col);
      });
    };

    var transformGeoms = function transformGeoms(op) {
      var geoms = op.geoms;
      return _.map(geoms, function (geom) {
        // 分发SharedData到Geom
        dispenseGeomData(geom, op);
        addConditionData(geom);
        prepareGeomData(geom, op);

        var options = geom.options,
            dataModel = geom.dataModel,
            measure = geom.measure,
            aesthetics = geom.aesthetics,
            rest = _objectWithoutPropertiesLoose(geom, ["options", "dataModel", "measure", "aesthetics"]);

        var geomType = geom.type;

        var label = options.label,
            tooltip = options.tooltip,
            opRest = _objectWithoutPropertiesLoose(options, ["label", "tooltip"]);

        var fields = _.map(dataModel.fields, function (field) {
          var id = field.id,
              type = field.fieldType,
              name = field.name,
              groupId = field.groupId;
          return {
            id: id,
            type: type,
            name: name,
            groupId: groupId
          };
        }),
            colData = dataModel.colData; // 先这样写吧，后面改后台的时候，把rich拿到外面来


        var formatRich = function formatRich(richConfig) {
          var rich = richConfig.rich,
              rest = _objectWithoutPropertiesLoose(richConfig, ["rich"]);

          return _extends({}, rest, rich);
        };

        return _extends({
          data: {
            fields: fields,
            colData: colData
          },
          measure: measure && measure.id !== 'graphic' ? measure.id : null
        }, rest, opRest, releaseAes(aesthetics, geomType), {
          dataLabel: formatRich(label),
          tooltip: formatRich(tooltip)
        });
      });
    };

    var transferLegend = function transferLegend(legend) {
      var style = legend.style,
          enabled = legend.enabled,
          borderColor = legend.borderColor,
          position = legend.position;
      return {
        style: style,
        enabled: enabled,
        borderColor: borderColor,
        position: position
      };
    };

    var transerMap = function transerMap(_ref) {
      var map = _ref.map;
      var crs = map.crs,
          features = map.features,
          gisValid = map.gisValid,
          layer = map.layer,
          maxZoom = map.maxZoom,
          minZoom = map.minZoom,
          imageBackground = map.imageBackground,
          zoomInTitle = map.zoomInTitle,
          zoomOutTitle = map.zoomOutTitle,
          center = map.center,
          bounds = map.bounds;
      return {
        crs: crs,
        imageBackground: imageBackground,
        gis: _extends({
          enabled: gisValid
        }, layer),
        maxZoom: maxZoom,
        minZoom: minZoom,
        features: features,
        zoomInTitle: zoomInTitle,
        zoomOutTitle: zoomOutTitle,
        center: center,
        bounds: bounds,
        fixedZoom: false
      };
    };

    var transformBIOption = function transformBIOption(option) {
      var condition = option.condition;
      var _option$shared = option.shared,
          isEditing = _option$shared.isEditing,
          stampId = _option$shared.stampId,
          bigData = _option$shared.bigData,
          animation = _option$shared.animation,
          isMobile = _option$shared.isMobile,
          enableMap = _option$shared.enableMap,
          darkTheme = _option$shared.darkTheme,
          bounds = _option$shared.bounds;
      var inverted = option.facetX.measuresToGeoms;

      var _transformFacet = transformFacet(option),
          facetX = _transformFacet.facetX,
          facetY = _transformFacet.facetY,
          defs = _transformFacet.defs;

      var geoms = transformGeoms(option);
      var legend = transferLegend(option.legend);
      var mapConfig = transerMap(option);
      mapConfig.enabled = enableMap;
      return {
        stampId: stampId,
        bigData: bigData,
        animation: animation,
        darkTheme: darkTheme,
        enableMap: enableMap,
        isMobile: isMobile,
        inverted: inverted,
        condition: condition,
        facetX: facetX,
        facetY: facetY,
        geoms: geoms,
        defs: defs,
        legend: legend,
        mapConfig: mapConfig,
        isEditing: isEditing,
        size: bounds ? {
          width: bounds.width,
          height: bounds.height
        } : null
      };
    };

    var dispenseChartStyle = function dispenseChartStyle(options) {};

    /**
     * 将BI后台传递过来的Option转换为期望的数据结构
     * http://kms.finedevelop.com/pages/viewpage.action?pageId=44681434
     * @param option
     */

    var reconstruct = function reconstruct(option) {
      if (option.computedState) {
        return option;
      }

      return option.resultType ? transformBIOption(option) : dispenseChartStyle(option);
    };

    /**
     * Created by Jeffrey on 2018/11/13.
     */
    function imageHover(payload) {
      this.store.dispatch(Act.highlightMatchedTarget(payload));
    }
    /** @this Chart */


    function pointCancel() {
      // todo, no force but hide
      this.interaction.hide();
    }
    /** @this Chart */


    function resize(opt) {
      this.resize(opt);
    }
    /** @this Chart */


    function orientationChange(_ref) {
      var type = _ref.type;

      var opt = _extends({}, this.size);

      var orientation = type;

      if (orientation) {
        orientation = orientation.toLowerCase();

        if (orientation.indexOf('portrait') !== -1) {
          opt.orientation = 'portrait';
        } else if (orientation.indexOf('landscape') !== -1) {
          opt.orientation = 'landscape';
        }
      }

      this.resize(opt);
    }
    /** @this Chart */


    function enable(opt) {
      if (opt === void 0) {
        opt = {};
      }

      var _opt = opt,
          x = _opt.x,
          y = _opt.y;

      if (x > 0 && y > 0) {
        var p = {
          x: x,
          y: y
        };
        var proxy = this.zr.handler.proxy;
        proxy.dispatch({
          type: 'touchstart',
          touches: [p]
        });
        proxy.dispatch({
          type: 'touchend',
          touches: [p]
        });
      }
    }
    /** @this Chart */


    function disable() {
      this.interaction.hide();
    } // default


    var Actions = {
      imageHover: imageHover
    };
    var MobileActions = {
      imageHover: imageHover,
      pointCancel: pointCancel,
      resize: resize,
      orientationChange: orientationChange,
      enable: enable,
      disable: disable
    };

    var ASYM_TRACK_W1 = 5,
        ASYM_TRACK_W2 = 10,
        ASYM_THUMB_WIDTH = 14;

    var AsymmetricSlider = function AsymmetricSlider(props) {
      return h(BasicSlider, _extends({}, props, {
        w1: ASYM_TRACK_W1,
        w2: ASYM_TRACK_W2,
        thumbWidth: ASYM_THUMB_WIDTH
      }));
    };

    assign(AsymmetricSlider, BasicSlider);
    AsymmetricSlider.propTypes = null;

    /**
     * Created by Jeffrey on 2018/6/5.
     */

    var getSliderCtor = function getSliderCtor(type) {
      return type.indexOf('color') > -1 ? SymmetricSlider : AsymmetricSlider;
    };
    var mergeSlidersProps = function mergeSlidersProps(sliders, parentStyle) {
      return _.map(sliders, function (g) {
        return _extends({}, g, {
          style: g.style || parentStyle,
          colorStops: _.toArray(g.colorStops)
        });
      });
    };
    var mergeTagsProps = function mergeTagsProps(tags, parentStyle) {
      return _.map(tags, function (g) {
        return _extends({}, g, {
          style: g.style || parentStyle,
          items: _.map(g.items, function (t) {
            return _extends({}, t, {
              text: getFormattedText(t.name, g.format)
            });
          })
        });
      });
    };

    var LINE_HEIGHT$5 = d.LINE_HEIGHT;
    var PADDING_TOP$1 = 3;
    var TITLE_LEFT$2 = 5;

    var TagTitle = function TagTitle(_ref) {
      var text = _ref.text,
          y = _ref.y,
          outerWidth = _ref.outerWidth,
          style = _ref.style;
      return h('text', {
        position: [TITLE_LEFT$2 + outerWidth, y],
        style: _extends({
          text: text,
          textPadding: [style.fontSize * d.TEXT_PANDDING_RATIO, 0],
          textAlign: 'right',
          textVerticalAlign: 'top',
          truncate: {
            // todo
            outerWidth: outerWidth + 1,
            // tmp solution
            ellipsis: '…'
          }
        }, style)
      });
    };

    var SliderTitle = function SliderTitle(_ref2) {
      var text = _ref2.text,
          y = _ref2.y,
          outerWidth = _ref2.outerWidth,
          outerHeight = _ref2.outerHeight,
          style = _ref2.style;
      return h('text', {
        position: [TITLE_LEFT$2 + outerWidth, y + outerHeight],
        style: _extends({
          text: text,
          textPadding: [style.fontSize * d.TEXT_PANDDING_RATIO, 0],
          textAlign: 'right',
          textVerticalAlign: 'bottom',
          truncate: {
            outerWidth: outerWidth + 1,
            ellipsis: '…'
          }
        }, style)
      });
    };

    var renderTagItems = function renderTagItems(_ref3) {
      var rows = _ref3.rows,
          items = _ref3.items,
          fieldIds = _ref3.fieldIds,
          lineHeight = _ref3.lineHeight,
          format = _ref3.format,
          style = _ref3.style,
          onItemToggle = _ref3.onItemToggle,
          silent = _ref3.silent;
      var itemNodes = [];

      _.map(rows, function (row, rowNo) {
        _.map(row, function (t) {
          var item = items[itemNodes.length];
          itemNodes.push(h(IconTag, _extends({
            fieldIds: fieldIds,
            position: [t[0], rowNo * lineHeight],
            text: item.text,
            key: item.name,
            width: t[1],
            handleClick: onItemToggle,
            silent: silent
          }, style, item)));
        });
      });

      return itemNodes;
    };

    var LegendHorizontal = function LegendHorizontal(props) {
      var style = props.style,
          fontSize = props.style.fontSize,
          borderColor = props.borderColor,
          x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          onRangeChange = props.onRangeChange,
          onRangeChangeEnd = props.onRangeChangeEnd,
          onItemToggle = props.onItemToggle,
          maxTitleWidth = props.maxTitleWidth,
          legendAreaHeight = props.legendAreaHeight,
          bigData = props.bigData,
          darkTheme = props.darkTheme;
      var lineHeight = fontSize * LINE_HEIGHT$5; // to merge style

      var tags = props.tags,
          sliders = props.sliders;
      tags = mergeTagsProps(tags, style);
      sliders = mergeSlidersProps(sliders, style);
      var children = [];
      forEach(tags, function (tag) {
        var title = tag.title,
            fieldIds = tag.fieldIds,
            items = tag.items,
            style = tag.style,
            titlePos = tag.titlePos,
            rows = tag.rows,
            iconsGroupBounds = tag.iconsGroupBounds;
        children.push(TagTitle({
          text: title,
          y: titlePos,
          outerWidth: maxTitleWidth,
          style: style
        }));

        var lineNum = _.size(rows);

        children.push(h(P, _extends({}, iconsGroupBounds, {
          realHeight: lineNum * lineHeight
        }), renderTagItems({
          rows: rows,
          items: items,
          fieldIds: fieldIds,
          lineHeight: lineHeight,
          style: style,
          onItemToggle: onItemToggle,
          silent: bigData
        })));
      });
      forEach(sliders, function (slider) {
        var title = slider.title,
            titlePos = slider.titlePos,
            height = slider.height,
            type = slider.type,
            iconsGroupBounds = slider.iconsGroupBounds;
        children.push(SliderTitle({
          text: title,
          y: titlePos,
          outerWidth: maxTitleWidth,
          outerHeight: height,
          style: style
        }));
        var Comp = getSliderCtor(type);
        var sliderComp = h(Comp, _extends({}, iconsGroupBounds, {
          handleValueChange: onRangeChange,
          handleValueChangeEnd: onRangeChangeEnd,
          silent: bigData
        }, slider));
        children.push(sliderComp);
      });
      return h(ScrollArea, {
        borderColor: borderColor || BORDER_COLOR,
        x: x,
        y: y,
        width: width,
        height: height,
        scrollHeight: legendAreaHeight,
        darkTheme: darkTheme
      }, h('group', {
        position: [0, PADDING_TOP$1]
      }, children));
    };

    var L$1 = LegendHorizontal; // TODO extract utils and split to another file
    // --------------

    var BTN_TOUCH_WIDTH = 28;
    var BTN_WIDTH$1 = 12;
    var BTN_HEIGHT = 8;
    var BTN_COLOR$1 = '#647185';
    var BTN_COLOR_FAINT$1 = '#d0d4da';

    var MobilePageArea =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(MobilePageArea, _Component);

      function MobilePageArea() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          page: 0
        };

        _this.onTap = function (d$$1) {
          var page = _this.state.page + d$$1;

          if (between(page, 0, _this.props.pagination.length - 1)) {
            _this.setState({
              page: page
            });
          }
        };

        _this.onUpperTap = function () {
          return _this.onTap(-1);
        };

        _this.onDownerTap = function () {
          return _this.onTap(1);
        };

        return _this;
      }

      var _proto = MobilePageArea.prototype;

      _proto.render = function render$$1() {
        var _this$props = this.props,
            x = _this$props.x,
            y = _this$props.y,
            width = _this$props.width,
            height = _this$props.height,
            borderColor = _this$props.borderColor,
            realHeight = _this$props.realHeight,
            pagination = _this$props.pagination,
            interaction = _this$props.interaction,
            children = _this$props.children;
        var page = this.state.page;
        var offsetY = -pagination[page];
        var areaSize = {
          x: 0,
          y: 0,
          width: width,
          height: height
        };
        var background = h("rect", {
          shape: areaSize,
          style: {
            fill: 'transparent',
            stroke: borderColor
          }
        }); // give a simple group if no pagination

        if (realHeight <= height) {
          return h("group", {
            position: [x, y],
            ontouchstart: interaction.legendTouchStart,
            ontouchmove: interaction.legendTouchMove,
            ontouchend: interaction.legendTouchEnd
          }, background, children);
        } // move wrapper to scroll


        var wrapper = h("group", {
          position: [0, offsetY]
        }, children);
        return h("group", {
          position: [x, y],
          ontouchstart: interaction.legendTouchStart,
          ontouchmove: interaction.legendTouchMove,
          ontouchend: interaction.legendTouchEnd,
          clip: {
            type: 'rect',
            shape: areaSize
          }
        }, background, wrapper, h("rect", {
          invisible: true // style={{ fill: '#ec3' }}
          ,
          position: [width - BTN_TOUCH_WIDTH, 0],
          shape: {
            width: BTN_TOUCH_WIDTH,
            height: height / 2
          },
          ontap: this.onUpperTap
        }), h("polygon", {
          silent: true,
          position: [width - BTN_TOUCH_WIDTH / 2, height / 4],
          shape: {
            points: [[-BTN_WIDTH$1 / 2, BTN_HEIGHT], [0, 0], [BTN_WIDTH$1 / 2, BTN_HEIGHT]]
          },
          style: {
            fill: page === 0 ? BTN_COLOR_FAINT$1 : BTN_COLOR$1
          }
        }), h("rect", {
          invisible: true // style={{ fill: '#0b9' }}
          ,
          position: [width - BTN_TOUCH_WIDTH, height / 2],
          shape: {
            width: BTN_TOUCH_WIDTH,
            height: height / 2
          },
          ontap: this.onDownerTap
        }), h("polygon", {
          silent: true,
          position: [width - BTN_TOUCH_WIDTH / 2, height * 3 / 4],
          shape: {
            points: [[-BTN_WIDTH$1 / 2, -BTN_HEIGHT], [0, 0], [BTN_WIDTH$1 / 2, -BTN_HEIGHT]]
          },
          style: {
            fill: page === pagination.length - 1 ? BTN_COLOR_FAINT$1 : BTN_COLOR$1
          }
        }));
      };

      return MobilePageArea;
    }(Component);

    L$1.Mobile = function (props) {
      var style = props.style,
          fontSize = props.style.fontSize,
          borderColor = props.borderColor,
          x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          onRangeChange = props.onRangeChange,
          onItemToggle = props.onItemToggle,
          interaction = props.interaction,
          maxTitleWidth = props.maxTitleWidth,
          legendAreaHeight = props.legendAreaHeight; // to merge style

      var tags = props.tags,
          sliders = props.sliders;
      tags = mergeTagsProps(tags, style);
      sliders = mergeSlidersProps(sliders, style);
      var lineHeight = fontSize * LINE_HEIGHT$5;
      var children = [];
      forEach(tags, function (tag) {
        var title = tag.title,
            titlePos = tag.titlePos,
            rows = tag.rows,
            iconsGroupBounds = tag.iconsGroupBounds,
            realWidth = tag.realWidth,
            items = tag.items,
            fieldIds = tag.fieldIds,
            format = tag.format;
        children.push(TagTitle({
          text: title,
          y: titlePos,
          outerWidth: maxTitleWidth,
          style: style
        }));
        children.push(h(ScrollArea, _extends({
          touch: true
        }, iconsGroupBounds, {
          scrollWidth: realWidth
        }), renderTagItems({
          rows: rows,
          items: items,
          fieldIds: fieldIds,
          lineHeight: lineHeight,
          format: format,
          style: style,
          onItemToggle: onItemToggle
        })));
      });
      forEach(sliders, function (slider) {
        var title = slider.title,
            height = slider.height,
            titlePos = slider.titlePos,
            type = slider.type,
            iconsGroupBounds = slider.iconsGroupBounds;
        children.push(SliderTitle({
          text: title,
          y: titlePos,
          outerWidth: maxTitleWidth,
          outerHeight: height,
          style: style
        }));
        var Comp = getSliderCtor(type);
        var sliderComp = h(Comp, _extends({
          touch: true
        }, iconsGroupBounds, {
          handleValueChange: onRangeChange
        }, slider));
        children.push(sliderComp);
      }); // pagination

      var windowSize = height;
      var pagination = [0];
      [].concat(tags, sliders).forEach(function (_ref4) {
        var titlePos = _ref4.titlePos,
            height = _ref4.height;
        var downPos = titlePos + (height || lineHeight);
        var prevOffset = pagination[pagination.length - 1];

        if (downPos - prevOffset > windowSize) {
          pagination.push(titlePos);
        }
      });
      return h(MobilePageArea, {
        borderColor: borderColor || BORDER_COLOR,
        x: x,
        y: y,
        width: width,
        height: height,
        realHeight: legendAreaHeight,
        pagination: pagination,
        interaction: interaction
      }, h('group', {
        position: [0, PADDING_TOP$1]
      }, children));
    };

    var DOT_COLOR = modifyAlpha('#B6EAFF', 0.4);
    var DOT_COLOR_ON = '#42CAFF';
    var DOT_AREA_HEIGHT = 26;
    var DOT_R = 2;
    var DOT_GAP = 12;
    var RECT_WIDTH = 8;
    var RECT_HEIGHT = 4;
    var RECT_R = 2;

    var Carousel =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Carousel, _Component);

      function Carousel() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        _this.state = {
          offsetX: 0 // wrapper offsetX, <= 0
          // offsetY: 0 // wrapper offsetY, <= 0,

        };
        _this._panStartIndex = 0;
        _this._turning = false;

        _this.onpanstart = function (e) {
          // may have to handle outside pan logic here
          stop$2(e);
          _this._panStartIndex = Carousel.getIndexByOffset(_this.props.width, _this.state.offsetX);
          _this._turning = true;
        };

        _this.onpan = function (e) {
          stop$2(e);

          var range = _this.getPanOffsetRange();

          var offsetX = clamp.apply(void 0, [_this.state.offsetX + e.event.deltaX].concat(range));

          _this.setState({
            offsetX: offsetX
          });
        };

        _this.onpanend = function (e) {
          var _this$props = _this.props,
              width = _this$props.width,
              children = _this$props.children;
          var offsetX = _this.state.offsetX;
          var count = children.length;
          var startOffset = Carousel.getOffsetByIndex(width, count, _this._panStartIndex);
          var nextIndex = _this._panStartIndex;

          if (Math.abs(offsetX - startOffset) / width > 1 / 3) {
            offsetX > 0 ? ++nextIndex : --nextIndex;
          } // determine in next tick with swipe


          setTimeout(function () {
            return _this.endOffset(nextIndex);
          }, 0);
        };

        _this.onswipe = function (e) {
          var direction = e.event.direction;
          var nextIndex = _this._panStartIndex;

          if (direction === 'Left') {
            ++nextIndex;
          } else if (direction === 'Right') {
            --nextIndex;
          } else {
            return;
          }

          _this.endOffset(nextIndex);
        };

        return _this;
      }

      var _proto = Carousel.prototype;

      _proto.getPanOffsetRange = function getPanOffsetRange() {
        var _this$props2 = this.props,
            width = _this$props2.width,
            children = _this$props2.children;
        var count = children.length;
        return [Carousel.getOffsetByIndex(width, count, this._panStartIndex + 1), Carousel.getOffsetByIndex(width, count, this._panStartIndex - 1)];
      };

      _proto.endOffset = function endOffset(nextIndex) {
        // one pan/swipe turn should have one end only
        if (this._turning) {
          this._turning = false;
          this.setState({
            offsetX: Carousel.getOffsetByIndex(this.props.width, this.props.children.length, nextIndex)
          });
        }
      };

      _proto.renderDots = function renderDots(_ref) {
        var count = _ref.count,
            index = _ref.index,
            width = _ref.width,
            height = _ref.height;
        var dots = [];
        var y = height - DOT_AREA_HEIGHT / 2;
        var x0 = width / 2 - (count - 1) * DOT_GAP / 2;
        var i = -1;

        while (++i < count) {
          dots.push(h('rect', {
            silent: true,
            position: [x0 + DOT_GAP * i, y],
            shape: index === i ? {
              x: -RECT_WIDTH / 2,
              y: -RECT_HEIGHT / 2,
              width: RECT_WIDTH,
              height: RECT_HEIGHT,
              r: RECT_R
            } : {
              x: -DOT_R,
              y: -DOT_R,
              width: DOT_R * 2,
              height: DOT_R * 2,
              r: DOT_R
            },
            style: {
              fill: index === i ? DOT_COLOR_ON : DOT_COLOR
            }
          }));
        }

        return dots;
      };

      _proto.render = function render$$1() {
        var _this$props3 = this.props,
            x = _this$props3.x,
            y = _this$props3.y,
            width = _this$props3.width,
            height = _this$props3.height,
            interaction = _this$props3.interaction,
            borderColor = _this$props3.borderColor,
            children = _this$props3.children;
        var offsetX = this.state.offsetX;
        var areaSize = {
          x: 0,
          y: 0,
          width: width,
          height: height
        };
        var background = h('rect', {
          cursor: null,
          z: -1,
          shape: areaSize,
          style: {
            fill: 'transparent',
            stroke: borderColor || null
          }
        }); // give a simple group if no pagination

        if (children.length <= 1) {
          return h('group', {
            ontouchstart: interaction.legendTouchStart,
            ontouchmove: interaction.legendTouchMove,
            ontouchend: interaction.legendTouchEnd,
            position: [x, y]
          }, background, children);
        } // main view
        // move wrapper to scroll


        var wrapper = h('group', {
          ontouchstart: interaction.legendTouchStart,
          ontouchmove: interaction.legendTouchMove,
          ontouchend: interaction.legendTouchEnd,
          position: [offsetX, 0]
        }, children.map(function (c, i) {
          return h('group', {
            position: [i * width, 0]
          }, c);
        }));
        return h('group', {
          pannable: true,
          position: [x, y],
          clip: {
            type: 'rect',
            shape: areaSize
          },
          onpanstart: this.onpanstart,
          onpan: this.onpan,
          onpanend: this.onpanend,
          onswipe: this.onswipe
        }, background, this.renderDots({
          count: children.length,
          index: Carousel.getIndexByOffset(width, offsetX),
          width: width,
          height: height
        }), // main area
        wrapper);
      };

      return Carousel;
    }(Component);

    Carousel.getDotAreaHeight = function () {
      return DOT_AREA_HEIGHT;
    };

    Carousel.getIndexByOffset = function (visibleLength, offset) {
      return Math.floor(-offset / visibleLength);
    };

    Carousel.getOffsetByIndex = function (visibleLength, childrenLength, index) {
      return -visibleLength * clamp(index, 0, childrenLength - 1);
    };

    var LINE_HEIGHT$6 = d.LINE_HEIGHT;
    var PADDING_TOP$2 = 7,
        PADDING_BOTTOM$2 = PADDING_TOP$2,
        PADDING_LEFT$1 = 5,
        PADDING_RIGHT$1 = PADDING_LEFT$1; // ...content | padding | scrollbar |

    var TITLE_PADDING_BOTTOM$1 = 3;
    var PADDING_H$2 = PADDING_LEFT$1 + PADDING_RIGHT$1;
    var SCROLL_THUMB_THICKNESS$1 = ScrollArea.THUMB_THICKNESS;

    var renderTitle = function renderTitle(_ref) {
      var text = _ref.text,
          y = _ref.y,
          outerWidth = _ref.outerWidth,
          style = _ref.style;
      return h('text', {
        silent: true,
        position: [PADDING_LEFT$1, y],
        style: _extends({
          text: text,
          textPadding: [style.fontSize * d.TEXT_PANDDING_RATIO, 0],
          textAlign: 'left',
          textVerticalAlign: 'top',
          truncate: {
            outerWidth: getTruncateOuterWidth(outerWidth - PADDING_H$2),
            // todo 后面把图例的layout放在前台
            ellipsis: '…'
          }
        }, style)
      });
    };

    var LegendVertical = function LegendVertical(props) {
      var style = props.style,
          borderColor = props.borderColor,
          x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          onRangeChange = props.onRangeChange,
          onRangeChangeEnd = props.onRangeChangeEnd,
          onItemToggle = props.onItemToggle,
          bigData = props.bigData,
          darkTheme = props.darkTheme;
      var tags = props.tags,
          sliders = props.sliders;
      tags = mergeTagsProps(tags, style);
      sliders = mergeSlidersProps(sliders, style);
      var fontSize = style.fontSize;
      var lineHeight = fontSize * LINE_HEIGHT$6;
      var children = [];
      map(tags, function (tag) {
        var titlePos = tag.titlePos,
            iconsGroupBounds = tag.iconsGroupBounds;
        children.push(renderTitle({
          text: tag.title,
          outerWidth: width,
          style: style,
          y: titlePos
        }));
        var tagsGroup = h(ScrollArea, _extends({}, iconsGroupBounds, {
          scrollHeight: _.size(tag.items) * lineHeight,
          scrollWidth: width - PADDING_LEFT$1,
          darkTheme: darkTheme
        }), map(tag.items, function (item, i) {
          return h(IconTag, _extends({
            key: item.name,
            fieldIds: tag.fieldIds,
            position: [0, lineHeight * i],
            text: item.text,
            width: width - PADDING_LEFT$1 - SCROLL_THUMB_THICKNESS$1,
            handleClick: onItemToggle,
            silent: bigData
          }, tag.style, item));
        }));
        children.push(tagsGroup);
      });
      map(sliders, function (slider) {
        var titlePos = slider.titlePos,
            iconsGroupBounds = slider.iconsGroupBounds;
        children.push(renderTitle({
          text: slider.title,
          y: titlePos,
          outerWidth: width,
          style: style
        }));
        var Comp = getSliderCtor(slider.type);
        var sliderComp = h(Comp, _extends({}, iconsGroupBounds, {
          handleValueChange: onRangeChange,
          handleValueChangeEnd: onRangeChangeEnd,
          silent: bigData
        }, slider));
        children.push(sliderComp);
      });
      return h('group', {
        position: [x, y]
      }, // background
      h('rect', {
        silent: true,
        shape: rectSubPixelOpt({
          width: width,
          height: height
        }),
        // pixel
        style: {
          fill: 'transparent',
          stroke: borderColor || BORDER_COLOR
        }
      }), children);
    };

    var L$2 = LegendVertical;

    L$2.Mobile = function (props) {
      var style = props.style,
          borderColor = props.borderColor,
          x = props.x,
          y = props.y,
          width = props.width,
          height = props.height,
          onRangeChange = props.onRangeChange,
          onItemToggle = props.onItemToggle,
          interaction = props.interaction;
      var tags = props.tags,
          sliders = props.sliders;
      tags = mergeTagsProps(tags, style);
      sliders = mergeSlidersProps(sliders, style);
      var fontSize = style.fontSize;
      var lineHeight = fontSize * LINE_HEIGHT$6;
      var multiChildren = tags.length + sliders.length > 1;
      var contentHeight = height - PADDING_TOP$2 - lineHeight - // title
      TITLE_PADDING_BOTTOM$1 - (multiChildren ? Carousel.getDotAreaHeight() : PADDING_BOTTOM$2);
      var contentY = PADDING_TOP$2 + lineHeight + TITLE_PADDING_BOTTOM$1;
      var children = map(tags, function (g) {
        return h('group', {}, renderTitle({
          text: g.title,
          y: PADDING_TOP$2,
          outerWidth: width,
          style: style
        }), h(ScrollArea, {
          touch: true,
          x: PADDING_LEFT$1,
          y: contentY,
          width: width - PADDING_LEFT$1,
          height: contentHeight,
          scrollHeight: _.size(g.items) * lineHeight,
          scrollWidth: width - PADDING_LEFT$1
        }, map(g.items, function (item, i) {
          return h(IconTag, _extends({
            key: item.name,
            fieldIds: g.fieldIds,
            position: [0, lineHeight * i],
            text: item.text,
            width: width - PADDING_LEFT$1,
            handleClick: onItemToggle
          }, g.style, item));
        })));
      });
      children = children.concat(map(sliders, function (g) {
        return h('group', {}, renderTitle({
          text: g.title,
          y: PADDING_TOP$2,
          outerWidth: width,
          style: style
        }), h(getSliderCtor(g.type), _extends({
          touch: true,
          direction: 'vertical',
          x: PADDING_LEFT$1,
          y: contentY,
          width: width - PADDING_H$2,
          height: contentHeight,
          handleValueChange: onRangeChange
        }, g)));
      }));
      return h(Carousel, {
        x: x,
        y: y,
        width: width,
        height: height,
        interaction: interaction,
        borderColor: borderColor,
        children: children
      });
    };

    var BORDER_COLOR = '#ccc';

    var Legend = function Legend(props) {
      var enabled = props.enabled,
          position = props.position,
          sliders = props.sliders,
          isMobile = props.isMobile,
          tags = props.tags;
      var empty = _.size(tags) === 0 && _.size(sliders) === 0;

      if (!enabled || empty) {
        return h('group');
      }

      var Comp = position === 'top' || position === 'bottom' ? LegendHorizontal : L$2;

      if (isMobile) {
        Comp = Comp.Mobile;
      } // FIXME legend 在这一步做这个有点奇怪
      // merge filter value to slider


      var filtered = props;

      if (sliders && _.size(sliders)) {
        filtered = _extends({}, props, {
          // onRangeChangeEnd: ,
          sliders: _.map(sliders, function (s) {
            return _extends({}, s);
          })
        });
      }

      return h(Comp, filtered);
    };

    var Legend$1 = connect(function (state) {
      var computedState = computedSelect(state);
      var legend = computedState.legend,
          isMobile = computedState.isMobile,
          sliderFilter = computedState.sliderFilter,
          bigData = computedState.bigData,
          darkTheme = computedState.darkTheme;

      if (_.isEmpty(sliderFilter)) {
        return _extends({}, legend, {
          bigData: bigData,
          isMobile: isMobile,
          darkTheme: darkTheme
        });
      }

      var sliders = [];

      _.each(legend.sliders, function (slider) {
        var isFind = _.some(sliderFilter, function (filter, fieldId) {
          var key = slider.fieldIds.join(SEPARATOR);

          if (key === fieldId) {
            sliders.push(assign({}, slider, filter));
            return true;
          }
        });

        !isFind && sliders.push(slider);
      });

      return _extends({}, legend, {
        sliders: sliders,
        isMobile: isMobile,
        bigData: bigData,
        darkTheme: darkTheme
      });
    }, function (dispatch) {
      return {
        onItemToggle: function onItemToggle(payload) {
          return dispatch(Act.tagFilter(payload));
        },
        onRangeChange: function onRangeChange(payload) {
          return dispatch(Act.sliderFilter(payload));
        } // onRangeChangeEnd: () => dispatch(Act.sliderFilterEnd())

      };
    })(Legend);

    var PADDING$1 = 3;
    /**
     * @param tick
     * @param labelPos: left-bottom :left坐标轴在左侧, 标签在下方
     */

    function dealRotateTickLabel(tick, labelPos) {
      var style = tick.style,
          _tick$style = tick.style,
          text = _tick$style.text,
          fontSize = _tick$style.fontSize,
          rotation = tick.rotation,
          position = tick.position,
          maxSize = tick.maxSize;
      var sin = Math.sin,
          cos = Math.cos,
          abs = Math.abs;

      var _calcTextDim = calcTextDim(text, style),
          textWidth = _calcTextDim[0],
          textHeight = fontSize * 1.5;

      if (textWidth > maxSize) {
        textWidth = maxSize;
        tick.style.truncate = {
          outerWidth: maxSize + 2
        };
      } else {
        tick.style.truncate = null; // @BI-35949: default value
      } // 先计算处旋转后的标签的boundingRect


      var w1 = textWidth * cos(rotation),
          w2 = textHeight * sin(rotation),
          h1 = textWidth * sin(rotation),
          h2 = textHeight * cos(rotation);
      var width = abs(w1) + abs(w2),
          height = abs(h1) + abs(h2); // 根据boundsRect和文字相对坐标轴位置及原有位置，计算出旋转后的偏移，作为新的position

      var px = position[0],
          py = position[1],
          w = width / 2,
          h = height / 2;

      var _px, _py;

      var _labelPos$split = labelPos.split('-'),
          axisPos = _labelPos$split[0],
          _labelPos$split$ = _labelPos$split[1],
          textPos = _labelPos$split$ === void 0 ? '' : _labelPos$split$;

      var isTop = textPos === 'top';
      var isLeft = textPos === 'left';
      var isRight = textPos === 'right';
      var isBottom = textPos === 'bottom';

      switch (axisPos) {
        // 坐标轴在左侧
        case 'left':
          _px = px - w;
          _py = py + (isTop ? h : isBottom ? -h : 0);
          break;
        // 坐标轴在下侧

        case 'bottom':
          _py = py + h;
          _px = px + (isLeft ? w + PADDING$1 : isRight ? -w - PADDING$1 : 0);
          break;
        // 坐标轴在上侧

        case 'top':
          _py = py - h;
          _px = px + (isLeft ? w + PADDING$1 : isRight ? -w - PADDING$1 : 0);
          break;
        // 坐标轴在右侧

        case 'right':
          _px = px + w;
          _py = py + (isTop ? h : isBottom ? -h : 0);
          break;

        default:
          _px = px;
          _py = py;
      }

      tick.position = [_px, _py];
    }

    /**
     * 判断水平摆放的文字是否需要裁剪省略
     * @param text
     * @param limit
     * @param style
     * @returns {*}
     */

    var getEllipsisText = function getEllipsisText(text, limit, style) {
      var _calcTextDim = calcTextDim(text, style),
          width = _calcTextDim[0];

      if (width <= limit) {
        return text;
      }

      var len = text.length;
      var end = 0; // todo 这种逐字计算尺寸判断省略位置并不是很好的做法

      while (++end <= len) {
        var content = text.slice(0, end);

        var _calcTextDim2 = calcTextDim(content, style),
            _width = _calcTextDim2[0];

        if (_width > limit) {
          var ellipsis = '',
              left = text.slice(0, Math.max(end - 1, 0)),
              e = (limit - calcTextDim(left, style)[0]) / style.fontSize;

          if (e > 0.6) {
            ellipsis = '..';
          } else if (e > 0.3) {
            ellipsis = '.';
          } else {
            // 存在文字时，再往前省略一个， 否则直接为"."
            if (left) {
              left = left.slice(0, left.length - 1);
              ellipsis = '...';
            } else {
              ellipsis = '.';
            }
          }

          return left + ellipsis;
        }
      }
    };

    var PADDING$2 = Axis.PADDING;
    var DOUBLE_PADDING$1 = PADDING$2 * 2;
    var CHINESE_REG = /[\u4e00-\u9fa5]+/g;
    var CHINESE = 0;
    var NON_CHINESE = 1;
    /**
     * @param titles [Array] 文字集合，对于维度标题这样的来说，可能用多个维度字段对应的标题组成，所以最后类似一行中存在多个不同样式的文字
     * @param horizontal 水平排布或者竖直排布
     * @param center 文字的中心位置
     * @param limit  尺寸限制
     * @constructor
     */

    var Title =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Title, _Component);

      function Title(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.state = {
          titleTextNodes: null
        };

        _this.updateState(props);

        return _this;
      }

      var _proto = Title.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.titles === this.props.titles) {
          return;
        }

        this.updateState(nextProps);
      };

      _proto.updateState = function updateState(props) {
        var titles = props.titles,
            horizontal = props.horizontal,
            textAlign = props.textAlign,
            textVerticalAlign = props.textVerticalAlign,
            limit = props.limit;
        var getTextNodes = horizontal ? getHorizontalTitle : getVerticalTitle;
        this.setState({
          titleTextNodes: getTextNodes(titles, limit, textAlign, textVerticalAlign)
        });
      };

      _proto.render = function render$$1() {
        var _this$props = this.props,
            _this$props$position = _this$props.position,
            x = _this$props$position[0],
            y = _this$props$position[1],
            id = _this$props.id,
            isScrolling = _this$props.isScrolling;
        var titleTextNodes = this.state.titleTextNodes;
        return h(Animate$$1, {
          key: id,
          start: {
            x: x,
            y: y
          },
          enter: {
            x: x,
            y: y
          },
          update: isScrolling ? {
            x: x,
            y: y
          } : {
            x: [x],
            y: [y]
          }
        }, function (_ref) {
          var x = _ref.x,
              y = _ref.y;
          return h('group', {
            position: [x, y]
          }, titleTextNodes);
        });
      };

      return Title;
    }(Component);

    function getVerticalTitle(titles, limit, textAlign, textVerticalAlign) {
      limit -= DOUBLE_PADDING$1;
      var lineHeight = 0,
          ncw,
          // non-chinese character width
      nch,
          cw,
          // chinese character width
      ch,
          height,
          sliced = false;
      var allWords = [];

      for (var i = 0, len = titles.length; i < len; i++) {
        if (sliced) {
          break;
        }

        var _titles$i = titles[i],
            text = _titles$i.text,
            style = _titles$i.style;
        var words = separeteVerticalChars(text);

        for (var j = 0, wLen = words.length; j < wLen; j++) {
          var word = words[j],
              _words$j = words[j],
              _text = _words$j.text,
              type = _words$j.type;

          if (type === NON_CHINESE) {
            if (!ncw) {
              var _calcTextDim = calcTextDim('0', style);

              ncw = _calcTextDim[0];
              nch = _calcTextDim[1];
            }
            height = (ncw + 1) * _text.length; // BI-32257 非中文1px间隔？？？
          } else {
            if (!cw) {
              // 竖直排列中，text的length = 1.
              var _calcTextDim2 = calcTextDim(_text, style);

              cw = _calcTextDim2[0];
              ch = _calcTextDim2[1];
            }
            height = ch * _text.length;
          }

          word.style = style;

          if (lineHeight + height > limit) {
            sliced = true;
            var valid = limit - lineHeight;
            var res = valid / (type === NON_CHINESE ? ncw : style.fontSize);

            var left = res | 0,
                content = _text.substr(0, left - 1),
                ellipsis = '..'; // 非中文


            if (type === NON_CHINESE) {
              allWords.push({
                text: content + ellipsis,
                y: (lineHeight + limit) / 2,
                type: type,
                style: style
              });
            } else {
              var _h = content.length * ch; // 中文时显示和省略号分开，省略号用非中文字符


              allWords.push({
                text: content,
                y: lineHeight + _h / 2,
                type: type,
                style: style
              });
              allWords.push({
                text: ellipsis,
                type: 1,
                style: style,
                y: (lineHeight + _h + limit) / 2
              });
            }

            lineHeight = limit;
          } else {
            word.y = lineHeight + height / 2;
            lineHeight += height;
            allWords.push(word);
          }

          if (sliced) {
            break;
          }
        }
      }

      var py = textVerticalAlign === 'top' ? 0 : -lineHeight * (textVerticalAlign === 'bottom' ? 1 : 0.5);
      return _.map(allWords, function (_ref2) {
        var text = _ref2.text,
            type = _ref2.type,
            y = _ref2.y,
            style = _ref2.style;
        return h('text', {
          silent: true,
          position: [0, py + y + PADDING$2],
          rotation: type === 0 ? 0 : -Math.PI / 2,
          style: _extends({
            text: type === 0 ? text.split('').join('\n') : text,
            textAlign: 'center',
            textVerticalAlign: 'middle'
          }, style)
        });
      });
    }
    /**
     * 将中文和非中文分离出来
     * @param str 原有字符串
     * @returns {Array} [{text:"hello,", type:0}, {text:"世界", type:1}]
     */


    function separateChineseCharacter(str) {
      if (!str) {
        return [];
      }

      var words = [];
      var lastIndex = CHINESE_REG.lastIndex = 0;
      var result;

      while ((result = CHINESE_REG.exec(str)) != null) {
        var mi = result.index; // 两个中文之间的非中文字符

        mi > lastIndex && words.push({
          text: str.substring(lastIndex, mi),
          type: NON_CHINESE // 1 means unChinese character while 0 means chinese character

        });
        words.push({
          text: result[0],
          type: CHINESE
        });
        lastIndex = CHINESE_REG.lastIndex;
      }

      lastIndex < str.length && words.push({
        text: str.substring(lastIndex, str.length),
        type: NON_CHINESE
      });
      return words;
    }
    /**
     * 竖直排布文字的时候，非中文字符的宽度偏差较大，所以将它们都查分成单个字符来计算。
     * @param str
     * @returns {Array}
     */


    function separeteVerticalChars(str) {
      var words = separateChineseCharacter(str);
      var newWords = [];

      _.each(words, function (_ref3) {
        var text = _ref3.text,
            type = _ref3.type;

        _.each(text, function (s) {
          newWords.push({
            text: s,
            type: type
          });
        });
      });

      return newWords;
    }
    /**
     * 水平标题
     * @param titles
     * @param limit
     * @param textAlign 是否居中
     * @param textVerticalAlign 是否居中
     */


    function getHorizontalTitle(titles, limit, textAlign, textVerticalAlign) {
      limit -= DOUBLE_PADDING$1;
      var lineWidth = 0,
          lineHeight = 0,
          sliced = false;
      var slicedTitles = [];

      for (var i = 0, len = titles.length; i < len; i++) {
        var _titles$i2 = titles[i],
            text = _titles$i2.text,
            style = _titles$i2.style;

        var _calcTextDim3 = calcTextDim(text, style),
            width = _calcTextDim3[0],
            height = _calcTextDim3[1];

        var _x = lineWidth,
            _y = lineHeight;

        if (lineWidth + width > limit) {
          text = getEllipsisText(text, limit - lineWidth, style);
          sliced = true;
          lineWidth = limit;
        } else {
          lineWidth += width;
        }

        lineHeight = Math.max(lineHeight, height);
        slicedTitles.push({
          text: text,
          style: style,
          dim: {
            x: _x,
            y: _y,
            width: width,
            height: height
          }
        });

        if (sliced) {
          break;
        }
      }

      slicedTitles.forEach(function (textObj) {
        var dim = textObj.dim,
            height = textObj.dim.height;
        dim.y = (lineHeight - height) / 2;
      });
      var x = textAlign === 'left' ? 0 : -lineWidth * (textAlign === 'right' ? 1 : 0.5);
      var y = textVerticalAlign === 'top' ? 0 : -lineHeight * (textVerticalAlign === 'bottom' ? 1 : 0.5);
      return h(Paragraph, {
        silent: true,
        bounds: {
          x: x,
          y: y,
          width: lineWidth,
          height: lineHeight
        },
        data: [slicedTitles]
      });
    }

    var Timing$1 = {
      duration: 300,
      ease: Ease.Swing
    };
    function renderTicks(_ref) {
      var animation = _ref.animation,
          ticks = _ref.ticks,
          calcTickPos = _ref.calcTickPos,
          horizontal = _ref.horizontal,
          isScrolling = _ref.isScrolling;

      if (!animation) {
        return simpleRenderTicks(ticks);
      }

      return h(NodeGroup$$1, {
        data: ticks,
        keyAccessor: function keyAccessor(d) {
          return d.id;
        },
        start: function start(_ref2) {
          var rotation = _ref2.rotation,
              _ref2$position = _ref2.position,
              x = _ref2$position[0],
              y = _ref2$position[1];
          return {
            opacity: 0,
            rotation: rotation,
            x: x,
            y: y
          };
        },
        enter: function enter(_ref3) {
          var rotation = _ref3.rotation,
              _ref3$position = _ref3.position,
              x = _ref3$position[0],
              y = _ref3$position[1];
          return {
            opacity: [1],
            rotation: [rotation],
            x: [x],
            y: [y],
            timing: Timing$1
          };
        },
        update: function update(_ref4) {
          var rotation = _ref4.rotation,
              _ref4$position = _ref4.position,
              x = _ref4$position[0],
              y = _ref4$position[1];
          return isScrolling ? {
            rotation: rotation,
            x: x,
            y: y,
            timing: Timing$1
          } : {
            rotation: [rotation],
            x: [x],
            y: [y],
            timing: Timing$1
          };
        },
        leave: function leave(_ref5) {
          var id = _ref5.id,
              rotation = _ref5.rotation,
              position = _ref5.position;
          var x = position[0],
              y = position[1];

          if (calcTickPos) {
            var _calcTickPos = calcTickPos(id),
                _x = _calcTickPos[0],
                _y = _calcTickPos[1];

            if (horizontal) {
              x = _x;
            } else {
              y = _y;
            }
          }

          return {
            opacity: [0],
            rotation: [rotation],
            x: [x],
            y: [y],
            timing: Timing$1
          };
        }
      }, function (nodes) {
        return h('group', null, _.map(nodes, function (item) {
          var key = item.key,
              style = item.data.style,
              _item$state = item.state,
              opacity = _item$state.opacity,
              x = _item$state.x,
              y = _item$state.y,
              rotation = _item$state.rotation;
          return h('text', {
            silent: true,
            key: key,
            position: [x, y],
            rotation: rotation,
            style: _extends({}, style, {
              opacity: opacity
            })
          });
        }));
      });
    }

    function simpleRenderTicks(ticks) {
      return h('group', null, _.map(ticks, function (tick) {
        var position = tick.position,
            rotation = tick.rotation,
            style = tick.style;
        return h('text', {
          key: tick.id,
          silent: true,
          position: position,
          rotation: rotation,
          style: _extends({}, style)
        });
      }));
    }

    var PADDING$3 = 3;
    var abs$3 = Math.abs,
        sin$3 = Math.sin,
        cos$3 = Math.cos;

    var MeasureTick =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(MeasureTick, _Component);

      function MeasureTick() {
        return _Component.apply(this, arguments) || this;
      }

      var _proto = MeasureTick.prototype;

      _proto.render = function render$$1() {
        var _this$props$bounds = this.props.bounds,
            x = _this$props$bounds.x,
            y = _this$props$bounds.y,
            width = _this$props$bounds.width,
            height = _this$props$bounds.height;
        return h('group', {
          clip: {
            type: 'rect',
            shape: {
              x: x,
              y: y,
              width: width,
              height: height
            }
          }
        }, this._renderTicks(), this._renderTitle());
      }
      /**
       * 标题
       * @private
       */
      ;

      _proto._renderTitle = function _renderTitle() {
        var _this$props = this.props,
            _this$props$measureDe = _this$props.measureDef,
            _this$props$measureDe2 = _this$props$measureDe.title,
            enabled = _this$props$measureDe2.enabled,
            text = _this$props$measureDe2.text,
            style = _this$props$measureDe2.style,
            size = _this$props$measureDe.size,
            horizontal = _this$props.facet.horizontal;

        if (!enabled || size === 0) {
          return [];
        }

        var _this$props2 = this.props,
            _this$props2$bounds = _this$props2.bounds,
            x = _this$props2$bounds.x,
            y = _this$props2$bounds.y,
            width = _this$props2$bounds.width,
            height = _this$props2$bounds.height,
            measureId = _this$props2.measureId,
            isScrolling = _this$props2.isScrolling;
        var fontSize = style.fontSize,
            fontStyle = style.fontStyle;
        var trans = fontSize / 2 + PADDING$3 + (fontStyle === 'italic' ? fontSize * 0.2 : 0);
        var mx, my;
        var isLeftOrBottom = measureId !== getSharedAxisName(horizontal, false);

        if (horizontal) {
          mx = x + width / 2;
          my = isLeftOrBottom ? height + y - trans : y + trans;
        } else {
          mx = isLeftOrBottom ? x + trans : x + width - trans;
          my = y + height / 2;
        }

        return h(Title, {
          isScrolling: isScrolling,
          id: text,
          titles: [{
            text: text,
            style: style
          }],
          horizontal: horizontal,
          position: [mx, my],
          limit: horizontal ? width : height
        });
      }
      /**
       * 刻度标签
       * @returns {any[]}
       * @private
       */
      ;

      _proto._renderTicks = function _renderTicks() {
        var _this$props3 = this.props,
            animation = _this$props3.animation,
            _this$props3$bounds = _this$props3.bounds,
            x = _this$props3$bounds.x,
            y = _this$props3$bounds.y,
            width = _this$props3$bounds.width,
            height = _this$props3$bounds.height,
            horizontal = _this$props3.horizontal,
            _this$props3$measureD = _this$props3.measureDef,
            _this$props3$measureD2 = _this$props3$measureD.tick,
            rotation = _this$props3$measureD2.rotation,
            enableTick = _this$props3$measureD2.enabled,
            _this$props3$measureD3 = _this$props3$measureD2.valid,
            tickValid = _this$props3$measureD3 === void 0 ? true : _this$props3$measureD3,
            tickStyle = _this$props3$measureD2.style,
            reverse = _this$props3$measureD.reverse,
            formatter = _this$props3$measureD.format,
            _this$props3$measureD4 = _this$props3$measureD.title,
            titleStyle = _this$props3$measureD4.style,
            enabledTitle = _this$props3$measureD4.enabled,
            fixedSize = _this$props3$measureD.size,
            isFirstAxis = _this$props3.isFirstAxis,
            axisScale = _this$props3.axisScale,
            isScrolling = _this$props3.isScrolling,
            measureId = _this$props3.measureId,
            facet = _this$props3.facet;
        var _facet$scaleMap$measu = facet.scaleMap[measureId],
            _facet$scaleMap$measu2 = _facet$scaleMap$measu.ticks,
            defTicks = _facet$scaleMap$measu2 === void 0 ? [] : _facet$scaleMap$measu2,
            _facet$scaleMap$measu3 = _facet$scaleMap$measu.domain,
            min = _facet$scaleMap$measu3[0],
            max = _facet$scaleMap$measu3[1];
        var ticks = [],
            len = defTicks.length;
        var showTick = enableTick && tickValid;

        if (len === 0 || !showTick) {
          return [];
        }

        var titleSize = enabledTitle ? titleStyle.fontSize + PADDING$3 * 2 : 0;

        var calcTickPos = function calcTickPos(tick) {
          tick = Math.min(max, Math.max(tick, min));
          return horizontal ? [axisScale(tick), y + (isFirstAxis ? PADDING$3 : height - PADDING$3)] : [x + (isFirstAxis ? width - PADDING$3 : PADDING$3), axisScale(tick)];
        };

        var maxSize = fixedSize ? width - titleSize - PADDING$3 * 2 : tickStyle.fontSize * 9;

        _.each(defTicks, function (tick, index) {
          var position = calcTickPos(tick);
          var tickLabel = {
            id: tick,
            position: position,
            maxSize: maxSize,
            rotation: -toRadian(rotation),
            silent: true,
            style: _extends({
              text: getFormattedText(tick, formatter),
              textAlign: 'center',
              textVerticalAlign: 'center'
            }, tickStyle)
          };
          var isFirst = index === 0 && !reverse || index === len - 1 && reverse && len > 1,
              isLast = index === len - 1 && !reverse || index === 0 && reverse;
          var labelPos;

          if (horizontal) {
            labelPos = "" + (isFirstAxis ? 'bottom' : 'top') + (isFirst ? '-left' : isLast ? '-right' : '');
          } else {
            labelPos = "" + (isFirstAxis ? 'left' : 'right') + (isFirst ? '-bottom' : isLast ? '-top' : '');
          }

          dealRotateTickLabel(tickLabel, labelPos);
          ticks.push(tickLabel);
        });

        var left = Math.min(x, x + width),
            top = Math.min(y, y + height);
        var newTicks = dealMeasureTickOverlap({
          ticks: ticks,
          horizontal: horizontal,
          rotation: rotation,
          bounds: {
            x: left,
            y: top,
            width: width,
            height: height
          }
        }); // 刻度标签

        return renderTicks({
          animation: animation,
          ticks: newTicks,
          calcTickPos: calcTickPos,
          horizontal: horizontal,
          isScrolling: isScrolling
        });
      };

      return MeasureTick;
    }(Component);

    function dealMeasureTickOverlap(_ref) {
      var ticks = _ref.ticks,
          horizontal = _ref.horizontal,
          rotation = _ref.rotation,
          bounds = _ref.bounds;
      var len = ticks.length;
      if (len <= 1) return ticks;
      var firstTick = ticks[0],
          lastTick = ticks[len - 1],
          rotated = horizontal ? abs$3(rotation) > 15 : abs$3(rotation) < 75,
          radian = abs$3(toRadian(rotation)); // 优先显示第一个标签

      var newTicks = [firstTick];

      if (rotated) {
        var posKey = horizontal ? 0 : 1;
        var prev = firstTick.position[posKey];
        var dis = firstTick.style.fontSize,
            multi = horizontal ? sin$3(radian) : cos$3(radian);

        for (var i = 0; i < len; i++) {
          var pos = ticks[i].position[posKey];

          if (abs$3(pos - prev) * multi > dis) {
            newTicks.push(ticks[i]);
            prev = pos;
          }
        }
      } else {
        var x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height;

        var _getTickDim = getTickDim(firstTick, radian),
            fw = _getTickDim[0],
            fh = _getTickDim[1],
            _getTickDim2 = getTickDim(lastTick, radian),
            lw = _getTickDim2[0],
            lh = _getTickDim2[1],
            twoTickLimitSize = horizontal ? fw + lw : fh + lh,
            total = horizontal ? width : height; // 可以放两个或者更多的标签


        if (twoTickLimitSize < total) {
          newTicks.push(lastTick); // 更新bounds

          if (horizontal) {
            width -= twoTickLimitSize + PADDING$3 * 2;
            x += fw + PADDING$3;
          } else {
            height -= twoTickLimitSize + PADDING$3 * 2;
            y += lh + PADDING$3;
          }

          for (var _i = 1; _i < len - 1; _i++) {
            var tick = ticks[_i],
                _getTickDim3 = getTickDim(tick, radian),
                w = _getTickDim3[0],
                _h = _getTickDim3[1],
                _tick$position = tick.position,
                tx = _tick$position[0],
                ty = _tick$position[1];

            var left = tx - w / 2,
                right = tx + w / 2,
                top = ty - _h / 2,
                bottom = ty + _h / 2;
            var addThis = false; // 判断剩余的bounds中能否放的下

            if (horizontal && left > x && right < x + width) {
              addThis = true;
              width = x + width - right;
              x = right;
            } else if (!horizontal && top > y && bottom < y + height) {
              addThis = true;
              height = y + height - bottom;
              y = bottom;
            }

            addThis && newTicks.splice(-1, 0, tick);
          }
        }
      }

      return newTicks;
    }
    /**
     * 计算标签的所占用的尺寸
     * @param tick
     * @param radian
     * @returns {*[]}
     */


    function getTickDim(tick, radian) {
      var _tick$style = tick.style,
          text = _tick$style.text,
          fontSize = _tick$style.fontSize,
          sinR = sin$3(radian),
          cosR = cos$3(radian);

      var _calcTextDim = calcTextDim(text, tick.style),
          w = _calcTextDim[0];

      return [w * cosR + fontSize * sinR, w * sinR + fontSize * cosR];
    }

    var TILE_SIZE = 400;
    var getVisibleTiledImages = function getVisibleTiledImages(_ref, stampId, componentType, stateId) {
      var x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height,
          scrollWidth = _ref.scrollWidth,
          scrollHeight = _ref.scrollHeight;
      var bounds = new Bounds([x, y], [x + width, y + height]);
      var range = new Bounds(bounds.min.unscaleBy(new Point(TILE_SIZE, TILE_SIZE)).floor(), bounds.max.unscaleBy(new Point(TILE_SIZE, TILE_SIZE)).ceil().subtract([1, 1]));
      var images = [];

      for (var j = range.min.y; j <= range.max.y; j++) {
        for (var i = range.min.x; i <= range.max.x; i++) {
          var imageId = [i, j, componentType, stampId, stateId].join('&&');
          images.push({
            imageId: imageId,
            image: Request.urls.tileImage(encodeURIComponent(imageId)),
            x: i * TILE_SIZE,
            y: j * TILE_SIZE,
            width: Math.min(TILE_SIZE, scrollWidth - i * TILE_SIZE),
            height: Math.min(TILE_SIZE, scrollHeight - j * TILE_SIZE)
          });
        }
      }

      return images;
    };
    var getTileImageBounds = function getTileImageBounds(tileX, tileY, plotBounds, scrollBounds) {
      var widthLeft = scrollBounds.width - tileX * TILE_SIZE;
      var heightLeft = scrollBounds.height - tileY * TILE_SIZE;
      return {
        x: plotBounds.x + TILE_SIZE * tileX,
        y: plotBounds.y + TILE_SIZE * tileY,
        width: Math.min(widthLeft, TILE_SIZE),
        height: Math.min(heightLeft, TILE_SIZE)
      };
    };

    var RENDER_FACET_X = 'renderFacetXTile';
    var RENDER_FACET_Y = 'renderFacetYTile';

    var ImageAxis =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(ImageAxis, _Component);

      function ImageAxis(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = ImageAxis.prototype;

      _proto.handleClick = function handleClick(ev) {
        var _this$props$scrollBou = this.props.scrollBounds,
            x = _this$props$scrollBou.x,
            y = _this$props$scrollBou.y;
        var pos = {
          x: ev.offsetX - x,
          y: ev.offsetY - y
        };
        var imageId = ev.target.style.imageId;
        this.props.interaction.emitter.trigger('imageDimensionSelected', {
          imageId: imageId,
          pos: pos
        });
      };

      _proto.render = function render$$1() {
        var _this2 = this;

        if (!this.props.bigData) {
          return h('group');
        }

        var _this$props = this.props,
            stateId = _this$props.stateId,
            stampId = _this$props.stampId,
            horizontal = _this$props.horizontal,
            axisScrollTranslate = _this$props.axisScrollTranslate,
            _this$props$viewBound = _this$props.viewBounds,
            x = _this$props$viewBound.x,
            y = _this$props$viewBound.y,
            width = _this$props$viewBound.width,
            height = _this$props$viewBound.height,
            axisSize = _this$props.axisSize,
            scrollBounds = _this$props.scrollBounds,
            isMobile = _this$props.isMobile;
        var totalSize = axisSize[0] + axisSize[1];
        var scrollWidth = scrollBounds.width + (horizontal ? 0 : totalSize);
        var scrollHeight = scrollBounds.height + (horizontal ? totalSize : 0);
        var images = getVisibleTiledImages({
          x: horizontal ? -axisScrollTranslate : 0,
          y: horizontal ? 0 : -axisScrollTranslate,
          width: width,
          height: height,
          scrollWidth: scrollWidth,
          scrollHeight: scrollHeight
        }, stampId, horizontal ? RENDER_FACET_X : RENDER_FACET_Y, stateId);
        return h('group', {
          silent: isMobile,
          position: [x + (horizontal ? axisScrollTranslate : 0), y + (horizontal ? 0 : axisScrollTranslate)]
        }, // tiledImage
        map(images || [], function (image) {
          return h('image', {
            style: _extends({}, image),
            onclick: _this2.handleClick
          });
        }));
      };

      return ImageAxis;
    }(Component);

    var ImageAxis$1 = connect(function (state) {
      return {
        stateId: computedSelect(state).stateId
      };
    })(ImageAxis);

    /**
     * 获取拖拽提示线的形状
     * @param direction     鼠标触发拖拽提示时在悬浮矩形块的位置
     * @param bounds        悬浮矩形块的尺寸
     * @param tx            水平偏移
     * @param ty            竖直偏移
     * @param axisLineWidth 轴线宽度
     * @returns {{x1: *, y1: *, x2: number, y2: number}}
     */

    var getCueLineShape = function getCueLineShape(direction, bounds, _ref, axisLineWidth) {
      var tx = _ref[0],
          ty = _ref[1];
      var x = bounds.x,
          y = bounds.y,
          width = bounds.width,
          height = bounds.height;
      var m = axisLineWidth + 2;
      x += tx;
      y += ty;
      var x1 = x + m,
          x2 = x + width - m,
          y1 = y + m,
          y2 = y + height - m;

      switch (direction) {
        case Direction.TOP:
          y2 = y1;
          break;

        case Direction.BOTTOM:
          y1 = y2;
          break;

        case Direction.LEFT:
          x2 = x1;
          break;

        case Direction.RIGHT:
          x1 = x2;
          break;
      }

      return {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      };
    };

    var _resizeCursorMap;
    var DEFAULT_CURSOR = 'default';
    var HOVER_FILL = '#D0D4DA';
    var HOVER_OPACITY = 0.2;
    var MIN_SIZE = 10;
    var TOP = Direction.TOP,
        BOTTOM = Direction.BOTTOM,
        LEFT = Direction.LEFT,
        RIGHT = Direction.RIGHT;
    var resizeCursorMap = (_resizeCursorMap = {}, _resizeCursorMap[LEFT] = 'col-resize', _resizeCursorMap[RIGHT] = 'col-resize', _resizeCursorMap[BOTTOM] = 'row-resize', _resizeCursorMap[TOP] = 'row-resize', _resizeCursorMap);
    var CueLineStyle = {
      stroke: '#3685F2',
      lineWidth: 1
    };

    var isHorizontalDirection = function isHorizontalDirection(direction) {
      return direction === Direction.LEFT || direction === Direction.RIGHT;
    };

    var getCountOnFacet = function getCountOnFacet(facet) {
      return facet.nodesMap[NODE_ROOT].leafCount * (facet.measures.length || 1);
    };

    var InteractiveArea =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(InteractiveArea, _Component);

      function InteractiveArea() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Component.call.apply(_Component, [this].concat(args)) || this;
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.cursor = DEFAULT_CURSOR;
        _this.state = {
          hoverRect: null,
          cursor: DEFAULT_CURSOR,
          direction: null
        };
        return _this;
      }

      var _proto = InteractiveArea.prototype;

      _proto.findRect = function findRect(ev) {
        var _this$props = this.props,
            horizontal = _this$props.horizontal,
            levels = _this$props.levels,
            axisLineWidth = _this$props.axisLineWidth,
            scrollTranslate = _this$props.scrollTranslate;
        var mousePos = this.getMousePos(ev);
        var rectState = null;
        var levelPos = mousePos[horizontal ? 'y' : 'x'];
        var rectPos = mousePos[horizontal ? 'x' : 'y']; // 第一步，先比较层级位置, 找到鼠标所在的层级

        var hoverLevel = _.find(levels, function (_ref) {
          var range = _ref.range;
          return range && range[0] <= levelPos && levelPos <= range[1];
        });

        if (!hoverLevel) {
          return rectState;
        }

        var inRect = function inRect(bounds) {
          var x = bounds.x,
              y = bounds.y,
              width = bounds.width,
              height = bounds.height;
          var start = horizontal ? x : y;
          var end = start + (horizontal ? width : height);
          return start <= rectPos && rectPos <= end;
        };

        var rects = hoverLevel.rects,
            measure = hoverLevel.measure; // 第二步, 在层级中找出悬浮的矩形块

        var hoverRect = _.find(rects, function (rect) {
          return inRect(rect.bounds);
        });

        if (!hoverRect) {
          return rectState;
        }

        var bounds = hoverRect.bounds; // 判断是否需要resize及resize的方向

        var direction = this.getResizeDirection(bounds, mousePos);
        var translate = horizontal ? [scrollTranslate, 0] : [0, scrollTranslate];
        var cueLine = direction && getCueLineShape(direction, bounds, translate, axisLineWidth);
        rectState = {
          hoverRect: hoverRect,
          // 悬浮的矩形
          cursor: direction // 鼠标手势(是否可以拖拽, 以及拖拽的方向)
          ? resizeCursorMap[direction] : measure // 指标使用默认, 维度使用手型, 表示可以点击
          ? DEFAULT_CURSOR : 'pointer',
          direction: direction,
          // 鼠标触发的提示拖拽线在悬浮矩形的位置
          cueLine: cueLine
        };
        return rectState;
      };

      _proto.onmousemove = function onmousemove(ev) {
        if (this.isPanning) {
          return;
        }

        var nextState = this.findRect(ev);

        if (nextState) {
          this.setState(nextState);
        }
      };

      _proto.onmouseout = function onmouseout() {
        if (this.isPanning) {
          return;
        }

        this.setState({
          hoverRect: null,
          cursor: DEFAULT_CURSOR,
          direction: null,
          cueLine: null
        });
      };

      _proto._isScrollable = function _isScrollable(direction) {
        var _this$props2 = this.props,
            plotBounds = _this$props2.plotBounds,
            scrollBounds = _this$props2.scrollBounds,
            facetX = _this$props2.facetX,
            facetY = _this$props2.facetY;
        return isHorizontalDirection(direction) ? plotBounds.width < scrollBounds.width || facetX.fit : plotBounds.height < scrollBounds.height || facetY.fit;
      };

      _proto.onpanstart = function onpanstart(ev) {
        var direction = this.state.direction;

        if (!direction) {
          return;
        }

        this.startPos = this.getMousePos(ev);
        this.isPanning = true; // 这里计算resizeLine的界限

        var _this$props3 = this.props,
            horizontal = _this$props3.horizontal,
            facet = _this$props3.facet,
            facetX = _this$props3.facetX,
            facetY = _this$props3.facetY,
            clipBounds$$1 = _this$props3.clipBounds,
            plotBounds = _this$props3.plotBounds,
            globalRects = _this$props3.globalRects; // const otherFacet = horizontal ? facetY : facetX;

        var _this$state$hoverRect = this.state.hoverRect,
            bounds = _this$state$hoverRect.bounds,
            measure = _this$state$hoverRect.measure,
            leafCount = _this$state$hoverRect.leafCount;
        var horizontalDirection = isHorizontalDirection(direction);

        var scrollable = this._isScrollable(direction);

        var x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height,
            position = bounds.position;
        var cx = clipBounds$$1.x,
            cy = clipBounds$$1.y,
            cw = clipBounds$$1.width,
            ch = clipBounds$$1.height;
        var px = plotBounds.x,
            py = plotBounds.y,
            pw = plotBounds.width,
            ph = plotBounds.height;
        var rect1 = globalRects[0],
            rect2 = globalRects[1];
        var rw1 = rect1.width,
            rh1 = rect1.height;
        var rw2 = rect2.width,
            rh2 = rect2.height;
        var limit;

        if (horizontal) {
          if (horizontalDirection) {
            var count = measure ? 1 : leafCount * (facet.measures.length || 1);
            limit = [x + MIN_SIZE * count, cx + cw];
          } else {
            var _count = scrollable ? 0 : getCountOnFacet(facetY);

            if (position === BOTTOM) {
              if (direction === BOTTOM) {
                var dis = py + ph + rh2 - y - height;
                limit = [y + MIN_SIZE, cy + ch - dis];
              } else {
                limit = [py + _count * MIN_SIZE, y + height - MIN_SIZE];
              }
            } else {
              var _dis = py - y - height;

              limit = [y + MIN_SIZE, py + ph - _count * MIN_SIZE - _dis - MIN_SIZE];
            }
          }
        } else {
          if (horizontalDirection) {
            var _count2 = scrollable ? 0 : getCountOnFacet(facetX);

            if (position === RIGHT) {
              if (direction === RIGHT) {
                var _dis2 = px + pw + rw2 - x - width;

                limit = [x + MIN_SIZE, cx + cw - _dis2];
              } else {
                limit = [px + _count2 * MIN_SIZE + MIN_SIZE, x + width - MIN_SIZE];
              }
            } else {
              var _dis3 = px - x - width;

              limit = [x + MIN_SIZE, px + pw - _count2 * MIN_SIZE - _dis3 - MIN_SIZE];
            }
          } else {
            var _count3 = measure ? 1 : leafCount * (facet.measures.length || 1);

            limit = [y + MIN_SIZE * _count3, cy + ch];
          }
        }

        this.limit = limit;
      };

      _proto.onpan = function onpan(ev) {
        if (!this.isPanning) {
          return;
        }

        var interaction = this.props.interaction;
        var resizeLine = this.getResizeLineShape(ev);
        interaction && interaction.facetResizeMove && interaction.facetResizeMove({
          resizeLine: resizeLine
        });
      };

      _proto.onpanend = function onpanend(ev) {
        if (!this.isPanning) {
          return;
        }

        var _this$props4 = this.props,
            facet = _this$props4.facet,
            horizontal = _this$props4.horizontal,
            interaction = _this$props4.interaction;
        var _this$state = this.state,
            hoverRect = _this$state.hoverRect,
            direction = _this$state.direction;
        var panHorizontal = direction === RIGHT || direction === LEFT,
            negative = direction === LEFT || direction === TOP;
        var _hoverRect$bounds = hoverRect.bounds,
            width = _hoverRect$bounds.width,
            height = _hoverRect$bounds.height,
            measure = hoverRect.measure,
            _hoverRect$leafCount = hoverRect.leafCount,
            leafCount = _hoverRect$leafCount === void 0 ? 0 : _hoverRect$leafCount,
            fieldId = hoverRect.fieldId;
        var _this$startPos = this.startPos,
            sx = _this$startPos.x,
            sy = _this$startPos.y;

        var _this$getMousePos = this.getMousePos(ev),
            ex = _this$getMousePos.x,
            ey = _this$getMousePos.y;

        var _this$limit = this.limit,
            min = _this$limit[0],
            max = _this$limit[1];

        if (panHorizontal) {
          ex = clamp(ex, min, max);
        } else {
          ey = clamp(ey, min, max);
        }

        var distance = panHorizontal ? ex - sx : ey - sy;
        var newSize = distance * (negative ? -1 : 1) + (panHorizontal ? width : height);
        var fixUnit = horizontal && panHorizontal || !(horizontal || panHorizontal);
        var value = fixUnit ? newSize * (measure ? facet.measuresOverlapped ? 1 : facet.measures.length : 1 / leafCount) : newSize;
        interaction && interaction.facetResizeEnd && interaction.facetResizeEnd({
          fixUnit: fixUnit,
          // 是否为固定unit, 否则表示维度或者指标字段为fixedSize
          horizontal: horizontal,
          // 拖拽横轴或者纵轴
          fieldId: fieldId,
          // fixSize的时候，对应的字段id，指标聚合时共享轴为 0|1
          value: value // 拖动后的大小值

        });
        this.startPos = null;
        this.isPanning = false;
        this.setState({
          resizeLineShape: null,
          direction: null,
          hoverRect: null,
          cueLine: null
        });
      } // TODO, 和tap一起重构
      ;

      _proto.onclick = function onclick() {
        var _this$props5 = this.props,
            facet = _this$props5.facet,
            interaction = _this$props5.interaction;
        var hoverRect = this.state.hoverRect;

        if (!hoverRect || hoverRect.id == null) {
          return;
        }

        var id = hoverRect.id;
        interaction.dimensionClick && interaction.dimensionClick({
          facet: facet,
          id: id
        });
      };

      _proto.ontap = function ontap(ev) {
        var interaction = this.props.interaction;
        var rectState = this.findRect(ev);

        if (rectState) {
          var facet = this.props.facet;
          var hoverRect = rectState.hoverRect;

          if (!hoverRect || hoverRect.id == null) {
            return;
          }

          var id = hoverRect.id;
          interaction.axisTap(ev);
          interaction.dimensionTap && interaction.dimensionTap({
            facet: facet,
            id: id
          });
        }
      };

      _proto.getResizeDirection = function getResizeDirection(bounds, mousePos) {
        var _this$props6 = this.props,
            facet = _this$props6.facet,
            horizontal = _this$props6.horizontal,
            plotBounds = _this$props6.plotBounds,
            scrollBounds = _this$props6.scrollBounds;
        var direction;
        var position = bounds.position; // const { width: pw, height: ph, scrollWidth, scrollHeight } = plotBounds;

        var yScrollAble = plotBounds.height <= scrollBounds.height,
            xScrollAble = plotBounds.width <= scrollBounds.width;

        if (horizontal) {
          if (onRightBorder(bounds, mousePos) && !facet.fit) {
            direction = RIGHT;
          }

          if (position === BOTTOM) {
            if (yScrollAble && onTopBorder(bounds, mousePos)) {
              direction = TOP;
            } else if (!yScrollAble && onBottomBorder(bounds, mousePos)) {
              direction = BOTTOM;
            }
          }

          if (position === TOP && onBottomBorder(bounds, mousePos)) {
            direction = BOTTOM;
          }
        } else {
          if (onBottomBorder(bounds, mousePos) && !facet.fit) {
            direction = BOTTOM;
          }

          if (position === LEFT && onRightBorder(bounds, mousePos)) {
            direction = RIGHT;
          }

          if (position === RIGHT) {
            if (xScrollAble && onLeftBorder(bounds, mousePos)) {
              direction = LEFT;
            } else if (!xScrollAble && onRightBorder(bounds, mousePos)) {
              direction = RIGHT;
            }
          }
        }

        return direction;
      };

      _proto.getResizeLineShape = function getResizeLineShape(_ref2) {
        var x = _ref2.offsetX,
            y = _ref2.offsetY;
        var direction = this.state.direction;
        var _this$props7 = this.props,
            horizontal = _this$props7.horizontal,
            plotBounds = _this$props7.plotBounds,
            globalRects = _this$props7.globalRects;
        var rect1 = globalRects[0],
            rect2 = globalRects[1];
        var rw1 = rect1.width,
            rh1 = rect1.height;
        var rw2 = rect2.width,
            rh2 = rect2.height;
        var px = plotBounds.x,
            py = plotBounds.y,
            pw = plotBounds.width,
            ph = plotBounds.height;
        var horizontalResize = direction === LEFT || direction === RIGHT;
        var diff = horizontalResize ^ horizontal;
        var x1, x2, y1, y2; // http://ui.finebi.com:7777/UI/03-%E4%BB%AA%E8%A1%A8%E6%9D%BF/start.html#g=1&p=%E8%BD%B4%E5%8C%BA%E9%97%B4%E4%BA%A4%E4%BA%92
        // 不同的方向不同的位置，线的shape不一样

        var _this$limit2 = this.limit,
            min = _this$limit2[0],
            max = _this$limit2[1];

        if (horizontalResize) {
          x1 = x2 = Math.max(min, Math.min(max, x));
          y1 = py - (diff ? 0 : rh1);
          y2 = py + ph + (diff ? 0 : rh2);
        } else {
          y1 = y2 = Math.max(min, Math.min(max, y));
          x1 = px - (diff ? 0 : rw1);
          x2 = px + pw + (diff ? 0 : rw2);
        }

        return {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        };
      };

      _proto.getMousePos = function getMousePos(ev) {
        var _this$props8 = this.props,
            scrollTranslate = _this$props8.scrollTranslate,
            horizontal = _this$props8.horizontal;
        var ex = ev.offsetX,
            ey = ev.offsetY;
        var mousePos = {
          x: ex,
          y: ey
        };
        mousePos[horizontal ? 'x' : 'y'] -= scrollTranslate;
        return mousePos;
      };

      _proto.render = function render$$1() {
        var _this$props9 = this.props,
            globalRects = _this$props9.globalRects,
            touch = _this$props9.touch,
            horizontal = _this$props9.horizontal,
            scrollTranslate = _this$props9.scrollTranslate;
        var _this$state2 = this.state,
            hoverRect = _this$state2.hoverRect,
            cursor = _this$state2.cursor,
            cueLine = _this$state2.cueLine;
        var groupProps;

        if (touch) {
          groupProps = {
            ontap: this.ontap
          };
        } else {
          groupProps = {
            onmouseover: this.onmousemove,
            onmousemove: this.onmousemove,
            onmouseout: this.onmouseout,
            onpanstart: this.onpanstart,
            onpan: this.onpan,
            onpanend: this.onpanend,
            onclick: this.onclick
          };
        }

        return h('group', groupProps, // 用于监听事件
        _.map(globalRects, function (shape) {
          return h('rect', {
            shape: shape,
            cursor: cursor,
            invisible: true
          });
        }), hoverRect && h('rect', {
          position: horizontal ? [scrollTranslate, 0] : [0, scrollTranslate],
          shape: hoverRect.bounds,
          silent: true,
          style: {
            fill: HOVER_FILL,
            opacity: HOVER_OPACITY
          }
        }), // cueLine
        cueLine && h('line', {
          silent: true,
          shape: cueLine,
          style: CueLineStyle
        }));
      };

      return InteractiveArea;
    }(Component);

    var SEGMENT_COLOR = '#5f5f5f';

    var getDimensionTitles = function getDimensionTitles(_ref) {
      var facet = _ref.facet,
          defs = _ref.defs;
      var dimensions = facet.dimensions;
      var maxFontSize = 0;
      var titles = [];

      _.each(dimensions, function (dim) {
        var _defs$dim$title = defs[dim].title,
            text = _defs$dim$title.text,
            style = _defs$dim$title.style,
            fontSize = _defs$dim$title.style.fontSize;
        maxFontSize = Math.max(fontSize, maxFontSize);
        text && titles.push({
          text: text,
          style: style
        });
      });

      var titleLen = titles.length; // 插入分割符 /

      for (var i = 0; i < titleLen - 1; i++) {
        titles.splice(i * 2 + 1, 0, {
          text: '/ ',
          // 加一个空格, 否则斜线与文字重叠
          style: {
            fontSize: maxFontSize,
            textFill: SEGMENT_COLOR
          }
        });
      }

      return titles;
    };

    var PADDING$4 = Axis.PADDING;

    var calcDimensionTickBounds = function calcDimensionTickBounds(node, facet, defs, plot) {
      var horizontal = facet.horizontal,
          measuresOverlapped = facet.measuresOverlapped,
          facetSize = facet.size,
          dimensions = facet.dimensions,
          scaleMap = facet.scaleMap;
      var x, y, width, height, position;

      if (horizontal) {
        x = node.pos;
        width = node.length;
        height = scaleMap[node.dim].size;
        y = plot.y + plot.height;
        var defName = getSharedAxisName(horizontal, true);
        var defSize = scaleMap[defName] && scaleMap[defName].size || 0;
        y += measuresOverlapped ? defSize : facetSize;
        var step = dimensions.length - node.path.length;

        for (var i = 0; i < step; i++) {
          var index = dimensions.length - i - 1;
          y += scaleMap[dimensions[index]].size;
        }

        position = 'bottom';
      } else {
        y = node.pos;
        height = node.length;
        width = scaleMap[node.dim].size;
        x = plot.x - PADDING$4;

        var _defName = getSharedAxisName(horizontal, true);

        var _defSize = scaleMap[_defName] && scaleMap[_defName].size || 0;

        x -= measuresOverlapped ? _defSize : facetSize;

        var _step = dimensions.length - node.path.length;

        for (var _i = 0; _i < _step; _i++) {
          var _index = dimensions.length - _i - 1;

          x -= scaleMap[dimensions[_index]].size;
        }

        x -= width;
        position = 'left';
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height,
        position: position
      };
    };

    var calcMeasureTickBounds = function calcMeasureTickBounds(measureId, index, node, facet, defs, plot) {
      var horizontal = facet.horizontal,
          scaleMap = facet.scaleMap,
          facetSize = facet.size;
      var x, y, width, height, position; // 指标Tick的bounds

      var measuresOverlapped = facet.measuresOverlapped;

      if (horizontal) {
        if (measuresOverlapped) {
          var defSize = scaleMap[measureId] && scaleMap[measureId].size || 0;
          x = node.pos;
          width = node.length;
          height = defSize;
          y = index === 0 ? plot.y + plot.height : plot.y - defSize;
          position = index === 0 ? 'bottom' : 'top';
        } else {
          y = plot.y + plot.height;
          height = facetSize;
          var _node$measurePosMap$m = node.measurePosMap[measureId],
              p1 = _node$measurePosMap$m[0],
              p2 = _node$measurePosMap$m[1];
          x = Math.min(p1, p2);
          width = Math.abs(p1 - p2);
          position = 'bottom';
        }
      } else {
        if (measuresOverlapped) {
          y = node.pos;
          height = node.length;
          width = scaleMap[measureId] && scaleMap[measureId].size || 0;
          x = index === 0 ? plot.x - width : plot.x + plot.width;
          position = index === 0 ? 'left' : 'right';
        } else {
          var _node$measurePosMap$m2 = node.measurePosMap[measureId],
              _p = _node$measurePosMap$m2[0],
              _p2 = _node$measurePosMap$m2[1];
          y = Math.min(_p, _p2);
          height = Math.abs(_p - _p2);
          width = facetSize;
          x = plot.x - width;
          position = 'left';
        }
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height,
        position: position
      };
    };

    var getAxisLines = function getAxisLines(defs, facet, actualBounds) {
      var nodesMap = facet.nodesMap,
          _facet$measures = facet.measures,
          measures = _facet$measures === void 0 ? [] : _facet$measures,
          measuresOverlapped = facet.measuresOverlapped,
          horizontal = facet.horizontal,
          hasMeasure = facet.hasMeasure;
      var secondDefName = getSharedAxisName(horizontal, false);
      var secondAxis = measuresOverlapped && measures[0] && measures[0].length ? defs[secondDefName].size : 0;
      var validMeasures = measuresOverlapped ? [getSharedAxisName(horizontal, true), secondDefName] : measures;
      var x = actualBounds.x,
          y = actualBounds.y,
          width = actualBounds.width,
          height = actualBounds.height;
      var keyPoints = {};
      var min = horizontal ? y - secondAxis : x + width + secondAxis,
          max = horizontal ? y + height : x,
          compare = horizontal ? Math.max : Math.min,
          xKey = horizontal ? 'x' : 'y',
          yKey = horizontal ? 'y' : 'x';

      var dealKeyPoints = function dealKeyPoints(bounds) {
        keyPoints[bounds[xKey]] = keyPoints[bounds[xKey]] || max;
        keyPoints[bounds[xKey]] = compare(horizontal ? bounds.y + bounds.height : bounds.x, keyPoints[bounds[xKey]]);
      };

      _.each(nodesMap, function (node) {
        // 不存在指标时, leafNode不生成轴线
        if (node.leaf && !hasMeasure) {
          return;
        }

        if (node.leaf) {
          _.each(validMeasures, function (target, index) {
            // @BI-27121
            // Note 第一个leafNode的第一个measure不需要算轴线
            if (node.leafIndex === 0 && (measuresOverlapped || index === 0)) {
              return;
            }

            dealKeyPoints(calcMeasureTickBounds(target, index, node, facet, defs, actualBounds));
          });
        }

        if (!node.isRoot) {
          dealKeyPoints(calcDimensionTickBounds(node, facet, defs, actualBounds));
        }
      });

      var lines = [];

      _.each(keyPoints, function (max, key) {
        var line = {};
        line[xKey + '1'] = +key;
        line[yKey + '1'] = min;
        line[xKey + '2'] = +key;
        line[yKey + '2'] = max;
        lines.push(line);
      });

      return lines;
    };

    /**
     * transform option.lineStyle to ZRLineStyle for render
     * use default lineStyle when option.lineStyle is null
     * @param lineStyle
     * @returns {{stroke: string, fill: null, lineWidth: number, lineDash: *}}
     */

    var getAxisLineStyle = function getAxisLineStyle(lineStyle) {
      var _ref = lineStyle || AxisLineStyle,
          enabled = _ref.enabled,
          color = _ref.color,
          width = _ref.width,
          type = _ref.type;

      return {
        stroke: enabled ? color : 'none',
        fill: null,
        lineWidth: enabled ? width : 0,
        lineDash: type === 'dashed' ? [8, 4] : null
      };
    };

    var getBoundaryLines = function getBoundaryLines(x, y, width, height, horizontal, lineWidth) {
      var w2 = lineWidth / 2;
      var left = x,
          right = x + width,
          top = y,
          bottom = y + height;
      var lines = [];

      if (horizontal) {
        var x1 = left + w2,
            x2 = right - w2,
            y1 = top,
            y2 = bottom;
        lines = [{
          x1: x1,
          x2: x1,
          y1: y1,
          y2: y2
        }, {
          x1: x2,
          x2: x2,
          y1: y1,
          y2: y2
        }];
      } else {
        var _y = top + w2,
            _y2 = bottom - w2,
            _x = left,
            _x2 = right;

        lines = [{
          x1: _x,
          x2: _x2,
          y1: _y,
          y2: _y
        }, {
          x1: _x,
          x2: _x2,
          y1: _y2,
          y2: _y2
        }];
      }

      return lines;
    };

    var getMeasureTicksAndGridLines = function getMeasureTicksAndGridLines(props, plotBounds) {
      var _areaProp;

      var facet = props.facet,
          defs = props.defs,
          _props$facet = props.facet,
          nodesMap = _props$facet.nodesMap,
          measuresOverlapped = _props$facet.measuresOverlapped,
          measures = _props$facet.measures,
          horizontal = _props$facet.horizontal;
      var ticks = [],
          gridLines = [],
          areaProp = (_areaProp = {}, _areaProp[getSharedAxisName(horizontal, true)] = {
        rects: [],
        range: null,
        measure: true
      }, _areaProp[getSharedAxisName(horizontal, false)] = {
        rects: [],
        range: null,
        measure: true
      }, _areaProp);
      var firstMeasures, secondMeasures;

      if (measuresOverlapped) {
        firstMeasures = measures[0];
        secondMeasures = measures[1];
      }

      var measureIds = measuresOverlapped ? [getSharedAxisName(horizontal, true), getSharedAxisName(horizontal, false)] : measures;

      var tickTitleValid = function tickTitleValid(facet, def, defName) {
        var scaleMap = facet.scaleMap;
        var tickValid = def && def.tick && def.tick.enabled;
        var titleValid = def && def.title && def.title.text;
        return scaleMap && scaleMap[defName] && (tickValid || titleValid);
      };

      _.each(_.pick(nodesMap, function (node) {
        return node.leaf;
      }), function (node) {
        _.each(measureIds, function (measureId, index) {
          var measureDef = defs[measureId];
          var isRightAxis = measuresOverlapped && index === 1;
          var axisScale = getAxisScale(facet, measureId, node);

          if (axisScale && tickTitleValid(facet, measureDef, measureId)) {
            var bounds = calcMeasureTickBounds(measureId, index, node, facet, defs, plotBounds, horizontal);
            var axisIndex = measuresOverlapped ? index : 0,
                isFirstAxis = axisIndex === 0;
            var axisId = measuresOverlapped ? measureId : getSharedAxisName(horizontal, true);
            var measureAreaProp = areaProp[axisId];

            if (bounds.width && bounds.height) {
              // 聚合时取第一个字段就可以了
              var fieldId = measuresOverlapped ? (isRightAxis ? secondMeasures : firstMeasures)[0] : measureId;
              fieldId && measureAreaProp.rects.push({
                measure: true,
                bounds: bounds,
                fieldId: fieldId
              });
            }

            if (measureAreaProp.range == null) {
              var x = bounds.x,
                  y = bounds.y,
                  width = bounds.width,
                  height = bounds.height;
              measureAreaProp.range = [horizontal ? y : x, horizontal ? y + height : x + width];
            }

            ticks.push({
              measureDef: measureDef,
              bounds: bounds,
              horizontal: horizontal,
              isFirstAxis: isFirstAxis,
              id: node.id + '+' + measureId,
              measureId: measureId,
              axisScale: axisScale
            });
            gridLines.push({
              axisScale: axisScale,
              measureId: measureId
            });
          }
        });
      });

      return {
        measureTicks: ticks,
        gridLines: gridLines,
        area: areaProp
      };
    };

    function dealWithDimTickInterval(_ref) {
      var ticks = _ref.ticks,
          horizontal = _ref.horizontal,
          tickInterval = _ref.tickInterval,
          unit = _ref.unit,
          _ref$range = _ref.range,
          start = _ref$range[0],
          end = _ref$range[1];

      if (!tickInterval) {
        return;
      }

      var add = tickInterval * unit / 2;
      var len = ticks.length;
      var startKey = horizontal ? 'x' : 'y',
          sizeKey = horizontal ? 'width' : 'height';

      var truncate = function truncate(tick) {
        var bounds = tick.bounds;
        tick.truncate = true;
        tick.position = getBoundsCenter(bounds);
        tick.style && (tick.style.truncate = {
          outerWidth: bounds.width,
          outerHeight: bounds.height,
          ellipsis: ELLIPSIS
        });
      };

      if (tickInterval >= len) {
        var tick = ticks[0];

        var bounds = _extends({}, tick.bounds);

        bounds[startKey] = start;
        bounds[sizeKey] = end - start;
        tick.bounds = bounds;
        truncate(tick);
      }

      for (var i = tickInterval; i < len; i += tickInterval + 1) {
        var _tick = ticks[i];
        var left = add,
            right = left;

        if (i === tickInterval) {
          left += add;
        } else if (i === len - 1) {
          right -= add;
        } else if (i + tickInterval >= len - 1) {
          right += add;
        }

        var _bounds = _extends({}, _tick.bounds);

        _bounds[startKey] = Math.max(_bounds[startKey] - left, start + Axis.PADDING);
        _bounds[sizeKey] = Math.min(_bounds[sizeKey] + left + right, end - _bounds[startKey] - Axis.PADDING);
        _tick.bounds = _bounds;
        truncate(_tick);
      }

      _.each(ticks, function (tick) {
        return !tick.truncate && (tick.style.text = '');
      });
    }

    var getDimensionTicksList = function getDimensionTicksList(props, plotBounds) {
      var facet = props.facet,
          scaleMap = props.facet.scaleMap,
          defs = props.defs,
          _props$facet = props.facet,
          nodesMap = _props$facet.nodesMap,
          dimensions = _props$facet.dimensions,
          unit = _props$facet.unit,
          horizontal = _props$facet.horizontal; // map， 存放dim对应的ticks和旋转角度rotation

      var ticksMap = {},
          areaProp = {}; // 初始化ticksGroup

      _.each(dimensions, function (dim, i) {
        var _defs$dim = defs[dim],
            format = _defs$dim.format,
            rotation = _defs$dim.tick.rotation;
        var vertical = Math.abs(rotation) === 90;
        ticksMap[dim] = {
          ticks: [],
          tickGroup: {},
          rotation: rotation,
          format: format,
          vertical: vertical,
          leaf: i === dimensions.length - 1
        };
        areaProp[dim] = {
          rects: [],
          range: null
        }; // 横轴对应纵向，水平对应横向
      }); // 第一步，先把nodes按照维度划分到对应的ticks数组中，顺带计算dimTick对应的props


      _.each(nodesMap, function (node) {
        if (node.isRoot) {
          return;
        }

        var dim = node.dim,
            id = node.id,
            text = node.text,
            pId = node.pId,
            leafCount = node.leafCount;
        var _defs$dim$tick = defs[dim].tick,
            rotation = _defs$dim$tick.rotation,
            enableTick = _defs$dim$tick.enabled,
            style = _defs$dim$tick.style;
        var size = scaleMap[dim].size;

        if (!enableTick || size === 0) {
          return;
        }

        var bounds = calcDimensionTickBounds(node, facet, defs, plotBounds);
        var x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height;
        var areaDimProp = areaProp[dim];
        areaDimProp.rects.push({
          measure: false,
          bounds: bounds,
          leafCount: leafCount,
          fieldId: dim,
          id: id
        });
        areaDimProp.range = areaDimProp.range || (horizontal ? [y, y + height] : [x, x + width]);
        var _ticksMap$dim = ticksMap[dim],
            ticks = _ticksMap$dim.ticks,
            format = _ticksMap$dim.format,
            vertical = _ticksMap$dim.vertical,
            tickGroup = _ticksMap$dim.tickGroup;

        if (!tickGroup[pId]) {
          var _nodesMap$pId = nodesMap[pId],
              pos = _nodesMap$pId.pos,
              length = _nodesMap$pId.length;
          tickGroup[pId] = {
            ticks: [],
            range: [pos, pos + length]
          };
          tickGroup[pId].ticks.vertical = vertical;
        } // rotation = 15 是一个分水岭，需要考虑不同的显示规则


        var isRotated = Math.abs(rotation) > 15;
        var radian = toRadian(rotation);
        var tickProp; // 竖直的汉字需要特殊处理，这边用Title去绘制

        if (vertical) {
          tickProp = {
            id: id,
            bounds: bounds,
            horizontal: false,
            limit: height,
            position: [x + width / 2, y + (horizontal ? 0 : height / 2)],
            textVerticalAlign: horizontal ? 'top' : 'middle',
            titles: [{
              text: getFormattedText(text, format),
              style: style
            }]
          };
        } else {
          var textAlign = 'center',
              textVerticalAlign = 'middle',
              // 默认align都在中心位置
          px = x + width / 2,
              py = y + height / 2; // 默认中心点旋转
          // 旋转的时候根据轴方向和旋转方向重新调整旋转点和textAlign

          if (isRotated) {
            // @BI-40552: 考虑标签旋转后的偏移
            var rotateDis = style.fontSize * 0.5 * Math.abs(Math.sin(radian));

            if (horizontal) {
              py = y + Axis.PADDING + rotateDis;
              textAlign = rotation < 0 ? 'right' : 'left';
            } else {
              px = x + width - Axis.PADDING - rotateDis;
              textAlign = 'right';
            }
          }

          var truncateOuterWith = isRotated ? horizontal ? bounds.height / Math.sin(Math.abs(radian)) : bounds.width / Math.cos(Math.abs(radian)) : bounds.width;
          tickProp = {
            id: id,
            bounds: bounds,
            position: [px, py],
            rotation: -radian,
            style: _extends({}, style, {
              text: getFormattedText(text, format),
              textAlign: textAlign,
              textVerticalAlign: textVerticalAlign,
              truncate: {
                outerWidth: truncateOuterWith - Axis.PADDING * 2
              }
            })
          };
        }

        tickProp.range = [node.pos, node.pos + node.length];
        ticks.push(tickProp);
        tickGroup[pId].ticks.push(tickProp);
      });

      var ticksList = []; // 二维数组，用于存放每个dim对应的ticks

      var sortFn = function sortFn(a, b) {
        return horizontal ? a.position[0] - b.position[0] : a.position[1] - b.position[1];
      }; // 第二步，处理标签重叠，并将dimTicks拿出放到ticksList


      _.each(ticksMap, function (_ref2, dim) {
        var ticks = _ref2.ticks,
            tickGroup = _ref2.tickGroup,
            rotation = _ref2.rotation,
            vertical = _ref2.vertical;
        var style = defs[dim].tick.style;
        var rotated = Math.abs(rotation) > 15,
            radian = toRadian(rotation); // 旋转时计算间隔

        if (rotated && !(!horizontal && vertical)) {
          var fontSize = style.fontSize;
          var step = 1;
          var sinV = Math.sin(Math.abs(radian));

          _.each(ticks, function (tick) {
            var _tick$bounds = tick.bounds,
                width = _tick$bounds.width,
                height = _tick$bounds.height;
            var distance = (horizontal ? width : height) * step;
            distance * sinV < fontSize && step++;
          });

          if (step > 1) {
            ticks.sort(sortFn);

            _.each(ticks, function (tick, index) {
              if (index % step !== 0) {
                if (vertical) {
                  tick.titles = [];
                } else {
                  tick.style.text = '';
                }
              }
            });
          }

          ticks.vertical = vertical;
          ticksList.push(ticks);
        } else {
          var tickInterval = 0;

          if (Math.abs(rotation) <= 15) {
            var minWidth = style.fontSize * (horizontal ? 2 : 1);
            tickInterval = Math.ceil((minWidth + Axis.PADDING * 2) / unit - 1);
          }

          tickInterval = Math.max(tickInterval, 0);

          var dealTickInterval = function dealTickInterval(ticks, range) {
            return dealWithDimTickInterval({
              ticks: ticks,
              range: range,
              horizontal: horizontal,
              verticalText: vertical,
              rotation: rotation,
              tickInterval: tickInterval,
              unit: unit,
              style: style
            });
          };

          var isLast = dimensions.length > 0 && dim === dimensions[dimensions.length - 1];

          _.each(tickGroup, function (_ref3) {
            var ticks = _ref3.ticks,
                range = _ref3.range;

            if (isLast) {
              ticks.sort(sortFn);
              dealTickInterval(ticks, range);
            } else {
              _.each(ticks, function (tick) {
                return dealTickInterval([tick], tick.range);
              });
            }

            ticksList.push(ticks);
          });
        }
      });

      return {
        ticksList: ticksList,
        area: areaProp
      };
    };

    var getFacetViewAttrs = function getFacetViewAttrs(plotBounds, chartBounds, facet) {
      var horizontal = facet.horizontal; // 坐标轴双值轴所占用大小，0:left||bottom, 1:right||top

      var axisSize = [0, 0]; // 指标聚合时，双轴

      if (horizontal) {
        axisSize[0] = chartBounds.y + chartBounds.height - plotBounds.y - plotBounds.height;
        axisSize[1] = plotBounds.y - chartBounds.y;
      } else {
        axisSize[0] = plotBounds.x - chartBounds.x;
        axisSize[1] = chartBounds.x + chartBounds.width - plotBounds.x - plotBounds.width;
      } // totalSize: axis layout is horizontal means height while vertical means width


      var totalSize = axisSize[0] + axisSize[1];
      var pw = plotBounds.width,
          ph = plotBounds.height,
          px = plotBounds.x,
          py = plotBounds.y; // 绘图区实际显示的宽高

      var x = px - (horizontal ? 0 : axisSize[0]);
      var y = py - (horizontal ? axisSize[1] : 0);
      var width = pw + (horizontal ? 0 : totalSize);
      var height = ph + (horizontal ? totalSize : 0);
      return {
        axisSize: axisSize,
        viewBounds: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        globalRects: [// 左上
        {
          x: x,
          y: y,
          width: horizontal ? width : axisSize[0],
          height: horizontal ? axisSize[1] : height
        }, // 右下
        {
          x: x + (horizontal ? 0 : width - axisSize[1]),
          y: y + (horizontal ? height - axisSize[0] : 0),
          width: horizontal ? width : axisSize[1],
          height: horizontal ? axisSize[0] : height
        }]
      };
    };

    var Axis$1 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Axis$$1, _Component);

      function Axis$$1(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.state = {};

        _this.updateState(_this.props);

        return _this;
      }

      var _proto = Axis$$1.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.facet === this.props.facet) {
          return;
        }

        this.updateState(nextProps);
      };

      _proto.updateState = function updateState(props) {
        var defs = props.defs,
            facet = props.facet,
            _props$facet = props.facet,
            titleSize = _props$facet.titleSize,
            horizontal = _props$facet.horizontal,
            axisLineSetting = _props$facet.axisLine,
            plotBounds = props.plotBounds,
            chartBounds = props.chartBounds;
        var viewAttrs = getFacetViewAttrs(plotBounds, chartBounds, facet);
        var _viewAttrs$viewBounds = viewAttrs.viewBounds,
            x = _viewAttrs$viewBounds.x,
            y = _viewAttrs$viewBounds.y,
            width = _viewAttrs$viewBounds.width,
            height = _viewAttrs$viewBounds.height;
        var axisLineStyle = getAxisLineStyle(axisLineSetting);

        var _getMeasureTicksAndGr = getMeasureTicksAndGridLines(props, plotBounds),
            measureTicks = _getMeasureTicksAndGr.measureTicks,
            gridLines = _getMeasureTicksAndGr.gridLines,
            measureAreaProp = _getMeasureTicksAndGr.area;

        var _getDimensionTicksLis = getDimensionTicksList(props, plotBounds),
            dimensionTicksList = _getDimensionTicksLis.ticksList,
            dimAreaProp = _getDimensionTicksLis.area;

        var areaProp = _extends({}, props, {
          horizontal: horizontal,
          levels: _extends({}, dimAreaProp, measureAreaProp),
          globalRects: viewAttrs.globalRects
        });

        var areas = [].concat(measureTicks);

        _.each(dimensionTicksList, function (ticks) {
          _.each(ticks, function (tick) {
            return areas.push(_extends({}, tick, {
              dimension: true
            }));
          });
        });

        this.setState({
          viewBounds: viewAttrs.viewBounds,
          axisSize: viewAttrs.axisSize,
          title: {
            position: [x + (horizontal ? width / 2 : titleSize / 2), y + (horizontal ? height - titleSize / 2 : height / 2)],
            limit: horizontal ? width : height,
            horizontal: horizontal,
            titles: getDimensionTitles(props)
          },
          axisLineStyle: axisLineStyle,
          boundaryLines: getBoundaryLines(x, y, width, height, horizontal, axisLineStyle.lineWidth),
          axisLines: getAxisLines(defs, facet, plotBounds),
          measureTicks: measureTicks,
          gridLines: gridLines,
          dimensionTicksList: dimensionTicksList,
          areas: areas,
          areaProp: areaProp
        });
      };

      _proto.getDimensionTicks = function getDimensionTicks() {
        return this.state.dimensionTicksList;
      };

      _proto.renderScrollArea = function renderScrollArea() {
        var _this$props = this.props,
            animation = _this$props.animation,
            radarChart = _this$props.radarChart,
            isScrolling = _this$props.isScrolling,
            facet = _this$props.facet,
            plotBounds = _this$props.plotBounds;
        var _this$state = this.state,
            _this$state$viewBound = _this$state.viewBounds,
            x = _this$state$viewBound.x,
            y = _this$state$viewBound.y,
            axisLines = _this$state.axisLines,
            measureTicks = _this$state.measureTicks,
            gridLines = _this$state.gridLines,
            axisLineStyle = _this$state.axisLineStyle;
        var dimensionTicksList = this.getDimensionTicks();
        return h('group', {
          position: [-x, -y]
        }, this.renderAxisLine(axisLines, axisLineStyle), // dimension ticks
        _.map(dimensionTicksList, function (ticks) {
          return ticks.vertical ? _.map(ticks, function (tick) {
            return h(Title, _extends({}, tick, {
              isScrolling: isScrolling
            }));
          }) : renderTicks({
            ticks: ticks,
            animation: animation,
            isScrolling: isScrolling
          });
        }), // measure ticks
        _.map(measureTicks, function (tick) {
          return h(MeasureTick, _extends({
            facet: facet
          }, tick, {
            animation: animation,
            isScrolling: isScrolling
          }));
        }), // gridLines
        !radarChart && this.renderGridLines(gridLines, plotBounds));
      };

      _proto.render = function render$$1() {
        var _this$props2 = this.props,
            store = _this$props2.store,
            stampId = _this$props2.stampId,
            bigData = _this$props2.bigData,
            isMobile = _this$props2.isMobile,
            interaction = _this$props2.interaction,
            translate = _this$props2.scrollTranslate,
            scrollBounds = _this$props2.scrollBounds,
            boundaryEnabled = _this$props2.boundaryEnabled,
            horizontal = _this$props2.facet.horizontal;
        var _this$state2 = this.state,
            viewBounds = _this$state2.viewBounds,
            boundaryLines = _this$state2.boundaryLines,
            axisLineStyle = _this$state2.axisLineStyle,
            title = _this$state2.title,
            axisSize = _this$state2.axisSize;
        var x = viewBounds.x,
            y = viewBounds.y,
            width = viewBounds.width,
            height = viewBounds.height;
        var axisScrollTranslate = translate[horizontal ? 0 : 1];
        var scrollArea = h('group', {
          silent: isMobile,
          position: [x + (horizontal ? axisScrollTranslate : 0), y + (horizontal ? 0 : axisScrollTranslate)]
        }, this.renderScrollArea());
        var imageScrollArea = h(ImageAxis$1, {
          bigData: bigData,
          isMobile: isMobile,
          horizontal: horizontal,
          axisScrollTranslate: axisScrollTranslate,
          viewBounds: viewBounds,
          scrollBounds: scrollBounds,
          axisSize: axisSize,
          stampId: stampId,
          interaction: interaction,
          store: store
        });
        return h('group', {
          clip: {
            type: 'rect',
            shape: {
              x: x,
              y: y,
              width: width,
              height: height
            }
          }
        }, // for mousewheel & pan
        h('rect', {
          cursor: null,
          shape: {
            x: x,
            y: y,
            width: width,
            height: height
          },
          style: {
            fill: 'transparent'
          }
        }), bigData ? h('group') : scrollArea, imageScrollArea, // dimensionTitle
        h(Title, title), // todo, bigData need axis click too?
        // !bigData && this.renderInteractiveRects(translate[horizontal ? 0 : 1], axisLineStyle.lineWidth),
        !bigData && this.renderInteractiveRects(axisLineStyle.lineWidth), // boundaryLine, will not move when axis scroll
        boundaryEnabled && this.renderAxisLine(boundaryLines, axisLineStyle));
      } // rects for trigger hover & drag event
      ;

      _proto.renderInteractiveRects = function renderInteractiveRects(axisLineWidth) {
        var areaProp = this.state.areaProp;
        var _this$props3 = this.props,
            facet = _this$props3.facet,
            scrollTranslate = _this$props3.scrollTranslate,
            isMobile = _this$props3.isMobile;
        var horizontal = facet.horizontal;
        return h(InteractiveArea, _extends({}, areaProp, {
          touch: isMobile,
          scrollTranslate: horizontal ? scrollTranslate[0] : scrollTranslate[1],
          axisLineWidth: axisLineWidth
        }));
      } // 网格线
      ;

      _proto.renderGridLines = function renderGridLines(gridLines, actualBounds) {
        var x = actualBounds.x,
            y = actualBounds.y,
            width = actualBounds.width,
            height = actualBounds.height;
        var _this$props$facet = this.props.facet,
            scaleMap = _this$props$facet.scaleMap,
            gridLineStyle = _this$props$facet.gridLine,
            horizontal = _this$props$facet.horizontal;
        var gridLineStart = horizontal ? y : x,
            gridLineLength = horizontal ? height : width;

        var _ref = gridLineStyle || {},
            _ref$enabled = _ref.enabled,
            gridLineEnable = _ref$enabled === void 0 ? false : _ref$enabled,
            _ref$color = _ref.color,
            color = _ref$color === void 0 ? '#d0d0d0' : _ref$color,
            _ref$type = _ref.type,
            type = _ref$type === void 0 ? 'solid' : _ref$type,
            _ref$width = _ref.width,
            lineWidth = _ref$width === void 0 ? 1 : _ref$width;

        var style = {
          stroke: color,
          fill: null,
          lineWidth: lineWidth,
          lineDash: type === 'dashed' ? [8, 4] : null
        };
        return !gridLineEnable ? [] : _.map(gridLines, function (_ref2) {
          var axisScale = _ref2.axisScale,
              measureId = _ref2.measureId;
          var lineShapes = [];
          var _scaleMap$measureId = scaleMap[measureId],
              ticks = _scaleMap$measureId.ticks,
              _scaleMap$measureId$d = _scaleMap$measureId.domain,
              min = _scaleMap$measureId$d[0],
              max = _scaleMap$measureId$d[1];
          var x1, x2, y1, y2; // 网格线与标签对齐，同时等于domain[0]以及domain[1]的网格线就不需要画了

          _.each(_.filter(ticks, function (tick) {
            return tick !== min && tick !== max;
          }), function (tick) {
            x1 = y1 = gridLineStart, x2 = y2 = x1 + gridLineLength;
            var pos = axisScale(tick);
            horizontal ? x1 = x2 = pos : y1 = y2 = pos;
            lineShapes.push({
              x1: x1,
              x2: x2,
              y1: y1,
              y2: y2
            });
          }); // 数据点提示共享时的highlightBackground要在图形下面给的-1，这里网格线还要在高亮的背景下面


          return h('multiLine', {
            shape: {
              lines: lineShapes
            },
            style: style,
            z: GridLineZ,
            silent: true
          });
        });
      } // 绘制轴线
      ;

      _proto.renderAxisLine = function renderAxisLine(lines, style) {
        return h('multiLine', {
          shape: {
            lines: lines
          },
          style: style,
          silent: true,
          z: AxisLineZ
        });
      };

      return Axis$$1;
    }(Component);

    var Facet$1 =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Facet$$1, _Component);

      function Facet$$1(props, context) {
        return _Component.call(this, props, context) || this;
      }

      var _proto = Facet$$1.prototype;

      _proto.render = function render$$1() {
        var _this$props = this.props,
            facetX = _this$props.facetX,
            facetY = _this$props.facetY,
            onmousewheel = _this$props.onmousewheel,
            handlePan = _this$props.handlePan,
            isMobile = _this$props.isMobile,
            resizeLine = _this$props.resizeLine,
            handleMultipointStart = _this$props.handleMultipointStart,
            handlePinch = _this$props.handlePinch,
            handleMultipointEnd = _this$props.handleMultipointEnd,
            radarChart = _this$props.radarChart,
            interaction = _this$props.interaction;
        var boundaryEnabled = !(isEmptyFacet(facetX) && isEmptyFacet(facetY));
        return h('group', {
          onmousewheel: onmousewheel,
          ontouchstart: isMobile && interaction.axisTouchStart,
          ontouchmove: isMobile && interaction.axisTouchMove,
          ontouchend: isMobile && interaction.axisTouchEnd,
          onpanstart: isMobile && interaction.axisPanStart,
          onpan: isMobile && interaction.axisPan,
          onpanend: isMobile && interaction.axisPanEnd,
          onmultipointstart: interaction.axisMultipointStart,
          onpinch: interaction.axisPinch,
          onmultipointend: interaction.axisMultipointEnd
        }, // 横轴
        h(Axis$1, _extends({}, this.props, {
          facet: facetX,
          boundaryEnabled: boundaryEnabled,
          radarChart: radarChart
        })), // 纵轴
        h(Axis$1, _extends({}, this.props, {
          facet: facetY,
          boundaryEnabled: boundaryEnabled,
          radarChart: radarChart
        })), resizeLine && h('line', {
          z: PanningLineZ,
          silent: true,
          shape: resizeLine,
          style: {
            lineDash: [4, 4],
            stroke: RESIZE_LINE_COLOR,
            lineWidth: 1
          }
        }));
      };

      return Facet$$1;
    }(Component);

    var mapStateToProps = function mapStateToProps(state) {
      var _computedSelect = computedSelect(state),
          bigData = _computedSelect.bigData,
          animation = _computedSelect.animation,
          stampId = _computedSelect.stampId,
          clipBounds = _computedSelect.clipBounds,
          plotBounds = _computedSelect.plotBounds,
          chartBounds = _computedSelect.chartBounds,
          geoms = _computedSelect.geoms,
          facetX = _computedSelect.facetX,
          facetY = _computedSelect.facetY,
          defs = _computedSelect.defs,
          scrollBounds = _computedSelect.scrollBounds,
          resizeLine = _computedSelect.resizeLine,
          isMobile = _computedSelect.isMobile;

      return {
        isMobile: isMobile,
        bigData: bigData,
        animation: animation,
        stampId: stampId,
        clipBounds: clipBounds,
        plotBounds: plotBounds,
        chartBounds: chartBounds,
        scrollBounds: scrollBounds,
        facetX: facetX,
        facetY: facetY,
        defs: defs,
        scrollTranslate: [scrollBounds.x, scrollBounds.y],
        resizeLine: resizeLine,
        radarChart: geoms && geoms[0] && geoms[0].type === ChartLibrary.LINE_RADAR
      };
    };
    var Facet$2 = connect(mapStateToProps, function (dispatch) {
      return {// onpan: payload => dispatch(act.shared.axispan(payload)),
        //
        // onpanend: payload => dispatch(act.shared.axisResize(payload)),
        //
        // onmousewheel: e => dispatch(act.shared.mouseWheel(e)),
        // // 移动端
        // handlePan: e => dispatch(act.hover.pan(e)),
        //
        // // touch event as effect
        // handleMultipointStart: e => dispatch(act.hover.multipointStart(e)),
        // handlePinch: e => dispatch(act.hover.pinch(e)),
        // handleMultipointEnd: e => dispatch(act.hover.multipointEnd(e))
      };
    })(Facet$1);

    var getDom$1 = function getDom(root, width, height) {
      var dom = document.createElement('div');
      var s = dom.style;
      s.position = 'absolute';
      s.width = width + 'px';
      s.height = height + 'px';
      s.overflow = 'hidden';
      s.margin = '0';
      s.padding = '0';
      s.border = 'none';
      root.insertBefore(dom, root.firstChild);
      return dom;
    };

    var MapCell =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(MapCell, _Component);

      function MapCell(props) {
        return _Component.call(this, props) || this;
      }

      var _proto = MapCell.prototype;

      _proto.render = function render$$1() {
        var _this = this;

        var _this$props = this.props,
            _this$props$bounds = _this$props.bounds,
            x = _this$props$bounds.x,
            y = _this$props$bounds.y,
            width = _this$props$bounds.width,
            height = _this$props$bounds.height,
            geoms = _this$props.geoms,
            _this$props$mapConfig = _this$props.mapConfig,
            crs = _this$props$mapConfig.crs,
            center = _this$props$mapConfig.center,
            zoom = _this$props$mapConfig.zoom,
            shifting = _this$props.shifting;

        var c = CRS[crs],
            _c$latLngToPoint = c.latLngToPoint(center, zoom),
            cx = _c$latLngToPoint.x,
            cy = _c$latLngToPoint.y;

        var position = [x + width / 2 - cx, y + height / 2 - cy]; // GIS tileLayer

        return h(Pane, this.props, map(geoms, function (_ref) {
          var geom = _ref.geom,
              rows = _ref.rows;
          var type = geom.type;
          return h(Geom.getGeom(type, true), _extends({}, _this.props, geom, {
            isMap: true,
            shifting: mergeShifting(shifting, position),
            rows: rows,
            bounds: {
              x: cx - width / 2,
              y: cy - height / 2,
              width: width,
              height: height
            }
          }));
        }));
      };

      return MapCell;
    }(Component);

    /**
     * 扫描式渐变clip, 按照clip显示SweepGradient
     * @param key
     * @param radius  半径
     * @param style  样式
     * @param palette  渐变画布 canvasElement
     * @param clip 裁剪元素
     * @param other
     */

    function clipSweepGradient(_ref) {
      var radius = _ref.radius,
          clip = _ref.clip,
          palette = _ref.palette,
          style = _ref.style,
          other = _objectWithoutPropertiesLoose(_ref, ["radius", "clip", "palette", "style"]);

      return h('image', _extends({}, other, {
        clip: clip,
        style: _extends({}, style, {
          x: -radius,
          y: -radius,
          width: radius * 2,
          height: radius * 2,
          image: palette
        })
      }));
    }

    /**
     * 圆环扫描式渐变，类似Android中的SweepGradient
     */
    var PI$8 = Math.PI;
    var DOUBLE_PI = PI$8 * 2;
    function SweepGradient(type) {
      if (type === void 0) {
        type = 'continuous';
      }

      var _radius = 100,
          total = 360;
      var _startAngle = 0,
          _endAngle = DOUBLE_PI;
      var _clockwise = true;
      var _corner = 0;
      var totalAngle = 0;
      var canvas = createCanvas$1();
      resize();

      function drawArc(ctx, sa, ea, color, isLast) {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, _radius, sa, ea, !_clockwise);
        ctx.closePath();
        ctx.strokeStyle = color;
        !isLast && ctx.stroke(); // 😔😔😔😔😔

        ctx.fillStyle = color;
        ctx.fill();
      }
      /**
       * 连续渐变
       * @param colors  [{color, percent}]
       * @returns {HTMLCanvasElement} canvas画布元素
       */


      function continuous(colors) {
        var scale = colorScale(colors);
        var angle = totalAngle / total * (_clockwise ? 1 : -1);
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, _radius * 2, _radius * 2);
        ctx.save();
        ctx.translate(_radius, _radius); // 考虑外接圆角圆弧渐变

        if (_corner > 0) {
          var c1 = colors[0],
              c2 = colors[colors.length - 1];

          var _angle = _corner * (_clockwise ? 1 : -1);

          drawArc(ctx, _startAngle - _angle, _startAngle, c1.color, false);
          drawArc(ctx, _endAngle, _endAngle + _angle, c2.color, false);
        }

        for (var i = 0; i < total; i++) {
          var percent = i / total,
              sa = toRadian(percent),
              color = scale(percent);
          drawArc(ctx, sa, sa + angle, color, i === total - 1);
        }

        ctx.restore();
        return canvas;
      }
      /**
       * 区域渐变
       * @param colors [{color, from, to}]
       * @returns {HTMLCanvasElement}  canvas画布元素
       */


      function interval(colors) {
        var len = colors.length;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, _radius * 2, _radius * 2);
        ctx.save();
        ctx.translate(_radius, _radius); // 考虑外接圆角圆弧渐变

        if (_corner > 0) {
          var c1 = colors[0],
              c2 = colors[colors.length - 1];
          var angle = _corner * (_clockwise ? 1 : -1);
          var s1 = toRadian(c1.from),
              s2 = toRadian(c2.to);
          drawArc(ctx, s1 - angle, s1, c1.color, false);
          drawArc(ctx, s2, s2 + angle, c2.color, false);
        }

        for (var i = 0; i < len; i++) {
          var color = colors[i],
              from = color.from,
              to = color.to;

          var _angle2 = Math.abs(from - to) * totalAngle * (_clockwise ? 1 : -1);

          var sa = toRadian(from);
          drawArc(ctx, sa, sa + _angle2, color.color, i === len - 1);
        }

        ctx.restore();
        return canvas;
      }

      function toRadian(percent) {
        var angle = percent * totalAngle * (_clockwise ? 1 : -1);
        return _startAngle + angle;
      }

      function resize() {
        canvas.width = canvas.height = _radius * 2;
      }

      var gradient = {
        // 设置渐变半径
        radius: function radius(r) {
          r && (_radius = r);
          resize();
          return gradient;
        },
        // 设置数量，越大则画的越细
        amount: function amount(t) {
          t && (total = t);
          return gradient;
        },
        // 设置起始角度
        startAngle: function startAngle(sa) {
          sa != null && (_startAngle = sa);
          return gradient;
        },
        // 设置结束角度
        endAngle: function endAngle(ea) {
          ea != null && (_endAngle = ea);
          return gradient;
        },
        // 设置绘制方向为是否为顺时针
        clockwise: function clockwise(c) {
          c != null && (_clockwise = c);
          return gradient;
        },
        // 创建渐变，返回HtmlCanvasElement
        create: function create(colors) {
          totalAngle = Math.abs(_startAngle - _endAngle);
          return (type === 'continuous' ? continuous : interval)(colors);
        },
        // 考虑两段存在圆角时额外的颜色
        corner: function corner(c) {
          _corner = Math.abs(c);
          return gradient;
        }
      };
      return gradient;
    }
    /**
     * 颜色比例尺
     * @param colors [{color, value}]
     * @returns {*}
     */

    function colorScale(colors) {
      var range = map(colors, function (color) {
        return color.color;
      });
      var domain = map(colors, function (color) {
        return color.value;
      });
      return scaleColor(domain, range);
    }

    /**
     * 矩形
     * @module zrender/graphic/shape/Rect
     */
    Path.extend({
      type: 'rect',
      shape: {
        // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
        // r缩写为1         相当于 [1, 1, 1, 1]
        // r缩写为[1]       相当于 [1, 1, 1, 1]
        // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
        // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
        r: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function buildPath$$1(ctx, shape) {
        var x = shape.x;
        var y = shape.y;
        var width = shape.width;
        var height = shape.height;

        if (!shape.r) {
          ctx.rect(x, y, width, height);
        } else {
          buildPath(ctx, shape);
        }

        ctx.closePath();
        return;
      }
    });

    /**
     * 椭圆形状
     * @module zrender/graphic/shape/Ellipse
     */
    Path.extend({
      type: 'ellipse',
      shape: {
        cx: 0,
        cy: 0,
        rx: 0,
        ry: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var k = 0.5522848;
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.rx;
        var b = shape.ry;
        var ox = a * k; // 水平控制点偏移量

        var oy = b * k; // 垂直控制点偏移量
        // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线

        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
      }
    });

    // CompoundPath to improve performance
    Path.extend({
      type: 'compound',
      shape: {
        paths: null
      },
      _updatePathDirty: function _updatePathDirty() {
        var dirtyPath = this.__dirtyPath;
        var paths = this.shape.paths;

        for (var i = 0; i < paths.length; i++) {
          // Mark as dirty if any subpath is dirty
          dirtyPath = dirtyPath || paths[i].__dirtyPath;
        }

        this.__dirtyPath = dirtyPath;
        this.__dirty = this.__dirty || dirtyPath;
      },
      beforeBrush: function beforeBrush() {
        this._updatePathDirty();

        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale(); // Update path scale

        for (var i = 0; i < paths.length; i++) {
          if (!paths[i].path) {
            paths[i].createPathProxy();
          }

          paths[i].path.setScale(scale[0], scale[1]);
        }
      },
      buildPath: function buildPath(ctx, shape) {
        var paths = shape.paths || [];

        for (var i = 0; i < paths.length; i++) {
          paths[i].buildPath(ctx, paths[i].shape, true);
        }
      },
      afterBrush: function afterBrush() {
        var paths = this.shape.paths || [];

        for (var i = 0; i < paths.length; i++) {
          paths[i].__dirtyPath = false;
        }
      },
      getBoundingRect: function getBoundingRect() {
        this._updatePathDirty();

        return Path.prototype.getBoundingRect.call(this);
      }
    });

    /**
     * Displayable for incremental rendering. It will be rendered in a separate layer
     * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`
     * addDisplayables will render the added displayables incremetally.
     *
     * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.
     */

    function IncrementalDisplayble(opts) {
      Displayable.call(this, opts);
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.notClear = true;
    }

    IncrementalDisplayble.prototype.incremental = true;

    IncrementalDisplayble.prototype.clearDisplaybles = function () {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.dirty();
      this.notClear = false;
    };

    IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }

      this.dirty();
    };

    IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
      notPersistent = notPersistent || false;

      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };

    IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };

    IncrementalDisplayble.prototype.update = function () {
      this.updateTransform();

      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i]; // PENDING

        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i]; // PENDING

        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };

    IncrementalDisplayble.prototype.brush = function (ctx, prevEl) {
      // Render persistant displayables.
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }

      this._cursor = i; // Render temporary displayables.

      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }

      this._temporaryDisplayables = [];
      this.notClear = true;
    };

    var m = [];

    IncrementalDisplayble.prototype.getBoundingRect = function () {
      if (!this._rect) {
        var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);

        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();

          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }

          rect.union(childRect);
        }

        this._rect = rect;
      }

      return this._rect;
    };

    IncrementalDisplayble.prototype.contain = function (x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();

      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];

          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }

      return false;
    };

    inherits(IncrementalDisplayble, Displayable);

    /**
     * 贝塞尔曲线
     * @module zrender/shape/BezierCurve
     */
    var out$1 = [];

    function someVectorAt(shape, t, isTangent) {
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;

      if (cpx2 === null || cpy2 === null) {
        return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
      } else {
        return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
      }
    }

    Path.extend({
      type: 'bezier-curve',
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        // cpx2: 0,
        // cpy2: 0
        // Curve show percent, for animating
        percent: 1
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;

        if (percent === 0) {
          return;
        }

        ctx.moveTo(x1, y1);

        if (cpx2 == null || cpy2 == null) {
          if (percent < 1) {
            quadraticSubdivide(x1, cpx1, x2, percent, out$1);
            cpx1 = out$1[1];
            x2 = out$1[2];
            quadraticSubdivide(y1, cpy1, y2, percent, out$1);
            cpy1 = out$1[1];
            y2 = out$1[2];
          }

          ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        } else {
          if (percent < 1) {
            cubicSubdivide(x1, cpx1, cpx2, x2, percent, out$1);
            cpx1 = out$1[1];
            cpx2 = out$1[2];
            x2 = out$1[3];
            cubicSubdivide(y1, cpy1, cpy2, y2, percent, out$1);
            cpy1 = out$1[1];
            cpy2 = out$1[2];
            y2 = out$1[3];
          }

          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
      },

      /**
       * Get point at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      pointAt: function pointAt(t) {
        return someVectorAt(this.shape, t, false);
      },

      /**
       * Get tangent at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      tangentAt: function tangentAt(t) {
        var p = someVectorAt(this.shape, t, true);
        return normalize(p, p);
      }
    });

    /**
     * 水滴形状
     * @module zrender/graphic/shape/Droplet
     */
    Path.extend({
      type: 'droplet',
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.width;
        var b = shape.height;
        ctx.moveTo(x, y + a);
        ctx.bezierCurveTo(x + a, y + a, x + a * 3 / 2, y - a / 3, x, y - b);
        ctx.bezierCurveTo(x - a * 3 / 2, y - a / 3, x - a, y + a, x, y + a);
        ctx.closePath();
      }
    });

    /**
     * 正多边形
     * @module zrender/shape/Isogon
     */
    var PI$9 = Math.PI;
    var sin$4 = Math.sin;
    var cos$4 = Math.cos;
    Path.extend({
      type: 'isogon',
      shape: {
        x: 0,
        y: 0,
        r: 0,
        n: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var n = shape.n;

        if (!n || n < 2) {
          return;
        }

        var x = shape.x;
        var y = shape.y;
        var r = shape.r;
        var dStep = 2 * PI$9 / n;
        var deg = -PI$9 / 2;
        ctx.moveTo(x + r * cos$4(deg), y + r * sin$4(deg));

        for (var i = 0, end = n - 1; i < end; i++) {
          deg += dStep;
          ctx.lineTo(x + r * cos$4(deg), y + r * sin$4(deg));
        }

        ctx.closePath();
        return;
      }
    });

    /**
     * 圆环
     * @module zrender/graphic/shape/Ring
     */
    Path.extend({
      type: 'ring',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0
      },
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
      }
    });

    /**
     * 玫瑰线
     * @module zrender/graphic/shape/Rose
     */
    var sin$5 = Math.sin;
    var cos$5 = Math.cos;
    var radian = Math.PI / 180;
    Path.extend({
      type: 'rose',
      shape: {
        cx: 0,
        cy: 0,
        r: [],
        k: 0,
        n: 1
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var x;
        var y;
        var R = shape.r;
        var r;
        var k = shape.k;
        var n = shape.n;
        var x0 = shape.cx;
        var y0 = shape.cy;
        ctx.moveTo(x0, y0);

        for (var i = 0, len = R.length; i < len; i++) {
          r = R[i];

          for (var j = 0; j <= 360 * n; j++) {
            x = r * sin$5(k / n * j % 360 * radian) * cos$5(j * radian) + x0;
            y = r * sin$5(k / n * j % 360 * radian) * sin$5(j * radian) + y0;
            ctx.lineTo(x, y);
          }
        }
      }
    });

    /**
     * 扇形
     * @module zrender/graphic/shape/Sector
     */
    Path.extend({
      type: 'sector',
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function buildPath(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
        ctx.lineTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);

        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }

        ctx.closePath();
      }
    });

    /**
     * 内外旋轮曲线
     * @module zrender/graphic/shape/Trochold
     */
    var cos$6 = Math.cos;
    var sin$6 = Math.sin;
    Path.extend({
      type: 'trochoid',
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0,
        d: 0,
        location: 'out'
      },
      style: {
        stroke: '#000',
        fill: null
      },
      buildPath: function buildPath(ctx, shape) {
        var x1;
        var y1;
        var x2;
        var y2;
        var R = shape.r;
        var r = shape.r0;
        var d = shape.d;
        var offsetX = shape.cx;
        var offsetY = shape.cy;
        var delta = shape.location === 'out' ? 1 : -1;

        if (shape.location && R <= r) {
          return;
        }

        var num = 0;
        var i = 1;
        var theta;
        x1 = (R + delta * r) * cos$6(0) - delta * d * cos$6(0) + offsetX;
        y1 = (R + delta * r) * sin$6(0) - d * sin$6(0) + offsetY;
        ctx.moveTo(x1, y1); // 计算结束时的i

        do {
          num++;
        } while (r * num % (R + delta * r) !== 0);

        do {
          theta = Math.PI / 180 * i;
          x2 = (R + delta * r) * cos$6(theta) - delta * d * cos$6((R / r + delta) * theta) + offsetX;
          y2 = (R + delta * r) * sin$6(theta) - d * sin$6((R / r + delta) * theta) + offsetY;
          ctx.lineTo(x2, y2);
          i++;
        } while (i <= r * num / (R + delta * r) * 360);
      }
    });

    /**
     * Do not mount those modules on 'src/zrender' for better tree shaking.
     */

    /**
     * 普通的单向的折线或面积图渐变色创建方法
     * @param data 线或者面积的数据点集合
     * @param isHorizontal   水平或者竖直
     * @returns {LinearGradient}
     */

    function createNormalGradient(data, isHorizontal) {
      if (isHorizontal === void 0) {
        isHorizontal = true;
      }

      if (!data.length) {
        return;
      }

      if (data.length === 1) {
        return data[0].color;
      }

      var x = 0,
          y = 0,
          x2 = 0,
          y2 = 0;

      var _minMax = minMax(map(data, function (d) {
        return isHorizontal ? d.x : d.y;
      })),
          min$$1 = _minMax[0],
          max$$1 = _minMax[1],
          total = max$$1 - min$$1;

      var percentValue = function percentValue(v) {
        return (v - min$$1) / total;
      };

      if (isHorizontal) {
        x2 = 1;
      } else {
        y = 1;
        y2 = 0;
      }

      var gradient = new LinearGradient(x, y, x2, y2);
      forEach(data, function (_ref) {
        var color$$1 = _ref.color,
            x = _ref.x,
            y = _ref.y,
            _ref$opacity = _ref.opacity,
            opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;
        gradient.addColorStop(percentValue(isHorizontal ? x : y), modifyAlpha(color$$1, opacity));
      });
      return gradient;
    }
    /**
     * 考虑到VarLine的走向很随意，这里通过计算连点直接的斜率来确定创建LinearGradient的 x,y, x2,y2
     * 使得渐变色的走向和线的走向保持一致
     * @param x1 p1.x
     * @param y1 p1.y
     * @param x2 p2.x
     * @param y2 p2.y
     * @param c1 p1.color
     * @param c2 p2.color
     * @returns {LinearGradient}
     */

    function createVarLineGradient(_ref2) {
      var x1 = _ref2.x1,
          y1 = _ref2.y1,
          x2 = _ref2.x2,
          y2 = _ref2.y2,
          c1 = _ref2.c1,
          c2 = _ref2.c2;
      var x = 0,
          y = 0,
          _x = 0,
          _y = 0;
      var k = (y2 - y1) / (x2 - x1) || 0; // 注意这里的y轴和直角坐标系的y轴是相反的

      if (k > 0) {
        if (x2 > x1) {
          _x = k > 1 ? 1 / k : 1;
          _y = k > 1 ? 1 : 1 - k;
        } else {
          x = y = 1;
          _x = k > 1 ? 1 - 1 / k : 0;
          _y = k > 1 ? 0 : 1 - k;
        }
      } else {
        if (x2 > x1) {
          y = 1;
          _x = k < -1 ? -1 / k : 1;
          _y = k < -1 ? 0 : 1 - k;
        } else {
          x = 1;
          _x = k < -1 ? 1 - 1 / k : 0;
          _y = k < -1 ? 1 : 1 - k;
        }
      }

      var gradient = new LinearGradient(x, y, _x, _y);
      gradient.addColorStop(0, c1);
      gradient.addColorStop(1, c2);
      return gradient;
    }
    var MAX_MARKER_RADIUS = 22.5;
    var MIN_MARKER_RADIUS = 4.5;
    var MAX_LINE_WIDTH = 35;
    var MIN_LINE_WIDTH = 0.5;
    var MARKER_STROKE_WIDTH = 2;
    var MARKER_SYMBOL = 'circle'; // default marker symbol

    var H_MARKER_ENLARGE_SIZE = 2; // hover: radius += 2

    var getMarkerRadiusByLineWidth = function getMarkerRadiusByLineWidth(size) {
      return (size - MIN_LINE_WIDTH) * (MAX_MARKER_RADIUS - MIN_MARKER_RADIUS) / (MAX_LINE_WIDTH - MIN_LINE_WIDTH) + MIN_MARKER_RADIUS;
    };
    var getLineEffectPoints = function getLineEffectPoints(points) {
      var duration = 0,
          min$$1 = points.length - 1,
          max$$1 = 0;

      _.map(points, function (p, i) {
        if (p.effect) {
          duration = Math.max(p.effect, duration);
          min$$1 = Math.min(min$$1, i);
          max$$1 = Math.max(i, max$$1);
        }
      });

      return [min$$1 >= max$$1 ? null : [min$$1, max$$1], duration];
    };
    /**
     * Note 不同的走向时候需要判断是否为置先，直线需要
     * @param points
     * @param horizontal
     */

    function isStraightLine(points, horizontal) {
      var key = horizontal ? 'x' : 'y';
      var first = points[0][key];

      for (var i = 1, len$$1 = points.length - 1; i < len$$1; i++) {
        if (points[i][key] !== first) {
          return false;
        }
      }

      return true;
    }

    function renderVarLine(_ref) {
      var id = _ref.id,
          points = _ref.points,
          handleBandOn = _ref.handleBandOn,
          onmouseout = _ref.onmouseout,
          style = _ref.style,
          isHovered = _ref.isHovered,
          opacity = _ref.opacity,
          gradual = _ref.gradual;

      var getVarLineProps = function getVarLineProps(p1, p2) {
        var x1 = p1.x,
            y1 = p1.y,
            c1 = p1.color,
            w1 = p1.size,
            x2 = p2.x,
            y2 = p2.y,
            c2 = p2.color,
            w2 = p2.size;
        var fill = c1 === c2 ? c1 : createVarLineGradient({
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          c1: c1,
          c2: c2
        });
        return {
          fill: fill,
          shape: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            w1: w1,
            w2: w2,
            style: style
          }
        };
      };

      var varLines = [],
          len = points.length;

      for (var i = 0; i < len - 1; i++) {
        var _getVarLineProps = getVarLineProps(points[i], points[i + 1]),
            shape = _getVarLineProps.shape,
            fill = _getVarLineProps.fill;

        varLines.push(h('varLine', {
          id: id,
          shape: shape,
          onmouseover: handleBandOn,
          onmousemove: handleBandOn,
          onmouseout: onmouseout,
          z: isHovered ? HoverLayerZ : NormalLayerZ,
          style: {
            fill: fill,
            stroke: 'none',
            opacity: opacity,
            blend: gradual ? 'lighter' : 'source-over'
          }
        }));
      }

      return varLines;
    }

    var ENTER_TIME = 1200;
    var MARKER_ENTER_TIME = 300;
    var MARKER_ENTER_FRAMES = {
      scale: [{
        frame: MARKER_ENTER_TIME / 2,
        value: [1.5, 1.5]
      }, {
        frame: MARKER_ENTER_TIME,
        value: [1, 1]
      }]
    };
    var Timing$2 = {
      INIT: function INIT$$1(pct) {
        return {
          delay: pct * (ENTER_TIME - MARKER_ENTER_TIME),
          ease: Ease.Swing,
          frames: MARKER_ENTER_FRAMES,
          appear: function appear() {
            return {
              scale: [0, 0]
            };
          }
        };
      },
      SHOW_ENTER: {
        ease: Ease.Swing,
        frames: MARKER_ENTER_FRAMES,
        appear: function appear() {
          return {
            scale: [0, 0]
          };
        }
      },
      HOVER: {
        duration: 300,
        ease: Ease.Ease
      },
      SHOW_UPDATE: {
        duration: 250,
        ease: Ease.Default
      },
      HIDE_UPDATE: {
        duration: 250,
        ease: Ease.Default
      },
      HIDE_LEAVE: {
        duration: 300,
        ease: Ease.Swing
      }
    };

    var MIN_KELP_WIDTH = 2;
    var getTransitionProps$2 = getGeomTransitionProps(Timing$2);
    function createLineBand(proto) {
      var LineBand =
      /*#__PURE__*/
      function (_Component) {
        _inheritsLoose(LineBand, _Component);

        function LineBand(props, context) {
          var _this;

          _this = _Component.call(this, props, context) || this;
          _this.isArea = proto.type === ChartLibrary.AREA;
          _this.isLineRadar = proto.type === ChartLibrary.LINE_RADAR;

          _this.updateState(props);

          return _this;
        }

        var _proto = LineBand.prototype;

        _proto.componentWillReceiveProps = function componentWillReceiveProps(next) {
          this.updateState(next);
        };

        _proto.updateState = function updateState(props) {
          var _this2 = this;

          var rows = props.rows;
          var nextNodeHash = {};
          var preData = this._nodeHash ? {} : null;

          _.each(rows, function (row) {
            var id = row.id;

            if (_this2._nodeHash) {
              preData[id] = _this2._nodeHash[id] || row; // 我们在这里diff一遍, nodeGroup那边得lastData就可以不用了
            }

            nextNodeHash[id] = row;
          });

          this._nodeHash = nextNodeHash;
          this.setState({
            preData: preData
          });
        };

        _proto.render = function render$$1(props) {
          var _this3 = this;

          var highlights = props.highlights,
              fadeChecker = props.fadeChecker,
              vanishChecker = props.vanishChecker,
              process = props.process,
              handleMarkerOn = props.handleMarkerOn,
              handleMarkerClick = props.handleMarkerClick,
              handleMouseOut = props.handleMouseOut,
              rows = props.rows,
              sameSize = props.sameSize,
              bigData = props.bigData,
              animation = props.animation,
              defaultOpacity = props.opacity;
          var preData = this.state.preData;
          return h(NodeGroup$$2, {
            data: rows,
            vanishChecker: vanishChecker,
            fadeChecker: fadeChecker,
            highlights: highlights,
            process: process
          }, function (nodes, clean) {
            var points = [],
                lastPoints = [],
                len = rows.length;
            var lineHovered = false;

            _.each(nodes, function (node) {
              var row = node.data,
                  condition = node.condition;
              var color = row.color,
                  size = row.size,
                  id = row.id,
                  x = row.x,
                  y = row.y;
              var hovered = false,
                  opacity = defaultOpacity;

              if (preData) {
                lastPoints.push(preData[id]); // for band animation
              }

              if (highlights[id]) {
                lineHovered = hovered = true;
              } else if (condition === FADE) {
                color = Fade.Fill;
                opacity = Fade.Opacity;
              }

              var point = _extends({}, row, {
                color: color,
                size: sameSize ? size : Math.max(size, MIN_KELP_WIDTH),
                hovered: hovered,
                opacity: opacity,
                x: x,
                y: y
              });

              points.push(point);
            });

            var graphics = bigData ? null : _.map(nodes, function (node, index) {
              return _this3.renderGraphics({
                animation: animation,
                node: node,
                point: points[index],
                pct: index / (len - 1),
                clean: clean,
                lineHovered: lineHovered
              });
            });

            var _getLineEffectPoints = getLineEffectPoints(points),
                effectStops = _getLineEffectPoints[0],
                duration = _getLineEffectPoints[1];

            return h('group', {
              onmouseover: handleMarkerOn,
              onmousemove: handleMarkerOn,
              onclick: handleMarkerClick,
              onmouseout: handleMouseOut
            }, points.length > 1 && _this3.renderBand(points, lineHovered, !!effectStops, bigData, lastPoints), effectStops && _this3.renderEffectBand(points, effectStops, duration), graphics);
          });
        } // 绘制线或者面积
        ;

        _proto.renderBand = function renderBand() {
          return null;
        } // 绘制闪烁流向
        ;

        _proto.renderEffectBand = function renderEffectBand() {
          return null;
        } // 绘制标记点即数据点标签等等
        ;

        _proto.renderGraphics = function renderGraphics(_ref) {
          var animation = _ref.animation,
              node = _ref.node,
              point = _ref.point,
              pct = _ref.pct,
              clean = _ref.clean,
              lineHovered = _ref.lineHovered;
          var _this$props = this.props,
              borderColor = _this$props.borderColor,
              dataLabel = _this$props.dataLabel,
              bounds = _this$props.bounds,
              process = _this$props.process,
              lineId = _this$props.lineId,
              marker = _this$props.marker;
          var transitionProps = animation ? getTransitionProps$2(node, process, clean) : {};
          var _transition = transitionProps.transition,
              transitionEnd = transitionProps.transitionEnd,
              isFade = transitionProps.isFade,
              isHover = transitionProps.isHover;
          var x = point.x,
              y = point.y,
              size = point.size,
              id = point.id,
              color = point.color,
              labelPos = point.labelPos,
              fake = point.fake,
              opacity = point.opacity,
              vanish = point.vanish,
              hovered = point.hovered;
          var transition = _transition;
          var markerVisible = fake ? false : this.isArea ? hovered : marker;

          if (animation && process === INIT && !this.isLineRadar) {
            transition = Timing$2.INIT(pct);
          }

          if (isFade) color = Fade.Fill;
          if (vanish) size = 0;
          var markerNode = renderMarker({
            key: id,
            id: id,
            x: x,
            y: y,
            color: color,
            transition: transition,
            transitionEnd: transitionEnd,
            invisible: !markerVisible,
            symbol: MARKER_SYMBOL,
            radius: getMarkerRadiusByLineWidth(size) + (isHover ? H_MARKER_ENLARGE_SIZE : 0),
            lineId: lineId,
            z: lineHovered ? HoverLayerZ : 0,
            // above the band
            lineWidth: MARKER_STROKE_WIDTH,
            silent: isFade,
            stroke: borderColor
          });

          if (vanish) {
            return markerNode;
          }

          var refer = {
            node: node,
            process: process,
            isFade: isFade,
            transition: transition,
            row: point
          };
          var dataLabelNode = renderDataLabel$$1(_extends({}, refer, {
            dataLabel: dataLabel,
            opacity: opacity,
            position: labelPos ? [].concat(labelPos) : null,
            applyTheme: true
          }));
          var annotation = renderAnnotation(_extends({}, refer, {
            startPos: [x, y],
            cellBounds: bounds
          }));
          return [markerNode, dataLabelNode, annotation];
        };

        return LineBand;
      }(Component);

      _.each(proto, function (v, k) {
        if (typeof v === 'function') {
          LineBand.prototype[k] = v;
        }
      });

      return LineBand;
    }

    var MAX_STROKE_WIDTH = 2; // 超过2px，stroke的连线拐角处就会出现尖尖角，这是不能被接受的

    var useStroke = function useStroke(points, sameSize, style) {
      return sameSize && points.length && (points[0].size < MAX_STROKE_WIDTH || style !== LineStyle.NORMAL);
    };
    var EFFECT_LINE_OPACITY_RATIO = 0.2;
    var Line$1 = createLineBand({
      renderBand: function renderBand(linePoints, lineHovered, effectValid, bigData, lastPoints) {
        if (linePoints.length < 2) {
          return null;
        }

        var _this$props = this.props,
            horizontal = _this$props.horizontal,
            isVarLine = _this$props.isVarLine,
            opacity = _this$props.opacity,
            lineId = _this$props.lineId;
        var renderFn = isVarLine && !bigData ? renderVarLine : renderKelpLine;
        return renderFn(_extends({}, this.props, {
          opacity: opacity * (effectValid ? EFFECT_LINE_OPACITY_RATIO : 1),
          key: lineId,
          id: lineId,
          points: linePoints,
          horizontal: horizontal,
          isHovered: lineHovered,
          lastPoints: lastPoints
        }));
      },
      renderEffectBand: function renderEffectBand(points, effectStops, duration) {
        var _this$props2 = this.props,
            style = _this$props2.style,
            horizontal = _this$props2.horizontal,
            sameSize = _this$props2.sameSize,
            isVarLine = _this$props2.isVarLine;
        return renderLineEffect({
          points: points,
          effectStops: effectStops,
          duration: duration,
          style: style,
          horizontal: horizontal,
          stroke: useStroke(points, sameSize, style),
          opacity: 1,
          isVarLine: isVarLine
        });
      }
    });

    var FAKE_POINT = 2.5; // 预测的点

    var FAKE_REGION = 10; // 预测的区间

    var FAKE_LINE_WIDTH = 2; // @BI-30750: 预测线改为2px虚线，没有大小映射了

    var FAKE = 'fake';
    var REGION = 'region';
    var formatPoints = function formatPoints(points, isArea) {
      return _.map(points, function (p) {
        return [p.x, p.y, isArea ? p.y0 : Math.max(p.size, MIN_KELP_WIDTH)];
      });
    };
    var getBandTransition = function getBandTransition(lastPoints, isArea) {
      return lastPoints.length ? _extends({}, Timing$2.SHOW_UPDATE, {
        forceAppear: true,
        appear: function appear() {
          return {
            shape: {
              points: formatPoints(lastPoints, isArea)
            }
          };
        }
      }) : null;
    }; // 过滤出数据挖掘相关的数据点

    var filterFakePoints = function filterFakePoints(points, lastPoints, horizontal, isLine) {
      var normalPoints = [],
          normalLastPoints = [],
          predictedPoints = [],
          predictedLastPoints = [],
          deviationPoints = [],
          deviationLastPoints = [];
      var update = !!lastPoints.length;
      var key = horizontal ? 'y' : 'x';

      _.each(points, function (point, index) {
        var lastPoint = lastPoints[index] || {};
        var y = point.y,
            fake = point.fake,
            _point$upper = point.upper,
            upper = _point$upper === void 0 ? y : _point$upper,
            _point$lower = point.lower,
            lower = _point$lower === void 0 ? y : _point$lower;
        var ly = lastPoint.y,
            _lastPoint$upper = lastPoint.upper,
            lUpper = _lastPoint$upper === void 0 ? ly : _lastPoint$upper,
            _lastPoint$lower = lastPoint.lower,
            lLower = _lastPoint$lower === void 0 ? ly : _lastPoint$lower;

        if (fake) {
          var _extends2, _extends3;

          predictedPoints.push(isLine ? _extends({}, point, {
            size: FAKE_LINE_WIDTH
          }) : point);
          update && predictedLastPoints.push(isLine ? _extends({}, lastPoint, {
            size: FAKE_LINE_WIDTH
          }) : lastPoint);
          deviationPoints.push(_extends({}, point, (_extends2 = {}, _extends2[key] = upper, _extends2.y0 = lower, _extends2)));
          update && deviationLastPoints.push(_extends({}, lastPoint, (_extends3 = {}, _extends3[key] = lUpper, _extends3.y0 = lLower, _extends3)));
        } else {
          normalPoints.push(point);
          update && normalLastPoints.push(lastPoint);
        }
      });

      if (predictedPoints.length && normalPoints.length) {
        var lastIndex = normalPoints.length - 1,
            lastNormalPoint = normalPoints[lastIndex],
            lastNormalLastPoint = normalLastPoints[lastIndex];
        predictedPoints.unshift(lastNormalPoint);
        update && predictedLastPoints.unshift(lastNormalLastPoint);
        deviationPoints.unshift(_extends({}, lastNormalPoint, {
          y0: lastNormalPoint[key]
        }));
        update && deviationLastPoints.unshift(_extends({}, lastNormalLastPoint, {
          y0: lastNormalLastPoint[key]
        }));
      }

      return {
        normalPoints: normalPoints,
        normalLastPoints: normalLastPoints,
        predictedPoints: predictedPoints,
        predictedLastPoints: predictedLastPoints,
        deviationPoints: deviationPoints,
        deviationLastPoints: deviationLastPoints
      };
    };

    var getKelpLineVNode = function getKelpLineVNode(_ref) {
      var id = _ref.id,
          style = _ref.style,
          points = _ref.points,
          horizontal = _ref.horizontal,
          handleBandOn = _ref.handleBandOn,
          handleBandClick = _ref.handleBandClick,
          handleMouseOut = _ref.handleMouseOut,
          isHovered = _ref.isHovered,
          sameColor = _ref.sameColor,
          sameSize = _ref.sameSize,
          opacity = _ref.opacity,
          fake = _ref.fake,
          fill = _ref.fill,
          gradual = _ref.gradual,
          lastPoints = _ref.lastPoints;

      if (!points.length) {
        return null;
      }

      var size = points[0].size;
      var isFakePoints = fake === FAKE_POINT; // Note 用stroke的原因是减少了很多计算，但是在一些特殊的情况下，比如线很细或者比较紧凑的折线，可能会出现尖角问题，这种情况下还是按照kelpLine的逻辑计算
      // @BI-27856

      var needStroke = isFakePoints ? false : sameSize && !fake && (size < MAX_STROKE_WIDTH || style !== LineStyle.NORMAL);
      var key = id + (fake ? isFakePoints ? FAKE : REGION : '');
      var useArea = fake === FAKE_REGION;
      return h(useArea ? 'area' : 'kelpLine', {
        key: key,
        id: id,
        onmouseover: handleBandOn,
        onmousemove: handleBandOn,
        onmouseout: handleMouseOut,
        onclick: handleBandClick,
        transition: getBandTransition(lastPoints, useArea),
        z: isHovered ? HoverLayerZ : NormalLayerZ,
        shape: {
          points: formatPoints(points, useArea),
          style: fake === FAKE_REGION ? LineStyle.NORMAL : style,
          sameColor: sameColor,
          stroke: isFakePoints || needStroke,
          horizontal: horizontal
        },
        // stroke means all the points share the same size,which means a stroke line is a much better choice
        style: {
          fill: isFakePoints || needStroke ? 'none' : fill,
          stroke: isFakePoints || needStroke ? fill : 'none',
          lineWidth: isFakePoints ? FAKE_LINE_WIDTH : needStroke ? Math.max(size, 0.5) : 0,
          opacity: opacity / (fake || 1),
          lineDash: isFakePoints ? [8, 4] : null,
          blend: gradual ? 'lighter' : 'source-over'
        }
      });
    };

    function renderKelpLine(props) {
      var points = props.points,
          horizontal = props.horizontal,
          lastPoints = props.lastPoints,
          bigData = props.bigData;

      if (!points.length) {
        return null;
      }

      var _filterFakePoints = filterFakePoints(points, lastPoints, horizontal, true),
          normalPoints = _filterFakePoints.normalPoints,
          normalLastPoints = _filterFakePoints.normalLastPoints,
          predictedPoints = _filterFakePoints.predictedPoints,
          predictedLastPoints = _filterFakePoints.predictedLastPoints,
          deviationPoints = _filterFakePoints.deviationPoints,
          deviationLastPoints = _filterFakePoints.deviationLastPoints;

      var normalFill = bigData ? normalPoints[0].color : createNormalGradient(normalPoints, horizontal),
          fakeFill = createNormalGradient(predictedPoints, horizontal);
      var validRegion = filter(deviationPoints, function (y, y0) {
        return y !== y0;
      }).length;
      return [// normalPoints
      getKelpLineVNode(_extends({}, props, {
        points: normalPoints,
        fill: normalFill,
        lastPoints: normalLastPoints
      })), // fakePoints
      getKelpLineVNode(_extends({}, props, {
        points: predictedPoints,
        fake: FAKE_POINT,
        fill: fakeFill,
        lastPoints: predictedLastPoints
      })), // prediction region of fakePoints
      validRegion ? getKelpLineVNode(_extends({}, props, {
        points: deviationPoints,
        fake: FAKE_REGION,
        fill: fakeFill,
        stroke: false,
        lastPoints: deviationLastPoints
      })) : null];
    }

    function renderRadarLine(_ref) {
      var lineId = _ref.lineId,
          points = _ref.points,
          radius = _ref.radius,
          opacity = _ref.opacity,
          onmousemove = _ref.handleBandOn,
          onclick = _ref.handleBandClick,
          isHovered = _ref.isHovered,
          lastPoints = _ref.lastPoints,
          gradual = _ref.gradual;
      var len$$1 = points.length;

      if (len$$1 < 2) {
        return null;
      }

      var palette = null,
          fill = points[0].color;

      var getModifyAlphaColor = function getModifyAlphaColor(_ref2) {
        var color$$1 = _ref2.color,
            _ref2$opacity = _ref2.opacity,
            opacity = _ref2$opacity === void 0 ? 1 : _ref2$opacity;
        return modifyAlpha(color$$1, opacity);
      }; // sweepGradient needs at least three points


      if (len$$1 > 2) {
        var _len = points.length;

        var colors = _.map(points, function (p, index) {
          return {
            color: getModifyAlphaColor(p),
            value: index / _len
          };
        }).concat([{
          color: getModifyAlphaColor(points[0]),
          // circular
          value: 1
        }]);

        palette = SweepGradient().radius(radius).startAngle(-0.5 * Math.PI).endAngle(1.5 * Math.PI).create(colors);
      } else {
        fill = new LinearGradient(0, 0, 0, 1);
        fill.addColorStop(0, getModifyAlphaColor(points[0]));
        fill.addColorStop(1, getModifyAlphaColor(points[1]));
      }

      var style = {
        opacity: opacity,
        fill: fill,
        blend: gradual ? 'lighter' : 'source-over'
      };
      var shape = {
        points: formatPoints(points, false)
      };
      var graphics = [];
      var transition = getBandTransition(lastPoints, false),
          invisible = !!palette;
      palette && graphics.push(clipSweepGradient({
        silent: true,
        palette: palette,
        radius: radius,
        clip: {
          type: 'radarLine',
          shape: shape,
          ref: function ref(clipEl) {
            if (!clipEl || !transition) return; // @BI-38485

            var points = shape.points;
            clipEl.attrKV('shape', transition.appear()['shape']);
            clipEl.animate('shape').when(transition.duration, {
              points: points
            }).start(transition.ease);
          }
        },
        style: style
      }));
      graphics.push(h('radarLine', {
        invisible: invisible,
        transition: invisible ? null : transition,
        key: lineId,
        id: lineId,
        z: isHovered ? HoverLayerZ : NormalLayerZ,
        onmouseover: onmousemove,
        onmousemove: onmousemove,
        onclick: onclick,
        shape: shape,
        style: style
      }));
      return graphics;
    }

    var LineRadar = createLineBand({
      type: ChartLibrary.LINE_RADAR,
      renderBand: function renderBand(points, isHovered, effectValid, bigData, lastPoints) {
        var opacity = this.props.opacity;
        return renderRadarLine(_extends({}, this.props, {
          points: points,
          isHovered: isHovered,
          opacity: opacity * (effectValid ? EFFECT_LINE_OPACITY_RATIO : 1),
          lastPoints: lastPoints
        }));
      },
      renderEffectBand: function renderEffectBand(points, effectStops, duration) {
        var sameSize = this.props.sameSize;
        return renderLineEffect({
          points: points,
          duration: duration,
          effectStops: effectStops,
          style: LineStyle.NORMAL,
          stroke: useStroke(points, sameSize, LineStyle.NORMAL),
          opacity: 1
        });
      }
    });
    LineRadar.calcDataLabelPos = DO_NOTHING;
    LineRadar.adjustLater = true;
    Geom.registerGeom('lineRadar', LineRadar);

    /**
     * 绘制线
     * @param shape
     * @param stroke
     * @param lineWidth
     * @param z
     */

    var drawLine = function drawLine(shape, stroke, lineWidth, z) {
      if (z === void 0) {
        z = 0;
      }

      return h('line', {
        z: z,
        silent: true,
        shape: shape,
        style: {
          stroke: stroke,
          lineWidth: lineWidth
        }
      });
    };

    /**
     * 计算轴标签的bounds
     * @param width
     * @param height
     * @param position
     * @param textAlign
     * @param textVerticalAlign
     * @returns {{x: *, y: *, width: *, height: *}}
     */
    function getAxisTickLabelBounds(_ref, position, textAlign, textVerticalAlign) {
      var width = _ref[0],
          height = _ref[1];
      var x = position[0],
          y = position[1];
      x += width * (textAlign === 'left' ? 0 : textAlign === 'right' ? -1 : -0.5);
      y += height * (textVerticalAlign === 'top' ? 0 : textVerticalAlign === 'bottom' ? -1 : -0.5);
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }

    /**
     * 优化标签显示策略
     * 优先显示两端以及中间的
     * @param tickLabels
     * @returns {*}
     */
    function optimizeTickLabels(tickLabels) {
      var len = tickLabels.length;

      if (len <= 2) {
        return tickLabels;
      }

      var middle = Math.floor((len - 1) / 2);
      var optimized = [tickLabels[0], tickLabels[len - 1], tickLabels[middle]];

      for (var i = 1; i < len - 1; i++) {
        if (i !== middle) {
          optimized.push(tickLabels[i]);
        }
      }

      return optimized;
    }

    var Axis$2 = function Axis(_ref) {
      var _ref$position = _ref.position,
          position = _ref$position === void 0 ? [0, 0] : _ref$position,
          _ref$length = _ref.length,
          length = _ref$length === void 0 ? 100 : _ref$length,
          _ref$isHorizontal = _ref.isHorizontal,
          isHorizontal = _ref$isHorizontal === void 0 ? true : _ref$isHorizontal,
          _ref$domain = _ref.domain,
          domain = _ref$domain === void 0 ? [] : _ref$domain,
          _ref$reverse = _ref.reverse,
          reverse = _ref$reverse === void 0 ? false : _ref$reverse,
          _ref$invert = _ref.invert,
          invert = _ref$invert === void 0 ? false : _ref$invert,
          _ref$baseLineEnabled = _ref.baseLineEnabled,
          baseLineEnabled = _ref$baseLineEnabled === void 0 ? true : _ref$baseLineEnabled,
          _ref$baseLineColor = _ref.baseLineColor,
          baseLineColor = _ref$baseLineColor === void 0 ? '#000' : _ref$baseLineColor,
          _ref$baseLineWidth = _ref.baseLineWidth,
          baseLineWidth = _ref$baseLineWidth === void 0 ? 1 : _ref$baseLineWidth,
          _ref$mainTickEnabled = _ref.mainTickEnabled,
          mainTickEnabled = _ref$mainTickEnabled === void 0 ? true : _ref$mainTickEnabled,
          _ref$mainTickColor = _ref.mainTickColor,
          mainTickColor = _ref$mainTickColor === void 0 ? '#4f4f4f' : _ref$mainTickColor,
          _ref$mainTickAmount = _ref.mainTickAmount,
          mainTickAmount = _ref$mainTickAmount === void 0 ? 5 : _ref$mainTickAmount,
          _ref$mainTickWidth = _ref.mainTickWidth,
          mainTickWidth = _ref$mainTickWidth === void 0 ? 1 : _ref$mainTickWidth,
          _ref$mainTickLength = _ref.mainTickLength,
          mainTickLength = _ref$mainTickLength === void 0 ? 8 : _ref$mainTickLength,
          _ref$minorTickEnabled = _ref.minorTickEnabled,
          minorTickEnabled = _ref$minorTickEnabled === void 0 ? false : _ref$minorTickEnabled,
          _ref$minorTickColor = _ref.minorTickColor,
          minorTickColor = _ref$minorTickColor === void 0 ? '#919191' : _ref$minorTickColor,
          _ref$minorTickAmount = _ref.minorTickAmount,
          minorTickAmount = _ref$minorTickAmount === void 0 ? 5 : _ref$minorTickAmount,
          _ref$minorTickWidth = _ref.minorTickWidth,
          minorTickWidth = _ref$minorTickWidth === void 0 ? 0.5 : _ref$minorTickWidth,
          _ref$minorTickLength = _ref.minorTickLength,
          minorTickLength = _ref$minorTickLength === void 0 ? 4 : _ref$minorTickLength,
          _ref$labelEnabled = _ref.labelEnabled,
          labelEnabled = _ref$labelEnabled === void 0 ? false : _ref$labelEnabled,
          _ref$labelGap = _ref.labelGap,
          labelGap = _ref$labelGap === void 0 ? 4 : _ref$labelGap,
          _ref$labelCenter = _ref.labelCenter,
          labelCenter = _ref$labelCenter === void 0 ? true : _ref$labelCenter,
          _ref$labelColor = _ref.labelColor,
          labelColor = _ref$labelColor === void 0 ? '#333' : _ref$labelColor,
          _ref$labelFontSize = _ref.labelFontSize,
          labelFontSize = _ref$labelFontSize === void 0 ? 12 : _ref$labelFontSize,
          _ref$labelFontFamily = _ref.labelFontFamily,
          labelFontFamily = _ref$labelFontFamily === void 0 ? 'Verdana' : _ref$labelFontFamily,
          _ref$labelFontWeight = _ref.labelFontWeight,
          labelFontWeight = _ref$labelFontWeight === void 0 ? '' : _ref$labelFontWeight,
          _ref$labelContent = _ref.labelContent,
          labelContent = _ref$labelContent === void 0 ? [] : _ref$labelContent,
          targetFormat = _ref.targetFormat,
          z = _ref.z;
      var x1 = position[0],
          y1 = position[1];
      var distance = (!isHorizontal ^ reverse ? -1 : 1) * length;
      var x2 = x1 + (isHorizontal ? distance : 0),
          y2 = y1 - (isHorizontal ? 0 : distance);
      var elements = []; // baseLine

      baseLineEnabled && elements.push(drawLine({
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      }, baseLineColor, baseLineWidth, z));
      var axisScale = domain.length && linear$2().domain(domain).range(isHorizontal ? [x1, x1 + distance] : [y1, y1 + distance]); // Ticks

      if (mainTickEnabled) {
        var trans = (invert ? 1 : -1) * baseLineWidth / 2;
        var fixed = (isHorizontal ? y1 : x1) + trans;
        var mainTicks = [];

        var addTick = function addTick(ticks, pos, size) {
          var _x1 = isHorizontal ? pos : fixed,
              _y1 = isHorizontal ? fixed : pos;

          var shape = {
            x1: _x1,
            y1: _y1,
            x2: _x1 + (isHorizontal ? 0 : size * (invert ? 1 : -1)),
            y2: _y1 + (isHorizontal ? size * (invert ? -1 : 1) : 0)
          };
          ticks.push({
            shape: shape,
            pos: pos
          });
        };

        if (axisScale) {
          _.each(labelContent, function (c) {
            return addTick(mainTicks, axisScale(c), mainTickLength);
          });
        } else {
          var unit = distance / (mainTickAmount + 1);
          var start = isHorizontal ? x1 : y1;
          var i = -1;

          while (++i <= mainTickAmount) {
            addTick(mainTicks, start + i * unit, mainTickLength);
          }
        }

        elements.push(drawTicks(mainTicks, mainTickColor, mainTickWidth, z));

        if (minorTickEnabled) {
          var step = (mainTicks[1].pos - mainTicks[0].pos) / (minorTickAmount + 1);

          var _start = isHorizontal ? x1 : y1;

          var minorTicks = [],
              mLen = mainTicks.length;

          var addMinorTick = function addMinorTick(s, e, step) {
            var c = s + step;

            while (step > 0 ? c < e : c > e) {
              addTick(minorTicks, c, minorTickLength);
              c += step;
            }
          };

          addMinorTick(mainTicks[0].pos, _start, -step);

          _.each(mainTicks, function (t, i) {
            var end = i === mLen - 1 ? _start + distance : mainTicks[i + 1].pos;
            addMinorTick(t.pos, end, step);
          });

          elements.push(drawTicks(minorTicks, minorTickColor, minorTickWidth, z));
        }
      } // label


      if (labelEnabled && labelContent.length) {
        var direction = isHorizontal ? invert ? 'top' : 'bottom' : invert ? 'right' : 'left';
        var style = {
          color: labelColor,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          fontWeight: labelFontWeight
        };
        var len = labelContent.length;
        var tickSize = Math.max(mainTickLength, minorTickLength);
        var gap = labelGap + tickSize;

        var _fixed = isHorizontal ? y1 + (invert ? -1 : 1) * gap : x1 + (invert ? 1 : -1) * gap;

        var getLabelPos;

        if (axisScale) {
          getLabelPos = function getLabelPos(content) {
            var cur = axisScale(content);
            return isHorizontal ? [cur, _fixed] : [_fixed, cur];
          };
        } else {
          var _unit = distance / (len - (labelCenter ? 0 : 1));

          getLabelPos = function getLabelPos(content, index) {
            var cur = (isHorizontal ? x1 : y1) + index * _unit + (labelCenter ? _unit / 2 : 0);
            return isHorizontal ? [cur, _fixed] : [_fixed, cur];
          };
        }

        var manager = new BoundsManager();

        var tickLabels = _.map(labelContent, function (c, i) {
          return {
            content: getFormattedText(c, targetFormat),
            position: getLabelPos(c, i)
          };
        });

        elements.push(_.map(optimizeTickLabels(tickLabels), function (_ref2) {
          var content = _ref2.content,
              position = _ref2.position;
          return drawLabel({
            content: content,
            position: position,
            direction: direction,
            style: style,
            z: z,
            manager: manager
          });
        }));
      }

      return h('group', null, elements);
    };

    function drawTicks(ticks, stroke, lineWidth, z) {
      return h('multiLine', {
        shape: {
          lines: _.map(ticks, function (tick) {
            return tick.shape;
          })
        },
        silent: true,
        z: z,
        style: {
          stroke: stroke,
          lineWidth: lineWidth
        }
      });
    }

    function getTextAlignment(direction) {
      var textAlign = 'center',
          textVerticalAlign = 'center';

      switch (direction) {
        case 'top':
          textVerticalAlign = 'bottom';
          break;

        case 'bottom':
          textVerticalAlign = 'top';
          break;

        case 'left':
          textAlign = 'right';
          break;

        case 'right':
          textAlign = 'left';
          break;
      }

      return [textAlign, textVerticalAlign];
    }
    /**
     * 绘制标签
     * @param content
     * @param position
     * @param direction
     * @param style
     * @param z
     * @param manager
     */


    function drawLabel(_ref3) {
      var content = _ref3.content,
          position = _ref3.position,
          direction = _ref3.direction,
          style = _ref3.style,
          z = _ref3.z,
          manager = _ref3.manager;
      var color = style.color,
          fontSize = style.fontSize,
          fontFamily = style.fontFamily;

      var _getTextAlignment = getTextAlignment(direction),
          textAlign = _getTextAlignment[0],
          textVerticalAlign = _getTextAlignment[1];

      var tickLabelBounds = getAxisTickLabelBounds(calcTextDim(content, style), position, textAlign, textVerticalAlign);

      if (manager != null) {
        if (manager.isOverlapped(tickLabelBounds)) {
          return;
        }

        manager.addBounds(tickLabelBounds);
      }

      return h('text', {
        silent: true,
        position: position,
        z: z,
        style: {
          text: content,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign,
          textFill: color,
          fontSize: fontSize,
          fontFamily: fontFamily
        }
      });
    }

    /**
     * 极坐标轴
     * @constructor
     */

    var sin$7 = Math.sin,
        cos$7 = Math.cos,
        PI$a = Math.PI;
    var DOUBLE_PI$1 = PI$a * 2;

    var PolarAxis = function PolarAxis(_ref) {
      var _ref$radius = _ref.radius,
          radius = _ref$radius === void 0 ? 100 : _ref$radius,
          _ref$center = _ref.center,
          center = _ref$center === void 0 ? [0, 0] : _ref$center,
          _ref$startAngle = _ref.startAngle,
          startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle,
          _ref$endAngle = _ref.endAngle,
          endAngle = _ref$endAngle === void 0 ? DOUBLE_PI$1 : _ref$endAngle,
          _ref$invert = _ref.invert,
          invert = _ref$invert === void 0 ? false : _ref$invert,
          _ref$domain = _ref.domain,
          domain = _ref$domain === void 0 ? [] : _ref$domain,
          _ref$baseLineEnabled = _ref.baseLineEnabled,
          baseLineEnabled = _ref$baseLineEnabled === void 0 ? true : _ref$baseLineEnabled,
          _ref$baseLineColor = _ref.baseLineColor,
          baseLineColor = _ref$baseLineColor === void 0 ? '#000' : _ref$baseLineColor,
          _ref$baseLineWidth = _ref.baseLineWidth,
          baseLineWidth = _ref$baseLineWidth === void 0 ? 1 : _ref$baseLineWidth,
          _ref$baseLineType = _ref.baseLineType,
          baseLineType = _ref$baseLineType === void 0 ? 'solid' : _ref$baseLineType,
          _ref$minorLineEnabled = _ref.minorLineEnabled,
          minorLineEnabled = _ref$minorLineEnabled === void 0 ? false : _ref$minorLineEnabled,
          _ref$minorLineColor = _ref.minorLineColor,
          minorLineColor = _ref$minorLineColor === void 0 ? '#444' : _ref$minorLineColor,
          _ref$minorLineAmount = _ref.minorLineAmount,
          minorLineAmount = _ref$minorLineAmount === void 0 ? 3 : _ref$minorLineAmount,
          _ref$minorLineWidth = _ref.minorLineWidth,
          minorLineWidth = _ref$minorLineWidth === void 0 ? 1 : _ref$minorLineWidth,
          _ref$minorLineType = _ref.minorLineType,
          minorLineType = _ref$minorLineType === void 0 ? 'solid' : _ref$minorLineType,
          _ref$mainTickEnabled = _ref.mainTickEnabled,
          mainTickEnabled = _ref$mainTickEnabled === void 0 ? true : _ref$mainTickEnabled,
          _ref$mainTickLinkCent = _ref.mainTickLinkCenter,
          mainTickLinkCenter = _ref$mainTickLinkCent === void 0 ? false : _ref$mainTickLinkCent,
          _ref$mainTickAmount = _ref.mainTickAmount,
          mainTickAmount = _ref$mainTickAmount === void 0 ? 5 : _ref$mainTickAmount,
          _ref$mainTickColor = _ref.mainTickColor,
          mainTickColor = _ref$mainTickColor === void 0 ? '#222' : _ref$mainTickColor,
          _ref$mainTickLength = _ref.mainTickLength,
          mainTickLength = _ref$mainTickLength === void 0 ? 8 : _ref$mainTickLength,
          _ref$mainTickWidth = _ref.mainTickWidth,
          mainTickWidth = _ref$mainTickWidth === void 0 ? 1 : _ref$mainTickWidth,
          _ref$minorTickEnabled = _ref.minorTickEnabled,
          minorTickEnabled = _ref$minorTickEnabled === void 0 ? false : _ref$minorTickEnabled,
          _ref$minorTickAmount = _ref.minorTickAmount,
          minorTickAmount = _ref$minorTickAmount === void 0 ? 4 : _ref$minorTickAmount,
          _ref$minorTickColor = _ref.minorTickColor,
          minorTickColor = _ref$minorTickColor === void 0 ? '#555' : _ref$minorTickColor,
          _ref$minorTickWidth = _ref.minorTickWidth,
          minorTickWidth = _ref$minorTickWidth === void 0 ? 0.5 : _ref$minorTickWidth,
          _ref$minorTickLength = _ref.minorTickLength,
          minorTickLength = _ref$minorTickLength === void 0 ? 4 : _ref$minorTickLength,
          _ref$labelEnabled = _ref.labelEnabled,
          labelEnabled = _ref$labelEnabled === void 0 ? false : _ref$labelEnabled,
          _ref$labelCenter = _ref.labelCenter,
          labelCenter = _ref$labelCenter === void 0 ? false : _ref$labelCenter,
          _ref$labelGap = _ref.labelGap,
          labelGap = _ref$labelGap === void 0 ? 4 : _ref$labelGap,
          _ref$labelColor = _ref.labelColor,
          labelColor = _ref$labelColor === void 0 ? '#333' : _ref$labelColor,
          _ref$labelFontSize = _ref.labelFontSize,
          labelFontSize = _ref$labelFontSize === void 0 ? 12 : _ref$labelFontSize,
          _ref$labelFontFamily = _ref.labelFontFamily,
          labelFontFamily = _ref$labelFontFamily === void 0 ? 'Verdana' : _ref$labelFontFamily,
          _ref$labelFontWeight = _ref.labelFontWeight,
          labelFontWeight = _ref$labelFontWeight === void 0 ? '' : _ref$labelFontWeight,
          _ref$labelContent = _ref.labelContent,
          labelContent = _ref$labelContent === void 0 ? [] : _ref$labelContent,
          targetFormat = _ref.targetFormat,
          _ref$z = _ref.z,
          z = _ref$z === void 0 ? 0 : _ref$z,
          _ref$opacity = _ref.opacity,
          opacity = _ref$opacity === void 0 ? 1 : _ref$opacity;
      var isCircle = false;

      if (Math.abs(endAngle - startAngle) >= PI$a * 2) {
        endAngle = startAngle + PI$a * 2;
        isCircle = true;
      }

      var elements = []; // 主基线

      baseLineEnabled && elements.push(drawCycloidLine({
        center: center,
        radius: radius,
        startAngle: startAngle,
        endAngle: endAngle,
        stroke: baseLineColor,
        lineWidth: baseLineWidth,
        lineType: baseLineType,
        z: z,
        opacity: opacity
      })); // 次要基线

      if (minorLineEnabled) {
        var unit = radius / (minorLineAmount + 1);

        for (var i = 0; i <= minorLineAmount; i++) {
          var r = i * unit;
          elements.push(drawCycloidLine({
            center: center,
            r: r,
            startAngle: startAngle,
            endAngle: endAngle,
            stroke: minorLineColor,
            lineWidth: minorLineWidth,
            lineType: minorLineType,
            z: z,
            opacity: opacity
          }));
        }
      }

      var axisScale = domain.length && linear$2().domain(domain).range([startAngle, endAngle]); // 主要刻度&次要刻度

      if (mainTickEnabled || minorTickEnabled) {
        var mainTicks = calculateTicks({
          startAngle: startAngle,
          endAngle: endAngle,
          size: mainTickLength,
          amount: mainTickAmount,
          linkCenter: mainTickLinkCenter,
          radius: radius,
          invert: invert,
          axisScale: axisScale,
          labelContent: labelContent
        });
        mainTickEnabled && elements.push(drawTicks$1({
          ticks: mainTicks,
          stroke: mainTickColor,
          lineWidth: mainTickWidth,
          z: z,
          lineType: mainTickLinkCenter && baseLineType
        }));

        if (minorTickEnabled) {
          var mainTickAngles = map(mainTicks, function (tick) {
            return tick.angle;
          }),
              len = mainTickAngles.length,
              minorTicks = [],
              step = (mainTickAngles[1] - mainTickAngles[0]) / (minorTickAmount + 1);

          var addMinorTick = function addMinorTick(sa, ea, step) {
            var ca = sa + step;

            while (step > 0 ? ca <= ea : ca >= ea) {
              minorTicks.push(calculateTick(radius, ca, minorTickLength, invert));
              ca += step;
            }
          }; // start -> first mainTick


          addMinorTick(mainTickAngles[0], startAngle, -step); // mainA -> mainB || end

          _.each(mainTickAngles, function (ca, i) {
            return addMinorTick(ca, i === len - 1 ? endAngle : mainTickAngles[i + 1], step);
          });

          elements.push(drawTicks$1({
            ticks: minorTicks,
            stroke: minorTickColor,
            lineWidth: minorTickWidth,
            z: z,
            opacity: opacity
          }));
        }
      } // 标签


      if (labelEnabled && labelContent.length) {
        var style = {
          color: labelColor,
          fontSize: labelFontSize,
          fontFamily: labelFontFamily,
          fontWeight: labelFontWeight
        };
        var _len = labelContent.length; // 考虑标签居中或者是360度的轴

        var amount = _len + (labelCenter ? 0 : isCircle ? 0 : -1);

        var getAngle = axisScale || function (v, i) {
          var unit = (endAngle - startAngle) / amount;
          return startAngle + i * unit + (labelCenter ? unit / 2 : 0);
        };

        var distance = Math.max(mainTickLength, minorTickLength) + labelGap;

        var tickLabels = _.map(labelContent, function (c, i) {
          var angle = getAngle(c, i),
              r = radius + (invert ? 1 : -1) * distance,
              position = calculatePointPos(r, angle),
              direction = getLabelDirection(angle);
          return {
            content: getFormattedText(labelContent[i], targetFormat),
            position: position,
            direction: direction
          };
        });

        var manager = new BoundsManager();
        elements.push(_.map(optimizeTickLabels(tickLabels), function (_ref2) {
          var content = _ref2.content,
              position = _ref2.position,
              direction = _ref2.direction;
          return drawLabel$1({
            content: content,
            position: position,
            direction: direction,
            z: z,
            style: style,
            manager: manager
          });
        }));
      }

      return h('group', {
        position: center
      }, elements);
    };
    /**
     * 绘制标签
     * @param content
     * @param pos
     * @param style
     * @param direction
     * @param z
     * @param opacity
     */

    function drawLabel$1(_ref3) {
      var content = _ref3.content,
          position = _ref3.position,
          style = _ref3.style,
          _ref3$direction = _ref3.direction,
          direction = _ref3$direction === void 0 ? 'center-top' : _ref3$direction,
          z = _ref3.z,
          opacity = _ref3.opacity,
          manager = _ref3.manager;
      var color = style.color,
          fontSize = style.fontSize,
          fontFamily = style.fontFamily;

      var _direction$split = direction.split('-'),
          textAlign = _direction$split[0],
          textVerticalAlign = _direction$split[1];

      var tickLabelBounds = getAxisTickLabelBounds(calcTextDim(content, style), position, textAlign, textVerticalAlign);

      if (manager != null) {
        if (manager.isOverlapped(tickLabelBounds)) {
          return;
        }

        manager.addBounds(tickLabelBounds);
      }

      return h('text', {
        position: position,
        silent: true,
        z: z,
        style: {
          text: content,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign,
          textFill: color,
          fontSize: fontSize,
          fontFamily: fontFamily,
          opacity: opacity
        }
      });
    }

    function similar(a, b) {
      return Math.abs(a - b) < 1e-6;
    } // 获取标签的摆放位置：textAlign & verticalAlign


    function getLabelDirection(angle) {
      var x = cos$7(angle),
          y = sin$7(angle);
      var h$$1 = similar(x, 0) ? 'center' : x > 0 ? 'right' : 'left';
      var v = similar(y, 0) ? 'middle' : y > 0 ? 'bottom' : 'top';
      return [h$$1, v].join('-');
    }
    /**
     * 绘制刻度
     * @param ticks
     * @param stroke
     * @param lineWidth
     * @param lineType
     * @param z
     * @param opacity
     */


    function drawTicks$1(_ref4) {
      var ticks = _ref4.ticks,
          stroke = _ref4.stroke,
          lineWidth = _ref4.lineWidth,
          lineType = _ref4.lineType,
          z = _ref4.z,
          opacity = _ref4.opacity;

      var lines = _.map(ticks, function (tick) {
        return tick.shape;
      });

      return h('multiLine', {
        shape: {
          lines: lines
        },
        silent: true,
        z: z,
        style: {
          stroke: stroke,
          lineWidth: lineWidth,
          opacity: opacity,
          lineDash: lineType === 'dashed' ? DASHED_ARRAY : null
        }
      });
    }

    function calculateTick(radius, angle, size, invert, linkCenter) {
      var p1 = calculatePointPos(radius, angle),
          p2 = calculatePointPos(radius + (invert ? 1 : -1) * size, angle);
      var startPoint = linkCenter ? [0, 0] : p1;
      var endPoint = linkCenter ? invert ? p2 : p1 : p2;
      return {
        angle: angle,
        shape: {
          x1: startPoint[0],
          y1: startPoint[1],
          x2: endPoint[0],
          y2: endPoint[1]
        }
      };
    }
    /**
     * 指定角度范围，计算指定数量的ticks相关的shape属性
     * @param invert  是否反转刻度
     * @param radius  半径
     * @param startAngle  起始角度
     * @param endAngle    结束角度
     * @param amount      刻度数量
     * @param size        刻度长度
     * @param linkCenter    是否连接中心点
     * @param axisScale    轴标签角度比例尺
     * @param labelContent    轴标签
     * @returns {Array}   刻度所在角度及对应的shape的集合
     */


    function calculateTicks(_ref5) {
      var startAngle = _ref5.startAngle,
          endAngle = _ref5.endAngle,
          invert = _ref5.invert,
          radius = _ref5.radius,
          amount = _ref5.amount,
          size = _ref5.size,
          _ref5$linkCenter = _ref5.linkCenter,
          linkCenter = _ref5$linkCenter === void 0 ? false : _ref5$linkCenter,
          axisScale = _ref5.axisScale,
          labelContent = _ref5.labelContent;
      var ticks = [];

      if (axisScale) {
        ticks = _.map(labelContent, function (c) {
          return calculateTick(radius, axisScale(c), size, invert, linkCenter);
        });
      } else {
        var i = -1;

        while (++i < amount) {
          var unit = (endAngle - startAngle) / (amount - 1),
              angle = startAngle + i * unit;
          ticks.push(calculateTick(radius, angle, size, invert, linkCenter));
        }
      }

      return ticks;
    }
    /**
     * 计算点在圆上固定角度的位置
     * @param radius
     * @param angle
     * @returns {*[]}
     */


    function calculatePointPos(radius, angle) {
      return [radius * cos$7(angle) | 0, radius * sin$7(angle) | 0];
    }
    /**
     * 绘制圆弧形线
     * @param center
     * @param radius
     * @param startAngle
     * @param endAngle
     * @param stroke
     * @param lineWidth
     * @param z
     * @param opacity
     */


    function drawCycloidLine(_ref6) {
      var _ref6$center = _ref6.center,
          cx = _ref6$center[0],
          cy = _ref6$center[1],
          radius = _ref6.radius,
          startAngle = _ref6.startAngle,
          endAngle = _ref6.endAngle,
          stroke = _ref6.stroke,
          lineWidth = _ref6.lineWidth,
          lineType = _ref6.lineType,
          z = _ref6.z,
          opacity = _ref6.opacity;
      return h('arc', {
        silent: true,
        z: z,
        shape: {
          cx: cx,
          cy: cy,
          r: radius,
          r0: radius,
          startAngle: startAngle,
          endAngle: endAngle
        },
        style: {
          lineWidth: lineWidth,
          stroke: stroke,
          opacity: opacity,
          lineDash: lineType === 'dashed' ? DASHED_ARRAY : null
        }
      });
    }

    var LINE_COLOR = '#b0b0b0';
    var DIMENSION_TICK_GAP = 5;
    var START_ANGLE = -0.5 * Math.PI;
    var END_ANGLE = START_ANGLE + Math.PI * 2;
    var PI$b = Math.PI,
        halfPI = PI$b * 0.5,
        opfPI = PI$b * 1.5;

    var getAlign = function getAlign(angle) {
      var textAlign, textVerticalAlign;

      if (angle > halfPI && angle < opfPI) {
        textVerticalAlign = 'top';
      } else if (angle === halfPI || angle === opfPI) {
        textVerticalAlign = 'middle';
      } else {
        textVerticalAlign = 'bottom';
      }

      if (angle > 0 && angle < PI$b) {
        textAlign = 'left';
      } else if (angle === 0 || angle === PI$b) {
        textAlign = 'center';
      } else {
        textAlign = 'right';
      }

      return {
        textAlign: textAlign,
        textVerticalAlign: textVerticalAlign
      };
    };

    var getTestPoint = function getTestPoint(angle, _ref, _ref2) {
      var x = _ref[0],
          y = _ref[1];
      var width = _ref2[0],
          height = _ref2[1];

      var _x, _y;

      if (angle > halfPI && angle < opfPI) {
        _y = y + height;
      } else if (angle === halfPI || angle === opfPI) {
        _y = y;
      } else {
        _y = y - height;
      }

      if (angle > 0 && angle < PI$b) {
        _x = x + width;
      } else if (angle === 0 || angle === PI$b) {
        _x = x + width;
      } else {
        _x = x - width;
      }

      return {
        x: _x,
        y: _y
      };
    };

    var adjustRadius = function adjustRadius(maxRadius, dimTicks, bounds) {
      var step = 3;
      var minRadius = maxRadius * 0.5;

      while (maxRadius > minRadius) {
        var found = true;

        for (var i = 0, len = dimTicks.length; i < len; i++) {
          var tick = dimTicks[i];
          var angle = tick.angle,
              textDim = tick.textDim;
          var x = maxRadius * Math.sin(angle),
              y = -maxRadius * Math.cos(angle);
          tick.position = [x, y];

          if (!containsPoint(bounds, getTestPoint(angle, [x, y], textDim))) {
            found = false;
            break;
          }
        }

        if (found) {
          break;
        }

        maxRadius -= step;
      }

      return Math.max(maxRadius - DIMENSION_TICK_GAP, 0);
    }; // layout & adjust


    function layoutRadarAxis(_ref3) {
      var dimensionTexts = _ref3.dimensionTexts,
          bounds = _ref3.bounds,
          dimensionDef = _ref3.dimensionDef;
      var width = bounds.width,
          height = bounds.height;
      var maxRadius = Math.min(width, height) / 2;

      var _ref4 = dimensionDef.tick || {},
          style = _ref4.style,
          enabled = _ref4.enabled;

      if (!enabled) {
        return {
          radius: maxRadius,
          dimTicks: []
        };
      }

      var dimStyle = {
        fontSize: style.fontSize,
        fontFamily: style.fontFamily
      };
      var dimLen = dimensionTexts.length;

      var dimTicks = _.map(dimensionTexts, function (text, index) {
        var angle = index * Math.PI * 2 / dimLen;

        var _getAlign = getAlign(angle),
            textAlign = _getAlign.textAlign,
            textVerticalAlign = _getAlign.textVerticalAlign;

        var textDim = calcTextDim(text, dimStyle);
        return {
          text: text,
          angle: angle,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign,
          textDim: textDim
        };
      });

      var radius = dimTicks.length ? adjustRadius(maxRadius, dimTicks, {
        x: -width / 2,
        y: -height / 2,
        width: width,
        height: height
      }) : maxRadius;
      return {
        radius: radius,
        dimTicks: dimTicks
      };
    }

    var getMeasureTicks = function getMeasureTicks(measureDef, scaleDef, scale, gridLineStyle) {
      if (!measureDef) {
        return null;
      }

      var measureFormatter = measureDef.format,
          tick = measureDef.tick;
      var enabled = tick.enabled,
          style = tick.style;
      var _style$fontSize = style.fontSize,
          fontSize = _style$fontSize === void 0 ? 12 : _style$fontSize,
          _style$textFill = style.textFill,
          textFill = _style$textFill === void 0 ? '#2b2b2b' : _style$textFill,
          fontFamily = style.fontFamily;
      var valueTicks = scaleDef.ticks,
          _scaleDef$domain = scaleDef.domain,
          min = _scaleDef$domain[0],
          max = _scaleDef$domain[1];

      var _ref5 = gridLineStyle || {},
          _ref5$enabled = _ref5.enabled,
          gridLineEnabled = _ref5$enabled === void 0 ? false : _ref5$enabled,
          type = _ref5.type,
          color = _ref5.color,
          width = _ref5.width;

      var vNodes = [];

      _.each(valueTicks, function (value) {
        var r = scale(value);
        var position = [0, -r];
        enabled && vNodes.push(h('text', {
          position: position,
          silent: true,
          style: {
            text: getFormattedText(value, measureFormatter),
            textAlign: 'left',
            textVerticalAlign: 'top',
            textFill: textFill,
            fontSize: fontSize,
            fontFamily: fontFamily
          }
        }));
        var gridLineValid = value !== min && value !== max && gridLineEnabled;
        gridLineValid && vNodes.push(h('arc', {
          silent: true,
          shape: {
            r: r,
            r0: r
          },
          style: {
            stroke: color,
            lineDash: type === 'dashed' ? DASHED_ARRAY : null,
            lineWidth: width
          }
        }));
      });

      return vNodes;
    };

    function radarAxis(_ref6) {
      var radius = _ref6.radius,
          dimTicks = _ref6.dimTicks,
          measureDef = _ref6.measureDef,
          dimensionDef = _ref6.dimensionDef,
          scale = _ref6.scale,
          gridLineStyle = _ref6.gridLineStyle,
          axisLineStyle = _ref6.axisLineStyle,
          scaleDef = _ref6.scaleDef;
      var dimFormatter = dimensionDef.format,
          tick = dimensionDef.tick;

      var dimTickNodes = _.map(dimTicks, function (_ref7) {
        var position = _ref7.position,
            text = _ref7.text,
            textAlign = _ref7.textAlign,
            textVerticalAlign = _ref7.textVerticalAlign;
        return h('text', {
          position: position,
          style: _extends({}, tick.style, {
            text: getFormattedText(text, dimFormatter),
            textAlign: textAlign,
            textVerticalAlign: textVerticalAlign
          })
        });
      });

      var measureTicks = getMeasureTicks(measureDef, scaleDef, scale, gridLineStyle);
      var _axisLineStyle$enable = axisLineStyle.enabled,
          axisLineEnabled = _axisLineStyle$enable === void 0 ? false : _axisLineStyle$enable,
          _axisLineStyle$color = axisLineStyle.color,
          axisLineColor = _axisLineStyle$color === void 0 ? LINE_COLOR : _axisLineStyle$color,
          _axisLineStyle$width = axisLineStyle.width,
          axisLineWidth = _axisLineStyle$width === void 0 ? 1 : _axisLineStyle$width,
          baseLineType = axisLineStyle.type;
      return h('group', null, h(PolarAxis, {
        radius: radius,
        startAngle: START_ANGLE,
        endAngle: END_ANGLE,
        baseLineColor: axisLineColor,
        baseLineWidth: axisLineWidth,
        minorLineEnabled: false,
        baseLineType: baseLineType,
        baseLineEnabled: axisLineEnabled,
        mainTickEnabled: axisLineEnabled,
        mainTickColor: axisLineColor,
        mainTickAmount: dimTicks.length + 1,
        mainTickLinkCenter: axisLineEnabled,
        mainTickWidth: axisLineWidth
      }), dimTickNodes, measureTicks);
    }

    var LABEL_GRAPHIC_GAP = 3;

    var calcDataLabelPosFunc = function calcDataLabelPosFunc(hasCenter) {
      if (hasCenter === void 0) {
        hasCenter = true;
      }

      var calcFn = function calcFn(_ref) {
        var bounds = _ref.bounds,
            row = _ref.row,
            position = _ref.position;
        var x = row.x,
            radius = row.size;
        var y = row.y;

        if (hasCenter && position === DataLabel.CENTER) {
          return [x, y];
        }

        var dis = bounds.height / 2 + radius + LABEL_GRAPHIC_GAP;
        y += position === DataLabel.BOTTOM ? dis : -dis;
        return [x, y];
      };

      calcFn.hasCenterLabel = function (hasCenter) {
        return calcDataLabelPosFunc(hasCenter);
      };

      return calcFn;
    };

    var calcDataLabelPos$2 = calcDataLabelPosFunc(true);

    var dealDataLabelByCell = function dealDataLabelByCell(lines, cellBounds) {
      var manager = new BoundsManager();
      var maxRadius = Math.min(cellBounds.width, cellBounds.height) / 2;

      _.each(lines, function (geom) {
        var rows = geom.rows,
            dataLabel = geom.dataLabel;
        var valid = dataLabel.valid,
            position = dataLabel.position,
            allowOverlap = dataLabel.allowOverlap,
            adjust = dataLabel.adjust;

        if (!valid) {
          return;
        }

        var labelRows = filter(rows, function (row) {
          return row.dataLabel;
        });
        forEach(labelRows, function (row) {
          var _row$dataLabel = row.dataLabel,
              bounds = _row$dataLabel.bounds,
              _row$dataLabel$bounds = _row$dataLabel.bounds,
              width = _row$dataLabel$bounds.width,
              height = _row$dataLabel$bounds.height;
          var pos = calcDataLabelPos$2({
            bounds: bounds,
            row: row,
            geom: geom,
            position: position
          });
          row.labelPos = pos;

          if (allowOverlap) {
            return;
          }

          var cx = pos[0],
              cy = pos[1];
          var testBounds = {
            x: cx - width / 2,
            y: cy - height / 2,
            width: width,
            height: height
          };

          if (adjust === DataLabel.HIDE) {
            if (manager.isOverlapped(testBounds)) {
              row.dataLabel = null;
            } else {
              manager.addBounds(testBounds);
            }
          } else {
            var bottom = position === DataLabel.BOTTOM;
            var angle = row.angle,
                radius = row.radius,
                size = row.size;
            var step = 3;

            var attempt = function attempt(step) {
              for (var s = radius; step > 0 ? s < maxRadius : s > 0; s += step) {
                var _calcPolarPos = calcPolarPos(s, angle),
                    x = _calcPolarPos[0],
                    y = _calcPolarPos[1];

                x |= 0;
                y += (size + height / 2) * (bottom ? 1 : -1) | 0; // keep label position

                var newBounds = {
                  x: x - width / 2,
                  y: y - height / 2,
                  width: width,
                  height: height
                };

                if (!manager.isOverlapped(newBounds)) {
                  row.labelPos = [x, y];
                  manager.addBounds(newBounds);
                  return true;
                }
              }
            };

            attempt(step) || attempt(-step) || (row.dataLabel = null);
          }
        });
      });
    };

    var getPointPos$1 = function getPointPos(angle, radius) {
      return [radius * Math.cos(angle) | 0, radius * Math.sin(angle) | 0];
    };

    var RadarCell =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(RadarCell, _Component);

      function RadarCell(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.state = {};
        _this.hoverLineId = null;
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));

        _this.updateState(props, context);

        return _this;
      }

      var _proto = RadarCell.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.geoms !== this.props.geoms) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var geoms = props.geoms,
            facetX = props.facetX,
            facetY = props.facetY,
            bounds = props.bounds,
            shifting = props.shifting,
            defs = props.defs;

        if (!geoms.length) {
          return;
        }

        var _geoms$ = geoms[0],
            rows = _geoms$.rows,
            fRadar = _geoms$.geom,
            measure = fRadar.measure,
            _diffFacet = diffFacet(facetX, facetY),
            baseFacet = _diffFacet.baseFacet,
            geomFacet = _diffFacet.geomFacet,
            dimensions = baseFacet.dimensions,
            gridLine = geomFacet.gridLine;

        var dimensionId = dimensions.length ? dimensions[dimensions.length - 1] : null,
            dimensionTexts = [],
            dimHash = {};

        if (dimensionId != null) {
          _.each(rows, function (row) {
            var text = row[dimensionId];

            if (!dimHash[text]) {
              dimHash[text] = 1;
              dimensionTexts.push(text);
            }
          });
        }

        var measureDef = measure ? defs[getMeasureDefKey(measure, geomFacet)] : null;
        var dimensionDef = defs[dimensionId] || {}; // layout

        var _layoutRadarAxis = layoutRadarAxis({
          dimensionTexts: dimensionTexts,
          bounds: bounds,
          dimensionDef: dimensionDef
        }),
            dimTicks = _layoutRadarAxis.dimTicks,
            radius = _layoutRadarAxis.radius;

        var axisScale, scaleDef;

        if (measureDef) {
          scaleDef = geomFacet.scaleMap[getMeasureDefKey(measure, geomFacet)];
          var _scaleDef = scaleDef,
              domain = _scaleDef.domain,
              reverse = _scaleDef.reverse,
              logBase = _scaleDef.logBase;
          axisScale = logBase ? log$2().base(logBase) : linear$2();
          axisScale.domain(domain).range(reverse ? [radius, 0] : [0, radius]);
        }

        var dimLen = dimensionTexts.length,
            getRowAngle = function getRowAngle(text) {
          return (dimensionTexts.length ? dimensionTexts.indexOf(text) * Math.PI * 2 / dimLen : 0) - Math.PI / 2;
        };

        var lines = [];
        var stackMap = {},
            axisStart = measureDef && measureDef.logBase ? 1 : 0;

        _.each(geoms, function (_ref) {
          var geom = _ref.geom,
              rows = _ref.rows;
          var measure = geom.measure,
              color = geom.color,
              size = geom.size,
              groupLineIds = geom.groupLineIds,
              lineConnect = geom.lineConnect,
              stack = geom.stack;
          var measureId = measure;
          var connect = lineConnect && lineConnect.length ? lineConnect[0] : null;
          rows = _.filter(rows, function (row) {
            return !row.vanish;
          });
          var sameColor = !_.isObject(color),
              sameSize = !_.isObject(size);

          var groupedLines = _.groupBy(rows, function (d) {
            return _.map(groupLineIds, function (key) {
              return d[key];
            }).join('*');
          });

          _.each(groupedLines, function (rows, key) {
            if (connect && connect.isMeasure) {
              var cname = connect.name;
              rows.sort(function (a, b) {
                return a[cname] - b[cname];
              });
            }

            var data = _.map(rows, function (row) {
              var dimValue = row[dimensionId],
                  value = row[measureId];

              if (stack) {
                var stackKey = dimValue + (value > 0 ? POSITIVE_SUFFIX : NEGATIVE_SUFFIX);
                value += stackMap[stackKey] == null ? axisStart : stackMap[stackKey];
                stackMap[stackKey] = value;
              }

              var angle = getRowAngle(dimValue),
                  r = measureId ? axisScale(value) : radius / 2,
                  _getPointPos = getPointPos$1(angle, r),
                  x = _getPointPos[0],
                  y = _getPointPos[1];

              return _extends({}, row, {
                size: Math.max(row.size, 0.5),
                angle: angle,
                radius: r,
                x: x,
                y: y
              });
            });

            lines.push(_extends({}, geom, {
              lineId: "lineRadar_" + measureId + "_" + key,
              rows: data.sort(function (a, b) {
                return a.angle - b.angle;
              }),
              sameColor: sameColor,
              sameSize: sameSize,
              isVarLine: !connect
            }));
          });
        });

        var center = getBoundsCenter(bounds);
        dealDataLabelByCell(lines, bounds);
        this.setState({
          dimKey: dimensionId,
          lines: lines,
          dimTexts: dimensionTexts,
          dimTicks: dimTicks,
          measureDef: measureDef,
          dimensionDef: dimensionDef,
          scaleDef: scaleDef,
          scale: axisScale,
          radius: radius,
          center: center,
          gridLineStyle: gridLine,
          shifting: mergeShifting(shifting, center)
        });
      } // 寻找最近的点，并生成payload
      ;

      _proto.findClosestPoint = function findClosestPoint(_ref2) {
        var _this2 = this;

        var offsetX = _ref2.offsetX,
            offsetY = _ref2.offsetY;
        var _this$props = this.props,
            fadeChecker = _this$props.fadeChecker,
            shifting = _this$props.shifting;
        var _this$state = this.state,
            lines = _this$state.lines,
            _this$state$center = _this$state.center,
            cx = _this$state$center[0],
            cy = _this$state$center[1];

        var line = _.filter(lines, function (line) {
          return line.lineId === _this2.hoverLineId;
        })[0];

        var rows = line.rows;
        var tx = shifting[0],
            ty = shifting[1];
        var pos = {
          x: offsetX - tx,
          y: offsetY - ty
        };

        var getDistance = function getDistance(row) {
          return distance$2({
            x: row.x + cx,
            y: row.y + cy
          }, pos);
        };

        var closest = rows[0],
            dis = getDistance(closest);

        _.each(rows, function (row) {
          var _dis = getDistance(row);

          if (_dis < dis) {
            dis = _dis;
            closest = row;
          }
        });

        if (fadeChecker(closest)) {
          return;
        }

        return {
          target: {
            id: closest.id,
            tooltipPos: [closest.x + tx + cx, closest.y + ty + cy]
          },
          offsetX: offsetX,
          offsetY: offsetY
        };
      } // 鼠标在标记点上
      ;

      _proto.handleMarkerOn = function handleMarkerOn(ev) {
        var lineId = ev.target.lineId;
        this.hoverLineId = lineId;
        this.handlePlotMove(ev);
        return true;
      } // 鼠标在线上
      ;

      _proto.handleBandOn = function handleBandOn(ev) {
        this.hoverLineId = ev.target.id;
        this.handlePlotMove(ev);
        return true;
      } // 鼠标在盘上
      ;

      _proto.handlePlotMove = function handlePlotMove(ev) {
        if (!this.hoverLineId) {
          return;
        }

        var payload = this.findClosestPoint(ev);
        payload && this.props.onmouseover(payload);
      };

      _proto.handleMarkerClick = function handleMarkerClick(ev) {
        var lineId = ev.target.lineId;
        this.hoverLineId = lineId;
        this.handlePlotClick(ev);
        return true;
      };

      _proto.handleBandClick = function handleBandClick(ev) {
        this.hoverLineId = ev.target.id;
        this.handlePlotClick(ev);
        return true;
      };

      _proto.handlePlotClick = function handlePlotClick(ev) {
        if (!this.hoverLineId) {
          return;
        }

        this.props.onclick(this.findClosestPoint(ev));
        return true;
      };

      _proto.handleMouseOut = function handleMouseOut() {
        this.props.onmouseout();
      };

      _proto.render = function render$$1() {
        var _this$state2 = this.state,
            radius = _this$state2.radius,
            center = _this$state2.center;

        if (!this.props.geoms.length) {
          return h('group');
        }

        return h('group', {
          position: center
        }, h('circle', {
          invisible: true,
          shape: {
            r: radius
          },
          cursor: this.hoveredLineId ? 'pointer' : null,
          onmouseover: this.handlePlotMove,
          onmousemove: this.handlePlotMove,
          onmouseout: this.handleMouseOut,
          onclick: this.handlePlotClick
        }), this.renderRadarAxis(), this.renderRadarLines());
      };

      _proto.renderRadarAxis = function renderRadarAxis() {
        var _this$state3 = this.state,
            measureDef = _this$state3.measureDef,
            dimensionDef = _this$state3.dimensionDef,
            scale = _this$state3.scale,
            dimTicks = _this$state3.dimTicks,
            radius = _this$state3.radius,
            scaleDef = _this$state3.scaleDef;
        var _this$props2 = this.props,
            facetX = _this$props2.facetX,
            facetY = _this$props2.facetY;
        var axisLine = facetX.axisLine;

        var _ref3 = facetY.measuresToGeoms ? facetY : facetX,
            gridLine = _ref3.gridLine;

        return h(radarAxis, {
          dimTicks: dimTicks,
          radius: radius,
          measureDef: measureDef,
          dimensionDef: dimensionDef,
          scaleDef: scaleDef,
          scale: scale,
          gridLineStyle: gridLine,
          axisLineStyle: axisLine
        });
      };

      _proto.renderRadarLines = function renderRadarLines() {
        var _this3 = this;

        var _this$state4 = this.state,
            lines = _this$state4.lines,
            radius = _this$state4.radius,
            shifting = _this$state4.shifting;
        var _this$props3 = this.props,
            process = _this$props3.process,
            animation = _this$props3.animation;
        var groupTransition = process === INIT && animation ? {
          duration: 1000,
          ease: Ease.EaseOutBounce,
          appear: function appear() {
            return {
              scale: [0, 0]
            };
          }
        } : null;
        return h('group', {
          scale: [1, 1],
          transition: groupTransition
        }, _.map(lines, function (line) {
          return h(LineRadar, _extends({}, _this3.props, line, {
            shifting: shifting,
            radius: radius,
            handleMarkerOn: _this3.handleMarkerOn,
            handleMarkerClick: _this3.handleMarkerClick,
            handleMouseOut: _this3.handleMouseOut,
            handleBandOn: _this3.handleBandOn,
            handleBandClick: _this3.handleBandClick
          }));
        }));
      };

      return RadarCell;
    }(Component);

    var TITLE_GAP = 3;
    var CELL_GAP = 5;
    var FONT_SIZE$1 = 10;
    var TITLE_PADDING = 3;
    var ROUND_RADIUS = 8;
    var DOUBLE_PADDING$2 = TITLE_PADDING * 2;
    var LINE_HEIGHT$7 = FONT_SIZE$1 + DOUBLE_PADDING$2;
    function TrendLine(_ref) {
      var trendLines = _ref.trendLines,
          _ref$horizontal = _ref.horizontal,
          horizontal = _ref$horizontal === void 0 ? true : _ref$horizontal;
      return h('group', null, map(trendLines, function (lineProp) {
        var data = lineProp.data,
            name = lineProp.name,
            borderStyle = lineProp.borderStyle,
            color = lineProp.color,
            _lineProp$lineWidth = lineProp.lineWidth,
            lineWidth = _lineProp$lineWidth === void 0 ? 1 : _lineProp$lineWidth,
            _lineProp$position = lineProp.position,
            position = _lineProp$position === void 0 ? [0, 0] : _lineProp$position,
            fontStyle = lineProp.fontStyle;

        var _width = calcTextDim(name, _extends({}, fontStyle, {
          fontSize: 12
        }))[0] * (FONT_SIZE$1 / 12) | 0;

        var _x = position[0],
            _y = position[1];
        var width = _width + DOUBLE_PADDING$2,
            height = LINE_HEIGHT$7,
            x = _x - width,
            y = _y - height / 2;
        return h('group', {
          silent: true
        }, // 线
        h('strokeLine', {
          z: GuideZLevel,
          shape: {
            points: data,
            style: LineStyle.NORMAL,
            horizontal: horizontal
          },
          style: {
            fill: 'none',
            stroke: color,
            lineWidth: lineWidth,
            lineDash: borderStyle === 'dashed' ? DASHED_ARRAY : null
          }
        }), // 标题半透明背景
        h('rect', {
          shape: {
            x: x,
            y: y,
            width: width,
            height: height,
            r: ROUND_RADIUS
          },
          style: {
            fill: color,
            opacity: 0.4
          }
        }), // 标题文字
        h('text', {
          position: [_x - TITLE_PADDING, _y],
          style: _extends({
            text: name,
            textAlign: 'right',
            textVerticalAlign: 'middle'
          }, fontStyle, {
            fontSize: FONT_SIZE$1,
            textFill: '#fff'
          })
        }));
      }));
    }

    /**
     * 获取分区内所有的趋势线Props集合
     * @param trendLines
     * @param bounds
     * @returns {Array}
     */

    var getAllTrendLinesInCell = function getAllTrendLinesInCell(trendLines, bounds) {
      if (trendLines.length === 0) {
        return [];
      }

      var cellTrendLines = [];
      var x = bounds.x,
          y = bounds.y,
          width = bounds.width; // 起始位置

      var titlePos = y + CELL_GAP;
      forEach(trendLines, function (trendLineList) {
        forEach(trendLineList, function (trendLine) {
          cellTrendLines.push(_extends({}, trendLine, {
            position: [x + width - CELL_GAP, titlePos + LINE_HEIGHT$7 / 2]
          }));
          titlePos += LINE_HEIGHT$7 + TITLE_GAP;
        });
      });
      return cellTrendLines;
    };

    var Cell =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Cell, _Component);

      function Cell(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.onclick = _this.onclick.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.onmouseover = _this.onmouseover.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.onmouseout = _this.onmouseout.bind(_assertThisInitialized(_assertThisInitialized(_this))); // eventHandler

        _this.clickHanlder = null;
        _this.mouseOverHandler = null;
        return _this;
      }

      var _proto = Cell.prototype;

      _proto.onclick = function onclick(ev) {
        this.clickHanlder && this.clickHanlder(ev);
      };

      _proto.onmouseover = function onmouseover(ev) {
        var _this$props = this.props,
            geoms = _this$props.geoms,
            facetX = _this$props.facetX,
            facetY = _this$props.facetY;

        var _diffFacet = diffFacet(facetX, facetY),
            baseFacet = _diffFacet.baseFacet,
            geomFacet = _diffFacet.geomFacet;

        if (!geoms.length) {
          return;
        }

        var _ref = geoms[0] || {},
            geom = _ref.geom;

        var openTooltipShared = geom.tooltip && geom.tooltip.shared && baseFacet.dimensions.length && geomFacet.hasMeasure; // 开启数据点提示呢，就从当前的分区里面找最新的那个点，作为

        if (openTooltipShared) {
          // @BI-40019 框选放大松开鼠标之后会触发mouseover的事件，
          // 这个时候图还没有刷新成功，但是props已经变了，
          // 由于框选之后每一个row的id都会重新计算，相当于拿新id去匹配旧的 zr instance，
          // 就找不到对应的target了。
          var tooltipInfo = this._getSharedTooltipInfo(ev);

          tooltipInfo.target && this.props.onmouseover(tooltipInfo);
        } else {
          // @BI-40019 原因同上
          var id = ev.target.id;

          var isTargetIdExist = _.some(geoms, function (_ref2) {
            var rows = _ref2.rows;
            return _.some(rows, function (row) {
              return id === row.id;
            });
          });

          isTargetIdExist && this.mouseOverHandler && this.mouseOverHandler(ev);
        }
      };

      _proto._getSharedTooltipInfo = function _getSharedTooltipInfo(ev) {
        var offsetX = ev.offsetX,
            offsetY = ev.offsetY;
        var _this$props2 = this.props,
            _this$props2$shifting = _this$props2.shifting,
            tx = _this$props2$shifting[0],
            ty = _this$props2$shifting[1],
            geoms = _this$props2.geoms,
            facetX = _this$props2.facetX,
            facetY = _this$props2.facetY;

        if (!geoms.length) {
          return;
        }

        var _diffFacet2 = diffFacet(facetX, facetY),
            inverted = _diffFacet2.inverted;

        var mousePos = inverted ? [offsetY - ty] : [offsetX - tx];
        var key = inverted ? 'y' : 'x';

        var getDistance = function getDistance(row) {
          return Math.abs(row[key] - mousePos);
        };

        var rows = reduce(geoms, function (rows, geom) {
          return [].concat(rows, geom.rows);
        }, []);
        var closest = rows[0];
        var target;

        if (closest) {
          reduce(rows, function (closestDis, row) {
            var dis = getDistance(row);

            if (dis < closestDis) {
              closest = row;
              return dis;
            }

            return closestDis;
          }, getDistance(closest));
          target = getZRInstanceById(closest.id, this.props.zr);
        }

        return {
          target: target,
          offsetX: offsetX,
          offsetY: offsetY
        };
      };

      _proto.onmouseout = function onmouseout() {
        this.mouseOverHandler = null;
        this.clickHanlder = null;
        this.props.onmouseout();
      };

      _proto.render = function render$$1() {
        var _this2 = this;

        var _this$props3 = this.props,
            bounds = _this$props3.bounds,
            onmouseover = _this$props3.onmouseover,
            onmouseout = _this$props3.onmouseout,
            onclick = _this$props3.onclick,
            geoms = _this$props3.geoms,
            highlights = _this$props3.highlights,
            trendLines = _this$props3.trendLines,
            facetX = _this$props3.facetX;
        return h('group', null, // 用于分区内全局响应事件
        h('rect', {
          shape: _extends({}, bounds),
          onmouseover: this.onmouseover,
          onmousemove: this.onmouseover,
          onmouseout: this.onmouseout,
          onclick: this.onclick,
          cursor: 'default',
          invisible: true
        }), map(geoms, function (_ref3) {
          var geom = _ref3.geom,
              rows = _ref3.rows,
              frameMeasure = _ref3.frameMeasure;
          var type = geom.type;
          var Graphic = Geom.getGeom(type);
          return h(Graphic, _extends({}, _this2.props, geom, {
            rows: rows,
            frameMeasure: frameMeasure,
            highlights: highlights,
            onmousemove: onmouseover,
            onmouseout: onmouseout,
            onclick: onclick,

            /**
             * NOTE: 我们面临的问题是，需要在分区的最外层统一接受处理非图形触发的鼠标事件如mouseover, click.etc，
             * NOTE: 故在render里加了一个invisible的rect用于接受这一类事件, 但是对于事件的处理, 则需要具体的Geom内部决定
             * NOTE: 即上层只负责响应，下层负责处理，由于上层获取不到下层的逻辑和状态，故在这里提供一个类似接口的东西
             * NOTE: 下层可以通过该接口注册事件响应的handler，这样在上层的rect触发事件时，即可使用下层的方法处理，下层自身可以获取需要的状态，从而解决问题
             */
            bindMouseOverHandler: function bindMouseOverHandler(handler) {
              if (_this2.mouseOverHandler !== handler) {
                _this2.mouseOverHandler = handler;
              }
            },
            bindClickHandler: function bindClickHandler(handler) {
              if (_this2.clickHanlder !== handler) {
                _this2.clickHanlder = handler;
              }
            }
          }));
        }), h(TrendLine, {
          trendLines: getAllTrendLinesInCell(trendLines, bounds),
          horizontal: !facetX.measuresToGeoms
        }));
      };

      return Cell;
    }(Component);

    var CellGroup =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(CellGroup, _Component);

      function CellGroup(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this.getGroup = _this.getGroup.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this._group = null;
        _this._startBounds = null;
        return _this;
      }

      var _proto = CellGroup.prototype;

      _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        if (!nextProps.enableMap && nextProps.isScrolling) {
          if (this._startBounds) {
            this.transformGroup(this._startBounds, nextProps.cells && nextProps.cells[0] && nextProps.cells[0].bounds);
            return false;
          } else {
            // 从 普通 到 滚动/缩放 的第一帧：
            // 记录bounds；正常刷新去掉高亮
            var cells = nextProps.cells;

            if (cells && cells[0]) {
              this._startBounds = cells[0].bounds;
            }

            return true;
          }
        }

        this._startBounds = null;

        this._group.attr({
          position: [0, 0],
          scale: [1, 1]
        });

        return true;
      } // change the group node's attr directly
      ;

      _proto.transformGroup = function transformGroup(start, now) {
        if (!start || !now) {
          return;
        }

        var scale = [now.width / start.width, now.height / start.height];

        this._group.attr({
          // no position 因为cell现在相对scrollArea是固定的
          scale: scale
        });
      };

      _proto.getGroup = function getGroup(node) {
        this._group = node;
        window._group = node;
      };

      _proto.render = function render$$1() {
        var _this2 = this;

        var _this$props = this.props,
            animation = _this$props.animation,
            isMobile = _this$props.isMobile,
            canPanShape = _this$props.canPanShape,
            enableMap = _this$props.enableMap,
            specialMode = _this$props.specialMode,
            rotation = _this$props.rotation,
            facetX = _this$props.facetX,
            facetY = _this$props.facetY,
            highlights = _this$props.highlights,
            handleMouseOver = _this$props.handleMouseOver,
            handleClick = _this$props.handleClick,
            dispatch = _this$props.dispatch,
            interaction = _this$props.interaction,
            zr = _this$props.zr,
            plot = _this$props.plotBounds,
            scroll = _this$props.scrollBounds,
            style = _this$props.style,
            rowCount = _this$props.rowCount,
            darkTheme = _this$props.darkTheme,
            process = _this$props.process,
            vanishChecker = _this$props.vanishChecker,
            fadeChecker = _this$props.fadeChecker,
            mirrorDom = _this$props.mirrorDom,
            root = _this$props.root,
            mapConfig = _this$props.mapConfig,
            rowMap = _this$props.rowMap,
            cellMap = _this$props.cellMap,
            inverted = _this$props.inverted,
            defs = _this$props.defs,
            panningCell = _this$props.panningCell;

        var children = _.map(cellMap, function (cell) {
          var geoms = cell.geoms,
              bounds = cell.bounds,
              rest = _objectWithoutPropertiesLoose(cell, ["geoms", "bounds"]);

          var isRadar = function isRadar() {
            return geoms[0] && geoms[0].geom.type === ChartLibrary.LINE_RADAR;
          };

          var CellCtr = enableMap ? MapCell : isRadar() ? RadarCell : Cell;
          var groupProps = {
            position: [-plot.x, -plot.y]
          };
          var groupClipShape = rectSubPixelOpt(bounds);

          if (panningCell && panningCell === rest.cellId) {
            groupClipShape.width = 0;
            groupClipShape.height = 0;
          } // clip 没更新


          groupProps.clip = {
            type: 'rect',
            shape: groupClipShape
          }; // todo, 套太多多多多多了
          // 把groupProps搬到Cell的group上

          return h('group', groupProps, h(CellCtr, _extends({}, rest, {
            rowCount: rowCount,
            animation: animation,
            isMobile: isMobile,
            canPanShape: canPanShape,
            enableMap: enableMap,
            specialMode: specialMode,
            rotation: rotation,
            interaction: interaction,
            plot: plot,
            scroll: scroll,
            facetX: facetX,
            facetY: facetY,
            defs: defs,
            // event handler
            handleMouseOver: handleMouseOver,
            handleClick: handleClick,
            onmouseover: _this2.props.onmouseover,
            onmousemove: _this2.props.onmouseover,
            onmouseout: _this2.props.onmouseout,
            onclick: _this2.props.onclick,
            // status & checker
            vanishChecker: vanishChecker,
            fadeChecker: fadeChecker,
            highlights: highlights,
            process: process,
            // map
            mapConfig: mapConfig,
            root: root,
            // 所有pane的container是this.dom
            mirrorDom: mirrorDom,
            // cell properties
            geoms: geoms,
            bounds: bounds,
            rowMap: rowMap,
            // special need
            zr: zr,
            dispatch: dispatch,
            shifting: [scroll.x, scroll.y],
            style: style,
            darkTheme: darkTheme,
            inverted: inverted
          })));
        });

        return h('group', {
          ref: this.getGroup
        }, children);
      };

      return CellGroup;
    }(Component);

    var ImagePlot =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(ImagePlot, _Component);

      function ImagePlot(props) {
        var _this;

        _this = _Component.call(this, props) || this;
        autoBind(_assertThisInitialized(_assertThisInitialized(_this)));
        return _this;
      }

      var _proto = ImagePlot.prototype;

      _proto.onmousemove = function onmousemove(ev) {
        var interaction = this.props.interaction;

        if (interaction.hasStage(STAGES.BOX_SELECT)) {
          return;
        }

        interaction.emitter.trigger('imagePointHover', this.getPayload(ev));
      };

      _proto.onclick = function onclick(ev) {
        this.props.interaction.emitter.trigger('imagePointSelected', this.getPayload(ev));
      };

      _proto.getPayload = function getPayload(ev) {
        var imageId = ev.target.style.imageId;
        var _this$props$scrollBou = this.props.scrollBounds,
            scrollX = _this$props$scrollBou.x,
            scrollY = _this$props$scrollBou.y;
        var pos = {
          x: ev.offsetX - scrollX,
          y: ev.offsetY - scrollY
        };
        return {
          imageId: imageId,
          pos: pos
        };
      };

      _proto.render = function render$$1() {
        var _this2 = this;

        if (!this.props.bigData) {
          return h('group');
        }

        var _this$props = this.props,
            stateId = _this$props.stateId,
            stampId = _this$props.stampId,
            _this$props$plotBound = _this$props.plotBounds,
            width = _this$props$plotBound.width,
            height = _this$props$plotBound.height,
            _this$props$scrollBou2 = _this$props.scrollBounds,
            transX = _this$props$scrollBou2.x,
            transY = _this$props$scrollBou2.y,
            scrollWidth = _this$props$scrollBou2.width,
            scrollHeight = _this$props$scrollBou2.height,
            interaction = _this$props.interaction;
        var viewBounds = {
          x: -transX,
          y: -transY,
          width: width,
          height: height,
          scrollWidth: scrollWidth,
          scrollHeight: scrollHeight
        };
        var images = getVisibleTiledImages(viewBounds, stampId, 'renderPlotTile', stateId);
        return h('group', {}, map(images || [], function (image) {
          return h('image', {
            style: _extends({}, image),
            onmousemove: _this2.onmousemove,
            onclick: _this2.onclick,
            onmouseout: interaction.hide
          });
        }));
      };

      return ImagePlot;
    }(Component);

    var ImagePlot$1 = connect(function (state) {
      return computedSelect(state);
    }, function (dispatch) {
      return {
        dispatch: dispatch
      };
    })(ImagePlot);

    function checkSinglePie(_ref) {
      var isMobile = _ref.isMobile,
          geoms = _ref.geoms,
          rowMap = _ref.rowMap;

      if (isMobile && geoms && geoms.length === 1 && geoms[0] && geoms[0].type === ChartLibrary.PIE) {
        var keys = Object.keys(rowMap);
        var oneRow = rowMap[keys[0]];

        if (!oneRow) {
          return false;
        }

        var center = oneRow.center;
        return _.every(rowMap, function (v) {
          return v.center === center;
        });
      }
    }

    function checkKPI(_ref2) {
      var cellMap = _ref2.cellMap,
          geoms = _ref2.geoms;
      return geoms.length === 1 && geoms[0].type === ChartLibrary.WORD_CLOUD && _.every(cellMap, function (_ref3) {
        var geoms = _ref3.geoms;
        return geoms.length === 1 && geoms[0].rows.length === 1;
      });
    }

    function checkChartSpecialMode(state) {
      if (checkSinglePie(state)) {
        return SpecialMode.SINGLE_PIE;
      }

      if (checkKPI(state)) {
        return SpecialMode.KPI;
      }

      return null;
    }

    var countTags = function countTags(tagFilter) {
      return Object.keys(tagFilter).reduce(function (n, f) {
        return n + tagFilter[f].length;
      }, 0);
    };

    var Plot =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(Plot, _Component);

      function Plot(props, ctx) {
        var _this;

        _this = _Component.call(this, props, ctx) || this;
        _this.state = {
          process: INIT,
          fadeChecker: getFadeChecker(props.sliderFilter)
        };

        _this.checkMapDom(props);

        return _this;
      }

      var _proto = Plot.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var newState = {
          process: null
        };
        var _this$props = this.props,
            oldTagFilter = _this$props.tagFilter,
            oldSlider = _this$props.sliderFilter;
        var tagFilter = nextProps.tagFilter,
            sliderFilter = nextProps.sliderFilter;

        if (tagFilter !== oldTagFilter) {
          newState.process = countTags(tagFilter) > countTags(oldTagFilter) ? HIDE : SHOW;
        }

        if (sliderFilter !== oldSlider) {
          newState.fadeChecker = getFadeChecker(sliderFilter);
        }

        this.checkMapDom(nextProps);
        this.setState(newState);
      };

      _proto.checkMapDom = function checkMapDom(props) {
        var zr = props.zr,
            root = props.root,
            plotBounds = props.plotBounds;
        var x = plotBounds.x,
            y = plotBounds.y,
            width = plotBounds.width,
            height = plotBounds.height;

        if (props.enableMap) {
          var zrRoot = zr.painter.getViewportRoot();
          this.dom = this.dom || getDom$1(root, width, height);
          this.dom.className = 'van-map-dom';
          this.dom.style.zIndex = 0; // @BI-32407 IE9地图图层遮住图表

          if (!this.mirrorDom) {
            this.mirrorDom = getDom$1(zrRoot, width, height);
            this.mirrorDom.style.visibility = 'hidden'; // @BI-32822:set visibility hidden to avoiding mirrorDom capture mouse event
          }

          this.mirrorDom.className = 'van-map-mirror-dom'; // this.mirrorDom.style.visibility = 'hidden'; // otherwise it captures event

          setPosition(this.dom, {
            x: x,
            y: y
          });
          setPosition(this.mirrorDom, {
            x: x,
            y: y
          });
          this.dom.style.width = width + 'px';
          this.dom.style.height = height + 'px';
          this.dom.style.overflow = 'hidden';
          this.mirrorDom.style.width = width + 'px';
          this.mirrorDom.style.height = height + 'px';
        } else {
          this.dom && remove(this.dom);
          this.mirrorDom && remove(this.mirrorDom);
          this.dom = this.mirrorDom = null;
        }
      };

      _proto.renderCellGroup = function renderCellGroup() {
        var _this$props2 = this.props,
            targets = _this$props2.targets,
            interaction = _this$props2.interaction;
        return h(CellGroup, _extends({}, this.props, this.state, {
          highlights: targets,
          onmouseover: interaction.show,
          onmousemove: interaction.show,
          onmouseout: interaction.hide,
          onclick: interaction.click,
          // map
          // map: this.props.map,
          root: this.dom,
          // 所有pane的container是this.dom
          mirrorDom: this.mirrorDom
        }));
      };

      _proto.render = function render$$1() {
        var _this$props3 = this.props,
            bigData = _this$props3.bigData,
            isMobile = _this$props3.isMobile,
            isScrolling = _this$props3.isScrolling,
            store = _this$props3.store,
            darkTheme = _this$props3.darkTheme,
            targets = _this$props3.targets,
            plotBounds = _this$props3.plotBounds,
            scrollBounds = _this$props3.scrollBounds,
            thumbOffsetX = _this$props3.thumbOffsetX,
            thumbOffsetY = _this$props3.thumbOffsetY,
            interaction = _this$props3.interaction;
        var plotArea = bigData ? h(ImagePlot$1, {
          store: store,
          interaction: interaction
        }) : this.renderCellGroup(targets, interaction); // 滚动绘图区

        return h(ControlledScrollArea, {
          // ...scrollProps,
          x: plotBounds.x,
          y: plotBounds.y,
          width: plotBounds.width,
          height: plotBounds.height,
          scrollWidth: scrollBounds.width,
          scrollHeight: scrollBounds.height,
          thumbOffsetX: thumbOffsetX,
          thumbOffsetY: thumbOffsetY,
          offsetX: scrollBounds.x,
          offsetY: scrollBounds.y,
          touch: isMobile,
          visible: isScrolling,
          borderColor: 'none',
          handleThumbPanY: interaction.plotScrollMoveY,
          handleThumbPanX: interaction.plotScrollMoveX,
          handleMousewheel: interaction.mouseWheel,
          handleTouchStart: interaction.plotTouchStart,
          handleTouchMove: interaction.plotTouchMove,
          handleTouchEnd: interaction.plotTouchEnd,
          handleMultipointStart: interaction.plotMultipointStart,
          handlePinch: interaction.plotPinch,
          handleMultipointEnd: interaction.plotMultipointEnd,
          handleTap: interaction.plotTap,
          handlePanStart: interaction.plotPanStart,
          handlePan: interaction.plotPan,
          handlePanEnd: interaction.plotPanEnd,
          darkTheme: darkTheme
        }, plotArea);
      };

      return Plot;
    }(Component);

    var mapStateToProps$1 = function mapStateToProps(state) {
      // FIXME 解耦：不需要传所有的
      var derived = computedSelect(state); // todo, different selector for mobile

      var isMobile = derived.isMobile,
          chartBounds = derived.chartBounds,
          plotBounds = derived.plotBounds,
          stateId = derived.stateId; // FixME

      var tooltip = derived.tooltip,
          pos = derived.pos,
          highlightNode = derived.highlightNode,
          rest = _objectWithoutPropertiesLoose(derived, ["tooltip", "pos", "highlightNode"]);

      return _extends({
        // trigger image reload
        stateId: stateId
      }, rest, {
        thumbOffsetX: isMobile ? null : chartBounds.x + chartBounds.width - plotBounds.x - plotBounds.width + THUMB_PADDING,
        thumbOffsetY: isMobile ? null : chartBounds.y + chartBounds.height - plotBounds.y - plotBounds.height + THUMB_PADDING,
        isScrolling: isMobile ? !!(state.hoverStage & STAGES.SCROLL_VISIBLE) : true,
        canPanShape: !!(state.hoverStage & ~STAGES.SELECTING),
        specialMode: checkChartSpecialMode(derived)
      });
    };
    var PlotComponent = Plot;
    var Plot$1 = connect(mapStateToProps$1, function (dispatch) {
      return {
        dispatch: dispatch // handleMouseOut: e => dispatch(act.hover.hide(e))
        // onMousewheel: e => dispatch(act.shared.mouseWheel(e))
        // touch event as effect
        // handleTouchStart: e => dispatch(act.hover.touchStart(e)),
        // handleTouchEnd: e => dispatch(act.hover.touchEnd(e)),
        //
        // handleMultipointStart: e => dispatch(act.hover.multipointStart(e)),
        // handlePinch: e => dispatch(act.hover.pinch(e)),
        // handleMultipointEnd: e => dispatch(act.hover.multipointEnd(e)),
        //
        // handleTap: e => dispatch(act.hover.tap(e)),
        //
        // handlePanStart: e => dispatch(act.hover.panStart(e)),
        // handlePan: e => dispatch(act.hover.pan(e)),
        // handlePanEnd: e => dispatch(act.hover.panEnd(e))

      };
    })(Plot);

    var LABEL_GAP$1 = 4; // 标签和线的间隔

    var CordonLine = function CordonLine(_ref) {
      var shape = _ref.shape,
          borderStyle = _ref.borderStyle,
          _ref$lineWidth = _ref.lineWidth,
          lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth,
          _ref$textOnTop = _ref.textOnTop,
          textOnTop = _ref$textOnTop === void 0 ? true : _ref$textOnTop,
          color = _ref.color,
          fontStyle = _ref.fontStyle,
          _ref$horizontal = _ref.horizontal,
          horizontal = _ref$horizontal === void 0 ? true : _ref$horizontal,
          name = _ref.name;
      var x1 = shape.x1,
          y1 = shape.y1,
          x2 = shape.x2,
          y2 = shape.y2;
      var position = [0, 0],
          textAlign = 'right',
          textVerticalAlign = 'top';

      if (horizontal) {
        position = [x1 + LABEL_GAP$1 * (textOnTop ? 1 : -1), y1 + LABEL_GAP$1];
        textAlign = textOnTop ? 'left' : 'right';
      } else {
        position = [x2 - LABEL_GAP$1, y2 + LABEL_GAP$1 * (textOnTop ? -1 : 1)];
        textVerticalAlign = textOnTop ? 'bottom' : 'top';
      }

      return h('group', null, h('line', {
        z: GuideZLevel,
        shape: shape,
        style: {
          stroke: color,
          lineWidth: lineWidth,
          lineDash: borderStyle === 'dashed' ? DASHED_ARRAY : null
        }
      }), h('text', {
        position: position,
        style: _extends({}, fontStyle, {
          text: name,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign
        })
      }));
    };

    var getCordonLineNodes = function getCordonLineNodes(_ref) {
      var facet = _ref.facet,
          plotBounds = _ref.plotBounds,
          scrollBounds = _ref.scrollBounds,
          defs = _ref.defs;
      var pw = plotBounds.width,
          ph = plotBounds.height,
          x = plotBounds.x,
          y = plotBounds.y;
      var sx = scrollBounds.x,
          sy = scrollBounds.y;
      var horizontal = facet.horizontal; // 警戒线长度

      var size = horizontal ? ph : pw;
      var nodesMap = facet.nodesMap;
      var measures = getAllMeasuresOnFacet$1(facet);

      var getLinePoint = function getLinePoint(pos) {
        var x1 = x,
            x2 = x + size,
            y1 = y,
            y2 = y + size;

        if (horizontal) {
          x1 = x2 = pos; // 考虑scroll的位置

          x1 += sx;
          x2 += sx;
        } else {
          y1 = y2 = pos;
          y1 += sy;
          y2 += sy;
        }

        return {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        };
      };

      var linePropsList = [];
      var getMeasureDefKeyFn = createGetMeasureDefKeyFunc$1(facet); // 一层一层地剥开你的心

      _.each(_.pick(nodesMap, function (node) {
        return node.leaf;
      }), function (node) {
        forEach(measures, function (measureId) {
          var measureDefKey = getMeasureDefKeyFn(measureId);
          var scaleDef = facet.scaleMap[measureDefKey]; // 值轴的measureDef

          var scale = getAxisScale(facet, measureDefKey, node);
          var _defs$measureId$cordo = defs[measureId].cordon,
              cordon = _defs$measureId$cordo === void 0 ? [] : _defs$measureId$cordo; // 指标的measureDef

          var _scaleDef$domain = scaleDef.domain,
              min = _scaleDef$domain[0],
              max = _scaleDef$domain[1];

          _.each(cordon, function (_ref2) {
            var value = _ref2.value,
                props = _objectWithoutPropertiesLoose(_ref2, ["value"]);

            value = +value;

            if (value >= min && value <= max) {
              var shape = getLinePoint(scale(value));
              linePropsList.push(_extends({
                shape: shape
              }, props));
            }
          });
        });
      });

      return map(linePropsList, function (props) {
        var fontStyle = props.fontStyle,
            name = props.name,
            _props$shape = props.shape,
            x1 = _props$shape.x1,
            y1 = _props$shape.y1;
        var textOnTop = true;

        var _calcTextDim = calcTextDim(name, fontStyle),
            tw = _calcTextDim[0],
            th = _calcTextDim[1]; // 默认标签在警戒线上方或者右方会溢出，因此调整标签位置到反方向


        if (horizontal && x1 + tw > x + pw || !horizontal && y1 - th < y) {
          textOnTop = false;
        }

        return h(CordonLine, _extends({}, props, {
          horizontal: horizontal,
          textOnTop: textOnTop
        }));
      });
    };

    var Cordon = function Cordon(_ref3) {
      var bigData = _ref3.bigData,
          facetX = _ref3.facetX,
          facetY = _ref3.facetY,
          plotBounds = _ref3.plotBounds,
          scrollBounds = _ref3.scrollBounds,
          defs = _ref3.defs;

      if (bigData) {
        return h('group');
      }

      return h('group', {
        clip: {
          type: 'rect',
          shape: _extends({}, plotBounds)
        }
      }, getCordonLineNodes({
        facet: facetX,
        plotBounds: plotBounds,
        scrollBounds: scrollBounds,
        defs: defs
      }), getCordonLineNodes({
        facet: facetY,
        plotBounds: plotBounds,
        scrollBounds: scrollBounds,
        defs: defs
      }));
    };

    var Cordon$1 = connect(function (state) {
      var _computedSelect = computedSelect(state),
          bigData = _computedSelect.bigData,
          facetX = _computedSelect.facetX,
          facetY = _computedSelect.facetY,
          plotBounds = _computedSelect.plotBounds,
          scrollBounds = _computedSelect.scrollBounds,
          defs = _computedSelect.defs;

      return {
        bigData: bigData,
        facetX: facetX,
        facetY: facetY,
        plotBounds: plotBounds,
        scrollBounds: scrollBounds,
        defs: defs
      };
    })(Cordon);

    var HOVER_SHAPE_KEY = 'hover_shape';
    var HOVER_SHAPE_STROKE = '#000';
    var HOVER_SHAPE_STROKE_LINE_WIDTH = 2;
    /**
     * 绘制大数据时的高亮形状
     * @param instance
     * @param x
     * @param y
     */

    var HoverShape = function HoverShape(_ref) {
      var instance = _ref.instance,
          _ref$x = _ref.x,
          x = _ref$x === void 0 ? 0 : _ref$x,
          _ref$y = _ref.y,
          y = _ref$y === void 0 ? 0 : _ref$y;
      var type = instance.type,
          shape = instance.shape,
          transform = instance.transform;
      return h(type, {
        key: HOVER_SHAPE_KEY,
        silent: true,
        shape: shape,
        position: [x + transform[4], y + transform[5]],
        style: {
          fill: 'none',
          stroke: HOVER_SHAPE_STROKE,
          lineWidth: HOVER_SHAPE_STROKE_LINE_WIDTH
        }
      });
    };

    var SELECT_RECT_KEY = 'select_rect';
    var SELECT_RECT_FILL = 'rgba(208, 212, 218, 0.2)';
    var SELECT_RECT_STROKE = 'rgba(208, 212, 218, 0.5)';
    var SELECT_RECT_STROKE_LINE_WIDTH = 2;
    /**
     * 框选矩形
     * @param initPos
     * @param pos
     * @returns {null}
     */

    var SelectRect = function SelectRect(_ref) {
      var initPos = _ref.initPos,
          pos = _ref.pos;
      return h("rect", {
        silent: true,
        key: SELECT_RECT_KEY,
        z: HoverLayerZ + 1,
        style: {
          fill: SELECT_RECT_FILL,
          stroke: SELECT_RECT_STROKE,
          lineWidth: SELECT_RECT_STROKE_LINE_WIDTH
        },
        shape: boundsOfDiagonalPoints(pos, initPos)
      });
    };

    var HIGHLIGHT_RECT_FILL = 'rgb(98, 179, 240)';
    var HIGHLIGHT_RECT_OPACITY = 0.2;
    var HIGHLIGHT_BACKGROUND_KEY = 'highlight_background';
    var HIGHLIGHT_LINE_STROKE = 'rgb(140, 140, 140)';
    /**
     * 高亮背景矩形
     * @param inverted
     * @param node
     * @param plotBounds
     * @param position
     */

    var getHighlightRectShape = function getHighlightRectShape(_ref) {
      var inverted = _ref.inverted,
          node = _ref.node,
          plotBounds = _ref.plotBounds,
          position = _ref.position;
      var width = plotBounds.width,
          height = plotBounds.height,
          x = plotBounds.x,
          y = plotBounds.y;
      var pos = node.pos,
          length = node.length;
      var px = position[0],
          py = position[1];
      return inverted ? {
        x: x,
        y: pos + py,
        width: width,
        height: length
      } : {
        x: pos + px,
        y: y,
        width: length,
        height: height
      };
    };
    /**
     * 计算高亮背景线
     * @param inverted
     * @param node
     * @param plotBounds
     * @param position
     * @returns {{x1: *, y1: *, x2: *, y2: *}}
     */

    var getHighlightLineShape = function getHighlightLineShape(_ref2) {
      var inverted = _ref2.inverted,
          node = _ref2.node,
          plotBounds = _ref2.plotBounds,
          position = _ref2.position;
      var width = plotBounds.width,
          height = plotBounds.height,
          x = plotBounds.x,
          y = plotBounds.y;
      var pos = node.pos,
          length = node.length;
      var px = position[0],
          py = position[1];
      var x1, x2, y1, y2;
      var c = pos + length / 2;

      if (inverted) {
        y1 = y2 = c + py;
        x1 = x;
        x2 = x + width;
      } else {
        x1 = x2 = c + px;
        y1 = y;
        y2 = y + height;
      }

      return {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      };
    };

    var HighlightBackground = function HighlightBackground(_ref3) {
      var highlightNode = _ref3.highlightNode,
          facetX = _ref3.facetX,
          facetY = _ref3.facetY,
          geoms = _ref3.geoms,
          plotBounds = _ref3.plotBounds,
          position = _ref3.position;

      var _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet,
          inverted = _diffFacet.inverted;

      var node = baseFacet.nodesMap[highlightNode];

      if (!node) {
        return h("group", null);
      } // 使用折线或者矩形块


      var useLine = _.every(geoms, function (geom) {
        return geom.type === ChartLibrary.LINE || geom.type === ChartLibrary.AREA;
      });

      if (useLine) {
        var _getHighlightLineShap = getHighlightLineShape({
          node: node,
          plotBounds: plotBounds,
          position: position,
          inverted: inverted
        }),
            x1 = _getHighlightLineShap.x1,
            y1 = _getHighlightLineShap.y1,
            x2 = _getHighlightLineShap.x2,
            y2 = _getHighlightLineShap.y2;

        return h(Animate$$1, {
          start: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          },
          enter: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          },
          update: {
            x1: [x1],
            y1: [y1],
            x2: [x2],
            y2: [y2],
            timing: {
              ease: Ease.Ease,
              duration: 200
            }
          }
        }, function (shape) {
          return h("line", {
            silent: true,
            key: HIGHLIGHT_BACKGROUND_KEY,
            z: ShadowLayerZ,
            shape: shape,
            style: {
              stroke: HIGHLIGHT_LINE_STROKE
            }
          });
        });
      } else {
        var _getHighlightRectShap = getHighlightRectShape({
          node: node,
          plotBounds: plotBounds,
          position: position,
          inverted: inverted
        }),
            x = _getHighlightRectShap.x,
            y = _getHighlightRectShap.y,
            width = _getHighlightRectShap.width,
            height = _getHighlightRectShap.height;

        return h(Animate$$1, {
          start: {
            x: x,
            y: y
          },
          enter: {
            x: x,
            y: y
          },
          update: {
            x: [x],
            y: [y],
            timing: {
              ease: Ease.Ease,
              duration: 200
            }
          }
        }, function (_ref4) {
          var x = _ref4.x,
              y = _ref4.y;
          return h("rect", {
            silent: true,
            key: HIGHLIGHT_BACKGROUND_KEY,
            z: ShadowLayerZ,
            shape: {
              x: x,
              y: y,
              width: width,
              height: height
            },
            style: {
              fill: HIGHLIGHT_RECT_FILL,
              opacity: HIGHLIGHT_RECT_OPACITY
            }
          });
        });
      }
    };

    var Hover = function Hover(_ref) {
      var bigData = _ref.bigData,
          x = _ref.x,
          y = _ref.y,
          plotBounds = _ref.plotBounds,
          pos = _ref.pos,
          initPos = _ref.initPos,
          instance = _ref.tooltip.instance,
          hoverStage = _ref.hoverStage,
          highlightNode = _ref.highlightNode,
          facetX = _ref.facetX,
          facetY = _ref.facetY,
          geoms = _ref.geoms;
      return h("group", {
        clip: {
          type: 'rect',
          shape: plotBounds
        }
      }, bigData && instance ? h(HoverShape, {
        instance: instance,
        x: x,
        y: y
      }) : null, hoverStage & STAGES.BOX_SELECT && initPos ? h(SelectRect, {
        initPos: initPos,
        pos: pos
      }) : null, highlightNode != null && h(HighlightBackground, {
        plotBounds: plotBounds,
        facetX: facetX,
        facetY: facetY,
        geoms: geoms,
        highlightNode: highlightNode,
        position: [x, y]
      }));
    };

    var Hover$1 = connect(function (state) {
      var _computedSelect = computedSelect(state),
          bigData = _computedSelect.bigData,
          scrollProps = _computedSelect.scrollProps,
          facetX = _computedSelect.facetX,
          facetY = _computedSelect.facetY,
          plotBounds = _computedSelect.plotBounds,
          scrollBounds = _computedSelect.scrollBounds,
          pos = _computedSelect.pos,
          initPos = _computedSelect.initPos,
          tooltip = _computedSelect.tooltip,
          hoverStage = _computedSelect.hoverStage,
          highlightNode = _computedSelect.highlightNode,
          geoms = _computedSelect.geoms;

      return {
        bigData: bigData,
        x: scrollBounds.x,
        y: scrollBounds.y,
        plotBounds: plotBounds,
        scrollProps: scrollProps,
        facetX: facetX,
        facetY: facetY,
        highlightNode: highlightNode,
        tooltip: tooltip,
        hoverStage: hoverStage,
        initPos: initPos,
        pos: pos,
        geoms: geoms
      };
    })(Hover);

    /** ↑↑↑↑ 看上面，乱不乱  */

    var Chart = function Chart(props) {
      return h("group", null, h(Facet$2, props), h(Plot$1, props), h(Cordon$1, props), h(Legend$1, props), h(Hover$1, props), h(Tooltip$2, props));
    };

    var CROSS_COLOR = '#98B4CD';

    var CrossLine = function CrossLine(_ref) {
      var pos = _ref.pos,
          plotBounds = _ref.plotBounds,
          show = _ref.show;
      var x = plotBounds.x,
          y = plotBounds.y,
          width = plotBounds.width,
          height = plotBounds.height;
      var hInvisible = !show || pos.y < y || pos.y > y + height;
      var vInvisible = !show || pos.x < x || pos.x > x + width;
      return h("group", null, h("line", {
        silent: true,
        zlevel: StaticLayerZ,
        invisible: hInvisible,
        shape: {
          x1: x,
          x2: x + width,
          y1: pos.y,
          y2: pos.y
        },
        style: {
          stroke: CROSS_COLOR
        }
      }), h("line", {
        silent: true,
        zlevel: StaticLayerZ,
        invisible: vInvisible,
        shape: {
          x1: pos.x,
          x2: pos.x,
          y1: y,
          y2: y + height
        },
        style: {
          stroke: CROSS_COLOR
        }
      }));
    };

    var AnimateCrossLine = function AnimateCrossLine(_ref2) {
      var active = _ref2.active,
          activating = _ref2.activating,
          _ref2$pos = _ref2.pos,
          pos = _ref2$pos === void 0 ? {} : _ref2$pos,
          plotBounds = _ref2.plotBounds;
      var x = pos.x,
          y = pos.y;
      return h(Animate$$1, {
        show: active,
        start: {
          x: x,
          y: y,
          show: true
        },
        enter: [{
          show: true,
          timing: {
            duration: 0
          }
        }, {
          show: false,
          timing: {
            delay: 1000,
            duration: 0
          }
        }],
        update: activating ? {
          x: x,
          y: y,
          show: true,
          timing: {
            duration: 0
          }
        } : [{
          x: [x],
          y: [y],
          show: true,
          timing: {
            duration: 200
          }
        }, {
          show: false,
          timing: {
            delay: 1200,
            duration: 0
          }
        }],
        leave: {
          timing: {
            duration: 0
          }
        }
      }, function (_ref3) {
        var x = _ref3.x,
            y = _ref3.y,
            show = _ref3.show;
        return h(CrossLine, {
          pos: {
            x: x,
            y: y
          },
          plotBounds: plotBounds,
          show: !!show
        });
      });
    };

    var CrossLine$1 = connect(function (state) {
      var _computedSelect = computedSelect(state),
          hoverStage = _computedSelect.hoverStage,
          plotBounds = _computedSelect.plotBounds,
          eventPos = _computedSelect.eventPos,
          targetCenter = _computedSelect.targetCenter,
          showCrossLine = _computedSelect.showCrossLine;

      var followTouch = hoverStage === STAGES.SELECTING;
      return {
        active: !!(hoverStage & STAGES.SELECT) && showCrossLine,
        activating: followTouch,
        plotBounds: plotBounds,
        pos: followTouch ? eventPos : targetCenter
      };
    })(AnimateCrossLine);

    var MobileChart = function MobileChart(props) {
      return h("group", {
        ontap: props.handleBlankTap
      }, h(Facet$2, props), h(Plot$1, props), h(Cordon$1, props), h(Legend$1, props), h(Hover$1, props), h(CrossLine$1, props));
    };

    var instances$2 = {};
    /**
     * clear lineEffectLayer
     * @param zr
     */

    var clearLineEffectLayer = function clearLineEffectLayer(zr) {
      if (!zr) {
        return;
      }

      var layers = zr.painter._layers;
      var effectLineLayer = layers && layers[EffectLineZLevel];
      effectLineLayer && effectLineLayer.clear(true);
    };

    function normalizeOptions(options$$1, id) {
      // normalize string/dom to options.container
      if (typeof options$$1 === 'string' || options$$1.nodeType === 1) {
        options$$1 = {
          container: options$$1
        };
      } // container


      var dom;

      if (typeof options$$1.container === 'string') {
        dom = document.getElementById(options$$1.container);
      } else {
        // here may be a special target in non-browser env
        // TODO, prepare for map
        dom = options$$1.container;
      } // may not exist in non-browser env


      if (dom.setAttribute && dom.style) {
        dom.style.overflow = 'hidden';
        dom.setAttribute('van-dom-id', id);
      } // width & height


      var size;

      if (options$$1.width && options$$1.height) {
        size = {
          width: options$$1.width,
          height: options$$1.height
        };
      } else {
        size = getDomSize(dom);
      }

      return {
        // todo: use chart.options instead of assigning directly?
        options: options$$1,
        dom: dom,
        size: size,
        mobile: options$$1.mobile || env$2.touchEventsSupported,
        orientation: options$$1.orientation && options$$1.orientation.toLowerCase() || env$2.getOrientation()
      };
    }

    var EE =
    /*#__PURE__*/
    function (_Eventful) {
      _inheritsLoose(EE, _Eventful);

      function EE() {
        return _Eventful.apply(this, arguments) || this;
      }

      var _proto = EE.prototype;

      _proto.setInfo = function setInfo(info) {
        this._$eventProcessor.info = info;
      };

      _proto.on = function on(event) {
        var _Eventful$prototype$o;

        var _event$split = event.split(':'),
            type = _event$split[0],
            evName = _event$split[1];

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return (_Eventful$prototype$o = _Eventful.prototype.on).call.apply(_Eventful$prototype$o, [this, type, evName].concat(args));
      };

      _proto.trigger = function trigger(event, ev) {
        var _event$split2 = event.split(':'),
            type = _event$split2[0],
            evName = _event$split2[1];

        this.setInfo(evName);

        if (type && evName) {
          ev = _extends({}, ev, {
            componentType: type,
            eventType: evName
          });
        }

        return _Eventful.prototype.trigger.call(this, type, ev);
      };

      return EE;
    }(Eventful);

    var EventProcessor =
    /*#__PURE__*/
    function () {
      function EventProcessor() {}

      var _proto2 = EventProcessor.prototype;

      _proto2.normalizeQuery = function normalizeQuery(query) {
        return query;
      };

      _proto2.filter = function filter$$1(eventType, query) {
        if (!query || query === this.info) {
          return true;
        } // console.warn('filtered', eventType, query, this.info);


        return false;
      };

      return EventProcessor;
    }();

    var Chart$1 =
    /*#__PURE__*/
    function () {
      /**
       *
       * @param {(string|HTMLElement|Object)} options        - config options or domId/dom or canvas
       * @param {(string|HTMLElement)} options.container     - domId/dom or canvas
       * @param {number} [options.width]                     - container width
       * @param {number} [options.height]                    - container height
       * @param {boolean} [options.mobile=auto]              - mobile mode
       * @param {boolean} [options.disableDomListener=false] - disable dom event listener
       * @param {string} [options.orientation=auto]          - mobile orientation
       * @param {Object} [data]
       */
      function Chart$$1(options$$1, data) {
        var _this = this;

        this.id = guid();
        this.emitter = new EE(new EventProcessor());
        this.zr = null;

        this._isSpecialInteractionMode = function () {
          return _this._specialInteractionMode;
        };

        instances$2[this.id] = this;
        assign(this, normalizeOptions(options$$1, this.id));
        this.store = initStore({
          mobile: this.isMobile(),
          extra: {
            emitter: this.emitter,
            isSpecialInteractionMode: this._isSpecialInteractionMode
          }
        });
        addComputedSelector(this.id);
        data && this.refreshData(data);
      }

      var _proto3 = Chart$$1.prototype;

      /**
       * @interface 图表刷新数据接口
       * @param data
       */
      _proto3.refreshData = function refreshData(data) {
        this._updateState(data);

        if (!this.zr) {
          this.render();
        }
      }
      /**
       * 统一的更新chart.state
       * @param state
       * @private
       */
      ;

      _proto3._updateState = function _updateState(state) {
        // clear line effect layer when update chart data
        clearLineEffectLayer(this.zr);
        state = reconstruct(state);
        state.chartId = this.id; // todo, state or instance property

        if (this.isMobile()) {
          // Should accept all values in the new state.
          // But we have some compatibility issues...
          // orientation from server is empty
          state.orientation = state.orientation || this.orientation; // legacy: ignore size from server

          state.size = this.size;
        } else {
          if (state.size) {
            var _state$size = state.size,
                width = _state$size.width,
                height = _state$size.height;

            this._updateRenderSize(width, height);
          }
        }

        this.store.dispatch(Act.init(state)); // ---------------------------------------------
        // log some flags to indicate mobile interaction

        if (this.isMobile()) {
          this._specialInteractionMode = state.mapConfig.enabled || checkSinglePie(computedSelect(this.store.getState()));
        }
      };

      _proto3.isMobile = function isMobile() {
        return this.mobile;
      };

      _proto3.getSize = function getSize() {
        return this.size;
      };

      _proto3.getWidth = function getWidth() {
        return this.size.width;
      };

      _proto3.getHeight = function getHeight() {
        return this.size.height;
      }
      /**
       * Size Object
       * @typedef {object} SizeLike
       * @property {string} [orientation]
       * @property {number} width
       * @property {number} height
       */

      /**
       * 图表前台resize接口
       * @param {number|SizeLike} [w]
       * @param {number} [h]
       */
      ;

      _proto3.resize = function resize(w, h$$1) {
        var width, height, orientation;

        if (typeof w === 'object') {
          width = w.width;
          height = w.height;
          orientation = w.orientation;
        } else if (w && h$$1) {
          width = w;
          height = h$$1;
        } else {
          var size = getDomSize(this.dom); // todo, temp for mobile dev

          this.isMobile() && console.log('get size from dom: ', size);
          width = size.width;
          height = size.height;
        } // 防止传进非整数size
        // 因为我们从dom上获取的是整数size
        // 有个问题值得注意，小数如何取整：
        // 经过简单试验，clientHeight, clientWidth是round
        // 我们getDomSize里面，首先取clientXXX
        // 没有的话对css取的size是floor，zr/我们以前，都是这个逻辑……
        // 所以设置小数size很混乱，不要设置小数size
        //
        // 同时现在移动端设置webview也取了下floor，防止出现sub pixel的情况，引起重复resize


        width = Math.round(width);
        height = Math.round(height);
        var _this$size = this.size,
            ow = _this$size.width,
            oh = _this$size.height; // todo, temp for mobile dev

        this.isMobile() && console.log("[" + ow + ", " + oh + "] -> [" + width + ", " + height + "]");

        this._updateRenderSize(width, height);

        if (this.isMobile()) {
          if (orientation) {
            var hasLand = orientation.toLowerCase().indexOf('landscape') !== -1;
            this.orientation = hasLand ? 'landscape' : 'portrait';
          } else {
            this.orientation = env$2.getOrientation();
          }
        }

        this.store.dispatch(Act.resize({
          width: width,
          height: height,
          orientation: this.orientation
        }));
      };

      _proto3._updateRenderSize = function _updateRenderSize(width, height) {
        var _this$size2 = this.size,
            ow = _this$size2.width,
            oh = _this$size2.height;

        if (ow !== width || oh !== height) {
          this.size = {
            width: width,
            height: height
          };
          this.zr && this.zr.resize(this.size);
        }
      } // 需要调用render是不是多余了？
      ;

      _proto3.render = function render$$1() {
        if (this.zr) {
          console.warn('do not render chart twice.');
          return;
        }

        var store = this.store,
            root = this.dom;

        var zr = render.initZr(root, this.size); // for line effect


        zr.configLayer(EffectLineZLevel, {
          motionBlur: true,
          lastFrameAlpha: 0.95
        });
        var mobile = this.isMobile();
        var Interaction = mobile ? Touch : Mouse;
        var interaction = new Interaction({
          store: store,
          emitter: this.emitter
        });
        this.interaction = interaction;
        var props = {
          store: store,
          interaction: interaction,
          root: root,
          zr: zr
        };

        if (mobile) {
          this.zr = render(h(MobileChart, assign({}, props, {
            handleBlankTap: interaction.handleBlankTap
          })), root, {
            zr: zr,
            touch: true,
            disableDomListener: this.options.disableDomListener
          });
        } else {
          this.zr = render(h(Chart, props), root, {
            zr: zr
          });
        } // TODO, init sequence


        interaction.setZr(this.zr);

        this._attachActionListener(mobile);
      };

      _proto3._attachActionListener = function _attachActionListener(isMobile) {
        var _this2 = this;

        var actions = Actions;

        if (isMobile) {
          actions = MobileActions;
          var proxy = this.zr.handler.proxy;
          this.emitter.on('touchEvent', proxy.dispatch, proxy);
        }

        _.each(actions, function (fn, k) {
          _this2.emitter.on(k, fn, _this2);
        });
      };

      _proto3.getScrollBounds = function getScrollBounds() {
        var state = this.getDerived();
        var horizontalEdge,
            verticalEdge,
            shouldNativeHandle = false;

        var checkHandle = function checkHandle(state) {
          // 跳过选中等状态
          if (state.hoverStage !== STAGES.NORMAL) {
            return false;
          } // 跳过空坐标轴


          if (isEmptyFacet(state.facetX) && isEmptyFacet(state.facetY)) {
            return false;
          }

          return true;
        };

        var getPctByOffset = function getPctByOffset(length, scrollLength, offset) {
          var v = offset / (length - scrollLength) || 0;

          if (isFinite(v)) {
            return v;
          }

          return 0;
        };

        var plotBounds = state.plotBounds,
            scrollBounds = state.scrollBounds; // 选中 或 空坐标轴 -> 事件全给图表，不用原生处理
        // 没有边界冲突逻辑

        if (checkHandle(state)) {
          var pctX = getPctByOffset(plotBounds.width, scrollBounds.width, scrollBounds.x);
          var pctY = getPctByOffset(plotBounds.height, scrollBounds.height, scrollBounds.y);

          if (scrollBounds.width > plotBounds.width) {
            if (pctX <= 0) {
              horizontalEdge = 'left';
            } else if (pctX >= 1) {
              horizontalEdge = 'right';
            } else {
              horizontalEdge = 'middle';
            }
          }

          if (scrollBounds.height > plotBounds.height) {
            if (pctY <= 0) {
              verticalEdge = 'top';
            } else if (pctY >= 1) {
              verticalEdge = 'bottom';
            } else {
              verticalEdge = 'middle';
            }
          } // 只有上下冲突逻辑，左右在横屏时候是按钮
          // 下一步迭代优化把scroll框同步给native


          shouldNativeHandle = !( // horizontalEdge === 'middle' &&
          verticalEdge === 'middle');
        }

        return {
          shouldNativeHandle: shouldNativeHandle,
          horizontalEdge: horizontalEdge,
          verticalEdge: verticalEdge,
          bounds: [_extends({}, plotBounds, {
            contentSize: {
              width: scrollBounds.width,
              height: scrollBounds.height
            },
            contentOffset: {
              x: scrollBounds.x,
              y: scrollBounds.y
            }
          })]
        };
      };

      _proto3.getInteractionMode = function getInteractionMode() {
        if (this._isSpecialInteractionMode()) {
          return 'select';
        } else {
          var _this$store$getState = this.store.getState(),
              hoverStage = _this$store$getState.hoverStage;

          var isSelect = hoverStage & STAGES.SELECT;
          return isSelect && 'select';
        }
      };

      _proto3.findPointData = function findPointData(obj) {
        if (obj === void 0) {
          obj = {};
        }

        var pos = {
          x: obj.x || obj.offsetX,
          y: obj.y || obj.offsetY
        };

        if (!(pos.x > 0 && pos.y > 0)) {
          return;
        }

        var action = this.interaction.getHighlightActionByPos(pos, true);

        if (!action) {
          return;
        }

        var _action$payload = action.payload,
            id = _action$payload.targetId,
            tooltip = _action$payload.tooltip;

        if (id) {
          var _this$interaction$_ge = this.interaction._getPointInfo({
            id: id
          }),
              row = _this$interaction$_ge.row,
              measure = _this$interaction$_ge.measure,
              metaData = _this$interaction$_ge.metaData;

          return {
            tooltipText: formatTooltipLines(tooltip),
            row: row,
            measure: measure,
            metaData: metaData,
            pos: pos
          };
        }
      };

      _proto3.forceRepaint = function forceRepaint() {
        this.zr._needsRefresh = false;
        this.zr.painter.refresh(true);
        this.zr._needsRefresh = false;
      };

      _proto3.getDerived = function getDerived() {
        return computedSelect(this.store.getState());
      };

      _proto3.trigger = function trigger(eventName, event) {
        return this.emitter.trigger(eventName, event);
      };

      _proto3.on = function on(eventName, eventHandler, context) {
        return this.emitter.on(eventName, eventHandler, context);
      };

      _proto3.off = function off(eventName, eventHandler) {
        return this.emitter.off(eventName, eventHandler);
      };

      _proto3.dispose = function dispose$$1() {
        delete instances$2[this.id];
        this.interaction && this.interaction.dispose();
        this.emitter && this.emitter.off();
        disposeComputedSelector(this.id); // todo, dispose map

        this.zr && dispose$1(this.zr);
        this.emitter = this.store = this.zr = null;
      };

      return Chart$$1;
    }();

    Chart$1.normalizeOptions = normalizeOptions;
    Chart$1.util = util; // convenient for dev

    Chart$1._instances = instances$2;

    var AxisTile =
    /*#__PURE__*/
    function (_Axis) {
      _inheritsLoose(AxisTile, _Axis);

      function AxisTile(props, context) {
        return _Axis.call(this, props, context) || this;
      }

      var _proto = AxisTile.prototype;

      _proto.getDimensionTicks = function getDimensionTicks() {
        var dimensionTicksList = this.state.dimensionTicksList;
        var tileBounds = this.props.tileBounds;
        return _.map(dimensionTicksList, function (ticks) {
          return _.filter(ticks, function (tick) {
            return isBoundsOverlapped(tileBounds, tick.bounds);
          });
        });
      };

      _proto.render = function render() {
        var _this$props$tileBound = this.props.tileBounds,
            x = _this$props$tileBound.x,
            y = _this$props$tileBound.y;
        var _this$state$viewBound = this.state.viewBounds,
            transX = _this$state$viewBound.x,
            transY = _this$state$viewBound.y;
        return h('group', {
          position: [-x + transX, -y + transY]
        }, this.renderScrollArea());
      };

      return AxisTile;
    }(Axis$1);

    var PlotTile =
    /*#__PURE__*/
    function (_PlotComponent) {
      _inheritsLoose(PlotTile, _PlotComponent);

      function PlotTile(props, context) {
        return _PlotComponent.call(this, props, context) || this;
      }

      var _proto = PlotTile.prototype;

      _proto.render = function render() {
        var _this$props = this.props,
            _this$props$tileBound = _this$props.tileBounds,
            x = _this$props$tileBound.x,
            y = _this$props$tileBound.y,
            _this$props$plotBound = _this$props.plotBounds,
            transX = _this$props$plotBound.x,
            transY = _this$props$plotBound.y;
        return h('group', {
          position: [-x + transX, -y + transY]
        }, this.renderCellGroup());
      };

      return PlotTile;
    }(PlotComponent);

    var TileChart =
    /*#__PURE__*/
    function (_Chart) {
      _inheritsLoose(TileChart, _Chart);

      function TileChart() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _Chart.call.apply(_Chart, [this].concat(args)) || this;
        _this.shapeMap = {};
        _this.visibleCellMap = {};
        _this.stateId = 0;
        return _this;
      }

      var _proto = TileChart.prototype;

      _proto.getVisibleRows = function getVisibleRows(geomType, rows, tileBounds) {
        var geom = Geom.getGeom(geomType); //线和面的特殊之处在于点和点之间有连线

        if (geomType == ChartLibrary.LINE || geomType == ChartLibrary.AREA || geomType == ChartLibrary.TREE_MAP || geomType == ChartLibrary.LINE_RADAR || geomType == ChartLibrary.FORCE_POINT || geomType == ChartLibrary.MULTI_PIE || geomType == ChartLibrary.WORD_CLOUD) {
          return rows;
        }

        return _.filter(rows, function (row) {
          var shapeBounds = geom.getShapeBounds(row);
          return isBoundsOverlapped(tileBounds, shapeBounds);
        });
      };

      _proto.getVisibleCellMap = function getVisibleCellMap(cellMap, tileBounds) {
        var _this2 = this;

        var visibleCellMap = _.filter(cellMap, function (cell) {
          return isBoundsOverlapped(tileBounds, cell.bounds);
        });

        return _.map(visibleCellMap, function (cell) {
          return _extends({}, cell, {
            geoms: _.map(cell.geoms, function (geom) {
              return _extends({}, geom, {
                rows: _this2.getVisibleRows(geom.geom.type, geom.rows, tileBounds)
              });
            })
          });
        });
      };

      _proto.createExportRoot = function createExportRoot(root, imageBounds) {
        var width = imageBounds.width;
        var height = imageBounds.height;

        if (!root) {
          root = root || createCanvas$1();
          var newDomStyle = root.style;

          if (newDomStyle) {
            newDomStyle.position = 'absolute';
            newDomStyle.left = 0;
            newDomStyle.top = 0;
            newDomStyle.width = width + 'px';
            newDomStyle.height = height + 'px';
          }

          this.dom.appendChild(root);
        }

        root.width = width * window.devicePixelRatio;
        root.height = height * window.devicePixelRatio;
        return root;
      };

      _proto.getComputedState = function getComputedState() {
        var state = this.getDerived();

        var _state$facetX = state.facetX,
            xStops = _state$facetX.stopNodes,
            xData = _state$facetX.data,
            xNodesMap = _state$facetX.nodesMap,
            restX = _objectWithoutPropertiesLoose(_state$facetX, ["stopNodes", "data", "nodesMap"]),
            _state$facetY = state.facetY,
            yStops = _state$facetY.stopNodes,
            yData = _state$facetY.data,
            yNodesMap = _state$facetY.nodesMap,
            restY = _objectWithoutPropertiesLoose(_state$facetY, ["stopNodes", "data", "nodesMap"]),
            cellMap = state.cellMap,
            rowMap = state.rowMap,
            geoms = state.geoms,
            tooltip = state.tooltip,
            targets = state.targets,
            hoverStage = state.hoverStage,
            initPos = state.initPos,
            restState = _objectWithoutPropertiesLoose(state, ["facetX", "facetY", "cellMap", "rowMap", "geoms", "tooltip", "targets", "hoverStage", "initPos"]);

        var cleanGeoms = _.map(state.geoms, function (geom) {
          var frames = geom.frames,
              color = geom.color,
              size = geom.size,
              granularity = geom.granularity,
              data = geom.data,
              dataMap = geom.dataMap,
              rest = _objectWithoutPropertiesLoose(geom, ["frames", "color", "size", "granularity", "data", "dataMap"]);

          return rest;
        });

        var _xNodesMap$Root = xNodesMap['..root'],
            xChildren = _xNodesMap$Root.children,
            restRootX = _objectWithoutPropertiesLoose(_xNodesMap$Root, ["children"]);

        var _yNodesMap$Root = yNodesMap['..root'],
            yChildren = _yNodesMap$Root.children,
            restRootY = _objectWithoutPropertiesLoose(_yNodesMap$Root, ["children"]);

        return _extends({
          stateId: this.id + this.stateId++,
          facetX: _extends({
            nodesMap: {
              '..root': restRootX
            }
          }, restX),
          facetY: _extends({
            nodesMap: {
              '..root': restRootY
            }
          }, restY),
          geoms: cleanGeoms
        }, restState);
      };

      _proto.getAxisClickedInfo = function getAxisClickedInfo(tile, position, facetKey, clickedInfo) {
        facetKey = facetKey == RENDER_FACET_X ? 'facetX' : 'facetY';
        var props = mapStateToProps(this.store.getState());
        var facet = props[facetKey];

        var _this$getFacetTileBou = this.getFacetTileBounds(tile.x, tile.y, facet),
            tileX = _this$getFacetTileBou.x,
            tileY = _this$getFacetTileBou.y;

        var zr = this.shapeMap[tile.x + '+' + tile.y + '+' + facetKey];
        var shapes = zr.storage.getDisplayList();

        _.some(shapes, function (shape) {
          if (shape && shape.key && shape.contain(position.x - tileX, position.y - tileY)) {
            clickedInfo.facet = facetKey;
            clickedInfo.id = shape.key;
            return true;
          }
        });
      };

      _proto.getPlotHoverInfo = function getPlotHoverInfo(tile, position, hoverInfo) {
        var _this$getDerived = this.getDerived(),
            rowMap = _this$getDerived.rowMap;

        var _this$getPlotTileBoun = this.getPlotTileBounds(tile.x, tile.y),
            tileX = _this$getPlotTileBoun.x,
            tileY = _this$getPlotTileBoun.y;

        var zr = this.shapeMap[tile.x + '+' + tile.y];

        if (!zr) {
          return;
        }

        var shapes = zr.storage.getDisplayList();
        var target; //从最上面的图形开始找

        for (var i = shapes.length - 1; i >= 0 && !target; i--) {
          var shape = shapes[i];

          if (shape && shape.id && shape.contain(position.x - tileX, position.y - tileY)) {
            var row = rowMap[shape.id];

            if (row) {
              target = shape;
            }
          }
        }

        if (!target) {
          var minDistance = Number.MAX_VALUE;

          _.each(this.visibleCellMap[tile.x + '+' + tile.y], function (cell) {
            _.each(cell.geoms, function (geom) {
              var geomType = geom.geom.type;

              if (geomType == ChartLibrary.LINE || geomType == ChartLibrary.AREA) {
                _.each(geom.rows, function (row) {
                  var detX = position.x - row.x;
                  var detY = position.y - row.y;
                  var distance = Math.sqrt(detX * detX + detY * detY);

                  if (distance < minDistance) {
                    target = new Circle({
                      shape: {
                        cx: row.x,
                        cy: row.y,
                        r: row.size
                      }
                    });
                    target.id = row.id;
                    minDistance = distance;
                  }
                });
              }
            });
          });
        }

        if (target) {
          var _row = rowMap[target.id];
          var tr = target.transform && [target.transform[0], target.transform[1], target.transform[2], target.transform[3], target.transform[4] + tileX, target.transform[5] + tileY];
          hoverInfo.geomIndex = _row.geomIndex;
          hoverInfo.instance = {
            shape: target.shape,
            type: target.type,
            transform: tr
          };
          hoverInfo.row = _row;
          hoverInfo.targets = {};
          hoverInfo.targets[target.id] = true;
        }
      };

      _proto.boxSelect = function boxSelect(range) {
        var _this3 = this;

        var computed = this.getDerived();
        var state = this.store.getState();
        var selectedRows = [];

        _.each(this.shapeMap, function (zr, key) {
          var tile = key.split('+');

          if (tile.length == 2) {
            var _this3$getPlotTileBou = _this3.getPlotTileBounds(tile[0], tile[1]),
                tileX = _this3$getPlotTileBou.x,
                tileY = _this3$getPlotTileBou.y;

            var rect = {
              x: range.x - tileX,
              y: range.y - tileY,
              width: range.width,
              height: range.height
            };
            var shapes = zr.storage.getDisplayList();
            selectedRows = selectedRows.concat(selectionFilter$$1(rect, computed, shapes));
          }
        });

        selectedRows.length > 0 && this.store.dispatch(Act.selectedRows(selectedRows));
        this.store.dispatch(Act.plotPanEnd({}));
        return {
          computedState: this.getComputedState()
        };
      };

      _proto.getPlotTileBounds = function getPlotTileBounds(tileX, tileY) {
        var state = mapStateToProps$1(this.store.getState());
        return getTileImageBounds(tileX, tileY, state.plotBounds, state.scrollBounds);
      };

      _proto.renderPlotTile = function renderPlotTile(tileX, tileY, root) {
        var state = mapStateToProps$1(this.store.getState());
        var tileBounds = this.getPlotTileBounds(tileX, tileY);
        root = this.createExportRoot(root, tileBounds);
        var zr = render.initZr(root, tileBounds);
        var cellMap = this.getVisibleCellMap(state.cellMap, tileBounds);
        render(h(PlotTile, _extends({}, state, {
          cellMap: cellMap,
          tileBounds: tileBounds,
          interaction: {},
          bigData: true
        })), root, {
          zr: zr
        });
        zr.refreshImmediately();
        this.shapeMap[tileX + '+' + tileY] = zr;
        this.visibleCellMap[tileX + '+' + tileY] = cellMap;
      };

      _proto.getFacetTileBounds = function getFacetTileBounds(tileX, tileY, facet) {
        var props = mapStateToProps(this.store.getState());
        var plotBounds = props.plotBounds,
            scrollBounds = props.scrollBounds,
            chartBounds = props.chartBounds;
        var viewAttrs = getFacetViewAttrs(plotBounds, chartBounds, facet);
        var totalSize = viewAttrs.axisSize[0] + viewAttrs.axisSize[1];
        var scrollWidth = scrollBounds.width + (facet.horizontal ? 0 : totalSize);
        var scrollHeight = scrollBounds.height + (facet.horizontal ? totalSize : 0);
        var facetScrollBounds = {
          width: scrollWidth,
          height: scrollHeight
        };
        return getTileImageBounds(tileX, tileY, viewAttrs.viewBounds, facetScrollBounds);
      };

      _proto.renderFacetTile = function renderFacetTile(tileX, tileY, root, key) {
        if (!this.store) {
          return;
        }

        var props = mapStateToProps(this.store.getState());
        var facet = props[key];
        var tileBounds = this.getFacetTileBounds(tileX, tileY, facet);
        root = this.createExportRoot(root, tileBounds);
        var zr = render.initZr(root, tileBounds);
        render(h(AxisTile, _extends({}, props, {
          facet: facet,
          tileBounds: tileBounds,
          bigData: true
        })), root, {
          zr: zr
        });
        zr.refreshImmediately();
        this.shapeMap[tileX + '+' + tileY + '+' + key] = zr;
      };

      _proto.renderFacetXTile = function renderFacetXTile(tileX, tileY, root) {
        if (!this.store) {
          return;
        }

        this.renderFacetTile(tileX, tileY, root, 'facetX');
      };

      _proto.renderFacetYTile = function renderFacetYTile(tileX, tileY, root) {
        if (!this.store) {
          return;
        }

        this.renderFacetTile(tileX, tileY, root, 'facetY');
      };

      _proto.dispose = function dispose$$1() {
        if (!this.shapeMap) {
          return;
        }

        _Chart.prototype.dispose.call(this);

        _.each(this.shapeMap, function (zr) {
          dispose$1(zr);
        });

        this.shapeMap = this.visibleCellMap = null;
      };

      return TileChart;
    }(Chart$1);

    var _symbols;
    var PUPPET = 'puppet'; // 需要invisibleMarker的symbol

    var symbols$1 = (_symbols = {}, _symbols[SymbolConstants.LIGHT_4] = true, _symbols[SymbolConstants.LIGHT_5] = true, _symbols[SymbolConstants.LIGHT_6] = true, _symbols[SymbolConstants.DET_1] = true, _symbols[SymbolConstants.DET_2] = true, _symbols[SymbolConstants.DET_3] = true, _symbols[SymbolConstants.DET_4] = true, _symbols);

    var needHiddenMarker = function needHiddenMarker(symbol) {
      return isHollow(symbol) || symbols$1[symbol];
    };

    var HALF_SQRT_2 = Math.sqrt(2) / 2; // FixME BI-25086

    function renderPoint(props) {
      var id = props.id,
          key = props.key,
          symbol = props.symbol,
          radius = props.radius;
      var markerKey = key,
          markerId = id;
      var hiddenValid = needHiddenMarker(symbol);
      var tooltipPos = [radius * HALF_SQRT_2, radius * HALF_SQRT_2];

      if (hiddenValid) {
        markerKey = key + PUPPET;
        markerId = id + PUPPET;
      }

      var marker = renderMarker(_extends({}, props, {
        key: markerKey,
        id: markerId,
        silent: hiddenValid,
        tooltipPos: tooltipPos
      }));
      var invisibleMarker = hiddenValid && renderMarker(_extends({}, props, {
        symbol: 'circle',
        invisible: true,
        tooltipPos: tooltipPos
      }));
      return [marker, invisibleMarker];
    }

    var vanishShape = function vanishShape(shape) {
      if (shape.r0) {
        shape.r0 = 0;
      }

      if (shape.r) {
        shape.r = 0;
      }

      if (shape.width) {
        shape.x += shape.width / 2;
        shape.y += shape.height / 2;
        shape.width = 0;
        shape.height = 0;
      }

      return shape;
    };
    var appear$2 = function appear(attr) {
      return {
        shape: vanishShape(_extends({}, attr.shape))
      };
    };
    var INIT_TIME = 800;
    var INIT_EASE = Ease.EaseOutCubic;
    var Timing$3 = {
      INIT: {
        duration: INIT_TIME / 2,
        ease: INIT_EASE,
        appear: appear$2
      },
      SHOW_ENTER: {
        duration: 500,
        ease: Ease.EaseOutCubic,
        appear: appear$2
      },
      SHOW_UPDATE: {
        duration: 500,
        ease: Ease.EaseOutCubic
      },
      HOVER: {
        duration: 150,
        ease: Ease.Default
      },
      HIDE_UPDATE: {
        duration: 500,
        ease: Ease.EaseOutCubic
      },
      HIDE_LEAVE: {
        duration: 300,
        ease: Ease.EaseInBack
      }
    };

    var STROKE = '#9D9D9D';
    function renderRegionLine(_ref) {
      var key = _ref.key,
          _ref$points = _ref.points,
          x = _ref$points[0],
          y = _ref$points[1],
          upper = _ref$points[2],
          lower = _ref$points[3],
          gTransition = _ref.transition,
          _ref$stroke = _ref.stroke,
          stroke = _ref$stroke === void 0 ? STROKE : _ref$stroke,
          inverted = _ref.inverted,
          type = _ref.type,
          appear = _ref.appear,
          _ref$node = _ref.node,
          node = _ref$node === void 0 ? {} : _ref$node;
      key = key || node.key;
      var enter = type === ENTER;
      var x1 = inverted ? upper : x,
          x2 = inverted ? lower : x,
          y1 = inverted ? y : upper,
          y2 = inverted ? y : lower;
      var transition = gTransition && {
        duration: gTransition.duration,
        ease: gTransition.ease,
        delay: gTransition.delay || 0,
        properties: {
          shape: 1
        }
      };

      if (enter && transition) {
        transition.appear = appear || function () {
          return {
            shape: {
              x1: x,
              x2: x,
              y1: y,
              y2: y
            }
          };
        };
      }

      key = key + "_regionLine";
      return h('regionLine', {
        key: key,
        transition: transition,
        silent: true,
        z: RegionLineLayerZ,
        shape: {
          x1: x1,
          x2: x2,
          y1: y1,
          y2: y2
        },
        style: {
          stroke: stroke
        }
      });
    }

    var HOVER_ADD_RADIUS = 1;
    var HOVER_SHADOW_BLUR = 5;
    var POINT_AREA_MAP_SIZE = 15;
    var POINT_AREA_MAP_SYMBOL = SymbolConstants.MAP;
    var MIN_RADIUS = 1.5; // 1 = 1.5 - 0.5

    var getTransitionProps$3 = getGeomTransitionProps(Timing$3);
    var EFFECT_TOTAL_TIME = 2.48;
    var EFFECT_DURATION = 1.6;
    var EFFECT_STEP = 0.44;

    var Point$1 =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Point, _Geometry);

      function Point(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$3;
        return _this;
      }

      var _proto = Point.prototype;

      _proto.renderGraphic = function renderGraphic(node, TransitionProps) {
        var key = node.key,
            data = node.data;
        var areaMap = this.props.areaMap;
        var _this$props = this.props,
            defaultOpacity = _this$props.opacity,
            borderColor = _this$props.borderColor,
            process = _this$props.process,
            gradual = _this$props.gradual;
        var x = data.x,
            y = data.y,
            color = data.color,
            size = data.size,
            symbol = data.symbol,
            fake = data.fake,
            vanish = data.vanish,
            effect = data.effect;

        if (areaMap) {
          symbol = POINT_AREA_MAP_SYMBOL;
          size = POINT_AREA_MAP_SIZE;
        }

        var _transition = TransitionProps.transition,
            transitionEnd = TransitionProps.transitionEnd,
            isFade = TransitionProps.isFade,
            isHover = TransitionProps.isHover,
            isEnter = TransitionProps.isEnter,
            z = TransitionProps.z,
            silent = TransitionProps.silent;
        var transition = _transition;

        if (_transition && isEnter && process !== SHOW) {
          transition = TransitionProps.transition = _extends({}, _transition, {
            delay: Math.random() * _transition.duration
          });
        }

        var radius = vanish ? 0 : Math.max(MIN_RADIUS, size);
        var shadowBlur,
            opacity = defaultOpacity; // shape & style related to end state

        if (isFade) {
          color = Fade.Fill;
          opacity = Fade.Opacity;
        } else if (isHover) {
          color = highlight(color);
          radius += HOVER_ADD_RADIUS;
          shadowBlur = HOVER_SHADOW_BLUR;
        }

        return renderPoint({
          key: key,
          id: key,
          z: z,
          silent: silent,
          transition: transition,
          transitionEnd: transitionEnd,
          symbol: symbol,
          x: x,
          y: y,
          radius: radius,
          color: color,
          opacity: opacity * (fake ? 0.5 : 1),
          shadowColor: color,
          shadowBlur: shadowBlur,
          stroke: effect ? null : borderColor || color,
          lineWidth: 1,
          blend: gradual ? 'lighter' : 'source-over'
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var row = node.data;

        if (row.annotation) {
          refer.startPos = [row.x, row.y];
        }

        if (row.fake) {
          var inverted = this.props.inverted;
          var x = row.x,
              y = row.y,
              upper = row.upper,
              lower = row.lower,
              color = row.color;
          refer.points = [x, y, upper, lower];
          refer.stroke = color;
          refer.inverted = inverted;
        }
      };

      _proto.renderGuides = function renderGuides(refer, node) {
        var guides = _Geometry.prototype.renderGuides.call(this, refer, node);

        node.data.fake && guides.push(renderRegionLine(refer));
        return guides;
      };

      _proto.renderEffect = function renderEffect(node, attr) {
        var row = node.data,
            key = node.key;
        var size = row.size,
            color = row.color,
            symbol = row.symbol;

        var _ref = attr || row,
            x = _ref.x,
            y = _ref.y;

        var props = {
          x: x,
          y: y,
          radius: size,
          color: color,
          opacity: 0,
          symbol: symbol,
          silent: true,
          stroke: color
        };
        var i = 0;
        var effectMarkers = [];

        while (i++ < 3) {
          effectMarkers.push(renderMarker(_extends({}, props, {
            key: key + EFFECT_SUFFIX + i
          })));
        }

        return effectMarkers;
      };

      _proto.showEffect = function showEffect(id, effect) {
        var _this2 = this;

        var durationRatio = effect * 1000 / EFFECT_TOTAL_TIME;
        var i = 0;

        var _loop = function _loop() {
          var effectMarker = _this2.getZNode(id + EFFECT_SUFFIX + i);

          var delay = EFFECT_STEP * durationRatio * (i - 1),
              duration = EFFECT_DURATION * durationRatio;

          var animator = _this2.createEffectAni(id, effect, duration, delay);

          animator.during(function (_ref2) {
            var pct = _ref2.pct;

            var row = _this2.getRow(id);

            var size = row.size;
            var opacity = 0.6 * (1 - pct);
            effectMarker.setStyle('opacity', opacity).setStyle('lineWidth', size * 2.5 * pct);
          }).start();
        };

        while (i++ < 3) {
          _loop();
        }
      };

      return Point;
    }(Geometry);
    Point$1.calcDataLabelPos = calcDataLabelPos$2;
    Geom.registerGeom('point', Point$1);

    var initialRadius = 10;
    var initialAngle = Math.PI * (3 - Math.sqrt(5));

    var constant$4 = function constant(x) {
      return function () {
        return x;
      };
    };

    var quadtree = function () {
      var tree_add = function tree_add(d) {
        var x = +this._x.call(null, d),
            y = +this._y.call(null, d);
        return add(this.cover(x, y), x, y, d);
      };

      var tree_cover = function tree_cover(x, y) {
        if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

        var x0 = this._x0,
            y0 = this._y0,
            x1 = this._x1,
            y1 = this._y1; // If the quadtree has no extent, initialize them.
        // Integer extent are necessary so that if we later double the extent,
        // the existing quadrant boundaries don’t change due to floating point error!

        if (isNaN(x0)) {
          x1 = (x0 = Math.floor(x)) + 1;
          y1 = (y0 = Math.floor(y)) + 1;
        } // Otherwise, double repeatedly to cover.
        else if (x0 > x || x > x1 || y0 > y || y > y1) {
            var z = x1 - x0,
                node = this._root,
                parent,
                i;

            switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
              case 0:
                {
                  do {
                    parent = new Array(4), parent[i] = node, node = parent;
                  } while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));

                  break;
                }

              case 1:
                {
                  do {
                    parent = new Array(4), parent[i] = node, node = parent;
                  } while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));

                  break;
                }

              case 2:
                {
                  do {
                    parent = new Array(4), parent[i] = node, node = parent;
                  } while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));

                  break;
                }

              case 3:
                {
                  do {
                    parent = new Array(4), parent[i] = node, node = parent;
                  } while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));

                  break;
                }
            }

            if (this._root && this._root.length) this._root = node;
          } // If the quadtree covers the point already, just return.
          else return this;

        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        return this;
      };

      var Quad = function Quad(node, x0, y0, x1, y1) {
        this.node = node;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      };

      var tree_visit = function tree_visit(callback) {
        var quads = [],
            q,
            node = this._root,
            child,
            x0,
            y0,
            x1,
            y1;
        if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));

        while (q = quads.pop()) {
          if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
            var xm = (x0 + x1) / 2,
                ym = (y0 + y1) / 2;
            if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
            if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
            if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
            if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          }
        }

        return this;
      };

      var tree_visitAfter = function tree_visitAfter(callback) {
        var quads = [],
            next = [],
            q;
        if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));

        while (q = quads.pop()) {
          var node = q.node;

          if (node.length) {
            var child,
                x0 = q.x0,
                y0 = q.y0,
                x1 = q.x1,
                y1 = q.y1,
                xm = (x0 + x1) / 2,
                ym = (y0 + y1) / 2;
            if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
            if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
            if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
            if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          }

          next.push(q);
        }

        while (q = next.pop()) {
          callback(q.node, q.x0, q.y0, q.x1, q.y1);
        }

        return this;
      };

      function add(tree, x, y, d) {
        if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

        var parent,
            node = tree._root,
            leaf = {
          data: d
        },
            x0 = tree._x0,
            y0 = tree._y0,
            x1 = tree._x1,
            y1 = tree._y1,
            xm,
            ym,
            xp,
            yp,
            right,
            bottom,
            i,
            j; // If the tree is empty, initialize the root as a leaf.

        if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.

        while (node.length) {
          if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
          if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
          if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
        } // Is the new point is exactly coincident with the existing point?


        xp = +tree._x.call(null, node.data);
        yp = +tree._y.call(null, node.data);
        if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.

        do {
          parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
          if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
          if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
        } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));

        return parent[j] = node, parent[i] = leaf, tree;
      }

      function addAll(data) {
        var d,
            i,
            n = data.length,
            x,
            y,
            xz = new Array(n),
            yz = new Array(n),
            x0 = Infinity,
            y0 = Infinity,
            x1 = -Infinity,
            y1 = -Infinity; // Compute the points and their extent.

        for (i = 0; i < n; ++i) {
          if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
          xz[i] = x;
          yz[i] = y;
          if (x < x0) x0 = x;
          if (x > x1) x1 = x;
          if (y < y0) y0 = y;
          if (y > y1) y1 = y;
        } // If there were no (valid) points, inherit the existing extent.


        if (x1 < x0) x0 = this._x0, x1 = this._x1;
        if (y1 < y0) y0 = this._y0, y1 = this._y1; // Expand the tree to cover the new points.

        this.cover(x0, y0).cover(x1, y1); // Add the new points.

        for (i = 0; i < n; ++i) {
          add(this, xz[i], yz[i], data[i]);
        }

        return this;
      }

      function defaultX(d) {
        return d[0];
      }

      function defaultY(d) {
        return d[1];
      }

      function quadtree(nodes, x, y) {
        var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
        return nodes == null ? tree : tree.addAll(nodes);
      }

      function Quadtree(x, y, x0, y0, x1, y1) {
        this._x = x;
        this._y = y;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        this._root = undefined;
      }

      var treeProto = quadtree.prototype = Quadtree.prototype;
      treeProto.add = tree_add;
      treeProto.addAll = addAll;
      treeProto.cover = tree_cover;
      treeProto.visit = tree_visit;
      treeProto.visitAfter = tree_visitAfter;
      return quadtree;
    }();

    var jiggle = function jiggle() {
      return (Math.random() - 0.5) * 1e-6;
    };

    var x$1 = function x(d) {
      return d.x + d.vx;
    };

    var y$1 = function y(d) {
      return d.y + d.vy;
    };

    var forceMap = function forceMap() {
      var prefix = '$';

      var collection = function collection() {};

      collection.prototype = {
        constructor: collection,
        get: function get(key) {
          return this[prefix + key];
        },
        set: function set(key, value) {
          this[prefix + key] = value;
          return this;
        },
        remove: function remove(key) {
          var property = prefix + key;
          return property in this && delete this[property];
        },
        each: function each(f) {
          for (var property in this) {
            if (property[0] === prefix) f(this[property], property.slice(1), this);
          }
        }
      };
      return new collection();
    };

    var simulation = function simulation() {
      var _nodes,
          _alpha = 1,
          _alphaMin = 0.001,
          _alphaDecay = 1 - Math.pow(_alphaMin, 1 / 300),
          _alphaTarget = 0,
          _velocityDecay = 0.6,
          forces = forceMap(),
          stepper = null,
          tickFunc,
          endFunc;

      function step() {
        tick();
        tickFunc && tickFunc(_alpha);

        if (_alpha < _alphaMin) {
          stepper.stop();
          endFunc && endFunc();
        }
      }

      function tick() {
        var i,
            n = _nodes.length,
            node;
        _alpha += (_alphaTarget - _alpha) * _alphaDecay;
        forces.each(function (force) {
          force(_alpha);
        });

        for (i = 0; i < n; ++i) {
          node = _nodes[i];
          if (node.fx == null) node.x += node.vx *= _velocityDecay;else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= _velocityDecay;else node.y = node.fy, node.vy = 0;
        }
      }

      function initializeNodes() {
        for (var i = 0, n = _nodes.length, node; i < n; ++i) {
          node = _nodes[i], node.index = i;

          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(i),
                angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }

          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(_nodes);
        return force;
      }

      var simulation = {
        tick: tick,
        restart: function restart() {
          _alpha = 1;

          if (stepper) {
            stepper.stop();
            stepper.restart(step);
          } else {
            simulation.start();
          }

          return simulation;
        },
        stop: function stop() {
          return stepper && stepper.stop(), simulation;
        },
        nodes: function nodes(_$$1) {
          return arguments.length ? (_nodes = _$$1, initializeNodes(), forces.each(initializeForce), simulation) : _nodes;
        },
        alpha: function alpha() {
          return arguments.length ? (_alpha = +_, simulation) : _alpha;
        },
        alphaMin: function alphaMin(_$$1) {
          return arguments.length ? (_alphaMin = +_$$1, simulation) : _alphaMin;
        },
        alphaDecay: function alphaDecay(_$$1) {
          return arguments.length ? (_alphaDecay = +_$$1, simulation) : +_alphaDecay;
        },
        alphaTarget: function alphaTarget(_$$1) {
          return arguments.length ? (_alphaTarget = +_$$1, simulation) : _alphaTarget;
        },
        velocityDecay: function velocityDecay(_$$1) {
          return arguments.length ? (_velocityDecay = 1 - _$$1, simulation) : 1 - _velocityDecay;
        },
        force: function force(name, _$$1) {
          return arguments.length > 1 ? (_$$1 == null ? forces.remove(name) : forces.set(name, initializeForce(_$$1)), simulation) : forces.get(name);
        },
        find: function find(x, y, radius) {
          var i = 0,
              n = _nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;
          if (radius == null) radius = Infinity;else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = _nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },
        eachTick: function eachTick(_$$1) {
          if (!arguments.length) {
            return tickFunc;
          }

          if (typeof _$$1 !== 'function') throw new TypeError('tick callback expect to be a function');
          tickFunc = _$$1;
          return simulation;
        },
        end: function end(_$$1) {
          if (!arguments.length) {
            return endFunc;
          }

          if (typeof _$$1 !== 'function') throw new TypeError('tickEnd callback expect to be a function!');
          endFunc = _$$1;
          return simulation;
        },
        start: function start() {
          stepper = timer(step);
        }
      };
      return simulation;
    };

    var forceX = function forceX(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;
      if (typeof x !== 'function') x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i,
            n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);

        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function (_$$1) {
        nodes = _$$1;
        initialize();
      };

      force.strength = function (_$$1) {
        return arguments.length ? (strength = typeof _$$1 === 'function' ? _$$1 : constant$4(+_$$1), initialize(), force) : strength;
      };

      force.x = function (_$$1) {
        return arguments.length ? (x = typeof _$$1 === 'function' ? _$$1 : constant$4(+_$$1), initialize(), force) : x;
      };

      return force;
    };

    var forceY = function forceY(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;
      if (typeof y !== 'function') y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i,
            n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);

        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function (_$$1) {
        nodes = _$$1;
        initialize();
      };

      force.strength = function (_$$1) {
        return arguments.length ? (strength = typeof _$$1 === 'function' ? _$$1 : constant$4(+_$$1), initialize(), force) : strength;
      };

      force.y = function (_$$1) {
        return arguments.length ? (y = typeof _$$1 === 'function' ? _$$1 : constant$4(+_$$1), initialize(), force) : y;
      };

      return force;
    };

    var collide = function collide(radius) {
      var nodes,
          radii,
          strength = 1,
          iterations = 1;
      if (typeof radius !== 'function') radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i,
            n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$1, y$1).visitAfter(prepare);

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data,
              rj = quad.r,
              r = ri + rj;

          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;

              if (l < r * r) {
                if (x === 0) x = jiggle(), l += x * x;
                if (y === 0) y = jiggle(), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }

            return;
          }

          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];

        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i,
            n = nodes.length,
            node;
        radii = new Array(n);

        for (i = 0; i < n; ++i) {
          node = nodes[i], radii[node.index] = +radius(node, i, nodes);
        }
      }

      force.initialize = function (_$$1) {
        nodes = _$$1;
        initialize();
      };

      force.iterations = function (_$$1) {
        return arguments.length ? (iterations = +_$$1, force) : iterations;
      };

      force.strength = function (_$$1) {
        return arguments.length ? (strength = +_$$1, force) : strength;
      };

      force.radius = function (_$$1) {
        return arguments.length ? (radius = typeof _$$1 === 'function' ? _$$1 : constant$4(+_$$1), initialize(), force) : radius;
      };

      return force;
    };

    var ForceLayout = {
      forceCollide: collide,
      forceSimulation: simulation,
      forceX: forceX,
      forceY: forceY
    };

    var Timing$4 = {
      HOVER: {
        duration: 150,
        ease: Ease.Default
      }
    };

    var getAttr = function getAttr(row, areaMap) {
      var id = row.id,
          radius = row.size,
          color = row.color,
          symbol = row.symbol,
          effect = row.effect,
          vanish = row.vanish;

      if (areaMap) {
        radius = POINT_AREA_MAP_SIZE;
        symbol = POINT_AREA_MAP_SYMBOL;
      }

      return {
        id: id,
        radius: radius,
        color: color,
        symbol: symbol,
        effect: effect,
        vanish: vanish
      };
    };

    var TICK_FN = function TICK_FN(node, _ref) {
      var x = _ref[0],
          y = _ref[1];
      node.x = x;
      node.y = y;
    };

    var RADIUS_FN = function RADIUS_FN(datum) {
      return datum.radius;
    };

    var BubbleLayout = function BubbleLayout() {
      var _nodes2;

      var _tick = TICK_FN,
          _radius = RADIUS_FN;
      var bubbleLayout = {
        nodes: function nodes(_nodes) {
          return arguments.length ? (_nodes2 = _nodes, bubbleLayout) : _nodes2;
        },
        radius: function radius(getRadiusFn) {
          if (typeof getRadiusFn !== 'function') {
            throw new TypeError('RadiusFormatter expect to be a function');
          }

          _radius = getRadiusFn;
          return bubbleLayout;
        },
        tick: function tick(tickHandler) {
          if (typeof tickHandler !== 'function') {
            throw new TypeError('TickHandler expect to be a function');
          }

          _tick = tickHandler;
          return bubbleLayout;
        },
        layout: function layout() {
          var circles = _nodes2.map(function (d) {
            return {
              data: d,
              r: _radius(d)
            };
          });

          packEnclose(circles);

          _nodes2.map(function (node, index) {
            var circle = circles[index];

            _tick(node, [circle.x, circle.y]);
          });
        }
      };
      return bubbleLayout;
    };

    function intersects(a, b) {
      var dx = b.x - a.x,
          dy = b.y - a.y,
          dr = a.r + b.r;
      return dr * dr - 1e-6 > dx * dx + dy * dy;
    }

    function Node$1(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function distance2(node, x, y) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab - x,
          dy = (a.y * b.r + b.y * a.r) / ab - y;
      return dx * dx + dy * dy;
    }

    function place(a, b, c) {
      var ax = a.x,
          ay = a.y,
          da = b.r + c.r,
          db = a.r + c.r,
          dx = b.x - ax,
          dy = b.y - ay,
          dc = dx * dx + dy * dy;

      if (dc) {
        var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
            y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
        c.x = ax + x * dx + y * dy;
        c.y = ay + x * dy - y * dx;
      } else {
        c.x = ax + db;
        c.y = ay;
      }
    }

    function packEnclose(circles) {
      if (!(n = circles.length)) return 0;
      var a, b, c, n; // Place the first circle.

      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r; // Place the second circle.

      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r; // Place the third circle.

      place(b, a, c = circles[2]); // Initialize the weighted centroid.

      var aa = a.r * a.r,
          ba = b.r * b.r,
          ca = c.r * c.r,
          oa = aa + ba + ca,
          ox = aa * a.x + ba * b.x + ca * c.x,
          oy = aa * a.y + ba * b.y + ca * c.y,
          cx,
          cy,
          i,
          j,
          k,
          sj,
          sk; // Initialize the front-chain using the first three circles a, b and c.

      a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a; // Attempt to place each remaining circle…

      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node$1(c); // Find the closest intersecting circle on the front-chain, if any.
        // “Closeness” is determined by linear distance along the front-chain.
        // “Ahead” or “behind” is likewise determined by linear distance.

        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;

        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }

            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }

            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next); // Success! Insert the new circle c between a and b.


        c.previous = a, c.next = b, a.next = b.previous = b = c; // Update the weighted centroid.

        oa += ca = c._.r * c._.r;
        ox += ca * c._.x;
        oy += ca * c._.y; // Compute the new closest circle pair to the centroid.

        aa = distance2(a, cx = ox / oa, cy = oy / oa);

        while ((c = c.next) !== b) {
          if ((ca = distance2(c, cx, cy)) < aa) {
            a = c, aa = ca;
          }
        }

        b = a.next;
      } // Compute the enclosing circle of the front chain.


      a = [b._], c = b;

      while ((c = c.next) !== b) {
        a.push(c._);
      }

      c = adjust$2(a); // // Translate the circles to put the enclosing circle around the origin.

      for (i = 0; i < n; ++i) {
        a = circles[i], a.x -= c.x, a.y -= c.y;
      }
    }

    function adjust$2(circles) {
      var endpointMap = {
        left: [],
        top: [],
        right: [],
        bottom: []
      };
      circles.forEach(function (circle) {
        var endPoints = getEndPoints(circle.x, circle.y, circle.r);

        for (var dir in endPoints) {
          endpointMap[dir].push(endPoints[dir]);
        }
      });

      var min = function min(arr) {
        return Math.min.apply(Math, arr);
      };

      var max = function max(arr) {
        return Math.max.apply(Math, arr);
      };

      var left = min(endpointMap['left']),
          right = max(endpointMap['right']),
          top = max(endpointMap['top']),
          bottom = min(endpointMap['bottom']);
      var x = (left + right) / 2,
          y = (top + bottom) / 2;
      return {
        x: x,
        y: y
      };
    }

    function getEndPoints(x, y, r) {
      var x1 = x - r,
          x2 = x + r,
          y1 = y + r,
          y2 = y - r;
      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    var HOVER_ADD_RADIUS$1 = 1;
    var HOVER_SHADOW_BLUR$1 = 5;

    var updatePointPos = function updatePointPos(el, x, y) {
      if (el) {
        var _ref = el.translate || [0, 0],
            tx = _ref[0],
            ty = _ref[1];

        el.attr('position', [x + tx, y + ty]);
      }
    }; // ex: 0.2 -> [-.5, -.2] & [.2, .5]


    var endsRand = function endsRand(p) {
      var r = Math.random();
      return (p + (0.5 - p) * r) * (r > 0.5 ? 1 : -1);
    };

    var getTransitionProps$4 = getGeomTransitionProps(Timing$4);

    var ForcePoint =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(ForcePoint, _Geometry);

      function ForcePoint(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.forceSimulation = ForceLayout.forceSimulation().velocityDecay(0.5).force('x', ForceLayout.forceX().strength(0.1)).force('y', ForceLayout.forceY().strength(0.1)).force('collide', ForceLayout.forceCollide().radius(function (d) {
          return d.radius;
        })).eachTick(_this.tickHandler.bind(_assertThisInitialized(_assertThisInitialized(_this)))).end(_this.forceLayoutEnd.bind(_assertThisInitialized(_assertThisInitialized(_this))));
        _this.bubbleLayout = BubbleLayout();
        _this.attrHash = {};
        _this.onPanStart = _this.onPanStart.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.onPanMove = _this.onPanMove.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.onPanEnd = _this.onPanEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));
        _this.getTransitionProps = getTransitionProps$4;

        _this.updateState(_this.props);

        return _this;
      }

      var _proto = ForcePoint.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (this.props.bounds !== nextProps.bounds) {
          this.updateState(nextProps);
        }
      };

      _proto.getGroupProps = function getGroupProps() {
        var center = this.state.center;

        var props = _Geometry.prototype.getGroupProps.call(this);

        props.onpanstart = this.onPanStart;
        props.onpan = this.onPanMove;
        props.onpanend = this.onPanEnd;
        props.position = center;
        return props;
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.forceSimulation.stop();
      };

      _proto.updateState = function updateState(_ref2) {
        var _this2 = this;

        var rows = _ref2.rows,
            bounds = _ref2.bounds;
        var areaMap = this.props.areaMap;
        var attrMap = {},
            nodes = [];
        var attrHash = {};

        _.each(rows, function (row) {
          var id = row.id,
              vanish = row.vanish;

          if (vanish) {
            return;
          }

          var attr = getAttr(row, areaMap);
          attrMap[id] = attr; // inherit position from last same key node

          if (_this2.attrHash[id]) {
            var _this2$attrHash$id = _this2.attrHash[id],
                x = _this2$attrHash$id.x,
                y = _this2$attrHash$id.y;
            attr.x = x;
            attr.y = y;
            attr.visible = true;
          }

          nodes.push(attr);
          attrHash[id] = attr;
        });

        this.attrHash = attrHash;
        this.enableForce = nodes.length > 1;

        this._layout(nodes);

        this.setState({
          attrMap: attrMap,
          center: getBoundsCenter(bounds),
          guideBounds: _extends({}, bounds, {
            x: -bounds.width / 2,
            y: -bounds.height / 2
          })
        });
      }
      /**
       * 布局
       * @param nodes
       * @private
       */
      ;

      _proto._layout = function _layout(nodes) {
        var animation = this.props.animation; // static bubble layout

        if (!animation) {
          this.bubbleLayout.nodes(nodes).layout();
          return;
        } // no force


        if (nodes.length < 2) {
          this._forceFinish(); // set center


          nodes[0] && (nodes[0].x = nodes[0].y = 0);
          return;
        }

        this._forceFinished = this._forceEnd = false;
        var _this$props$bounds = this.props.bounds,
            width = _this$props$bounds.width,
            height = _this$props$bounds.height;

        _.each(nodes, function (n) {
          if (n.x || n.y) {
            return;
          }

          n.x = endsRand(0.1) * width * 2;
          n.y = (Math.random() - 1) * height;
        });

        this.enableForce && this.forceSimulation.nodes(nodes).restart();
      };

      _proto.forceLayoutEnd = function forceLayoutEnd() {
        this._forceEnd = true;
        this.setState({});
      };

      _proto.tickHandler = function tickHandler(alpha) {
        var _this3 = this;

        alpha < 0.5 && !this._forceFinished && this._forceFinish();

        _.each(this.forceSimulation.nodes(), function (_ref3) {
          var id = _ref3.id,
              x = _ref3.x,
              y = _ref3.y;

          var el = _this3.getZNode(id),
              puppet = _this3.getZNode(id + PUPPET);

          updatePointPos(el, x, y);
          updatePointPos(puppet, x, y);
          var node = _this3.attrHash[id];

          if (node) {
            node.x = x;
            node.y = y;
          }

          _this3._updateGuideNode(id, x, y);
        });
      } // 力学布局接近结束，手动调用animator来触发闪烁，避免diff时打断effectEl的尴尬
      ;

      _proto._forceFinish = function _forceFinish() {
        this._forceFinished = this._forceEnd = true;
        this.triggerGroupEffects();
      } // 手动更新标签和闪烁点的位置
      ;

      _proto._updateGuideNode = function _updateGuideNode(id, x, y) {
        var _this4 = this;

        if (!this._forceFinished) return;
        var suffixes = [LABEL_KEY, ANNOTATION_GROUP_SUFFIX, EFFECT_SUFFIX + 1, EFFECT_SUFFIX + 2, EFFECT_SUFFIX + 3];

        _.each(suffixes, function (suffix) {
          var el = _this4.getZNode(id + suffix);

          if (el) {
            el.attr('position', [x, y]);
            el.attrKV('invisible', false);
          }
        });
      };

      _proto.onPanStart = function onPanStart(ev) {
        var _this$props = this.props,
            canPanShape = _this$props.canPanShape,
            rows = _this$props.rows;

        if (!canPanShape || rows.length < 2) {
          return;
        }

        var node = this.attrHash[ev.target.id];
        node.fx = node.x;
        node.fy = node.y;
        this.forceSimulation.alphaTarget(0.3).restart();
        this._panning = true;
        return true;
      };

      _proto.onPanMove = function onPanMove(ev) {
        if (!this._panning) {
          return;
        }

        var center = this.state.center;
        var node = this.attrHash[ev.target.id];
        var cx = center[0],
            cy = center[1];
        node.fx = ev.offsetX - cx;
        node.fy = ev.offsetY - cy;
        return true;
      };

      _proto.onPanEnd = function onPanEnd(ev) {
        this.forceSimulation.alphaTarget(0);
        var node = this.attrHash[ev.target.id];
        node.fx = null;
        node.fy = null;
        this._panning = false;
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var areaMap = this.props.areaMap;
        var key = node.key,
            data = node.data;

        if (data.vanish) {
          return null;
        }

        var _this$props2 = this.props,
            defineOpacity = _this$props2.opacity,
            borderColor = _this$props2.borderColor;
        var attrMap = this.state.attrMap;

        var _ref4 = attrMap[key] || getAttr(data, areaMap),
            symbol = _ref4.symbol,
            radius = _ref4.radius,
            color = _ref4.color,
            _ref4$x = _ref4.x,
            x = _ref4$x === void 0 ? 0 : _ref4$x,
            _ref4$y = _ref4.y,
            y = _ref4$y === void 0 ? 0 : _ref4$y;

        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            silent = transitionProps.silent,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            z = transitionProps.z;
        var opacity = defineOpacity,
            shadowBlur; // shape & style related to end state

        if (isFade) {
          color = Fade.Fill;
          opacity = Fade.Opacity;
        } else if (isHover) {
          color = highlight(color);
          radius += HOVER_ADD_RADIUS$1;
          shadowBlur = HOVER_SHADOW_BLUR$1;
        }

        return renderPoint({
          key: key,
          id: key,
          silent: silent,
          z: z,
          transition: transition,
          transitionEnd: transitionEnd,
          symbol: symbol,
          x: x,
          y: y,
          radius: Math.max(radius, MIN_RADIUS),
          color: color,
          opacity: opacity,
          shadowColor: color,
          shadowBlur: shadowBlur,
          stroke: data.effect ? null : borderColor || color
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var areaMap = this.props.areaMap;
        var key = node.key,
            row = node.data;
        var guideBounds = this.state.guideBounds;
        var attr = this.attrHash[key] || getAttr(row, areaMap);
        var _attr$x = attr.x,
            x = _attr$x === void 0 ? 0 : _attr$x,
            _attr$y = attr.y,
            y = _attr$y === void 0 ? 0 : _attr$y;
        refer.position = [x, y];
        refer.startPos = [x, y];
        refer.transition = null;
        refer.cellBounds = guideBounds;
        refer.invisible = this._forceFinished ? false : !attr.visible;
        refer.applyTheme = true;
      };

      _proto.renderGuides = function renderGuides(refer, node) {
        var guides = _Geometry.prototype.renderGuides.call(this, refer, node);

        return this._forceEnd ? guides : guides[0];
      };

      _proto.renderEffect = function renderEffect(node) {
        var attr = this.attrHash[node.key];
        return Point$1.prototype.renderEffect.call(this, node, attr);
      };

      _proto.showEffect = function showEffect(id, effect) {
        Point$1.prototype.showEffect.call(this, id, effect);
      };

      return ForcePoint;
    }(Geometry);
    /**
     * Note 同4.1逻辑一致，超出点半径的直接不显示，没有调整处理
     */


    ForcePoint.calcDataLabelPos = calcDataLabelPos$2;

    ForcePoint.adjustDataLabel = function (_ref5) {
      var rows = _ref5.rows;

      if (rows.length < 2) {
        return;
      }

      _.each(rows, function (row) {
        var _row$dataLabel$bounds = row.dataLabel.bounds,
            width = _row$dataLabel$bounds.width,
            height = _row$dataLabel$bounds.height;

        if (Math.max(width, height) > row.size * 2) {
          row.dataLabel = null;
        }
      });
    };

    Geom.registerGeom('forcePoint', ForcePoint);

    var vanishShape$1 = function vanishShape(shape, direction) {
      if (direction === void 0) {
        direction = shape.direction;
      }

      var x = shape.x,
          y = shape.y,
          width = shape.width,
          height = shape.height;
      var toTop = direction === Direction.TOP,
          toLeft = direction === Direction.LEFT;

      switch (direction) {
        case Direction.TOP:
        case Direction.BOTTOM:
          y = y + (toTop ? height : 0);
          height = 0;
          break;

        case Direction.LEFT:
        case Direction.RIGHT:
          x = x + (toLeft ? width : 0);
          width = 0;
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    };
    var H_ENLARGE_SIZE = 1;
    var getLabelHoverTranslate = function getLabelHoverTranslate(direction) {
      var translate = [0, 0];

      switch (direction) {
        case Direction.BOTTOM:
          translate[1] = DataLabel.HOVER_TRANS;
          break;

        case Direction.LEFT:
          translate[0] = -DataLabel.HOVER_TRANS;
          break;

        case Direction.RIGHT:
          translate[0] = DataLabel.HOVER_TRANS;
          break;

        default:
          translate[1] = -DataLabel.HOVER_TRANS;
      }

      return translate;
    };
    var hoverShape$1 = function hoverShape(shape) {
      var s = H_ENLARGE_SIZE;
      shape.x -= s;
      shape.y -= s;
      shape.width += s * 2;
      shape.height += s * 2;
    }; // http://www.finedevelop.com/pages/viewpage.action?pageId=18460724

    var getGradualStops = function getGradualStops(direction) {
      var x1 = 0,
          x2 = 0,
          y1 = 0,
          y2 = 0;

      switch (direction) {
        case Direction.BOTTOM:
          y2 = 1;
          break;

        case Direction.RIGHT:
          x2 = 1;
          break;

        case Direction.LEFT:
          x1 = 1;
          break;

        default:
          y1 = 1;
          break;
      }

      return [x1, y1, x2, y2];
    };
    /**
     * 计算注释的其实位置以及展示方向
     * @param x
     * @param y
     * @param width
     * @param height
     * @param direction
     * @returns {{startPos: *[], direction: string}}
     */

    var getAnnotateStartPosAndDirection = function getAnnotateStartPosAndDirection(_ref) {
      var x = _ref.x,
          y = _ref.y,
          width = _ref.width,
          height = _ref.height,
          direction = _ref.direction;
      var cx = x + width / 2,
          cy = y + height / 2;
      var sx, sy, annotateDirection;

      switch (direction) {
        case Direction.LEFT:
          sx = x;
          sy = cy;
          annotateDirection = Direction.LEFT_TOP;
          break;

        case Direction.RIGHT:
          sx = x + width;
          sy = cy;
          annotateDirection = Direction.RIGHT_TOP;
          break;

        case Direction.BOTTOM:
          sx = cx;
          sy = y + height;
          annotateDirection = Direction.RIGHT_BOTTOM;
          break;

        default:
          sx = cx;
          sy = y;
          annotateDirection = Direction.RIGHT_TOP;
      }

      return {
        startPos: [sx, sy],
        direction: annotateDirection
      };
    };

    var getImageUrl = function getImageUrl(attachmentId) {
      return Request.urls.image(attachmentId);
    };

    var PATTERN_CANVAS, PATTERN_CTX, IMAGE_CANVAS, IMAGE_CTX;
    /**
     * 创建图片填充时用于fill的pattern
     * @param image
     * @param imageFill
     * @param originFill
     * @param rectShape
     * @param plot
     * @returns {CanvasPattern}
     */

    var createPattern = function createPattern(image, imageFill, originFill, rectShape, plot) {
      if (!PATTERN_CANVAS) {
        PATTERN_CANVAS = createCanvas$1();
        PATTERN_CTX = PATTERN_CANVAS.getContext('2d');
        IMAGE_CANVAS = createCanvas$1();
        IMAGE_CTX = IMAGE_CANVAS.getContext('2d');
      }

      var x = rectShape.x,
          y = rectShape.y,
          rectWidth = rectShape.width,
          rectHeight = rectShape.height;
      var px = plot.x,
          py = plot.y,
          pw = plot.width,
          ph = plot.height;
      var plotWidth = px + pw,
          plotHeight = py + ph;
      var fillType = imageFill.fillType;
      IMAGE_CANVAS.setAttribute('width', plotWidth);
      IMAGE_CANVAS.setAttribute('height', plotHeight); // 堆积

      if (fillType === 'stack') {
        IMAGE_CTX.translate(x, y);
        IMAGE_CTX.fillStyle = IMAGE_CTX.createPattern(image, 'repeat');
        IMAGE_CTX.fillRect(0, 0, plotWidth, plotHeight);
      } // 自适应
      else if (fillType === 'adaptive') {
          var width = image.width,
              height = image.height,
              aspectRatio1 = width / height,
              aspectRatio2 = rectWidth / rectHeight;
          var adaptiveWidth, adaptiveHeight; // 适应高度

          if (aspectRatio1 > aspectRatio2) {
            adaptiveHeight = rectHeight;
            adaptiveWidth = adaptiveHeight * aspectRatio1;
          } // 适应宽度
          else {
              adaptiveWidth = rectWidth;
              adaptiveHeight = adaptiveWidth / aspectRatio1;
            }

          IMAGE_CTX.translate(x + (rectWidth - adaptiveWidth) / 2, y + (rectHeight - adaptiveHeight) / 2);
          IMAGE_CTX.drawImage(image, 0, 0, width, height, 0, 0, adaptiveWidth, adaptiveHeight);
        } else {
          // 居中
          var _width = image.width,
              _height = image.height;
          var fill = originFill; // NOTE 原来的填充如果是渐变色，这里得从ZRender的gradient里面拿出stop重新实现一下

          if (typeof originFill !== 'string') {
            var _x = originFill.x,
                _y = originFill.y,
                x2 = originFill.x2,
                y2 = originFill.y2,
                colorStops = originFill.colorStops;
            var stop1 = colorStops[0],
                stop2 = colorStops[1];
            fill = IMAGE_CTX.createLinearGradient(_x, _y, x2, y2);
            fill.addColorStop(stop1.offset, stop1.color);
            fill.addColorStop(stop2.offset, stop2.color);
          } // NOTE 自适应和堆积都是图片填充满柱子的，center的时候，图片可能填充不满柱子，此时先填充canvas再绘制图片


          IMAGE_CTX.fillStyle = fill;
          IMAGE_CTX.fillRect(0, 0, plotWidth, plotHeight);
          IMAGE_CTX.translate(x, y);
          var minWidth = Math.min(_width, rectWidth),
              minHeight = Math.min(_height, rectHeight);
          var imageX = Math.max(0, (_width - rectWidth) / 2),
              imageY = Math.max(0, (_height - rectHeight) / 2),
              plotX = Math.max(0, (rectWidth - _width) / 2),
              plotY = Math.max(0, (rectHeight - _height) / 2);
          IMAGE_CTX.drawImage(image, imageX, imageY, minWidth, minHeight, plotX, plotY, minWidth, minHeight);
        }

      return PATTERN_CTX.createPattern(IMAGE_CANVAS, 'no-repeat');
    };
    /**
     * pattern controller
     * @param imageFill
     * @param originFill
     * @param rectShape
     * @param plot
     * @returns {*}
     */


    var getImagePattern = function getImagePattern(imageFill, originFill, rectShape, plot) {
      var id = imageFill.src;
      var src = getImageUrl(id);

      if (!src) {
        return null;
      }

      return {
        load: function load(cb) {
          var image = new Image(); // NOTE 考虑到图片未加载情况下创建的pattern无效，这边追加一个回调，render的时候，在回调成功后更新rect的fill

          image.onload = function () {
            var fill = createPattern(image, imageFill, originFill, rectShape, plot);
            cb(fill);
          };

          image.src = src;
        }
      };
    }; // consider hover shape


    var shapeEqual = function shapeEqual(s1, s2) {
      var dx = Math.abs(s1.x - s2.x) <= H_ENLARGE_SIZE;
      var dy = Math.abs(s1.y - s2.y) <= H_ENLARGE_SIZE;
      var dw = Math.abs(s1.width - s2.width) <= 2 * H_ENLARGE_SIZE;
      var dh = Math.abs(s1.height - s2.height) <= 2 * H_ENLARGE_SIZE;
      return dx && dy && dw && dh;
    };
    /**
     * 是否需要更新pattern
     * @param el
     * @param imageFill
     * @param shape
     * @returns {boolean}
     */


    var needUpdateImageFill = function needUpdateImageFill(el, imageFill, shape) {
      var src = imageFill.src,
          fillType = imageFill.fillType;
      var _el$lastShape = el.lastShape,
          lastShape = _el$lastShape === void 0 ? {} : _el$lastShape,
          pattern = el.pattern,
          attachId = el.attachId,
          eFillType = el.fillType; // NOTE 形状或者src或者fillType发生改变，都需要更新pattern

      var stayStill = shapeEqual(lastShape, shape) && attachId === src && eFillType === fillType && pattern != null;
      return !stayStill;
    };
    /**
     * ref
     * @param imageFill
     * @param shape
     * @param style
     * @param plot
     * @returns {Function}
     */


    var getIntervalRef = function getIntervalRef(imageFill, shape, style, plot) {
      return function (el) {
        if (!el) {
          return;
        }

        if (needUpdateImageFill(el, imageFill, shape)) {
          var src = imageFill.src,
              fillType = imageFill.fillType;
          var pattern = getImagePattern(imageFill, style.fill, shape, plot);
          pattern && pattern.load(function (fill) {
            el && el.setStyle('fill', fill);
            el.pattern = fill;
            el.attachId = src;
            el.fillType = fillType;
            el.lastShape = shape;
          });
        } else {
          var _pattern = el.pattern;
          style.fill = _pattern;
          el.setStyle('fill', _pattern);
        }
      };
    };
    var getRegionLineShape = function getRegionLineShape(shape, inverted, reversed) {
      var x = shape.x,
          y = shape.y,
          width = shape.width,
          height = shape.height;
      var regionStartX = x + (inverted ? reversed ? width : 0 : width / 2),
          regionStartY = y + (inverted ? height / 2 : reversed ? 0 : height);
      return {
        x1: regionStartX,
        x2: regionStartX,
        y1: regionStartY,
        y2: regionStartY
      };
    };
    var MIN_INTERVAL_SIZE = 2;
    /**
     *
     * @这个问题起源于: CHART-8982
     * 大概是这样的, 理论上值为0的柱子, 其对应的高度也为0
     * 但是产品的设计中, 有希望所有有意义的数据可见, 于是就给了一个最小的高度限制
     * 看着似乎没什么问题, 但是只要有高度就会占据空间, 所有这里就有了一个疑问, 对于0高度的柱子, 在限制最小的高度之后, 该往哪个方向画？
     * 之前的做法默认是上右, 但是如果是纯负数轴的话, 往上画的话就会超出绘图区
     * 然后在值轴调整的时候判断有图形溢出，就会尝试调整值轴的值域
     * 从而就有了这个问题
     *
     * 个人倾向将它认为是产品设计中的冲突, 但是如果仅因此就批判王军设计的不好或者砍掉这个功能, 也是不合情理的
     * 这里我们换个角度看待问题, 对于0高度，在限制最小高度之后, 其生长方向应该在当前空余的空间里
     * 比如值域为0 ~ positive， 那么此时就理解为+0, 往正方向生长， 反之亦同理
     *
     * @param shape
     * @param bounds
     * @param r
     * @returns {*}
     */

    var adjustIntervalShape = function adjustIntervalShape(shape, bounds, r) {
      if (r === void 0) {
        r = 0;
      }

      if (shape.height > 0 && shape.width > 0) {
        return _extends({}, shape, {
          r: r
        });
      }

      var edgeChecker = getEdgeChecker(bounds);
      var x = shape.x,
          y = shape.y,
          width = shape.width,
          height = shape.height,
          direction = shape.direction;

      if (height === 0) {
        height = MIN_INTERVAL_SIZE;
        y = edgeChecker.onTopEdge(y) ? y : y - height;
      }

      if (width === 0) {
        width = MIN_INTERVAL_SIZE;
        x = edgeChecker.onRightEdge(x) ? x - width : x;
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height,
        direction: direction,
        r: r
      };
    };

    var calcRectShape = function calcRectShape(posX, posY, posY0, size, inverted) {
      var yy0 = Math.abs(posY0 - posY);
      var top = Math.min(posY, posY0),
          left = posX - size / 2;
      var x, y, width, height, direction;

      if (inverted) {
        x = top;
        y = left;
        width = yy0;
        height = size;
        direction = posY > posY0 ? Direction.RIGHT : Direction.LEFT;
      } else {
        x = left;
        y = top;
        width = size;
        height = yy0;
        direction = posY > posY0 ? Direction.BOTTOM : Direction.TOP;
      }

      var shape = rectSubPixelOpt({
        x: x,
        y: y,
        width: width,
        height: height
      });
      shape.direction = direction;
      return shape;
    };
    var layout$2 = function layout(rows, _ref) {
      var geom = _ref.geom,
          inverted = _ref.inverted;
      var _geom$sizeScale = geom.sizeScale,
          sizeScale = _geom$sizeScale === void 0 ? 1 : _geom$sizeScale;

      _.each(rows, function (row) {
        row.size *= sizeScale;
        var x = row.x,
            y = row.y,
            y0 = row.y0,
            size = row.size;
        var shape = calcRectShape(x, y, y0, size, inverted);
        row.shape = row.vanish ? vanishShape$1(shape) : shape;
        exchangeXY(row, inverted);
      });
    };

    var CATEGORY_GAP = 0.2;
    var MIN_COLUMN_COUNT = 1;

    function dealIntervalGapWhileMeasureOverlap(geom, geomFacet, baseFacet, chart) {
      var dataModel = geom.data,
          frames = geom.frames,
          size = geom.size;
      var sizeAes = getAesInstance(AesTypes.SIZE, geom, size);

      if (dataModel.getColById(AesTypes.SIZE).length === 0) {
        return []; // @BI-40485
      }

      var sizeCol = sizeAes.dealMapping(dataModel);
      var isConst = sizeAes.isConstField(),
          constSize = isConst ? sizeCol[0] : -1,
          unit = baseFacet.unit;
      var countAndIndex = getIntervalCountAndIndex(geom, geomFacet, chart);
      var columnCount = countAndIndex[0],
          columnIndex = countAndIndex[1];
      var dimWidth = 1 - CATEGORY_GAP; // 可用的维度宽度

      var width = dimWidth / columnCount,
          // 默认的柱子宽度
      offset = CATEGORY_GAP / 2 + width * (columnIndex + 0.5); // 默认的柱子间隔

      var posX = frames[0].value; // 当作系列间隔处理宽度

      if (isConst && columnCount > MIN_COLUMN_COUNT) {
        // constSize 为1时柱子宽度最大，此时系列间隔为-1，表示柱子之间的间隔最小，此时柱子的宽度为分类的宽度，所有柱子重叠
        // constSize 为0时柱子宽度最小，此时系列间隔为1， 表示柱子间的间隔最大，此时柱子的宽度为1，即最小宽度
        var seriesGap = -2 * (constSize - 0.5);

        if (seriesGap > 0) {
          // 柱子不堆叠
          width *= 1 - seriesGap; // 默认的宽度再减去系列间隔
        } else {
          // 柱子堆叠
          var overlap = -seriesGap * dimWidth; // 重叠的部分

          var beyond = (dimWidth - overlap) / columnCount; // 重叠之外的宽度

          width = overlap + beyond; // 柱子宽度为重叠部分 + (剩余部分 / columnCount)

          offset = CATEGORY_GAP / 2 + beyond * (columnIndex + 0.5) + overlap * 0.5;
        }

        for (var i = 0, len = sizeCol.length; i < len; i++) {
          // 原来的计算位置在维度中心点，这边先计算最左边，然后再加上offset即可
          posX[i] = posX[i] + (-0.5 + offset) * unit;
          sizeCol[i] = Math.max(width * unit, 1);
        }
      } // 按照数量均分维度宽度处理
      else {
          for (var _i = 0, _len = sizeCol.length; _i < _len; _i++) {
            // 原来的计算位置在维度中心点，这边先计算最左边，然后再加上offset即可
            posX[_i] = posX[_i] + (-0.5 + offset) * unit;
            sizeCol[_i] = Math.max(sizeCol[_i] * unit * dimWidth / columnCount, 1);
          }
        }

      return sizeCol;
    }

    var FIRST_KEY = '0';
    var SECOND_KEY = '1';

    function getIntervalCountAndIndex(geom, facet, chart) {
      var id = geom.measure;
      var measures = facet.measures;
      var secondMeasureIds = measures[1];
      var firstStackIds = [],
          secondStackIds = [],
          ids = [];

      _.each(chart.geoms, function (geom) {
        var type = geom.type,
            measure = geom.measure,
            stack = geom.stack;

        if (type !== ChartLibrary.INTERVAL) {
          return;
        }

        if (stack) {
          var inSecondAxis = _.contains(secondMeasureIds, measure);

          var stackIds = inSecondAxis ? secondStackIds : firstStackIds; // 共享轴上堆积的柱子的位置应该是该轴上第一个开启堆积的柱子

          stackIds.length === 0 && ids.push(inSecondAxis ? SECOND_KEY : FIRST_KEY);
          stackIds.push(measure);
        } else {
          ids.push(measure);
        }
      });

      var count = ids.length;
      var key = id;

      if (_.contains(firstStackIds, id)) {
        key = FIRST_KEY;
      } else if (_.contains(secondStackIds, id)) {
        key = SECOND_KEY;
      }

      return [count, _.indexOf(ids, key)];
    }
    /**
     * adjust Interval.size
     * @param geom
     * @param chart
     */


    var adjust$3 = function adjust(geom, chart) {
      var facetX = chart.facetX,
          facetY = chart.facetY,
          data = geom.data,
          size = geom.size,
          _diffFacet = diffFacet(facetX, facetY),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet,
          unit = baseFacet.unit,
          baseFacetHasMeasure = baseFacet.hasMeasure,
          geomFacetHasMeasure = geomFacet.hasMeasure,
          measuresOverlapped = geomFacet.measuresOverlapped;

      var fixedWidth = baseFacetHasMeasure && geomFacetHasMeasure; // 是否为固定宽度1-150px

      var sizeCol = data.getColById(AesTypes.SIZE);
      var newSizeCol;

      if (measuresOverlapped && !baseFacetHasMeasure) {
        newSizeCol = dealIntervalGapWhileMeasureOverlap(geom, geomFacet, baseFacet, chart);
        data.replaceCol(AesTypes.SIZE, newSizeCol);
      } else {
        var sizeAes = getAesInstance(AesTypes.SIZE, geom, size);
        newSizeCol = sizeAes.dealMapping(data); // 非指标聚合或者横轴上存在指标时, 判断百分比大小后更新colData

        _.each(sizeCol, function (value, i) {
          sizeCol[i] = fixedWidth ? newSizeCol[i] : newSizeCol[i] * unit;
        });
      }
    };

    var GRAPHIC_LABEL_GAP = 5;
    var getIntervalLabelPos = function getIntervalLabelPos(shape, labelBounds, position) {
      var lw = labelBounds.width,
          lh = labelBounds.height;
      var x = shape.x,
          y = shape.y,
          width = shape.width,
          height = shape.height,
          direction = shape.direction; // suppose initial position is center

      var cx = x + width / 2,
          cy = y + height / 2;
      var inside = position === DataLabel.INSIDE,
          center = position === DataLabel.CENTER,
          outside = !inside && !center;
      var h2 = height - lh - GRAPHIC_LABEL_GAP,
          h3 = height + lh + GRAPHIC_LABEL_GAP,
          w2 = width - lw - GRAPHIC_LABEL_GAP,
          w3 = width + lw + GRAPHIC_LABEL_GAP;

      switch (direction) {
        case Direction.TOP:
          cy -= (inside ? h2 : outside ? h3 : 0) / 2;
          break;

        case Direction.BOTTOM:
          cy += (inside ? h2 : outside ? h3 : 0) / 2;
          break;

        case Direction.RIGHT:
          cx += (inside ? w2 : outside ? w3 : 0) / 2;
          break;

        case Direction.LEFT:
          cx -= (inside ? w2 : outside ? w3 : 0) / 2;
          break;
      }

      return [cx, cy];
    };
    function calcDataLabelPos$3(_ref) {
      var position = _ref.position,
          bounds = _ref.bounds,
          row = _ref.row;
      return getIntervalLabelPos(row.shape, bounds, position);
    }

    var appear$3 = function appear(attr) {
      return {
        shape: vanishShape$1(attr.shape)
      };
    };

    var Timing$5 = {
      INIT: {
        duration: 1200,
        ease: Ease.EaseOutCubic,
        appear: appear$3
      },
      SHOW_ENTER: {
        duration: 900,
        ease: Ease.EaseOutQuint,
        appear: appear$3
      },
      SHOW_UPDATE: {
        duration: 250,
        ease: Ease.EaseOutRevise
      },
      HOVER: {
        duration: 150,
        ease: Ease.Default
      },
      HIDE_UPDATE: {
        delay: 200,
        duration: 250,
        ease: Ease.EaseOutRevise
      },
      HIDE_LEAVE: {
        duration: 150,
        ease: Ease.EaseInBack
      }
    };

    var getTransitionProps$5 = getGeomTransitionProps(Timing$5);

    var hoverProps = function hoverProps(shape, style) {
      hoverShape$1(shape);
      hoverStyle(style);
    };

    var TOTAL_EFFECT_TIME = 2800;
    var EFFECT_STEP$1 = 600;
    var EFFECT_DURATION$1 = 1600;

    var Interval =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Interval, _Geometry);

      function Interval(props, ctx) {
        var _this;

        _this = _Geometry.call(this, props, ctx) || this;
        _this.type = ChartLibrary.INTERVAL;
        _this.getTransitionProps = getTransitionProps$5;
        return _this;
      }

      var _proto = Interval.prototype;

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            row = node.data;
        var bounds = this.props.bounds;
        var _this$props = this.props,
            opacity = _this$props.opacity,
            gradual = _this$props.gradual,
            borderColor = _this$props.borderColor,
            _this$props$roundRadi = _this$props.roundRadius,
            r = _this$props$roundRadi === void 0 ? 0 : _this$props$roundRadi,
            plot = _this$props.plot,
            measure = _this$props.measure,
            facetY = _this$props.facetY,
            isMap = _this$props.isMap;
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isHover = transitionProps.isHover,
            isFade = transitionProps.isFade,
            z = transitionProps.z,
            silent = transitionProps.silent;
        var color = row.color,
            fake = row.fake,
            imageFill = row.imageFill,
            effect = row.effect,
            vanish = row.vanish;
        var shape = vanish ? row.shape : adjustIntervalShape(row.shape, bounds, r); //

        if (measure == null && !isMap) {
          shape.height = facetY.unit / 2;
        }

        var direction = shape.direction;
        var style = {
          fill: color,
          opacity: opacity,
          shadowColor: 'transparent',
          shadowBlur: 0,
          stroke: effect ? null : borderColor || color
        };
        fake && fakeStyle(style); // fake data get half opacity

        isFade && fadeStyle(style);
        isHover && hoverProps(shape, style);

        if (gradual && !isFade) {
          style.fill = getLinearGradualColor({
            color: style.fill,
            type: ChartLibrary.INTERVAL,
            stops: getGradualStops(direction)
          });
        }

        return h('rect', {
          key: key,
          id: key,
          silent: silent,
          z: z,
          ref: imageFill && getIntervalRef(imageFill, shape, style, plot),
          shape: shape,
          style: style,
          transition: transition,
          transitionEnd: transitionEnd
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var isHover = refer.isHover;
        var row = node.data;

        if (isHover) {
          refer.translate = getLabelHoverTranslate(row.shape.direction);
        }

        if (row.annotation) {
          var _getAnnotateStartPosA = getAnnotateStartPosAndDirection(row.shape),
              startPos = _getAnnotateStartPosA.startPos,
              direction = _getAnnotateStartPosA.direction;

          refer.startPos = startPos;
          refer.direction = direction;
        }
      };

      _proto.showEffect = function showEffect(key, effect) {
        var _this2 = this;

        var i = 0;
        var durationRatio = effect * 1000 / TOTAL_EFFECT_TIME;

        var _loop = function _loop() {
          var effectNode = _this2.getZNode(key + EFFECT_SUFFIX + i);

          var delay = EFFECT_STEP$1 * durationRatio * (i - 1);
          var duration = EFFECT_DURATION$1 * durationRatio;

          var animator = _this2.createEffectAni(key, effect, duration, delay);

          animator.during(function (_ref) {
            var pct = _ref.pct;

            var row = _this2.getRow(key);

            var _row$shape = row.shape,
                x = _row$shape.x,
                y = _row$shape.y,
                width = _row$shape.width,
                height = _row$shape.height;
            var inverted = _this2.props.inverted;
            var opacity = 0.8 * (1 - pct),
                lineWidth = (inverted ? height : width) * pct / 4,
                shape = {
              x: x - lineWidth / 2,
              y: y - lineWidth / 2,
              width: width + lineWidth,
              height: height + lineWidth
            };
            effectNode.setStyle({
              opacity: opacity,
              lineWidth: lineWidth
            });
            effectNode.attr('shape', shape);
          }).start();
        };

        while (i++ < 3) {
          _loop();
        }
      };

      _proto.renderEffect = function renderEffect(node) {
        var row = node.data,
            key = node.key;
        var shape = row.shape,
            color = row.color;
        var style = {
          fill: 'transparent',
          stroke: color,
          opacity: 0,
          lineWidth: 1
        };
        var i = 0;
        var effectNodes = [];

        while (i++ < 3) {
          effectNodes.push(h('rect', {
            key: key + EFFECT_SUFFIX + i,
            silent: true,
            style: style,
            shape: shape
          }));
        }

        return effectNodes;
      };

      _proto.renderGuides = function renderGuides(refer, node) {
        var guides = _Geometry.prototype.renderGuides.call(this, refer, node);

        var row = node.data,
            key = node.key,
            type = node.type;

        if (row.fake) {
          var _this$props2 = this.props,
              inverted = _this$props2.inverted,
              reversed = _this$props2.reversed;
          var transition = refer.transition;
          var x = row.x,
              y = row.y,
              upper = row.upper,
              lower = row.lower;
          var lineShape = getRegionLineShape(row.shape, inverted, reversed);
          guides.push(renderRegionLine({
            key: key,
            transition: transition,
            stroke: row.color,
            points: [x, y, upper, lower],
            inverted: inverted,
            type: type,
            appear: function appear() {
              return {
                shape: lineShape
              };
            }
          }));
        }

        return guides;
      };

      return Interval;
    }(Geometry);

    Geom.registerGeom(ChartLibrary.INTERVAL, Interval);
    Interval.layout = layout$2;
    Interval.adjust = adjust$3;

    Interval.usePercentSize = function (baseFacet) {
      return !baseFacet.hasMeasure;
    };

    Interval.updateGeometryWhileZoomScale = function (_ref2) {
      var geom = _ref2.geom,
          zoom = _ref2.zoom,
          inverted = _ref2.inverted;
      geom.sizeScale = zoom[inverted ? 'y' : 'x'];
    };

    Interval.calcDataLabelPos = calcDataLabelPos$3;

    Interval.getRowBounds = function (row, x, inverted) {
      var y = row.y,
          y0 = row.y0,
          size = row.size;
      return calcRectShape(x, y, y0, size, inverted);
    };

    /**
     * 热力地区渐变色绘制抽象
     */
    var DEFAULT_GRADIENT = {
      0.25: 'rgb(0,0,255)',
      0.55: 'rgb(0,255,0)',
      0.85: 'yellow',
      1.0: 'rgb(255,0,0)'
    };
    var DEFAULT_MAX_OPACITY = 1;
    var DEFAULT_MIN_OPACITY = 0;
    var DEFAULT_BLUR = 1;

    var HeatMapLayer =
    /*#__PURE__*/
    function () {
      function HeatMapLayer() {
        var shadowCanvas = this.shadowCanvas = createCanvas$1();
        var canvas = this.canvas = createCanvas$1();
        this._renderBoundaries = [10000, 10000, 0, 0];
        this._templates = {};
        this.shadowCtx = shadowCanvas.getContext('2d');
        this.ctx = canvas.getContext('2d');
        return this;
      }

      var _proto = HeatMapLayer.prototype;

      _proto.setConfig = function setConfig(config) {
        if (config === void 0) {
          config = {};
        }

        if (config['gradient'] || !this._palette) {
          this._updateGradient(config['gradient']);
        }

        this._setStyles(config);
      };

      _proto.setData = function setData(data) {
        var dataPoints = data.data;
        var pointsLen = dataPoints.length;

        this._clear();

        this._data = [];
        this._radi = [];
        this._opaci = [];

        for (var i = 0; i < pointsLen; i++) {
          this._organiseData(dataPoints[i], false);
        }

        this._max = data.max;
        this._min = data.min || 0;
        this.render({
          min: this._min,
          max: this._max,
          data: this._data,
          radi: this._radi,
          opaci: this._opaci
        });
      };

      _proto._organiseData = function _organiseData(dataPoint) {
        var x = dataPoint._x = dataPoint.x - this._x >> 0;
        var y = dataPoint._y = dataPoint.y - this._y >> 0;
        var radi = this._radi;
        var store = this._data;
        var opaci = this._opaci;
        var max = this._max;
        var min = this._min;
        var value = dataPoint.value;
        var radius = dataPoint.radius;

        if (!store[x]) {
          store[x] = [];
          radi[x] = [];
          opaci[x] = [];
        }

        if (!store[x][y]) {
          store[x][y] = value;
          radi[x][y] = radius;
          opaci[x][y] = dataPoint.fake ? 0.5 : 1;
        } else {
          store[x][y] += value;
        }

        return {
          x: x,
          y: y,
          value: value,
          radius: radius,
          min: min,
          max: max
        };
      };

      _proto.render = function render(data) {
        if (data.data.length > 0) {
          this._drawAlpha(prepareData(data));

          this._colorize();
        }
      };

      _proto._updateGradient = function _updateGradient(config) {
        this._palette = getColorPalette(config);
      };

      _proto._setDimensions = function _setDimensions(x, y, width, height) {
        this._x = x;
        this._y = y;
        this._width = this.canvas.width = this.shadowCanvas.width = width;
        this._height = this.canvas.height = this.shadowCanvas.height = height;
      };

      _proto._clear = function _clear() {
        this.shadowCtx.clearRect(0, 0, this._width, this._height);
        this.ctx.clearRect(0, 0, this._width, this._height);
      };

      _proto._setStyles = function _setStyles(_ref) {
        var _ref$blur = _ref.blur,
            blur = _ref$blur === void 0 ? DEFAULT_BLUR : _ref$blur,
            backgroundColor = _ref.backgroundColor,
            _ref$width = _ref.width,
            width = _ref$width === void 0 ? 100 : _ref$width,
            _ref$height = _ref.height,
            height = _ref$height === void 0 ? 100 : _ref$height,
            _ref$x = _ref.x,
            x = _ref$x === void 0 ? 0 : _ref$x,
            _ref$y = _ref.y,
            y = _ref$y === void 0 ? 0 : _ref$y,
            _ref$maxOpacity = _ref.maxOpacity,
            maxOpacity = _ref$maxOpacity === void 0 ? DEFAULT_MAX_OPACITY : _ref$maxOpacity,
            _ref$minOpacity = _ref.minOpacity,
            minOpacity = _ref$minOpacity === void 0 ? DEFAULT_MIN_OPACITY : _ref$minOpacity,
            _ref$opacity = _ref.opacity,
            opacity = _ref$opacity === void 0 ? 0 : _ref$opacity,
            _ref$useGradientOpaci = _ref.useGradientOpacity,
            useGradientOpacity = _ref$useGradientOpaci === void 0 ? false : _ref$useGradientOpaci;
        this._blur = blur; // maybe no needed ...

        if (backgroundColor) {
          this.canvas.style.backgroundColor = backgroundColor;
        }

        width = width >> 0;
        height = height >> 0;

        this._setDimensions(x, y, width, height);

        this._opacity = opacity * 255;
        this._maxOpacity = maxOpacity * 255;
        this._minOpacity = minOpacity * 255;
        this._useGradientOpacity = useGradientOpacity;
      };

      _proto._drawAlpha = function _drawAlpha(data) {
        var min = this._min = data.min;
        var max = this._max = data.max;
        data = data.data || [];
        var dataLen = data.length; // on a point basis?

        var blur = 1 - this._blur;

        while (dataLen--) {
          var point = data[dataLen];
          var x = point.x;
          var y = point.y;
          var radius = point.radius; // if value is bigger than max
          // use max as value

          var value = Math.min(point.value, max);
          var rectX = x - radius;
          var rectY = y - radius;
          var shadowCtx = this.ctx;
          var tpl = void 0;

          if (!this._templates[radius]) {
            this._templates[radius] = tpl = getPointTemplate(radius, blur);
          } else {
            tpl = this._templates[radius];
          } // value from minimum / value range
          // => [0, 1]


          var templateAlpha = (min === max ? 1 : (value - min) / (max - min)) * point.opacity; // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData

          shadowCtx.globalAlpha = templateAlpha < 0.01 ? 0.01 : templateAlpha;

          if (radius > 0.5) {
            //动画过程会出现
            shadowCtx.drawImage(tpl, rectX, rectY);
          } // update renderBoundaries


          if (rectX < this._renderBoundaries[0]) {
            this._renderBoundaries[0] = rectX;
          }

          if (rectY < this._renderBoundaries[1]) {
            this._renderBoundaries[1] = rectY;
          }

          if (rectX + 2 * radius > this._renderBoundaries[2]) {
            this._renderBoundaries[2] = rectX + 2 * radius;
          }

          if (rectY + 2 * radius > this._renderBoundaries[3]) {
            this._renderBoundaries[3] = rectY + 2 * radius;
          }
        }
      };

      _proto._colorize = function _colorize() {
        var x = this._renderBoundaries[0];
        var y = this._renderBoundaries[1];
        var width = this._renderBoundaries[2] - x;
        var height = this._renderBoundaries[3] - y;
        var maxWidth = this._width;
        var maxHeight = this._height;
        var opacity = this._opacity;
        var maxOpacity = this._maxOpacity;
        var minOpacity = this._minOpacity;
        var useGradientOpacity = this._useGradientOpacity;

        if (x < 0) {
          x = 0;
        }

        if (y < 0) {
          y = 0;
        }

        if (x + width > maxWidth) {
          width = maxWidth - x;
        }

        if (y + height > maxHeight) {
          height = maxHeight - y;
        }

        var img = this.ctx.getImageData(x, y, width, height);
        var imgData = img.data;
        var len = imgData.length;
        var palette = this._palette;

        for (var i = 3; i < len; i += 4) {
          var alpha = imgData[i];
          var offset = alpha * 4;

          if (!offset) {
            continue;
          }

          var finalAlpha = void 0;

          if (opacity > 0) {
            finalAlpha = opacity;
          } else {
            if (alpha < maxOpacity) {
              if (alpha < minOpacity) {
                finalAlpha = minOpacity;
              } else {
                finalAlpha = alpha;
              }
            } else {
              finalAlpha = maxOpacity;
            }
          }

          imgData[i - 3] = palette[offset];
          imgData[i - 2] = palette[offset + 1];
          imgData[i - 1] = palette[offset + 2];
          imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;
        } // img.data = imgData;


        this.ctx.putImageData(img, x, y);
        this._renderBoundaries = [1000, 1000, 0, 0];
      };

      _proto.getValueAt = function getValueAt(point) {
        var value;
        var shadowCtx = this.shadowCtx;
        var img = shadowCtx.getImageData(point._x, point._y, 1, 1);
        var data = img.data[3];
        var max = this._max;
        var min = this._min;
        value = Math.abs(max - min) * (data / 255) >> 0;
        return value;
      };

      _proto.getDataURL = function getDataURL() {
        return this.canvas.toDataURL();
      };

      return HeatMapLayer;
    }();

    function getColorPalette(_gradient) {
      if (_gradient === void 0) {
        _gradient = DEFAULT_GRADIENT;
      }

      var paletteCanvas = createCanvas$1();
      var paletteCtx = paletteCanvas.getContext('2d');
      paletteCanvas.width = 256;
      paletteCanvas.height = 1;
      var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);

      for (var key in _gradient) {
        gradient.addColorStop(key, _gradient[key]);
      }

      paletteCtx.fillStyle = gradient;
      paletteCtx.fillRect(0, 0, 256, 1);
      return paletteCtx.getImageData(0, 0, 256, 1).data;
    }

    function getPointTemplate(radius, blurFactor) {
      var tplCanvas = createCanvas$1();
      var tplCtx = tplCanvas.getContext('2d');
      var x = radius;
      var y = radius;
      tplCanvas.width = tplCanvas.height = radius * 2;

      if (blurFactor == 1) {
        tplCtx.beginPath();
        tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
        tplCtx.fillStyle = 'rgba(0,0,0,1)';
        tplCtx.fill();
      } else {
        var gradient = tplCtx.createRadialGradient(x, y, radius * blurFactor, x, y, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        tplCtx.fillStyle = gradient;
        tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
      }

      return tplCanvas;
    }

    function prepareData(data) {
      var renderData = [];
      var min = data.min;
      var max = data.max;
      var radi = data.radi,
          opaci = data.opaci;
      data = data.data;
      var xValues = Object.keys(data);
      var xValuesLen = xValues.length;

      while (xValuesLen--) {
        var xValue = xValues[xValuesLen];
        var yValues = Object.keys(data[xValue]);
        var yValuesLen = yValues.length;

        while (yValuesLen--) {
          var yValue = yValues[yValuesLen];
          var value = data[xValue][yValue];
          var radius = radi[xValue][yValue];
          renderData.push({
            x: xValue,
            y: yValue,
            value: value,
            radius: radius,
            opacity: opaci[xValue][yValue]
          });
        }
      }

      return {
        min: min,
        max: max,
        data: renderData
      };
    }

    var reCalculateGradientConfig = function reCalculateGradientConfig(_ref, geom) {
      var _min = _ref[0],
          _max = _ref[1];
      var color = geom.color,
          opacity = geom.opacity;
      var range = color.range;
      var aes = getAesInstance(AesTypes.COLOR, geom, color);
      var domain = color.id ? aes.domain : [1, color.max];
      var min = domain[0],
          max = domain[domain.length - 1];
      var niceDomain = getStepDomainWithRanges([min, max], range);
      var gradientConfig = {
        min: min,
        max: max,
        minOpacity: 0,
        maxOpacity: opacity,
        radius: 40,
        blur: 1,
        gradient: _.reduce(niceDomain, function (g, d, i) {
          g[(d - min) / (max - min)] = range[i];
          return g;
        }, {})
      };

      if (_min === _max) {
        return gradientConfig;
      }

      if (_min >= max || _max <= min || _min <= min && _max >= max) {
        return gradientConfig;
      }

      var colorScale = linear$2().domain(domain).range(range).interpolate(interpolateValue).interpolate(interpolateValue);
      var valueScale = linear$2().domain([_min, _max]).range([0, 1]);
      var newGradient = {
        0: colorScale(_min),
        1: colorScale(_max)
      };

      _.each(domain, function (value, i) {
        if (value > _min && value < _max) {
          newGradient[valueScale(value)] = range[i];
        }
      });

      return _extends({}, gradientConfig, {
        min: _min,
        max: _max,
        gradient: newGradient
      });
    };

    var ENTER_DURATION = 500;
    var UPDATE_DURATION = 500;

    var getAttr$1 = function getAttr(row, inverted) {
      var x = row.x,
          y = row.y;

      if (inverted) {
        var _ref = [y, x];
        x = _ref[0];
        y = _ref[1];
      }

      return _extends({}, row, {
        x: x,
        y: y
      });
    };

    var HeatMap =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(HeatMap, _Component);

      function HeatMap(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;
        _this._heatMapLayer = new HeatMapLayer();
        _this.state = {
          data: []
        };

        _this.updateState(_this.props);

        return _this;
      }

      var _proto = HeatMap.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.rows !== this.props.rows) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var bounds = props.bounds,
            facetX = props.facetX,
            facetY = props.facetY,
            rows = props.rows,
            mapConfig = props.map,
            inverted = props.inverted;
        var len = rows.length,
            x = bounds.x,
            width = bounds.width,
            needAdjustX = facetX.measures.length === 0 && facetY.measures.length === 0 && !mapConfig;

        var adjustX = function adjustX(i) {
          return x + (i + 1) * width / (len + 1);
        };

        var data = _.map(rows, function (row, index) {
          var datum = getAttr$1(row, inverted);

          if (needAdjustX) {
            datum[AttrKeys.X] = adjustX(index);
          }

          return datum;
        });

        this.setState({
          data: data
        });
      }
      /**
       * render= renderGradientBackGround + renderTransparentPoints
       */
      ;

      _proto.render = function render$$1() {
        var _this2 = this;

        var _this$props = this.props,
            onmousemove = _this$props.onmousemove,
            onmouseout = _this$props.onmouseout,
            onclick = _this$props.onclick,
            color = _this$props.color,
            fadeChecker = _this$props.fadeChecker,
            inverted = _this$props.inverted,
            bounds = _this$props.bounds,
            process = _this$props.process,
            animation = _this$props.animation;
        var data = this.state.data;

        if (data.length === 0) {
          return h('group', null);
        } // NOTE: 理论上颜色中拖入维度字段应该生成点击图例，但是热力点由于特殊故生成的是滑块图例，那么此时的滑块滑动的时候，
        // NOTE: fadeChecker判断的row[id]应该是维度对应的下标即..color的值，而不是原来的维度值字符串


        var unFadeData = _.filter(data, function (datum) {
          var _extends2;

          return !fadeChecker(color.id ? _extends({}, datum, (_extends2 = {}, _extends2[color.id] = datum.color, _extends2)) : datum);
        });

        var validData = _.filter(unFadeData, function (datum) {
          return !datum.vanish;
        });

        var attrList = _.map(validData, function (datum) {
          return getAttr$1(datum, inverted);
        });

        var newGradient = reCalculateGradientConfig(minMax(_.map(validData, function (d) {
          return d.color;
        })), this.props);

        this._heatMapLayer.setConfig(_extends({}, bounds, newGradient));

        var nullProcess = process == null;
        return h(NodeGroup$$1, {
          data: attrList.sort(function (a, b) {
            return b.size - a.size;
          }),
          //  @BI-38590
          keyAccessor: function keyAccessor(d) {
            return d.id;
          },
          start: function start(_ref2) {
            var x = _ref2.x,
                y = _ref2.y;
            return {
              cx: x,
              cy: y,
              upper: inverted ? x : y,
              lower: inverted ? x : y,
              r: 1
            };
          },
          enter: function enter(_ref3) {
            var x = _ref3.x,
                y = _ref3.y,
                size = _ref3.size,
                upper = _ref3.upper,
                lower = _ref3.lower;
            return {
              cx: x,
              cy: y,
              r: [size],
              upper: [upper],
              lower: [lower],
              timing: {
                duration: animation ? ENTER_DURATION : 0,
                ease: Ease.EaseOutCubic
              }
            };
          },
          update: function update(_ref4) {
            var x = _ref4.x,
                y = _ref4.y,
                size = _ref4.size,
                upper = _ref4.upper,
                lower = _ref4.lower;
            return {
              cx: nullProcess ? x : [x],
              cy: nullProcess ? y : [y],
              r: [size],
              upper: [upper],
              lower: [lower],
              timing: {
                duration: animation ? UPDATE_DURATION : 0,
                ease: Ease.EaseOutCubic
              }
            };
          },
          leave: function leave(_ref5) {
            var x = _ref5.x,
                y = _ref5.y;
            return {
              r: 0,
              upper: inverted ? y : x,
              lower: inverted ? y : x
            };
          }
        }, function (nodes) {
          return h('group', {
            onmousemove: onmousemove,
            onmouseout: onmouseout,
            onclick: onclick
          }, _this2._renderHeatBackground(nodes, newGradient), _this2._renderPoints(nodes));
        });
      } // render transparent point for trigger mouse event and dataLabel
      ;

      _proto._renderPoints = function _renderPoints(nodes) {
        var _this$props2 = this.props,
            inverted = _this$props2.inverted,
            rows = _this$props2.rows,
            bounds = _this$props2.bounds,
            dataLabel = _this$props2.dataLabel;
        return _.map(nodes, function (node, index) {
          var state = node.state,
              data = node.data;
          var upper = state.upper,
              lower = state.lower;
          var id = data.id,
              fake = data.fake,
              x = data.x,
              y = data.y;
          var row = rows[index];
          var point = h('circle', {
            id: id,
            key: id,
            data: data,
            shape: state,
            pos: [x, y],
            invisible: true
          });
          var regionLine = fake ? h('regionLine', {
            silent: true,
            z: RegionLineLayerZ,
            shape: {
              x1: inverted ? upper : x,
              y1: inverted ? y : upper,
              x2: inverted ? lower : x,
              y2: inverted ? y : lower
            },
            style: {
              stroke: Timing_Prediction.Color
            }
          }) : null;
          var labelNode = renderDataLabel$$1({
            row: row,
            dataLabel: dataLabel,
            applyTheme: true
          });
          var annotationNode = renderAnnotation({
            row: rows[index],
            startPos: [x, y],
            cellBounds: bounds
          });
          return [point, regionLine, labelNode, annotationNode];
        });
      } // 热力背景
      ;

      _proto._renderHeatBackground = function _renderHeatBackground(nodes, _ref6) {
        var min = _ref6.min,
            max = _ref6.max;
        var bounds = this.props.bounds;
        nodes = _.filter(nodes, function (node) {
          return node.type !== LEAVE;
        });

        this._heatMapLayer.setData({
          data: _.map(nodes, function (node) {
            var _node$state = node.state,
                cx = _node$state.cx,
                cy = _node$state.cy,
                r = _node$state.r,
                fake = _node$state.fake;
            return {
              x: cx,
              y: cy,
              radius: Math.max(r, 1),
              fake: fake,
              value: node.data.color
            };
          }),
          min: min,
          max: max
        }); // 热力背景


        return h('image', {
          style: _extends({}, bounds, {
            image: this._heatMapLayer.canvas
          }),
          silent: true
        });
      };

      return HeatMap;
    }(Component);

    HeatMap.calcDataLabelPos = function (_ref7) {
      var row = _ref7.row;
      return [row.x, row.y];
    };

    Geom.registerGeom(ChartLibrary.HEAT_MAP, HeatMap);

    var adjust$4 = function adjust(geom, chart) {
      var facetX = chart.facetX,
          facetY = chart.facetY,
          inverted = chart.inverted;
      var data = geom.data,
          size = geom.size,
          measure = geom.measure;

      var _diffFacet = diffFacet(facetX, facetY),
          geomFacet = _diffFacet.geomFacet; // 同时考虑反转&轴逆序, 为负是表示反方向增长


      var direction = inverted ? 1 : -1;
      var sizeAes = getAesInstance(AesTypes.SIZE, geom, size),
          sizeCol = data.getColById(AesTypes.SIZE);

      if (sizeCol.length === 0) {
        return;
      } // set geom.width


      setSquareWidth(geom, facetX, facetY);

      if (sizeAes.isConstField()) {
        _.each(sizeCol, function (v, i) {
          return sizeCol[i] = direction * geom.width;
        });
      } else {
        var scaleMap = geomFacet.scaleMap,
            nodesMap = geomFacet.nodesMap;
        var id = size.id;
        var axisKey = createGetMeasureDefKeyFunc(geomFacet)(measure),
            domain = scaleMap[axisKey].domain;
        var scale = linear$2().domain(domain);
        var root = nodesMap[NODE_ROOT];
        var range = [root.pos, root.pos + root.length / root.leafCount / (geomFacet.measuresOverlapped ? 1 : geomFacet.measures.length)];
        scale.range(range);
        var zeroPos = scale(0); // 直接用原始值计算高度

        var sizeValueCol = data.getColById(id);

        if (data.isDimension(id)) {
          var domainMap = oneBasedIndexMap(data.ordinal(id));
          sizeValueCol = _.map(sizeValueCol, function (v) {
            return domainMap[v];
          });
        }

        data.replaceCol(AesTypes.SIZE, _.map(sizeValueCol, function (value) {
          return direction * (scale(value) - zeroPos);
        }));
      }
    };

    var vanishShape$2 = function vanishShape(shape) {
      var width = shape.width,
          height = shape.height;
      shape.x += width / 2;
      shape.y += height / 2;
      shape.width = 0;
      shape.height = 0;
      return shape;
    };

    var getYY0 = function getYY0(_ref, reversed) {
      var y = _ref.y,
          size = _ref.size;
      return {
        y0: y,
        y: y + size * (reversed ? -1 : 1)
      };
    };
    var layoutRow = function layoutRow(row, width, inverted, reversed) {
      var x = row.x;

      var _getYY = getYY0(row, reversed),
          y = _getYY.y,
          y0 = _getYY.y0;

      var shape = calcRectShape(x, y, y0, width, inverted);
      return row.vanish ? vanishShape$2(shape) : shape;
    };
    var layout$3 = function layout(rows, _ref2) {
      var inverted = _ref2.inverted,
          _ref2$geom = _ref2.geom,
          width = _ref2$geom.width,
          reversed = _ref2$geom.reversed;

      _.each(rows, function (row) {
        // row.size *= zoom[inverted ? "x" : "y"];
        row.shape = layoutRow(row, width, inverted, reversed);
        exchangeXY(row, inverted);
      });
    };

    var appear$4 = function appear() {
      return {
        scale: [0, 0]
      };
    };

    var H_ENLARGE_SIZE$1 = 1;
    var hoverProps$1 = function hoverProps(_ref) {
      var shape = _ref.shape,
          style = _ref.style;
      var s = H_ENLARGE_SIZE$1;
      shape.x -= s;
      shape.y -= s;
      shape.width += s * 2;
      shape.height += s * 2;
      hoverStyle(style);
    };
    var Timing$6 = {
      INIT: {
        duration: 800,
        ease: Ease.EaseOutBounce,
        appear: appear$4
      },
      SHOW_ENTER: {
        duration: 800,
        ease: Ease.EaseOutQuint,
        appear: appear$4
      },
      HOVER: {
        duration: 200,
        ease: Ease.Default
      },
      SHOW_UPDATE: {
        duration: 250,
        ease: Ease.EaseInQuint
      },
      HIDE_UPDATE: {
        duration: 250,
        ease: Ease.EaseOutQuint
      },
      HIDE_LEAVE: {
        duration: 200,
        ease: Ease.EaseInQuint
      }
    };

    var LINE_WIDTH$1 = 1;
    var getTransitionProps$6 = getGeomTransitionProps(Timing$6);

    var Square =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Square, _Geometry);

      function Square(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$6;
        return _this;
      }

      var _proto = Square.prototype;

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            data = node.data;
        var _this$props = this.props,
            opacity = _this$props.opacity,
            borderColor = _this$props.borderColor,
            bounds = _this$props.bounds;
        var _data$shape = data.shape,
            x = _data$shape.x,
            y = _data$shape.y,
            width = _data$shape.width,
            fill = data.color,
            fake = data.fake,
            vanish = data.vanish;
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            silent = transitionProps.silent,
            z = transitionProps.z;
        var props = {
          key: key,
          id: key,
          z: z,
          silent: silent,
          scale: [1, 1],
          origin: [x + width / 2, y + width / 2],
          shape: vanish ? data.shape : adjustIntervalShape(data.shape, bounds),
          style: {
            fill: fill,
            opacity: opacity * (fake ? 0.5 : 1),
            shadowColor: 'transparent',
            shadowBlur: 0,
            stroke: borderColor || fill,
            lineWidth: LINE_WIDTH$1
          },
          transition: transition,
          transitionEnd: transitionEnd
        }; // shape & style related to end state

        isFade && fadeStyle(props.style);
        isHover && hoverProps$1(props);
        return h('rect', props);
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var row = node.data;
        var annotation = row.annotation,
            shape = row.shape;

        if (annotation) {
          var x = shape.x,
              y = shape.y,
              width = shape.width,
              height = shape.height;
          refer.startPos = [x + width / 2, y + height / 2];
        }

        if (row.fake) {
          var inverted = this.props.inverted;
          var _x = row.x,
              _y = row.y,
              upper = row.upper,
              lower = row.lower;
          refer.inverted = inverted;
          refer.points = [_x, _y, upper, lower];
        }
      };

      _proto.renderGuides = function renderGuides(refer, node) {
        var guides = _Geometry.prototype.renderGuides.call(this, refer, node);

        node.data.fake && guides.push(renderRegionLine(refer));
        return guides;
      };

      _proto.renderEffect = function renderEffect(node) {
        return Interval.prototype.renderEffect.call(this, node);
      };

      _proto.showEffect = function showEffect(id, effect) {
        Interval.prototype.showEffect.call(this, id, effect);
      };

      return Square;
    }(Geometry);

    Square.updateGeometryWhileZoomScale = function (_ref) {
      var geom = _ref.geom,
          zoom = _ref.zoom,
          inverted = _ref.inverted;
      // Note 对于矩形块来说，百分比影响的是宽度，故这里只需要更新geom.width即可
      geom.width *= zoom[inverted ? 'y' : 'x'];
    };

    Square.usePercentSize = isGeomUsePercentSize;

    Square.calcDataLabelPos = function (_ref2) {
      var row = _ref2.row,
          position = _ref2.position,
          bounds = _ref2.bounds;
      return getIntervalLabelPos(row.shape, bounds, position);
    };

    Square.layout = layout$3;

    Square.calcDataLabelPos = function (_ref3) {
      var row = _ref3.row,
          position = _ref3.position,
          bounds = _ref3.bounds;
      return getIntervalLabelPos(row.shape, bounds, position);
    };

    Square.adjust = adjust$4;

    Square.getRowBounds = function (row, x, inverted, geom) {
      var reversed = geom.reversed,
          width = geom.width;

      var _getYY = getYY0(row, reversed),
          y = _getYY.y,
          y0 = _getYY.y0;

      return calcRectShape(x, y, y0, width, inverted);
    };

    Geom.registerGeom('square', Square);

    var sin$8 = Math.sin,
        cos$8 = Math.cos;
    var ANGLE = 60;
    var al = ANGLE / 180 * Math.PI;
    var y2 = 1 / Math.tan(Math.PI / 2 - al);
    var ShadowFill = {
      type: 'linear',
      x: 0,
      y: 0,
      x2: 1,
      y2: y2,
      colorStops: [{
        offset: 1,
        color: 'rgba(0, 0, 0, 0.3)'
      }, {
        offset: 0,
        color: 'rgba(0, 0, 0, 0)'
      }]
    };
    var getPillarFace = function getPillarFace(w, h) {
      var dx = w * sin$8(al),
          dy = w * cos$8(al);
      return [[-dx, 0], // bottom, left
      [0, dy], // bottom, middle
      [dx, 0], // bottom, right
      [dx, -h], // top, right
      [0, -dy - h], [-dx, -h]];
    };
    var getPillarLine = function getPillarLine(w, h) {
      var dx = w * sin$8(al),
          dy = w * cos$8(al);
      return [[0, dy - h], [dx, -h], [0, dy - h], [0, dy], [0, dy - h], [-dx, -h]];
    };
    var getPillarShadow = function getPillarShadow(w, h) {
      var dx = w * sin$8(al),
          dy = w * cos$8(al);
      var ex = -h * sin$8(al),
          ey = -h * cos$8(al);
      return [[-dx / 2, dy / 2], [dx / 2, -dy / 2], [ex + dx / 2, ey - dy / 2], [ex - dx / 2, ey + dy / 2]];
    };

    var getPillarWidth = function getPillarWidth(w) {
      return Math.max(w * 0.3, 1);
    }; // 100 -> 30


    var getPillarHeight = function getPillarHeight(w) {
      return w * 5;
    }; // 30 -> 150


    var layoutPillar = function layoutPillar(rows) {
      _.each(rows, function (row) {
        var vanish = row.vanish,
            size = row.size;
        var width = getPillarWidth(size),
            height = vanish ? 0 : getPillarHeight(width);
        row.shape = {
          width: width,
          height: height,
          shadow: getPillarShadow(width, height),
          face: getPillarFace(width, height),
          line: getPillarLine(width, height)
        };
      });
    };
    var calcDataLabelPos$4 = function calcDataLabelPos(_ref) {
      var row = _ref.row,
          position = _ref.position,
          bounds = _ref.bounds;
      var _row$shape = row.shape,
          width = _row$shape.width,
          height = _row$shape.height,
          x = row.x,
          y = row.y;
      var lh = bounds.height;
      var dh = width * cos$8(al);
      var cx = x,
          cy = y - height / 2;

      if (position === DataLabel.INSIDE) {
        cy = y - height + dh + lh / 2;
      } else if (position === DataLabel.OUTSIDE) {
        cy = y - height - lh / 2;
      }

      return [cx, cy];
    };

    var getPillarTransition = function getPillarTransition(transition, isEnter, row) {
      var faceTransition, shadowTransition, strokeTransition;

      if (isEnter) {
        var width = row.shape.width;

        var getTransition = function getTransition(shapeFn) {
          return _extends({}, transition, {
            appear: function appear() {
              return {
                shape: {
                  points: shapeFn(width, 0)
                }
              };
            }
          });
        };

        faceTransition = getTransition(getPillarFace);
        shadowTransition = getTransition(getPillarShadow);
        strokeTransition = getTransition(getPillarLine);
      } else {
        faceTransition = shadowTransition = shadowTransition = transition;
      }

      return {
        faceTransition: faceTransition,
        shadowTransition: shadowTransition,
        strokeTransition: strokeTransition
      };
    };

    var LINE_COLOR$1 = '#555';
    var getTransitionProps$7 = getGeomTransitionProps(Timing$5);
    var SHADOW_KEY = '_shadow';
    var STROKE_KEY = '_stroke';

    var Pillar =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Pillar, _Geometry);

      function Pillar(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$7;

        _this.updateState(props);

        return _this;
      }

      var _proto = Pillar.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.updateState(nextProps);
      };

      _proto.updateState = function updateState(_ref) {
        var rows = _ref.rows;
        this.setState({
          data: rows.slice().sort(function (r1, r2) {
            return r1.y - r2.y;
          })
        });
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var data = node.data,
            key = node.key;
        var _this$props = this.props,
            borderColor = _this$props.borderColor,
            defaultOpacity = _this$props.opacity;
        var x = data.x,
            y = data.y,
            color = data.color,
            shape = data.shape;
        var position = [x, y];
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            silent = transitionProps.silent,
            isEnter = transitionProps.isEnter;
        var fill = isFade ? Fade.Fill : isHover ? highlight(color) : color;

        var _getPillarTransition = getPillarTransition(transition, isEnter, data),
            faceTransition = _getPillarTransition.faceTransition,
            shadowTransition = _getPillarTransition.shadowTransition,
            strokeTransition = _getPillarTransition.strokeTransition;

        var opacity = isFade ? Fade.Opacity : defaultOpacity;
        var shadow = h('polygon', {
          key: key + SHADOW_KEY,
          position: position,
          silent: true,
          zlevel: ShadowLayerZ,
          transition: shadowTransition,
          shape: {
            points: shape.shadow
          },
          style: {
            fill: ShadowFill,
            opacity: opacity
          }
        });
        var mainFace = h('polygon', {
          id: key,
          key: key,
          position: position,
          tooltipPos: [0, -shape.height],
          transition: faceTransition,
          transitionEnd: transitionEnd,
          silent: silent,
          shape: {
            points: shape.face
          },
          style: {
            fill: fill,
            stroke: borderColor,
            opacity: opacity
          }
        });
        var strokeLine = h('polygon', {
          key: key + STROKE_KEY,
          position: position,
          silent: true,
          transition: strokeTransition,
          shape: {
            points: shape.line
          },
          style: {
            stroke: borderColor || LINE_COLOR$1,
            opacity: opacity
          }
        });
        return [shadow, mainFace, strokeLine];
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var _node$data = node.data,
            shape = _node$data.shape,
            annotation = _node$data.annotation,
            x = _node$data.x,
            y = _node$data.y;

        if (annotation) {
          refer.startPos = [x, y - shape.height];
        }
      };

      return Pillar;
    }(Geometry);

    Pillar.layout = layoutPillar;
    Pillar.calcDataLabelPos = calcDataLabelPos$4;
    Geom.registerGeom('pillar', Pillar);

    function calcDataLabelPos$5(_ref) {
      var row = _ref.row,
          bounds = _ref.bounds,
          position = _ref.position;
      var _row$shape = row.shape,
          x = _row$shape.x,
          y = _row$shape.y,
          width = _row$shape.width,
          height = _row$shape.height;
      var lw = bounds.width,
          lh = bounds.height;
      var cx, cy;

      if (position === 'inside') {
        cx = x + lw / 2;
        cy = y + lh / 2;
      } else {
        // center & outside: treeMap 标签outside没有意义，咨询王军后outside和center一样处理
        cx = x + width / 2;
        cy = y + height / 2;
      }

      return [cx, cy];
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;else while (--i >= 0) {
        sum += children[i].value;
      }
      node.value = sum;
    }

    function node_count () {
      return this.eachAfter(count);
    }

    function node_each (callback) {
      var node = this,
          current,
          next = [node],
          children,
          i,
          n;

      do {
        current = next.reverse(), next = [];

        while (node = current.pop()) {
          callback(node), children = node.children;
          if (children) for (i = 0, n = children.length; i < n; ++i) {
            next.push(children[i]);
          }
        }
      } while (next.length);

      return this;
    }

    function node_eachBefore (callback) {
      var node = this,
          nodes = [node],
          children,
          i;

      while (node = nodes.pop()) {
        callback(node), children = node.children;
        if (children) for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }

      return this;
    }

    function node_eachAfter (callback) {
      var node = this,
          nodes = [node],
          next = [],
          children,
          i,
          n;

      while (node = nodes.pop()) {
        next.push(node), children = node.children;
        if (children) for (i = 0, n = children.length; i < n; ++i) {
          nodes.push(children[i]);
        }
      }

      while (node = next.pop()) {
        callback(node);
      }

      return this;
    }

    function node_sum (value) {
      return this.eachAfter(function (node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;

        while (--i >= 0) {
          sum += children[i].value;
        }

        node.value = sum;
      });
    }

    function node_sort (compare) {
      return this.eachBefore(function (node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path (end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];

      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }

      var k = nodes.length;

      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }

      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();

      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }

      return c;
    }

    function node_ancestors () {
      var node = this,
          nodes = [node];

      while (node = node.parent) {
        nodes.push(node);
      }

      return nodes;
    }

    function node_descendants () {
      var nodes = [];
      this.each(function (node) {
        nodes.push(node);
      });
      return nodes;
    }

    function node_leaves () {
      var leaves = [];
      this.eachBefore(function (node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links () {
      var root = this,
          links = [];
      root.each(function (node) {
        if (node !== root) {
          // Don’t include the root’s parent, if any.
          links.push({
            source: node.parent,
            target: node
          });
        }
      });
      return links;
    }

    function hierarchy(data, children) {
      var root = new Node$2(data),
          valued = +data.value && (root.value = data.value),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;
      if (children == null) children = defaultChildren;

      while (node = nodes.pop()) {
        if (valued) node.value = +node.data.value;

        if ((childs = children(node.data)) && (n = childs.length)) {
          node.children = new Array(n);

          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new Node$2(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function defaultChildren(d) {
      return d.children;
    }

    function copyData(node) {
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;

      do {
        node.height = height;
      } while ((node = node.parent) && node.height < ++height);
    }
    function Node$2(data) {
      this.data = data;
      this.depth = this.height = 0;
      this.parent = null;
    }
    Node$2.prototype = hierarchy.prototype = {
      constructor: Node$2,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy
    };

    function required(f) {
      if (typeof f !== "function") throw new Error();
      return f;
    }

    function constantZero() {
      return 0;
    }
    function constant$5 (x) {
      return function () {
        return x;
      };
    }

    function roundNode (node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice (parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function treemapSlice (parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;
    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx,
          dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.

        do {
          sumValue = nodes[i1++].value;
        } while (!sumValue && i1 < n);

        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.

        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);

          if (newRatio > minRatio) {
            sumValue -= nodeValue;
            break;
          }

          minRatio = newRatio;
        } // Position and record the row orientation.


        rows.push(row = {
          value: sumValue,
          dice: dx < dy,
          children: nodes.slice(i0, i1)
        });
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }
    var squarify = (function custom(ratio) {
      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function (x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function TreeMapLayout () {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 = root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;

        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function (x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function (x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function (x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function (x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function (x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$5(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function (x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function (x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$5(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function (x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$5(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function (x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$5(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function (x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$5(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    var getValue = function getValue(row, sizeKey) {
      return row.vanish ? 0 : Math.abs(row[sizeKey]);
    };

    var sumRows = function sumRows(rows, sizeId) {
      return _.reduce(rows, function (total, next) {
        return total + getValue(next, sizeId);
      }, 0);
    };

    var GAP$1 = 3;
    var layout$4 = function layout(rows, _ref) {
      var _ref$cell = _ref.cell,
          bounds = _ref$cell.bounds,
          percent = _ref$cell.percent,
          _ref$geom = _ref.geom,
          data = _ref$geom.data,
          hierarchy$$1 = _ref$geom.hierarchy,
          size = _ref$geom.size;
      var width = bounds.width,
          height = bounds.height;
      var id = size.id; // NOTE 这里判断如果size中指标字段时, 布局计算Value的时候, 使用指标值的绝对值
      // NOTE 否则使用aesMapping后的size

      var sizeKey = id && data.isMeasure(id) ? id : 'size';
      var root = hierarchy(generateTreeNode$1(rows, hierarchy$$1, sizeKey)); // sort by size

      root.eachBefore(function (child) {
        return child.children && child.children.sort(function (c1, c2) {
          return c2.value - c1.value;
        });
      });
      var gap = rows.length > 1 ? GAP$1 : 0;
      TreeMapLayout().size([width * percent - gap * 2, height - gap * 2])(root);
      updateRowShape(root);
      root = null;
    };
    /**
     * 从树形结构的最后一层节点上更新row.shape
     * @param node
     */

    function updateRowShape(node) {
      if (!node.children) {
        var x0 = node.x0,
            y0 = node.y0,
            x1 = node.x1,
            y1 = node.y1,
            row = node.data.row;

        if (row) {
          row.shape = {
            x: x0,
            y: y0,
            width: x1 - x0,
            height: y1 - y0
          };
        }
      } else {
        _.each(node.children, function (nc) {
          return updateRowShape(nc);
        });
      }
    }
    /**
     * 创建树形结构，用于treeMapLayout
     * @param rows
     * @param granularityList
     * @param sizeKey
     * @param root
     * @returns {*}
     */


    function generateTreeNode$1(rows, granularityList, sizeKey, root) {
      if (granularityList === void 0) {
        granularityList = [];
      }

      if (root === void 0) {
        root = null;
      }

      var len = granularityList.length; // const rows = originRows.slice().sort((r1, r2) => r2.size - r1.size);

      if (root == null) {
        root = {
          depth: 0,
          parent: null,
          value: sumRows(rows, sizeKey),
          children: [],
          level: len + 1
        };
      }

      var props = {
        depth: root.depth + 1,
        level: root.level - 1,
        parent: root
      };

      if (len > 1) {
        var key = granularityList[0];

        var groups = _.groupBy(rows, function (d) {
          return d[key];
        });

        root.children = [];

        _.each(groups, function (group) {
          var child = _extends({}, props, {
            value: sumRows(group, sizeKey),
            children: []
          });

          root.children.push(generateTreeNode$1(group, granularityList.slice(1, len), sizeKey, child));
        });
      } else {
        _.each(rows, function (row) {
          root.children.push(_extends({}, props, {
            row: row,
            value: getValue(row, sizeKey)
          }));
        });
      }

      return root;
    }

    var hoverStyle$1 = function hoverStyle(style) {
      style.fill = highlight(style.fill);
    };
    var Timing$7 = {
      // init group scale transition
      INIT_GROUP_TRANSITION: {
        duration: 800,
        ease: Ease.EaseOutBounce,
        appear: function appear() {
          return {
            scale: [0, 0]
          };
        }
      },
      SHOW_ENTER: {
        duration: 800,
        ease: Ease.EaseOutQuint,
        appear: function appear(_ref) {
          var _ref$shape = _ref.shape,
              x = _ref$shape.x,
              y = _ref$shape.y;
          return {
            shape: {
              x: x,
              y: y,
              width: 0,
              height: 0
            }
          };
        }
      },
      HOVER: {
        duration: 200,
        ease: Ease.Default
      },
      SHOW_UPDATE: {
        duration: 800,
        ease: Ease.EaseOutQuint
      },
      HIDE_UPDATE: {
        duration: 800,
        ease: Ease.EaseOutQuint
      },
      HIDE_LEAVE: {
        duration: 800,
        ease: Ease.EaseOutQuint
      }
    };

    // @http://www.finedevelop.com/pages/viewpage.action?pageId=14685575#id-3%E5%BD%A2%E7%8A%B6%EF%BC%8C%E9%A2%9C%E8%89%B2%EF%BC%8C%E5%A4%A7%E5%B0%8F%E7%AD%89%E5%B1%9E%E6%80%A7%E9%9D%A2%E6%9D%BF-%E7%9F%A9%E5%BD%A2%E5%9D%97%EF%BC%9A
    // Note 重叠处理即超出不显示
    function adjustDataLabel$1(_ref) {
      var rows = _ref.rows;

      _.each(rows, function (row) {
        var _row$dataLabel$bounds = row.dataLabel.bounds,
            lw = _row$dataLabel$bounds.width,
            lh = _row$dataLabel$bounds.height;
        var _row$shape = row.shape,
            width = _row$shape.width,
            height = _row$shape.height;

        if (lw > width || lh > height) {
          row.dataLabel = null;
        }
      });
    }

    var LINE_WIDTH$2 = 1; // http://ui.finebi.com/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E9%97%AA%E7%83%81%E5%8A%A8%E6%95%88

    var getTransitionProps$8 = getGeomTransitionProps(Timing$7);

    var TreeMap =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(TreeMap, _Geometry);

      function TreeMap(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$8;
        return _this;
      }

      var _proto = TreeMap.prototype;

      _proto.getGroupTransition = function getGroupTransition() {
        var animation = this.props.animation;
        return this._init && animation ? Timing$7.INIT_GROUP_TRANSITION : null;
      };

      _proto.getGroupProps = function getGroupProps() {
        var props = _Geometry.prototype.getGroupProps.call(this);

        var _this$props = this.props,
            rows = _this$props.rows,
            bounds = _this$props.bounds,
            x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height,
            gap = rows.length > 1 ? GAP$1 : 0;
        props.position = [x + gap, y + gap];
        props.scale = [1, 1];
        props.origin = [width / 2, height / 2];
        return props;
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var _this$props2 = this.props,
            opacity = _this$props2.opacity,
            borderColor = _this$props2.borderColor;
        var key = node.key,
            data = node.data;
        var _data$shape = data.shape,
            x = _data$shape.x,
            y = _data$shape.y,
            width = _data$shape.width,
            height = _data$shape.height,
            fill = data.color;
        var shape = {
          x: x,
          y: y,
          width: width,
          height: height
        };
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            silent = transitionProps.silent,
            z = transitionProps.z;
        var style = {
          fill: fill,
          opacity: opacity,
          stroke: borderColor || fill,
          lineWidth: LINE_WIDTH$2
        };
        isFade && fadeStyle(style);
        isHover && hoverStyle$1(style);
        return h('rect', {
          key: key,
          id: key,
          z: z,
          silent: silent,
          origin: [x + width / 2, y + height / 2],
          transition: transition,
          transitionEnd: transitionEnd,
          shape: shape,
          style: style
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        if (this._groupTransition) {
          refer.transition = this._groupTransition;
        }

        refer.applyTheme = true;
        var _node$data$shape = node.data.shape,
            x = _node$data$shape.x,
            y = _node$data$shape.y,
            width = _node$data$shape.width,
            height = _node$data$shape.height;
        refer.startPos = [x + width / 2, y + height / 2];
      };

      _proto.showEffect = function showEffect(id, effect) {
        showScaledEffect.call(this, id, effect);
      };

      return TreeMap;
    }(Geometry);

    TreeMap.calcDataLabelPos = calcDataLabelPos$5;
    TreeMap.adjustDataLabel = adjustDataLabel$1;
    TreeMap.layout = layout$4;

    TreeMap.updateShapeWhileScaleZoom = function (row, _ref) {
      var zoom = _ref.zoom;

      if (!row._shape) {
        row._shape = row.shape;
      }

      var _shape = row._shape;
      row.shape = {
        x: zoom.x * _shape.x,
        y: zoom.y * _shape.y,
        width: zoom.x * _shape.width,
        height: zoom.y * _shape.height
      };
    };

    Geom.registerGeom('treeMap', TreeMap);

    var PREDICTED_FILL_OPACITY_RATIO = 0.5;
    var DEVIATION_FILL_OPACITY_RATIO = 0.3;
    var PREDICTED_STROKE_OPACITY_RATIO = 0.5;
    var PREDICTED_LINE_DASH = [8, 4]; // http://www.finedevelop.com/pages/viewpage.action?pageId=18460724

    var GRADUAL_UPPER_OPACITY = 0.8;
    var GRADUAL_LOWER_OPACITY = 0;
    var BORDER_RATIO = 2; // normalArea & fakeArea

    function renderArea(_ref) {
      var id = _ref.id,
          onmouseover = _ref.onmouseover,
          onmousemove = _ref.onmousemove,
          onmouseout = _ref.onmouseout,
          onclick = _ref.onclick,
          areaHovered = _ref.areaHovered,
          points = _ref.points,
          style = _ref.style,
          borderColor = _ref.borderColor,
          defaultOpacity = _ref.opacity,
          gradual = _ref.gradual,
          inverted = _ref.inverted,
          reversed = _ref.reversed,
          sameColor = _ref.sameColor,
          effectValid = _ref.effectValid,
          lastPoints = _ref.lastPoints;

      if (!points.length) {
        return null;
      }

      var horizontal = !inverted;
      var z = areaHovered ? HoverLayerZ : NormalLayerZ;

      var getGradualFill = function getGradualFill(fill, opacityRatio) {
        var upperFill = modifyAlpha(fill, GRADUAL_UPPER_OPACITY * opacityRatio),
            lowerFill = modifyAlpha(fill, GRADUAL_LOWER_OPACITY * opacityRatio);
        var pos = {
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0
        };
        pos[inverted ? reversed ? 'x1' : 'x2' : reversed ? 'y2' : 'y1'] = 1;
        var x1 = pos.x1,
            y1 = pos.y1,
            x2 = pos.x2,
            y2 = pos.y2;
        var gradient = new LinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, lowerFill);
        gradient.addColorStop(1, upperFill);
        return gradient;
      };

      var getAreaFill = function getAreaFill(points) {
        return sameColor && points[0] ? points[0].color : createNormalGradient(points, horizontal);
      };
      /**
       *
       * @param points
       * @param fill
       * @param opacityRatio normal: 1, predicted: 0.2, deviation: 0.1
       * @param lastPoints
       * @returns props
       */


      var drawArea = function drawArea(points, fill, opacityRatio, lastPoints) {
        if (points.length < 2) {
          return null;
        }

        var opacity = defaultOpacity * opacityRatio; // 只有在单色且开启了效果且为正常数据的时候，才会有gradual的效果

        var gradualEffectValid = sameColor && gradual && opacityRatio !== DEVIATION_FILL_OPACITY_RATIO && fill !== 'transparent'; // @BI-23647   透明色即无颜色即看不见

        fill = gradualEffectValid ? getGradualFill(fill, opacityRatio) : fill;
        return h('area', {
          id: id,
          z: z,
          onmouseover: onmouseover,
          onmousemove: onmousemove,
          onmouseout: onmouseout,
          onclick: onclick,
          transition: getBandTransition(lastPoints, true),
          shape: {
            points: formatPoints(points, true),
            style: style,
            horizontal: horizontal
          },
          style: {
            fill: fill,
            lineWidth: 0,
            opacity: gradualEffectValid ? 1 : opacity // 渐变效果开启时不透明度设置不生效

          }
        });
      }; // 面积边框


      var drawBand = function drawBand(points, fill, opacityRatio, lastPoints) {
        var opacity = Math.min(defaultOpacity * BORDER_RATIO * opacityRatio, 1);
        var lineDash = opacityRatio === PREDICTED_STROKE_OPACITY_RATIO ? PREDICTED_LINE_DASH : null;

        if (points.length < 2) {
          return null;
        }

        return h('strokeLine', {
          z: z,
          transition: getBandTransition(lastPoints, false),
          shape: {
            points: formatPoints(points, false)
          },
          style: {
            stroke: borderColor || fill,
            lineWidth: AREA_STROKE_LINE_WIDTH + (areaHovered ? 1 : 0),
            opacity: opacity * (effectValid ? EFFECT_LINE_OPACITY_RATIO : 1),
            lineDash: lineDash
          }
        });
      };

      var _filterFakePoints = filterFakePoints(points, lastPoints, horizontal),
          normalPoints = _filterFakePoints.normalPoints,
          normalLastPoints = _filterFakePoints.normalLastPoints,
          predictedPoints = _filterFakePoints.predictedPoints,
          predictedLastPoints = _filterFakePoints.predictedLastPoints,
          deviationPoints = _filterFakePoints.deviationPoints,
          deviationLastPoints = _filterFakePoints.deviationLastPoints;

      var normalAreaFill = getAreaFill(normalPoints),
          fakeAreaFill = getAreaFill(predictedPoints);
      var graphics = [];
      graphics.push(drawArea(normalPoints, normalAreaFill, 1, normalLastPoints));
      graphics.push(drawArea(predictedPoints, fakeAreaFill, PREDICTED_FILL_OPACITY_RATIO, predictedLastPoints));
      graphics.push(drawArea(deviationPoints, fakeAreaFill, DEVIATION_FILL_OPACITY_RATIO, deviationLastPoints));
      graphics.push(drawBand(normalPoints, normalAreaFill, 1, normalLastPoints));
      graphics.push(drawBand(predictedPoints, fakeAreaFill, PREDICTED_STROKE_OPACITY_RATIO, predictedLastPoints));
      return graphics;
    }

    var AREA_STROKE_LINE_WIDTH = 2;
    var Area$1 = createLineBand({
      type: ChartLibrary.AREA,
      renderBand: function renderBand(points, areaHovered, effectValid, bigData, lastPoints) {
        var _this$props = this.props,
            handleBandOn = _this$props.handleBandOn,
            handleBandClick = _this$props.handleBandClick,
            handleMouseOut = _this$props.handleMouseOut,
            facetY = _this$props.facetY,
            lineId = _this$props.lineId;
        var areaNode = renderArea(_extends({}, this.props, {
          id: lineId,
          areaHovered: areaHovered,
          points: points,
          onmouseover: handleBandOn,
          onmousemove: handleBandOn,
          onmouseout: handleMouseOut,
          onclick: handleBandClick,
          unit: facetY.unit,
          effectValid: effectValid,
          lastPoints: lastPoints
        }));
        return [areaNode];
      },
      renderEffectBand: function renderEffectBand(points, effectStops, duration) {
        return renderLineEffect({
          points: points,
          duration: duration,
          effectStops: effectStops,
          style: LineStyle.NORMAL,
          stroke: true,
          lineWidth: AREA_STROKE_LINE_WIDTH + 1,
          size: AREA_STROKE_LINE_WIDTH + 1
        });
      }
    });

    var ENTER_TIMING = {
      duration: 1200,
      ease: Ease.EaseOutCubic
    };

    var distance$4 = function distance(a, b) {
      var dx = a.x - b.x,
          dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    };

    var getDistFn = function getDistFn(inverted, isVarLine) {
      if (isVarLine) {
        return distance$4;
      } else {
        var base = inverted ? 'y' : 'x';
        return function (a, b) {
          return Math.abs(a[base] - b[base]);
        };
      }
    };

    function GenLinear(LineType) {
      var Linear =
      /*#__PURE__*/
      function (_Component) {
        _inheritsLoose(Linear, _Component);

        function Linear(props, context) {
          var _this;

          _this = _Component.call(this, props, context) || this;
          _this.state = {
            partitionData: [],
            grouped: {}
          }; // for clip animation

          _this.gap = 0; //

          _this.hoveredLineId = null;
          autoBind(_assertThisInitialized(_assertThisInitialized(_this)));

          _this.updateGroup(props);

          return _this;
        }

        var _proto = Linear.prototype;

        _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
          if (nextProps.rows !== this.props.rows) {
            this.updateGroup(nextProps);
          }
        } // 绑定cell内的全局鼠标事件handler
        ;

        _proto.registerCellMouseEventHandler = function registerCellMouseEventHandler() {
          var _this$props = this.props,
              bindMouseOverHandler = _this$props.bindMouseOverHandler,
              bindClickHandler = _this$props.bindClickHandler;
          bindMouseOverHandler && bindMouseOverHandler(this.handleMouseOver);
          bindClickHandler && bindClickHandler(this.handleClick);
        } // find closestPoint and generate payload for dispatch action
        ;

        _proto.findClosestPoint = function findClosestPoint(_ref) {
          var offsetX = _ref.offsetX,
              offsetY = _ref.offsetY;
          var group = this.hoveredLineId && this.state.grouped[this.hoveredLineId];

          if (!group) {
            return;
          } // zr's bug: attr.onxxxx cancelBubble no effect;
          // return `true` instead.
          // ev.cancelBubble = true;


          var _this$props2 = this.props,
              inverted = _this$props2.inverted,
              fadeChecker = _this$props2.fadeChecker,
              scroll = _this$props2.scroll,
              _this$props2$shifting = _this$props2.shifting,
              shifting = _this$props2$shifting === void 0 ? [scroll.x, scroll.y] : _this$props2$shifting;
          var tx = shifting[0],
              ty = shifting[1];
          var pos = {
            x: offsetX - tx,
            y: offsetY - ty
          };
          var closest = group[0];
          var isVarLine = group.isVarLine;
          var getDist = getDistFn(inverted, isVarLine);
          reduce(group, function (closestDist, d) {
            var dist = getDist(d, pos); // @BI-41647: 好奇怪, 记得之前改过这个问题的

            if (dist <= closestDist) {
              closest = d;
              return dist;
            }

            return closestDist;
          }, getDist(closest, pos));

          if (fadeChecker(closest)) {
            return;
          }

          var _closest = closest,
              x = _closest.x,
              y = _closest.y; // payload

          return {
            target: {
              id: closest.id,
              tooltipPos: [x + tx, y + ty]
            },
            offsetX: offsetX,
            offsetY: offsetY
          };
        } // mouse on marker
        ;

        _proto.handleMarkerOn = function handleMarkerOn(ev) {
          var lineId = ev.target.lineId;
          this.hoveredLineId = lineId;
          this.props.onmousemove(ev); // fire Variable's onmouseover

          this.registerCellMouseEventHandler(); // register mouseHandler for cell

          return true;
        } // get closest point by event position
        // mouse on lineBand
        ;

        _proto.handleBandOn = function handleBandOn(ev) {
          var lineId = ev.target.id;
          this.hoveredLineId = lineId;
          this.handleMouseOver(ev);
          this.registerCellMouseEventHandler(); // cancel bubble

          return true;
        } // markerOn & bandOn主要用来响应鼠标悬浮的标记点或者线上
        // 这里的handleMouseOver主要是处理线或者cell里面的用于全局接受事件的react的mouseover事件
        ;

        _proto.handleMouseOver = function handleMouseOver(ev) {
          if (!this.hoveredLineId) {
            return;
          }

          var payload = this.findClosestPoint(ev);
          payload && this.props.onmouseover(payload);
        } // click marker
        ;

        _proto.handleMarkerClick = function handleMarkerClick(ev) {
          var lineId = ev.target.lineId;
          this.hoveredLineId = lineId;
          this.handleClick(ev);
        } // click band
        ;

        _proto.handleBandClick = function handleBandClick(ev) {
          var lineId = ev.target.id;
          this.hoveredLineId = lineId;
          this.handleClick(ev); // cancel bubble

          return true;
        } // click event handler
        ;

        _proto.handleClick = function handleClick(ev) {
          if (!this.hoveredLineId) {
            return;
          }

          var payload = this.findClosestPoint(ev);
          payload && this.props.onclick(payload);
        };

        _proto.handleMouseOut = function handleMouseOut()
        /* ev */
        {
          // PENDING: It will fire out when mouse over line/marker
          // this.hoveredLineId = null;
          this.props.onmouseout();
        };

        _proto.updateGroup = function updateGroup(_ref2) {
          var enableMap = _ref2.enableMap,
              rows = _ref2.rows,
              color = _ref2.color,
              size = _ref2.size,
              inverted = _ref2.inverted,
              rowCount = _ref2.rowCount,
              groupLineIds = _ref2.groupLineIds,
              lineConnect = _ref2.lineConnect,
              data = _ref2.data;
          // 获取连线属性上的第一个字段
          var connect = lineConnect && lineConnect.length ? lineConnect[0] : null;
          var bigData = enableMap && rowCount > BIG_DATA_LIMIT;
          var horizontal = !inverted || enableMap; // 第一步:按照分区划分数据
          // 考虑到同一个分区内的线可以使用一个clip，这边把group划分好的线放在对应的分区partition内

          var grouped = {},
              partitionData = []; // @BI-23858

          rows = _.filter(rows, function (row) {
            return !row.vanish;
          });

          var lineGrouped = _.groupBy(rows, function (d) {
            return map(groupLineIds, function (id) {
              return d[id];
            }).join('*');
          });

          var lines = [];
          var linesIds = [];
          forOwn(lineGrouped, function (lineRows, lineKey) {
            // 按照连线规则将点排序
            // 没有连线属性是，按照基础轴方向绘制
            var sortKey = connect == null ? inverted ? 'y' : 'x' : data.isMeasure(connect) ? connect : null; // 连线属性是指标时按照指标大小排序

            sortKey && lineRows.sort(function (a, b) {
              return a[sortKey] - b[sortKey];
            });
            var key = 'Line_' + lineKey;
            lineRows.isVarLine = connect != null || isStraightLine(lineRows, horizontal);
            grouped[key] = lineRows;
            lines.push(lineRows);
            linesIds.push(key);
          });
          this.setState({
            linesIds: linesIds,
            lines: lines,
            partitionData: partitionData,
            grouped: grouped,
            bigData: bigData,
            horizontal: horizontal,
            sameColor: !_.isObject(color),
            sameSize: !_.isObject(size)
          });
        };

        _proto.render = function render$$1() {
          var _this2 = this;

          var _this$state = this.state,
              linesIds = _this$state.linesIds,
              lines = _this$state.lines;
          var _this$props3 = this.props,
              bounds = _this$props3.bounds,
              inverted = _this$props3.inverted,
              animation = _this$props3.animation;
          return h('group', {
            ref: function ref(el) {
              if (!el || _this2.cliped || !animation) {
                return;
              }

              _this2.cliped = true;
              var x = bounds.x,
                  y = bounds.y,
                  width = bounds.width,
                  height = bounds.height;
              var clip = graphic.rect({
                style: {
                  fill: '#0b9',
                  opacity: 0.5
                },
                shape: {
                  x: x,
                  y: y,
                  width: inverted ? width : 0,
                  height: inverted ? 0 : height
                }
              });
              el.setClipPath(clip);
              clip.animate('shape').when(ENTER_TIMING.duration, {
                x: x,
                y: y,
                width: width,
                height: height
              }).done(function () {
                el.removeClipPath();
              }).start(ENTER_TIMING.ease);
            }
          }, _.map(lines, function (rows, i) {
            var lineId = linesIds[i];
            return h(LineType, _extends({}, _this2.props, _this2.state, {
              isVarLine: rows.isVarLine,
              lineIndex: i,
              rows: rows,
              lineId: lineId,
              handleMarkerOn: _this2.handleMarkerOn,
              handleMarkerClick: _this2.handleMarkerClick,
              handleBandOn: _this2.handleBandOn,
              handleBandClick: _this2.handleBandClick,
              handleMouseOut: _this2.handleMouseOut
            }));
          }));
        };

        return Linear;
      }(Component);

      Linear.defaultProps = {
        stroke: true,
        aes: {} // 这里要不要默认值……似乎抛错还明显点

      };
      return Linear;
    }
    var LineGeom = GenLinear(Line$1);
    var AreaGeom = GenLinear(Area$1);
    LineGeom.calcDataLabelPos = calcDataLabelPos$2;
    AreaGeom.calcDataLabelPos = calcDataLabelPos$2.hasCenterLabel(false); // LineGeom.layout = AreaGeom.layout = function(){};

    Geom.registerGeom('line', LineGeom);
    Geom.registerGeom('area', AreaGeom);

    // http://www.finedevelop.com/pages/viewpage.action?pageId=18460724
    var getGradualStops$1 = function getGradualStops(inverted) {
      var x1 = 0,
          y1 = 0,
          x2 = 0,
          y2 = 0;

      if (inverted) {
        y1 = 1;
      } else {
        x1 = 1;
      }

      return [x1, y1, x2, y2];
    };
    var calcTrapezoidPoints = function calcTrapezoidPoints(shape, inverted) {
      var cx = shape.cx,
          cy = shape.cy,
          w1 = shape.w1,
          w2 = shape.w2,
          height = shape.height;

      if (w1 == null || w2 == null) {
        return [];
      }

      var halfHeight = height / 2;
      var cp = inverted ? cx : cy;
      var p1 = cp - halfHeight,
          p2 = cp + halfHeight;

      if (inverted) {
        var _ref = [p2, p1];
        p1 = _ref[0];
        p2 = _ref[1];
      }

      if (inverted) {
        return [[p1, cy - w1 / 2], [p1, cy + w1 / 2], [p2, cy + w2 / 2], [p2, cy - w2 / 2]];
      } else {
        return [[cx - w1 / 2, p1], [cx + w1 / 2, p1], [cx + w2 / 2, p2], [cx - w2 / 2, p2]];
      }
    };

    function adjustLabel$2(_ref) {
      var rows = _ref.rows,
          manager = _ref.manager;
      // Note 漏斗图的标签调整没有意义，这里和重叠隐藏一样处理
      forEach(rows, function (row) {
        var bounds = row.dataLabel.bounds;

        if (manager.isOverlapped(bounds)) {
          row.dataLabel = null;
        } else {
          manager.addBounds(bounds);
        }
      });
    }

    var appear$5 = function appear() {
      return {
        scale: [0, 0]
      };
    }; // #https://note.youdao.com/share/?token=5CCE7A16D9AC47999DB186D4F3BF935C&gid=2941765#/
    // #http://47.104.151.0:8011/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E5%8A%A8%E6%95%88


    var Timing$8 = {
      INIT: function INIT$$1(percent) {
        return {
          delay: Math.sqrt(percent) * 400,
          duration: 400,
          ease: Ease.EaseOutQuint,
          appear: appear$5
        };
      },
      SHOW_ENTER: {
        duration: 600,
        ease: Ease.EaseOutCubic
      },
      HOVER: {
        duration: 150,
        ease: Ease.EaseOutBack
      },
      SHOW_UPDATE: {
        duration: 600,
        ease: Ease.EaseOutCubic
      },
      HIDE_UPDATE: {
        duration: 600,
        ease: Ease.EaseOutCubic
      },
      HIDE_LEAVE: {
        duration: 600,
        ease: Ease.EaseOutCubic
      }
    };

    var adjust$5 = function adjust(geom, chart) {
      var _diffFacet = diffFacet(chart),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      var data = geom.data,
          size = geom.size;
      var sizeCol = data.getColById(AesTypes.SIZE);

      if (isGeomUsePercentSize(baseFacet, geomFacet)) {
        var sizeAes = getAesInstance(AesTypes.SIZE, geom, size);
        var rangeMax = sizeAes.isConstField() ? sizeAes.constValue : size.range[1];
        var unit = baseFacet.unit;
        geom.maxWidth = unit * rangeMax;

        _.each(sizeAes.dealMapping(data), function (v, i) {
          return sizeCol[i] = v * unit;
        });
      }
    };

    var MIN_SIZE$1 = 2; // export const getUnVanishRow

    var layout$5 = function layout(rows, props) {
      var maxWidth = props.geom.maxWidth,
          facetX = props.facetX,
          facetY = props.facetY,
          bounds = props.cell.bounds,
          inverted = props.inverted;
      var width = bounds.width,
          height = bounds.height;
      var xHasMeasure = facetX.hasMeasure,
          xUnit = facetX.unit,
          yHasMeasure = facetY.hasMeasure,
          yUnit = facetY.unit; // 如果是在有值轴坐标系中，则漏斗图图形比例为1：1
      // 这里的指标个数没有考虑指标聚合的情况

      var isSquare = xHasMeasure || yHasMeasure;
      var isVertical = !inverted; // 不含值轴时，漏斗的整体宽高比例与漏斗所在维度区域的宽高比例一致

      var maxHeight = !isSquare && (isVertical ? height : width) * (maxWidth / (isVertical ? xUnit : yUnit));
      groupRowsByPos(rows, function (group, groupId, center) {
        var position = inverted ? center.reverse() : center;
        var maxSize = Math.max.apply(Math, _.map(group, function (point) {
          return point.size;
        }));
        var funnelHeight = isSquare ? maxSize : maxHeight;
        var unVanished = {},
            unVanishedRows = [];
        var validRowCount = 0;

        _.each(group, function (row) {
          row.groupId = groupId;
          var id = row.id;

          if (row.vanish) ; else {
            unVanished[id] = validRowCount;
            unVanishedRows.push(row);
            validRowCount++;
          }
        });

        funnelHeight = Math.max(funnelHeight, validRowCount * MIN_SIZE$1);

        if (validRowCount <= 1) {
          // http://www.finedevelop.com/pages/viewpage.action?pageId=24067976
          _.each(group, function (row) {
            var cx = position[0],
                cy = position[1];
            var vanish = row.vanish,
                size = row.size;
            var height = vanish ? 0 : funnelHeight;
            var width = vanish ? 0 : Math.max(size, MIN_SIZE$1);
            row.shape = {
              cx: cx,
              cy: cy,
              height: height,
              w1: width,
              w2: width
            };
          });
        } else {
          var _cx = position[0],
              _cy = position[1];

          var _height = funnelHeight / (validRowCount - 1),
              hh = _height / 2,
              fhh = funnelHeight / 2;

          var scx = _cx + fhh - hh,
              scy = _cy - fhh + hh;
          var len = group.length;

          for (var i = 0; i < len; i++) {
            var row = group[i],
                id = row.id,
                vanish = row.vanish,
                isLast = i === len - 1;
            var validHeight = !vanish && !isLast && unVanished[id] < validRowCount - 1;
            var w1 = Math.max(row.size, MIN_SIZE$1);

            if (validHeight) {
              var w2 = Math.max(unVanishedRows[unVanished[id] + 1].size, MIN_SIZE$1);

              var _ref = isVertical ? [_cx, scy] : [scx, _cy],
                  cx = _ref[0],
                  cy = _ref[1];

              row.shape = {
                w1: w1,
                w2: w2,
                cx: cx,
                cy: cy,
                height: _height
              };

              if (isVertical) {
                scy += _height;
              } else {
                scx -= _height;
              }
            } else {
              var hw = group[i < len - 2 ? i + 1 : i].size;

              var _ref2 = isVertical ? [_cx, scy - hh] : [scx + hh, _cy],
                  _cx2 = _ref2[0],
                  _cy2 = _ref2[1];

              row.shape = {
                cx: _cx2,
                cy: _cy2,
                height: 0,
                w1: hw,
                w2: hw
              };
            }
          }
        } // @BI-39116


        _.each(group, function (row) {
          return exchangeXY(row, inverted);
        });
      });
    };

    var getTransitionProps$9 = getGeomTransitionProps(Timing$8);

    var getShowEnterAppearFn$1 = function getShowEnterAppearFn(node, vertical) {
      return function () {
        return node.lastData ? {
          shape: {
            points: _.map(node.lastData.shape.points, function (p) {
              return p.slice();
            })
          }
        } : {
          scale: vertical ? [1, 0] : [0, 1]
        };
      };
    };

    var Funnel =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Funnel, _Geometry);

      function Funnel(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$9;
        return _this;
      }

      var _proto = Funnel.prototype;

      _proto.renderGraphic = function renderGraphic(node, transitionProps, index) {
        var rows = this.props.rows;
        var percent = rows.length > 1 ? index / (rows.length - 1) : 0;
        var key = node.key,
            data = node.data;

        if (!data.shape) {
          return null;
        }

        var _this$props = this.props,
            process = _this$props.process,
            opacity = _this$props.opacity,
            borderColor = _this$props.borderColor,
            gradual = _this$props.gradual,
            inverted = _this$props.inverted,
            reversed = _this$props.reversed;
        var color = data.color,
            fake = data.fake,
            shape = data.shape;
        var scale = [1, 1];
        var cx = shape.cx,
            cy = shape.cy;
        var center = [cx, cy];
        var _transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            z = transitionProps.z,
            silent = transitionProps.silent,
            isEnter = transitionProps.isEnter;
        var style = {
          fill: color,
          opacity: opacity * (fake ? 0.5 : 1),
          shadowBlur: 0,
          shadowColor: 'transparent',
          stroke: borderColor || color
        };
        isFade && fadeStyle(style);
        isHover && hoverStyle(style);
        var transition = _transition;

        if (isEnter && transition) {
          if (process === SHOW) {
            transition.appear = getShowEnterAppearFn$1(node, !inverted);
          } else {
            transition = _transition(percent);
            this._transition = transition;
          }
        }

        if (gradual) {
          style.fill = getLinearGradualColor({
            color: style.fill,
            type: ChartLibrary.FUNNEL,
            stops: getGradualStops$1(inverted, reversed)
          });
        }

        return h('polygon', {
          key: key,
          id: key,
          silent: silent,
          scale: scale,
          z: z,
          origin: center,
          tooltipPos: center,
          shape: {
            points: calcTrapezoidPoints(shape, inverted)
          },
          style: style,
          transition: transition,
          transitionEnd: transitionEnd
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        if (this._transition) {
          refer.transition = this._transition;
          this._transition = null;
        }

        var row = node.data;

        if (row.annotation) {
          refer.startPos = [row.x, row.y];
        }
      };

      _proto.renderGuides = function renderGuides(refer) {
        var node = refer.node;
        var shape = node.data.shape;
        return shape && shape.height ? _Geometry.prototype.renderGuides.call(this, refer) : null;
      };

      _proto.showEffect = function showEffect(id, effect) {
        showScaledEffect.call(this, id, effect);
      };

      return Funnel;
    }(Geometry);

    var FunnelGroup = Geom.createGeomGroup(ChartLibrary.FUNNEL, Funnel);
    FunnelGroup.layout = layout$5;

    FunnelGroup.calcDataLabelPos = function (_ref) {
      var row = _ref.row;
      var _row$shape = row.shape,
          cx = _row$shape.cx,
          cy = _row$shape.cy,
          height = _row$shape.height; // the last row does not display.

      return Math.abs(height) < 1e-6 ? null : [cx, cy];
    };

    FunnelGroup.adjustDataLabel = adjustLabel$2;
    FunnelGroup.usePercentSize = isGeomUsePercentSize;

    FunnelGroup.updateGeometryWhileZoomScale = function (_ref2) {
      var geom = _ref2.geom,
          inverted = _ref2.inverted,
          zoom = _ref2.zoom;
      geom.maxWidth *= zoom[inverted ? 'y' : 'x'];
    };

    FunnelGroup.adjust = adjust$5;

    var INIT_TIME$1 = 800;
    var HOVER_SCALE = [1.2, 1.2];
    var fadeStyle$1 = function fadeStyle(style) {
      style.opacity = Fade.Opacity;
    };
    var Timing$9 = {
      INIT: function INIT$$1() {
        return {
          delay: Math.random() * INIT_TIME$1 / 2,
          duration: INIT_TIME$1 / 2,
          ease: Ease.EaseOutBack,
          appear: function appear() {
            return {
              scale: [0, 0]
            };
          }
        };
      },
      SHOW_ENTER: {
        duration: 300,
        ease: Ease.EaseOutBack
      },
      HOVER: {
        duration: 150,
        ease: Ease.Default
      },
      SHOW_UPDATE: {
        duration: 500,
        ease: Ease.EaseOutBack
      },
      HIDE_UPDATE: {
        duration: 500,
        ease: Ease.EaseOutBack
      },
      HIDE_LEAVE: {
        duration: 300,
        ease: Ease.EaseInBack
      }
    };

    var getTransitionProps$a = getGeomTransitionProps(Timing$9);
    var EFFECT_SCALE_COEFFICIENT = 0.2;

    var hasField = function hasField(aes) {
      return aes && aes.id;
    };

    var Text$1 =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Text, _Geometry);

      function Text(props, context) {
        var _this;

        _this = _Geometry.call(this, props, context) || this;
        _this.getTransitionProps = getTransitionProps$a;

        _this.updateState(props);

        return _this;
      }

      var _proto = Text.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        this.updateState(nextProps);
      };

      _proto.updateState = function updateState(props) {
        var style = props.rich.style,
            color = props.color,
            size = props.size;
        var hasColorField = hasField(color);
        var hasSizeField = hasField(size);

        var _rich = cloneRichStyle(style);

        var getTextRich = function getTextRich(_ref, isFade) {
          var color = _ref.color,
              size = _ref.size;
          var rich = _rich;

          if (hasColorField) {
            rich = cloneRichStyle(rich, {
              textFill: color
            });
          }

          if (isFade) {
            rich = cloneRichStyle(rich, {
              textFill: Fade.Fill
            });
          }

          return hasSizeField ? cloneRichStyle(rich, {
            fontSize: size
          }) : rich;
        };

        this.setState({
          hasColorField: hasColorField,
          hasSizeField: hasSizeField,
          getTextRich: getTextRich
        });
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            data = node.data;
        var _this$props = this.props,
            process = _this$props.process,
            opacity = _this$props.opacity,
            borderColor = _this$props.borderColor,
            richConfig = _this$props.rich;
        var getTextRich = this.state.getTextRich;
        var fake = data.fake,
            x = data.x,
            y = data.y,
            vanish = data.vanish;
        var text = getRichContent(richConfig, data);
        var position = [x, y],
            scale = vanish ? [0, 0] : [1, 1];
        var _transition = transitionProps.transition,
            _transitionEnd = transitionProps.transitionEnd,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            z = transitionProps.z,
            silent = transitionProps.silent,
            isEnter = transitionProps.isEnter;
        var transition = _transition,
            transitionEnd = _transitionEnd;

        if (transition) {
          transition.properties = {
            position: true,
            scale: true
          };
        }

        var showEnter = isEnter && process === INIT;

        if (transition && showEnter) {
          transition = transition();
        }

        var rich = getTextRich(data, isFade);
        var style = {
          text: text,
          fontSize: FONT_SIZE,
          textAlign: 'center',
          textVerticalAlign: 'center',
          rich: rich,
          textStroke: borderColor || 'none',
          textStrokeWidth: 1,
          opacity: opacity * (fake ? 0.5 : 1)
        };
        fake && fakeStyle(style);
        isFade && fadeStyle$1(style);

        if (isHover) {
          scale = HOVER_SCALE;
          highlightRichStyle(style.rich);
        }

        return h('text', {
          key: key,
          id: key,
          position: position,
          scale: scale,
          tooltipPos: [0, 0],
          z: z,
          silent: silent,
          style: style,
          transition: transition,
          transitionEnd: transitionEnd
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var row = node.data;

        if (row.annotation) {
          refer.startPos = [row.x, row.y];
        }

        if (row.fake) {
          var inverted = this.props.inverted;
          var x = row.x,
              y = row.y,
              upper = row.upper,
              lower = row.lower,
              color = row.color;
          var hasColorField = this.state.hasColorField;
          refer.stroke = hasColorField ? color : Timing_Prediction.Color;
          refer.points = [x, y, upper, lower];
          refer.inverted = inverted;
        }
      };

      _proto.renderGuides = function renderGuides(refer, node) {
        var guides = [renderAnnotation(refer)];
        node.data.fake && guides.push(renderRegionLine(refer));
        return guides;
      };

      _proto.showEffect = function showEffect(id, effect) {
        showScaledEffect.call(this, id, effect, EFFECT_SCALE_COEFFICIENT);
      };

      return Text;
    }(Geometry);
    Geom.registerGeom('text', Text$1);

    var MAX_HEIGHT = 0.88; // 1 - 0.06 * 2

    var MAX_WIDTH = 0.84; // 1 - 0.08 * 2

    var LINE_HEIGHT$8 = 1.2;
    /**
     * 分区内单个词时自适应词的大小
     * UI文档见: http://ui.finebi.com/git/%E8%A7%86%E8%A7%89/vidocuments/8-%E5%9B%BE%E8%A1%A8%E8%A7%86%E8%A7%89%E8%A7%84%E5%88%99/index.html#g=1&p=%E8%AF%8D%E4%BA%91_%E8%A1%A8%E6%A0%BC_kpi%E6%8C%87%E6%A0%87%E5%8D%A1
     */

    function adaptKPISize(word, cellBounds) {
      var _word$bounds = word.bounds,
          width = _word$bounds.width,
          height = _word$bounds.height;
      height *= LINE_HEIGHT$8; // 默认的bounds计算不考虑lineHeight, 但是视觉规范里有要求, 这里补充一下

      var cellWidth = cellBounds.width,
          cellHeight = cellBounds.height;
      cellWidth *= MAX_WIDTH;
      cellHeight *= MAX_HEIGHT;
      var adaptHeight = height / width > cellHeight / cellWidth;
      var scaleRatio = adaptHeight ? cellHeight / height : cellWidth / width;

      _.each(word.rich, function (s) {
        s.fontSize = s.fontSize * scaleRatio;
        s.textLineHeight = s.fontSize * LINE_HEIGHT$8;
      });
    }

    var Timing$a = {
      SHOW_DURATION: 800,
      INIT: {
        duration: 400,
        ease: Ease.EaseOutBack
      },
      SHOW_ENTER: {
        duration: 1200,
        ease: Ease.EaseOutCubic
      },
      HOVER: {
        duration: 300,
        ease: Ease.EaseOutQuart
      },
      SHOW_UPDATE: {
        duration: 600,
        ease: Ease.EaseOutQuart
      },
      HIDE_LEAVE: {
        duration: 1000,
        ease: Ease.EaseOutCubic
      }
    };

    /**
     * Get ShapeFunction for layout
     * @param shape
     */
    function getShapeFunction(shape) {
      switch (shape) {
        case 'cardioid':
          shape = function shapeCardioid(theta) {
            return 1 - Math.sin(theta);
          };

          break;

        /*
          To work out an X-gon, one has to calculate "m",
         where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))
         http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28
         2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29
          Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))
         where t' equals to mod(t, 2PI/X);
          */

        case 'diamond':
          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+
          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D
          // +0+..+2*PI
          shape = function shapeSquare(theta) {
            var thetaPrime = theta % (2 * Math.PI / 4);
            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
          };

          break;

        case 'square':
          // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t
          // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI
          shape = function shapeSquare(theta) {
            return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
          };

          break;

        case 'triangle-forward':
          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+
          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29
          // %29%29%2C+t+%3D+0+..+2*PI
          shape = function shapeTriangle(theta) {
            var thetaPrime = theta % (2 * Math.PI / 3);
            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
          };

          break;

        case 'triangle':
        case 'triangle-upright':
          shape = function shapeTriangle(theta) {
            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);
            return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
          };

          break;

        case 'pentagon':
          shape = function shapePentagon(theta) {
            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);
            return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));
          };

          break;

        case 'star':
          shape = function shapeStar(theta) {
            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);

            if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {
              return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));
            } else {
              return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));
            }
          };

          break;

        case 'circle':
        /* falls through */

        default:
          // 'circle' is the default and a shortcut in the code loop.
          shape = 'circle';
          break;
      }
    }

    function fillRichText(ctx, word) {
      var data = word.data,
          bounds = word.bounds;
      var wordWidth = bounds.width,
          wordHeight = bounds.height;
      ctx.textBaseline = 'middle'; // Note baseLine = middle, 约等于top: 0.6, bottom: 0.4
      // Note 如果想让文字完全显示，则需要讲文字向下偏移0.6 * fontSize
      // Note 这里我们需要垂直居中, 故计算位置的时候应该是 y + yOffset + yTrans

      var yTrans = -wordHeight / 2;

      _.each(data, function (line) {
        var lineWidth = 0;

        _.each(line, function (word) {
          return lineWidth += word.dim.width;
        });

        var trans = (bounds.width - lineWidth) / 2;

        _.each(line, function (word) {
          var dim = word.dim,
              text = word.text,
              style = word.style;
          var x = dim.x,
              y = dim.y,
              height = dim.height;
          ctx.font = toFont(style);
          ctx.fillText(text, x + trans - wordWidth / 2, y + yTrans + height * 0.6);
        });
      });
    }

    /**
     * 词云布局算法
     * Reference to https://github.com/timdream/wordcloud2.js
     */
    var ELLIPTICITY = 0.65;

    function wordCloudLayout() {
      var minRotation = 0,
          // 最小旋转角度
      maxRotation = 0,
          // 最大旋转角度
      rotationRange = 0,
          // 旋转角度范围
      words = [],
          // 待布局的单词
      plotWidth = 100,
          // 画布宽度
      plotHeight = 100,
          // 画布高度
      drawOutOfBound = false,
          // 超出是否绘制
      placeCallBack = DO_NOTHING,
          // 单个词摆放结束后的回调
      getWordSizeFn = function getWordSizeFn(_ref) {
        var bounds = _ref.bounds;
        return [bounds.width, bounds.height];
      },
          shapeFn = 'circle'; // 形状函数

      /* start开始布局时自动更新的一些局部变量, 以供内部计算相关函数使用 */


      var grid, // 2d array containing filling information
      ngx, ngy, // width and height of the grid
      center, // position of the center of the cloud
      maxRadius;
      var g = 4;
      /* Get points on the grid for a given radius away from the center */

      var pointsAtRadius = [];

      var getPointsAtRadius = function getPointsAtRadius(radius) {
        if (pointsAtRadius[radius]) {
          return pointsAtRadius[radius];
        } // Look for these number of points on each radius


        var T = radius * 8,
            points = []; // Getting all the points at this radius

        var t = T;

        if (radius === 0) {
          points.push([center[0], center[1], 0]);
        }

        while (t--) {
          // distort the radius to put the cloud in shape
          var rx = 1;

          if (shapeFn !== 'circle') {
            rx = shapeFn(t / T * 2 * Math.PI); // 0 to 1
          } // Push [x, y, t]; t is used solely for getTextColor()


          points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * ELLIPTICITY, t / T * 2 * Math.PI]);
        }

        pointsAtRadius[radius] = points;
        return points;
      };
      /* Get the deg of rotation according to settings, and luck. */


      var getRotateDeg = function getRotateDeg() {
        if (rotationRange === 0) {
          return minRotation;
        }

        return minRotation + Math.random() * rotationRange;
      };

      var fcanvas = createCanvas$1(),
          fctx = fcanvas.getContext('2d', {
        willReadFrequently: true
      });

      var getTextInfo = function getTextInfo(word, rotateDeg) {
        var _getWordSizeFn = getWordSizeFn(word),
            wordWidth = _getWordSizeFn[0],
            wordHeight = _getWordSizeFn[1]; // Estimate the dimension of the text with measureText().


        var fw = wordWidth,
            fh = wordHeight; // Create a boundary box that is larger than our estimates,
        // so text don't get cut of (it sill might)

        var boxWidth = fw + fh * 2;
        var boxHeight = fh * 3;
        var fgw = Math.ceil(boxWidth / g);
        var fgh = Math.ceil(boxHeight / g);
        boxWidth = fgw * g;
        boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at
        // the preferred position.
        // This is simply half of the width.

        var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred
        // position, for Y-offset we move 0.4 instead, so Latin alphabets look
        // vertical centered.

        var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.

        var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);
        var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);
        var width = cgw * g;
        var height = cgh * g;
        fcanvas.setAttribute('width', width);
        fcanvas.setAttribute('height', height); // Scale the canvas with |mu|.

        fctx.translate(width / 2, height / 2);
        fctx.rotate(-rotateDeg); // Fill the text into the fcanvas.
        // XXX: We cannot because textBaseline = 'top' here because
        // Firefox and Chrome uses different default line-height for canvas.
        // Please read https://bugzil.la/737852#c6.
        // Here, we use textBaseline = 'middle' and draw the text at exactly
        // 0.5 * fontSize lower.

        fctx.textBaseline = 'middle';
        fctx.fillStyle = '#000';
        fillRichText(fctx, word); // Get the pixels of the text

        var imageData = fctx.getImageData(0, 0, width, height).data; // Read the pixels and save the information to the occupied array

        var occupied = [];
        var gx = cgw,
            gy,
            x,
            y;
        var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];

        while (gx--) {
          gy = cgh;

          while (gy--) {
            y = g;

            singleGridLoop: {
              while (y--) {
                x = g;

                while (x--) {
                  if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {
                    occupied.push([gx, gy]);

                    if (gx < bounds[3]) {
                      bounds[3] = gx;
                    }

                    if (gx > bounds[1]) {
                      bounds[1] = gx;
                    }

                    if (gy < bounds[0]) {
                      bounds[0] = gy;
                    }

                    if (gy > bounds[2]) {
                      bounds[2] = gy;
                    }

                    break singleGridLoop;
                  }
                }
              }
            }
          }
        } // Return information needed to create the text on the real canvas


        return {
          occupied: occupied,
          bounds: bounds,
          gw: cgw,
          gh: cgh,
          fillTextOffsetX: fillTextOffsetX,
          fillTextOffsetY: fillTextOffsetY,
          fillTextWidth: fw,
          fillTextHeight: fh
        };
      };
      /* Determine if there is room available in the given dimension */


      var canFitText = function canFitText(gx, gy, gw, gh, occupied) {
        // Go through the occupied points,
        // return false if the space is not available.
        var i = occupied.length;

        while (i--) {
          var px = gx + occupied[i][0];
          var py = gy + occupied[i][1];

          if (px >= ngx || py >= ngy || px < 0 || py < 0) {
            if (!drawOutOfBound) {
              return false;
            }

            continue;
          }

          if (!grid[px][py]) {
            return false;
          }
        }

        return true;
      };
      /* Help function to updateGrid */


      var fillGridAt = function fillGridAt(x, y) {
        if (x >= ngx || y >= ngy || x < 0 || y < 0) {
          return;
        }

        grid[x][y] = false;
      };
      /* Update the filling information of the given space with occupied points.
       Draw the mask on the canvas if necessary. */


      var updateGrid = function updateGrid(gx, gy, gw, gh, info) {
        var occupied = info.occupied;
        var i = occupied.length;
        var px, py;

        while (i--) {
          px = gx + occupied[i][0];
          py = gy + occupied[i][1];

          if (px >= ngx || py >= ngy || px < 0 || py < 0) {
            continue;
          }

          fillGridAt(px, py);
        }
      };
      /* putWord() processes each item on the list,
       calculate it's size and determine it's position, and actually
       put it on the canvas. */


      var putWord = function putWord(word) {
        var _getWordSizeFn2 = getWordSizeFn(word),
            width = _getWordSizeFn2[0],
            height = _getWordSizeFn2[1];

        if (width === 0 || height === 0) {
          return false;
        }

        var rotateDeg = getRotateDeg(); // get info needed to put the text onto the canvas

        var info = getTextInfo(word, rotateDeg); // not getting the info means we shouldn't be drawing this one.

        if (!info) {
          return false;
        } // If drawOutOfBound is set to false,
        // skip the loop if we have already know the bounding box of
        // word is larger than the canvas.


        if (!drawOutOfBound) {
          var bounds = info.bounds;

          if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {
            return false;
          }
        } // Determine the position to put the text by
        // start looking for the nearest points


        var r = maxRadius + 1;

        var tryToPutWordAtPoint = function tryToPutWordAtPoint(gxy) {
          var gx = Math.floor(gxy[0] - info.gw / 2);
          var gy = Math.floor(gxy[1] - info.gh / 2);
          var gw = info.gw;
          var gh = info.gh; // If we cannot fit the text at this position, return false
          // and go to the next position.

          if (!canFitText(gx, gy, gw, gh, info.occupied)) {
            return false;
          }

          var x = (gx + info.gw / 2) * g + info.fillTextOffsetX;
          var y = (gy + info.gh / 2) * g + info.fillTextOffsetY; // Actually put the text on the canvas

          placeCallBack(word, x, y); // Mark the spaces on the grid as filled

          updateGrid(gx, gy, gw, gh, info); // Return true so some() will stop and also return true.

          return true;
        };

        while (r--) {
          var points = getPointsAtRadius(maxRadius - r); // Try to fit the words by looking at each point.
          // array.some() will stop and return true
          // when putWordAtPoint() returns true.
          // If all the points returns false, array.some() returns false.

          var drawn = points.some(tryToPutWordAtPoint);

          if (drawn) {
            // leave putWord() and return true
            return true;
          }
        } // we tried all distances but text won't fit, return false


        return false;
      };

      var timer,
          loopingFunction = window.setTimeout,
          stoppingFunction = window.clearTimeout;

      var startLayout = function start(async) {
        async && stoppingFunction(timer);

        if (plotWidth < 1 || plotHeight < 1) {
          return;
        }

        ngx = Math.ceil(plotWidth / g);
        ngy = Math.ceil(plotHeight / g); // Determine the center of the word cloud

        center = [ngx / 2, ngy / 2];
        pointsAtRadius = []; // Maxium radius to look for space

        maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));
        /* Clear the canvas only if the clearCanvas is set,
         if not, update the grid to the current canvas state */

        grid = [];
        var gx, gy;
        /* fill the grid with empty state */

        gx = ngx;

        while (gx--) {
          grid[gx] = [];
          gy = ngy;

          while (gy--) {
            grid[gx][gy] = true;
          }
        }

        var i = 0;

        function loop() {
          if (i >= words.length) {
            stoppingFunction(timer);
            return;
          }

          putWord(words[i]);
          i++;
          layout();
        }

        function layout() {
          if (async) {
            timer = loopingFunction(loop, 0);
          } else {
            loop();
          }
        }

        layout();
      };

      var cloudLayout = {
        /**
         * 设置文字旋转角度范围
         */
        setRotationRange: function setRotationRange(_ref2) {
          var min = _ref2[0],
              max = _ref2[1];
          minRotation = min;
          maxRotation = max;
          rotationRange = Math.abs(maxRotation - minRotation);
          return cloudLayout;
        },
        setShape: function setShape(shape) {
          shapeFn = typeof shape === 'function' ? shape : getShapeFunction(shape);
          return cloudLayout;
        },
        setWords: function setWords(wordList) {
          words = wordList;
          return cloudLayout;
        },
        setPlotSize: function setPlotSize(_ref3) {
          var width = _ref3[0],
              height = _ref3[1];
          plotWidth = width;
          plotHeight = height;
          return cloudLayout;
        },
        setDrawOutOfBound: function setDrawOutOfBound(drawAll) {
          drawOutOfBound = drawAll;
          return cloudLayout;
        },
        tick: function tick(cb) {
          placeCallBack = cb;
          return cloudLayout;
        },
        gridSize: function gridSize(size) {
          g = Math.max(size, 4);
          return cloudLayout;
        },
        start: function start(async) {
          startLayout(async);
        }
      };
      return cloudLayout;
    }

    var getTransitionProps$b = getGeomTransitionProps(Timing$a);

    var hasId = function hasId(aes) {
      return aes && aes.id != null;
    };
    /**
     * 是否需要自适应KPI文字大小
     * @returns {*}
     * @private
     */


    var needAdaptKPISize = function needAdaptKPISize(_ref) {
      var facetX = _ref.facetX,
          facetY = _ref.facetY,
          specialMode = _ref.specialMode,
          autoFont = _ref.autoFont,
          size = _ref.size;

      if (specialMode !== SpecialMode.KPI) {
        return false;
      } // @CHART-8978 大小中存在字段时, KPI不需要自适应组件


      if (hasId(size)) {
        return false;
      } // http://www.finedevelop.com:2016/browse/DOCDESIGN-843


      return autoFont || facetX.fit && facetY.fit;
    };

    var WordCloud =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(WordCloud, _Geometry);

      function WordCloud() {
        var _this;

        _this = _Geometry.apply(this, arguments) || this;
        _this.cloudLayout = wordCloudLayout().tick(_this._tick.bind(_assertThisInitialized(_assertThisInitialized(_this))));
        _this.getTransitionProps = getTransitionProps$b;

        _this.updateState(_this.props);

        return _this;
      }

      var _proto = WordCloud.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.rows !== this.props.rows) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var _this2 = this;

        var rows = props.rows,
            richConfig = props.rich,
            bounds = props.bounds,
            animation = props.animation;
        var x = bounds.x,
            y = bounds.y,
            cellWidth = bounds.width,
            cellHeight = bounds.height;
        var hasColorField = hasId(props.color),
            hasSizeField = hasId(props.size);
        var rich = cloneRichStyle(richConfig.style);
        var sorted = hasSizeField ? rows.slice().sort(function (a, b) {
          return b.size - a.size;
        }) : rows;
        var validRows = [];
        var wordNodes = {}; // cache wordInfo

        var words = []; // words data for layout

        var plotAreaSize = cellWidth * cellHeight * 2;
        var placedAreaSize = 0;

        _.each(sorted, function (row) {
          var size = row.size,
              color = row.color,
              id = row.id,
              vanish = row.vanish; // 对于数据很多很多，明显放不下的，这里计算占用面积过滤掉一部分，不做无用功

          if (vanish || placedAreaSize > plotAreaSize) return;

          var _rich = hasColorField ? cloneRichStyle(rich, {
            textFill: color
          }) : rich;

          _rich = hasSizeField ? cloneRichStyle(_rich, {
            fontSize: size
          }) : _rich;
          var word = rowToParagraphProp({
            row: row,
            rich: _extends({}, richConfig, {
              style: _rich
            })
          });
          word.id = id;
          word.invisible = true;

          var zEl = _this2.getZNode(id);

          zEl && setCenter(word.bounds, zEl.position);
          wordNodes[id] = word;
          var _word$bounds = word.bounds,
              width = _word$bounds.width,
              height = _word$bounds.height;
          placedAreaSize += Math.min(width, cellWidth) * Math.min(height, cellHeight);
          words.push(word);
          validRows.push(row);
        });

        var singleWord = words.length === 1;
        this.setState({
          rows: validRows,
          // 排序后hover拿到的instance居然不对.....
          words: words,
          wordNodes: wordNodes,
          bounds: bounds,
          position: [x, y],
          singleWord: singleWord,
          layoutEnd: false
        });
        this.showIndex = 0;
        needAdaptKPISize(props) && words[0] && adaptKPISize(words[0], bounds);

        if (words.length > 0) {
          var width = bounds.width,
              height = bounds.height;
          var grid = Math.ceil(Math.min(width, height) / 100); // gridSize应该根据plotBounds调整

          this.cloudLayout.setPlotSize([cellWidth, cellHeight]).setDrawOutOfBound(singleWord).setWords(words).gridSize(grid).start(animation);
        }
      }
      /**
       * callback for cloudLayout
       * @param item
       * @param x
       * @param y
       * @private
       */
      ;

      _proto._tick = function _tick(item, x, y) {
        var _this3 = this;

        var _this$props = this.props,
            process = _this$props.process,
            _this$props$bounds = _this$props.bounds,
            cw = _this$props$bounds.width,
            ch = _this$props$bounds.height;
        var _this$state = this.state,
            singleWord = _this$state.singleWord,
            wordNodes = _this$state.wordNodes; // 设置数据点文本的位置

        var _item$bounds = item.bounds,
            width = _item$bounds.width,
            height = _item$bounds.height; // 单个词的时候，直接定位分区的中心点，这边主要为了统一流程，手动控制init动画

        var position = singleWord ? [cw / 2, ch / 2] : [x + width / 2, y + height / 2];
        setCenter(item.bounds, position);
        var el = this.getZNode(item.id);
        var word = wordNodes[item.id];

        if (word) {
          word.invisible = false;
        }

        if (!el) {
          return;
        }

        var invisible = el.invisible;
        el.attrKV('invisible', false);
        item.invisible = false;
        var reRenderDelay = 0; // reShow or init

        if (invisible) {
          var init = process === INIT;
          var timing = init ? Timing$a.INIT : Timing$a.SHOW_ENTER;
          var delay = init ? this.showIndex * Timing$a.SHOW_DURATION / this.state.words.length : 0;
          reRenderDelay = delay + timing.duration;
          el.attrKV('position', position);
          el.attrKV('scale', [0, 0]);
          el.animate('scale').delay(delay).when(timing.duration, [1, 1]).start(timing.ease);
        } // update
        else {
            var _timing = Timing$a.SHOW_UPDATE;
            el.animate('position').when(_timing.duration, position).start(_timing.ease);
            reRenderDelay = _timing.duration;
          }

        this.showIndex++;

        if (this.showIndex === this.state.words.length) {
          // reRender annotation & effect when layout finished.
          setTimeout(function () {
            _this3.triggerGroupEffects();

            _this3.setState({
              layoutEnd: true
            });
          }, reRenderDelay);
        }
      };

      _proto.getGroupProps = function getGroupProps() {
        var props = _Geometry.prototype.getGroupProps.call(this);

        var position = this.state.position;
        props.position = position;
        return props;
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            row = node.data;
        var _this$props2 = this.props,
            defaultOpacity = _this$props2.opacity,
            borderColor = _this$props2.borderColor;
        var wordNodes = this.state.wordNodes;
        var word = wordNodes[row.id];

        if (!word) {
          return;
        }

        var _word$bounds2 = word.bounds,
            bounds = _word$bounds2 === void 0 ? {
          x: 0,
          y: 0
        } : _word$bounds2,
            _word$rich = word.rich,
            rich = _word$rich === void 0 ? {} : _word$rich,
            _word$text = word.text,
            text = _word$text === void 0 ? '' : _word$text,
            invisible = word.invisible;
        var isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            isLeave = transitionProps.isLeave,
            silent = transitionProps.silent,
            z = transitionProps.z;

        var _ref2 = bounds.x == null ? [-bounds.width, -bounds.height] : getBoundsCenter(bounds),
            cx = _ref2[0],
            cy = _ref2[1];

        var opacity = defaultOpacity,
            textRich = rich;
        var scale = [1, 1];

        if (isFade) {
          opacity = Fade.Opacity;
          textRich = cloneRichStyle(textRich, {
            textFill: Fade.Fill
          });
        } else if (isHover) {
          scale = [1.2, 1.2];
          textRich = cloneRichStyle(textRich); // Note 富文本最烦的一点就是要不停的判断cloneStyle

          highlightRichStyle(textRich);
        }

        if (isLeave) {
          scale = [0, 0];
          opacity = 0;
        }

        if (transition) {
          transition.properties = {
            scale: 1,
            style: 1
          };
        }

        var style = {
          text: text,
          rich: textRich,
          fontSize: FONT_SIZE,
          opacity: opacity,
          textAlign: 'center',
          textVerticalAlign: 'middle',
          textStroke: borderColor || 'none',
          textStrokeWidth: 1
        };

        if (word.truncate) {
          style.truncate = {
            outerWidth: word.truncate
          };
        }

        var position = [cx, cy];
        return h('text', {
          key: key,
          id: key,
          scale: scale,
          position: position,
          silent: silent,
          invisible: invisible,
          z: z,
          transition: transition,
          transitionEnd: transitionEnd,
          tooltipPos: [0, 0],
          style: style
        });
      };

      _proto.renderGuides = function renderGuides(refer) {
        if (!this.state.layoutEnd) {
          return null;
        }

        return renderAnnotation(refer);
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var row = node.data;
        var word = this.state.wordNodes[row.id];

        if (word && this.state.layoutEnd && row.annotation) {
          var _getBoundsCenter = getBoundsCenter(word.bounds),
              x = _getBoundsCenter[0],
              y = _getBoundsCenter[1];

          refer.startPos = [x, y];
        }
      };

      _proto.showEffect = function showEffect(id, effect) {
        Text$1.prototype.showEffect.call(this, id, effect);
      };

      return WordCloud;
    }(Geometry);

    Geom.registerGeom('wordCloud', WordCloud);

    var PLOT_SHADOW_COLOR = 'rgba(0, 0, 0, 0.1)';
    var PLOT_SHADOW_BLUR = 5;
    var PI$c = Math.PI;

    var renderPlot = function renderPlot(_ref) {
      var radius = _ref.radius,
          isSemi = _ref.isSemi,
          backgroundColor = _ref.backgroundColor,
          isFade = _ref.isFade,
          row = _ref.row,
          opacity = _ref.opacity,
          pos = _ref.pos,
          z = _ref.z;
      var id = row.id,
          fake = row.fake;
      return h(isSemi ? 'semiPointerGaugePlot' : 'arc', {
        id: id,
        key: id,
        pos: pos,
        z: z,
        silent: isFade,
        shape: {
          r: radius,
          startAngle: isSemi ? PI$c : 0,
          endAngle: PI$c * 2
        },
        style: {
          fill: backgroundColor,
          shadowColor: PLOT_SHADOW_COLOR,
          shadowBlur: fake ? 0 : PLOT_SHADOW_BLUR,
          lineWidth: 0,
          opacity: opacity
        }
      });
    };

    var AXIS_PALETTE_GAP = 0.06; // 坐标底盘到边界距离

    var AXIS_PALETTE_SIZE = 0.08; // 坐标底盘宽度

    var TICK_COLOR = '#2e2e2e';
    var MAIN_TICK_COLOR = '#fcfcfc';
    var MINOR_TICK_COLOR = 'rgba(255,255,255,0.5)';

    var renderAxisPlot = function renderAxisPlot(_ref) {
      var color = _ref.color,
          radius = _ref.radius,
          startAngle = _ref.startAngle,
          endAngle = _ref.endAngle,
          gradient = _ref.gradient,
          opacity = _ref.opacity,
          pointers = _ref.pointers,
          z = _ref.z,
          row = _ref.row;

      // 空指针时不绘制色盘
      // http://www.finedevelop.com/pages/viewpage.action?pageId=24067976
      if (pointers.length === 0) {
        return;
      }

      var key = row.id + '_axisPlot';
      var simple = gradient == null || typeof gradient === 'string';
      var r0 = radius * (1 - AXIS_PALETTE_GAP - AXIS_PALETTE_SIZE),
          r = radius * (1 - AXIS_PALETTE_GAP);
      var shape = {
        startAngle: startAngle,
        endAngle: endAngle,
        r: r,
        r0: r0
      };
      var style = {
        fill: color,
        opacity: opacity
      }; // 单色

      if (simple) {
        return h('roundCornerArc', {
          key: key,
          z: z,
          silent: true,
          shape: shape,
          style: style
        });
      } // 渐变色
      else {
          var palette = SweepGradient(gradient.type).radius(radius).startAngle(startAngle).endAngle(endAngle).corner(AXIS_PALETTE_SIZE).create(gradient.colors);
          return clipSweepGradient({
            key: key,
            radius: radius,
            palette: palette,
            silent: true,
            z: z,
            clip: {
              type: 'roundCornerArc',
              shape: shape
            },
            style: style
          });
        }
    };

    var renderTicks$1 = function renderTicks(_ref2) {
      var radius = _ref2.radius,
          axis = _ref2.axis,
          startAngle = _ref2.startAngle,
          endAngle = _ref2.endAngle,
          tickColor = _ref2.tickColor,
          targetFormat = _ref2.targetFormat,
          z = _ref2.z,
          opacity = _ref2.opacity;
      var labelContent = axis.labelContent;

      if (labelContent.length === 0) {
        return null;
      }

      var axisR = radius * (1 - AXIS_PALETTE_GAP),
          tickSize = radius * AXIS_PALETTE_SIZE;
      return h(PolarAxis, _extends({
        startAngle: startAngle,
        endAngle: endAngle,
        radius: axisR,
        z: z,
        baseLineEnabled: false,
        mainTickColor: MAIN_TICK_COLOR,
        mainTickLength: tickSize,
        mainTickAmount: axis.labelContent && axis.labelContent.length,
        minorTickEnabled: true,
        minorTickColor: MINOR_TICK_COLOR,
        minorTickLength: tickSize,
        minorTickAmount: 5,
        labelEnabled: true,
        labelCenter: false,
        labelColor: tickColor || TICK_COLOR,
        targetFormat: targetFormat,
        opacity: opacity
      }, axis));
    };
    /**
     * 坐标轴
     * @param props
     * @returns {*[]}
     */


    var renderAxis = function renderAxis(props) {
      return [renderAxisPlot(props), // 色盘
      renderTicks$1(props) // 标签
      ];
    };

    var renderHinge = function renderHinge(r, fill, z, opacity) {
      return h('circle', {
        z: z,
        silent: true,
        shape: {
          r: r
        },
        style: {
          fill: fill
        },
        opacity: opacity
      });
    };

    var PI$d = Math.PI;
    var FRONT_HINGE_SIZE = 0.07; // 360度仪表盘前枢纽半径占比

    var BACK_HINGE_SIZE = 0.16; // 360度仪表盘后枢纽半径占比

    var SEMI_FRONT_HINGE_SIZE = 0.055; // 180度仪表盘前枢纽半径占比

    var SEMI_BACK_HINGE_SIZE = 0.11; // 180度仪表盘后枢纽半径占比

    var ENTER_DURATION$1 = 1200; // 进入过渡持续时间

    var ENTER_EASE = Ease.EaseInOutExpo; // 进入过渡缓动函数

    var GROUP_TRANSITION = {
      duration: ENTER_DURATION$1,
      ease: ENTER_EASE
    };
    var POINTER_START_ANGLE = PI$d * 2 / 3; // 360度仪表盘指针起始角度

    var POINTER_SEMI_START_ANGLE = PI$d; // 180度仪表盘指针起始角度

    var POINTER_TOTAL_ANGLE = PI$d * 5 / 3; // 360度指针仪表盘总角度

    var POINTER_SEMI_TOTAL_ANGLE = PI$d; // 180度指针仪表盘总角度

    var BACKGROUND_COLOR = '#fcfcfc';
    var POINTER_COLOR$1 = '#E5715A';
    var HUB_COLOR = '#656B6D';
    var HUB_BACKGROUND_COLOR = '#DCF2F9';
    var POINTER_SIZE_RATIO = 0.86; // 指针长度占比-相对于仪表盘半径

    var POINTER_WIDTH_RATIO = 0.04; // 指针宽度占比-相对于仪表盘半径

    var DEFAULT_GAUGE_AUTO_LABEL_COLOR = '#4D4D4D';

    var PointerGauge =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(PointerGauge, _Component);

      function PointerGauge(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;

        _this.updateState(props);

        return _this;
      }

      var _proto = PointerGauge.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var _this$props = this.props,
            row = _this$props.row,
            isHovered = _this$props.isHovered;

        if (row !== nextProps.row || isHovered !== nextProps.isHovered) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var fake = props.fake,
            tickColor = props.gaugeColor.tickColor,
            isSemi = props.isSemi,
            radius = props.radius,
            isHovered = props.isHovered,
            gaugeColor = props.gaugeColor;
        var startAngle = isSemi ? POINTER_SEMI_START_ANGLE : POINTER_START_ANGLE;
        var endAngle = isSemi ? POINTER_SEMI_TOTAL_ANGLE + POINTER_SEMI_START_ANGLE : POINTER_TOTAL_ANGLE + POINTER_START_ANGLE;
        var backHinge = isSemi ? SEMI_BACK_HINGE_SIZE : BACK_HINGE_SIZE,
            frontHinge = isSemi ? SEMI_FRONT_HINGE_SIZE : FRONT_HINGE_SIZE;
        var opacityRatio = fake ? Timing_Prediction.Fake_Opacity : 1;
        var hubColor = gaugeColor.hubColor,
            hubBackgroundColor = gaugeColor.hubBackgroundColor,
            backgroundColor = gaugeColor.backgroundColor,
            pointerColor = gaugeColor.pointerColor;
        var axisNode = renderAxis(_extends({}, props, {
          radius: radius,
          startAngle: startAngle,
          endAngle: endAngle,
          tickColor: tickColor,
          opacity: opacityRatio
        }));
        var z = isHovered ? HoverLayerZ : NormalLayerZ;
        this.setState({
          opacityRatio: opacityRatio,
          startAngle: startAngle,
          endAngle: endAngle,
          axisNode: axisNode,
          z: z,
          backHinge: backHinge,
          frontHinge: frontHinge,
          backgroundColor: backgroundColor || BACKGROUND_COLOR,
          backHubColor: hubBackgroundColor || HUB_BACKGROUND_COLOR,
          frontHubColor: hubColor || HUB_COLOR,
          pointerColor: pointerColor || POINTER_COLOR$1
        });
      };

      _proto._renderPlot = function _renderPlot() {
        var _this$props2 = this.props,
            center = _this$props2.center,
            row = _this$props2.row,
            isSemi = _this$props2.isSemi,
            radius = _this$props2.radius,
            isFade = _this$props2.isFade;
        var _this$state = this.state,
            backgroundColor = _this$state.backgroundColor,
            z = _this$state.z,
            opacityRatio = _this$state.opacityRatio;
        var cx = center[0],
            cy = center[1];
        return renderPlot({
          row: row,
          radius: radius,
          isSemi: isSemi,
          isFade: isFade,
          backgroundColor: backgroundColor,
          pos: [cx + (isSemi ? 0 : radius), cy + (isSemi ? radius * 0.1 : 0)],
          z: z,
          opacity: opacityRatio
        });
      };

      _proto.render = function render$$1(_ref) {
        var center = _ref.center,
            radius = _ref.radius,
            animation = _ref.animation;
        var _this$state2 = this.state,
            opacityRatio = _this$state2.opacityRatio,
            backHinge = _this$state2.backHinge,
            frontHinge = _this$state2.frontHinge,
            axisNode = _this$state2.axisNode,
            z = _this$state2.z,
            backHubColor = _this$state2.backHubColor,
            frontHubColor = _this$state2.frontHubColor;
        return h('group', {
          position: center,
          transition: animation ? GROUP_TRANSITION : null
        }, this._renderPlot(), renderHinge(radius * backHinge, backHubColor, z, opacityRatio), this._renderPointers(this.props), renderHinge(radius * frontHinge, frontHubColor, z, opacityRatio), axisNode);
      };

      _proto._renderPointers = function _renderPointers(_ref2) {
        var radius = _ref2.radius,
            pointers = _ref2.pointers,
            isSemi = _ref2.isSemi,
            row = _ref2.row,
            dataLabel = _ref2.dataLabel,
            cellBounds = _ref2.bounds,
            z = _ref2.z,
            isFade = _ref2.isFade,
            defaultOpacity = _ref2.opacity,
            animation = _ref2.animation;
        var _this$state3 = this.state,
            pointerColor = _this$state3.pointerColor,
            opacityRatio = _this$state3.opacityRatio;
        var opacity = defaultOpacity * opacityRatio;

        var getRotation = function getRotation(pct) {
          return startAngle - pct * totalAngle;
        };

        var startAngle = isSemi ? 0 : PI$d / 3,
            totalAngle = isSemi ? POINTER_SEMI_TOTAL_ANGLE : POINTER_TOTAL_ANGLE;
        var graphics = map(pointers, function (p) {
          var transition,
              color = pointerColor;
          var zero = p.zero,
              percent = p.percent,
              key = p.key;

          if (isFade) {
            color = Fade.Color;
          } else if (animation) {
            var zeroAngle = getRotation(zero);
            transition = {
              duration: ENTER_DURATION$1,
              ease: ENTER_EASE,
              properties: {
                rotation: true
              },
              appear: function appear() {
                return {
                  rotation: zeroAngle
                };
              }
            };
          }

          var rotation = startAngle - percent * totalAngle;
          return h('pointer', {
            key: key,
            id: key,
            transition: transition,
            z: z,
            rotation: rotation,
            silent: true,
            shape: {
              r: radius * POINTER_SIZE_RATIO,
              r0: radius * POINTER_WIDTH_RATIO / 2
            },
            style: {
              fill: color,
              opacity: opacity
            }
          });
        });
        graphics.push(renderAnnotation({
          row: row,
          cellBounds: cellBounds
        }));

        if (row.dataLabel) {
          var height = row.dataLabel.bounds.height;
          graphics.push(renderDataLabel$$1({
            row: row,
            dataLabel: dataLabel,
            z: z,
            position: [0, (radius * 2 * SEMI_BACK_HINGE_SIZE + height / 2) * (isSemi ? -1 : 1)],
            opacity: opacity,
            autoColor: DEFAULT_GAUGE_AUTO_LABEL_COLOR
          }));
        }

        return graphics;
      };

      return PointerGauge;
    }(Component);

    var PI$e = Math.PI,
        DOUBLE_PI$2 = PI$e * 2;
    var INNER_PLOT_OUTER_STROKE_WIDTH = 4;
    var INNER_PLOT_INNER_STROKE_WIDTH = 3;
    var INNER_PLOT_SIZE = 0.8;
    var PLOT_START_ANGLE = -0.5 * PI$e;
    var ENTER_DURATION$2 = 1200;
    var ENTER_EASE$1 = Ease.EaseInOutExpo;
    var GROUP_TRANSITION$1 = {
      duration: ENTER_DURATION$2,
      ease: ENTER_EASE$1
    };
    var DEFAULT_BACKGROUND$1 = '#f1f1f1';
    var DEFAULT_SLOT_BACKGROUND = '#f6f6f6';

    var RingGauge =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(RingGauge, _Component);

      function RingGauge() {
        return _Component.apply(this, arguments) || this;
      }

      var _proto = RingGauge.prototype;

      _proto.render = function render$$1() {
        var props = this.props;
        var center = props.center,
            fake = props.fake,
            row = props.row,
            fadeChecker = props.fadeChecker,
            highlights = props.highlights,
            dataLabel = props.dataLabel,
            animation = props.animation;
        var isFade = fadeChecker(row);
        var hovered = highlights[row.id];
        var z = hovered ? HoverLayerZ : NormalLayerZ;
        var plotOpacity = fake ? Timing_Prediction.Fake_Opacity : 1;
        return h('group', {
          position: center,
          transition: animation ? GROUP_TRANSITION$1 : null
        }, this.renderPlot(isFade, z, plotOpacity), renderDataLabel$$1({
          row: row,
          dataLabel: dataLabel,
          position: [0, 0],
          z: z,
          autoColor: DEFAULT_GAUGE_AUTO_LABEL_COLOR
        }), this.renderPointer(isFade, hovered, z));
      };

      _proto.renderPlot = function renderPlot(isFade, z, opacity) {
        var _this$props = this.props,
            radius = _this$props.radius,
            _this$props$gaugeColo = _this$props.gaugeColor,
            tickSlotColor = _this$props$gaugeColo.tickSlotColor,
            backgroundColor = _this$props$gaugeColo.backgroundColor,
            id = _this$props.row.id;
        var innerStrokeGradient = new LinearGradient(0, 0, 0, 1);
        innerStrokeGradient.addColorStop(0, '#fff');
        innerStrokeGradient.addColorStop(1, '#ddd'); // 同VanCharts

        var inner = h('circle', {
          silent: true,
          z: z,
          shape: {
            r: radius * INNER_PLOT_SIZE - INNER_PLOT_INNER_STROKE_WIDTH / 2
          },
          style: {
            fill: backgroundColor || DEFAULT_BACKGROUND$1,
            stroke: innerStrokeGradient,
            opacity: opacity
          }
        });
        var innerStroke = h('circle', {
          silent: true,
          z: z,
          shape: {
            r: radius * INNER_PLOT_SIZE + INNER_PLOT_OUTER_STROKE_WIDTH
          },
          style: {
            fill: 'rgba(0, 0, 0, 0.05)'
          }
        });
        var outer = h('circle', {
          key: id,
          id: id,
          z: z,
          silent: isFade,
          shape: {
            r: radius
          },
          style: {
            fill: tickSlotColor || DEFAULT_SLOT_BACKGROUND,
            opacity: opacity
          }
        });
        return [outer, innerStroke, inner];
      }
      /**
       * 指针绘制
       * @private
       */
      ;

      _proto.renderPointer = function renderPointer(isFade, hovered, z) {
        var _this = this;

        var _this$props2 = this.props,
            radius = _this$props2.radius,
            pointers = _this$props2.pointers,
            gradient = _this$props2.gradient,
            animation = _this$props2.animation;

        if (pointers.length === 0) {
          return null;
        }

        var percent = pointers[0].percent;
        var endAngle = PLOT_START_ANGLE - DOUBLE_PI$2 * percent;
        var isGradient = !isFade && gradient && typeof gradient !== 'string';
        var palette = isGradient ? SweepGradient(gradient.type).radius(radius).startAngle(1.5 * PI$e).endAngle(-0.5 * PI$e).clockwise(false).create(gradient.colors) : null;
        return h(Animate$$1, {
          start: {
            endAngle: PLOT_START_ANGLE
          },
          enter: {
            endAngle: animation ? [endAngle] : endAngle,
            timing: {
              duration: ENTER_DURATION$2,
              ease: ENTER_EASE$1
            }
          },
          update: {
            endAngle: animation ? [endAngle] : endAngle,
            timing: {
              duration: ENTER_DURATION$2,
              ease: ENTER_EASE$1
            }
          }
        }, function (state) {
          return h('group', null, _this.renderGraphics({
            state: state,
            palette: palette,
            isFade: isFade,
            hovered: hovered,
            z: z
          }));
        });
      };

      _proto.renderGraphics = function renderGraphics(_ref) {
        var state = _ref.state,
            palette = _ref.palette,
            isFade = _ref.isFade,
            hovered = _ref.hovered,
            z = _ref.z;
        var _this$props3 = this.props,
            radius = _this$props3.radius,
            color = _this$props3.color,
            opacity = _this$props3.opacity,
            _this$props3$center = _this$props3.center,
            cx = _this$props3$center[0],
            cy = _this$props3$center[1],
            row = _this$props3.row,
            label = _this$props3.label,
            fake = _this$props3.fake;
        var fill = palette ? color : isFade ? Fade.Color : hovered ? highlight(color) : color;
        var shape = {
          startAngle: PLOT_START_ANGLE,
          endAngle: state.endAngle,
          r: radius,
          r0: radius * INNER_PLOT_SIZE,
          clockwise: false
        };
        var style = {
          fill: fill,
          opacity: opacity * (palette && hovered ? 0.9 : 1)
        };
        style.opacity *= fake ? Timing_Prediction.Fake_Opacity : 1; // for Gradient

        var sweepGradient = palette ? clipSweepGradient({
          silent: true,
          z: z,
          radius: radius,
          palette: palette,
          clip: {
            type: 'sector',
            shape: shape
          },
          style: style
        }) : null;
        var key = row.id + '_pointer'; // for event

        var sectorNode = h('sector', {
          key: key,
          id: key,
          z: z,
          silent: true,
          pos: [cx + radius, cy],
          shape: shape,
          style: style,
          invisible: !!palette
        });
        return [sweepGradient, sectorNode];
      };

      return RingGauge;
    }(Component);

    var createGradientPalette = function createGradientPalette(gradient, radius) {
      // normal color
      if (!gradient || typeof gradient === 'string') {
        return null;
      }

      if (gradient.colors.length === 0) {
        return null;
      }

      return SweepGradient(gradient.type).radius(radius).startAngle(BACK_START_ANGLE).endAngle(BACK_END_ANGLE).corner(BACKGROUND_STROKE_WIDTH).create(gradient.colors);
    };

    var PI$f = Math.PI;
    var BACKGROUND_STROKE_WIDTH = 0.16;
    var BACK_START_ANGLE = 3 / 4 * PI$f;
    var BACK_END_ANGLE = BACK_START_ANGLE + 3 / 2 * PI$f;
    var ARC_POINT_RADIUS_PERCENT = 0.048;
    var DEFAULT_BACKGROUND$2 = '#e9e9e9';
    var DEFAULT_POINTER_COLOR = '#fff';
    var ENTER_EASE$2 = Ease.EaseInOutExpo;
    var ENTER_DURATION$3 = 1200;
    var GROUP_TRANSITION$2 = {
      duration: ENTER_DURATION$3,
      ease: ENTER_EASE$2
    };

    var SlotGauge =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(SlotGauge, _Component);

      function SlotGauge() {
        return _Component.apply(this, arguments) || this;
      }

      var _proto = SlotGauge.prototype;

      _proto.render = function render$$1() {
        var _this$props = this.props,
            center = _this$props.center,
            defaultOpacity = _this$props.opacity,
            fake = _this$props.fake,
            animation = _this$props.animation;
        var opacity = defaultOpacity * (fake ? Timing_Prediction.Fake_Opacity : 1);
        return h('group', {
          position: center,
          transition: animation ? GROUP_TRANSITION$2 : null
        }, // background
        this.renderSlot(), this.renderNoodle(opacity), this.renderGraphics(opacity));
      };

      _proto.renderSlot = function renderSlot() {
        var _this$props2 = this.props,
            radius = _this$props2.radius,
            tickSlotColor = _this$props2.gaugeColor.tickSlotColor,
            row = _this$props2.row,
            isFade = _this$props2.isFade,
            z = _this$props2.z,
            fake = _this$props2.fake;
        return h('roundCornerArc', {
          id: row.id,
          silent: isFade,
          tooltipPos: [radius, 0],
          z: z,
          shape: {
            r0: radius * (1 - BACKGROUND_STROKE_WIDTH),
            r: radius,
            startAngle: BACK_START_ANGLE,
            endAngle: BACK_END_ANGLE
          },
          style: {
            fill: tickSlotColor || DEFAULT_BACKGROUND$2,
            opacity: fake ? Timing_Prediction.Fake_Opacity : 1
          }
        });
      };

      _proto.renderNoodle = function renderNoodle(opacity) {
        var _this = this;

        var _this$props3 = this.props,
            pointers = _this$props3.pointers,
            color = _this$props3.color,
            radius = _this$props3.radius,
            gradient = _this$props3.gradient,
            highlights = _this$props3.highlights,
            _this$props3$center = _this$props3.center,
            cx = _this$props3$center[0],
            cy = _this$props3$center[1],
            z = _this$props3.z,
            isFade = _this$props3.isFade,
            animation = _this$props3.animation;

        if (pointers.length === 0) {
          return null;
        }

        var p = pointers[0],
            key = p.key,
            percent = p.percent;
        var palette = !isFade && createGradientPalette(gradient, radius);
        var totalAngle = BACK_END_ANGLE - BACK_START_ANGLE,
            endAngle = totalAngle * percent + BACK_START_ANGLE;
        return h(Animate$$1, {
          start: {
            endAngle: BACK_START_ANGLE
          },
          enter: {
            endAngle: animation ? [endAngle] : endAngle,
            timing: {
              duration: ENTER_DURATION$3,
              ease: ENTER_EASE$2
            }
          },
          update: {
            endAngle: animation ? [endAngle] : endAngle,
            timing: {
              duration: ENTER_DURATION$3,
              ease: ENTER_EASE$2
            }
          }
        }, function (state) {
          var fill = color;

          if (isFade) {
            fill = Fade.Color;
          } else if (highlights[p.key]) {
            fill = highlight(fill);
          }

          var shape = {
            r0: radius * (1 - BACKGROUND_STROKE_WIDTH),
            r: radius,
            startAngle: BACK_START_ANGLE,
            endAngle: state.endAngle
          };
          var style = {
            fill: fill,
            opacity: opacity
          };
          var sweepGradient = palette && clipSweepGradient({
            z: z,
            silent: true,
            radius: radius,
            palette: palette,
            clip: {
              type: 'roundCornerArc',
              shape: shape
            }
          });
          var arcNode = h('roundCornerArc', {
            z: z,
            key: key,
            silent: true,
            pos: [cx + radius, cy],
            shape: shape,
            style: style,
            invisible: !!palette
          });
          return h('group', null, sweepGradient, arcNode, _this.renderWhitePoint(state));
        });
      }
      /**
       * 绘制指针上那个白色的小圆点
       * @param state
       * @private
       */
      ;

      _proto.renderWhitePoint = function renderWhitePoint(state) {
        var _this$props4 = this.props,
            radius = _this$props4.radius,
            pointerColor = _this$props4.gaugeColor.pointerColor,
            z = _this$props4.z,
            fake = _this$props4.fake;
        var angle = state.endAngle - PI$f / 2;
        var baseR = radius * (1 - BACKGROUND_STROKE_WIDTH / 2),
            cx = -baseR * Math.sin(angle),
            cy = baseR * Math.cos(angle),
            r = radius * ARC_POINT_RADIUS_PERCENT;
        return h('circle', {
          z: z,
          shape: {
            cx: cx,
            cy: cy,
            r: r,
            r0: 0
          },
          style: {
            fill: pointerColor || DEFAULT_POINTER_COLOR,
            opacity: fake ? Timing_Prediction.Fake_Opacity : 1
          }
        });
      } // 标签&注释
      ;

      _proto.renderGraphics = function renderGraphics(opacity) {
        var _this$props5 = this.props,
            row = _this$props5.row,
            dataLabel = _this$props5.dataLabel,
            bounds = _this$props5.bounds,
            z = _this$props5.z;
        var dataLabelNode = renderDataLabel$$1({
          dataLabel: dataLabel,
          row: row,
          position: [0, 0],
          z: z,
          opacity: opacity
        });
        var annotation = renderAnnotation({
          row: row,
          cellBounds: bounds
        });
        return [dataLabelNode, annotation];
      };

      return SlotGauge;
    }(Component);

    var fakeOpacity = Timing_Prediction.Fake_Opacity;
    var DEFAULT_TICK_COLOR = '#2e2e2e';
    var DARK_THEME_TICK_COLOR = '#fff';
    var AXIS_DISTANCE = 10;
    var THERMOMETER_WIDTH = 10;
    var AXIS_TICK_SIZE = 16;
    var AXIS_TICK_FONT_SIZE = 12; // consider fake point

    var getColor = function getColor(color$$1, defaultColor, opacity) {
      color$$1 = color$$1 || defaultColor;
      return opacity < 1 ? modifyAlpha(color$$1, opacity) : color$$1;
    };
    var getTickSize = function getTickSize(_ref, horizontal) {
      var _ref$labelContent = _ref.labelContent,
          labelContent = _ref$labelContent === void 0 ? [] : _ref$labelContent;
      var size = 0;

      if (horizontal) {
        size = AXIS_TICK_FONT_SIZE;
      } else {
        forEach(labelContent, function (label) {
          var width = calcTextDim(label, {
            fontSize: AXIS_TICK_FONT_SIZE,
            fontFamily: 'Verdana'
          })[0];
          size = Math.max(width, size);
        });
      }

      return size + AXIS_TICK_SIZE;
    };
    function renderAxis$1(props, radius) {
      var axis = props.axis,
          horizontal = props.horizontal,
          tickColor = props.gaugeColor.tickColor,
          fake = props.fake,
          z = props.z,
          darkTheme = props.darkTheme;
      var axisColor = getColor(tickColor, darkTheme ? DARK_THEME_TICK_COLOR : DEFAULT_TICK_COLOR, fake ? fakeOpacity : 1);

      if (!axis || !axis.labelContent.length) {
        return null;
      }

      var x = -(horizontal ? radius : -AXIS_DISTANCE),
          y = horizontal ? -AXIS_DISTANCE : radius;
      var axisProps = assign({
        isHorizontal: horizontal,
        position: [x, y],
        length: radius * 2,
        invert: true,
        mainTickAmount: axis.labelContent && axis.labelContent.length,
        baseLineEnabled: false,
        minorTickEnabled: true,
        labelEnabled: true,
        labelCenter: false,
        mainTickColor: axisColor,
        minorTickColor: axisColor,
        labelColor: axisColor,
        z: z
      }, axis);
      return h(Axis$2, axisProps);
    }
    /**
     * 底盘rectShape
     * @param radius
     * @param horizontal
     * @param sp
     * @param ep
     * @returns {{x: number, y: number, width: number, height: number, r: number}}
     */

    function getRectShape(radius, horizontal, sp, ep) {
      if (sp === void 0) {
        sp = 0;
      }

      if (ep === void 0) {
        ep = 1;
      }

      var borderRadius = THERMOMETER_WIDTH / 2; // 由于要处理渐变+过渡，所以得用到clip，之前的line+stroke+lineCap就不适用
      // 这边用rect+borderRadius来模拟，注意处理一下端点的borderRadius

      sp -= 0.5;
      ep -= 0.5;
      var length$$1 = 2 * radius,
          size = THERMOMETER_WIDTH;
      var x, y, width, height;

      if (horizontal) {
        x = Math.min(sp, ep) * length$$1 - borderRadius;
        y = -borderRadius;
        width = Math.abs(sp - ep) * length$$1 + THERMOMETER_WIDTH;
        height = size;
      } else {
        x = -borderRadius;
        y = -Math.max(sp, ep) * length$$1 - borderRadius;
        width = size;
        height = Math.abs(sp - ep) * length$$1 + THERMOMETER_WIDTH;
      }

      return {
        x: x,
        y: y,
        width: width,
        height: height,
        r: borderRadius
      }; // return {
      //     x: - (horizontal ? (radius + borderRadius) : borderRadius),
      //     y: - (horizontal ? borderRadius : (radius + borderRadius)),
      //     width: horizontal ? (2 * radius + THERMOMETER_WIDTH) : THERMOMETER_WIDTH,
      //     height: horizontal ? THERMOMETER_WIDTH : (2 * radius + THERMOMETER_WIDTH)
      // };
    }
    /**
     * 创建colorScale
     * @param colors
     * @param type
     * @returns {Function}
     */

    function createColorScale(_ref2) {
      var colors = _ref2.colors,
          type = _ref2.type;

      if (type === 'interval') {
        return function (d) {
          var color$$1;

          for (var i = 0; i < colors.length; i++) {
            if (d >= colors[i].from && d <= colors[i].to) {
              color$$1 = colors[i].color;
              break;
            }
          }

          return color$$1;
        };
      } else {
        var domain = map(colors, function (d) {
          return d.value;
        }),
            range = map(colors, function (d) {
          return d.color;
        });
        return scaleColor(domain, range);
      }
    }
    /**
     * 创建渐变色画板
     * @param colors
     * @param type
     * @returns {LinearGradient}
     */

    function createGradientPalette$1(_ref3) {
      var colors = _ref3.colors,
          type = _ref3.type;
      var gradient = new LinearGradient(0, 1, 1, 0);
      forEach(colors, function (color$$1) {
        if (type === 'step') {
          gradient.addColorStop(color$$1.from, color$$1.color);
          gradient.addColorStop(color$$1.to, color$$1.color);
        } else {
          gradient.addColorStop(color$$1.value, color$$1.color);
        }
      });
      return gradient;
    }

    var ENTER_DURATION$4 = 1000;
    var ENTER_EASE$3 = Ease.EaseInOutExpo;
    var DEFAULT_BACKGROUND$3 = '#ededed';
    var DEFAULT_POINTER_COLOR$1 = '#fff';
    var TOOLTIP_GAP = 12;
    var GROUP_TRANSITION$3 = {
      duration: ENTER_DURATION$4,
      ease: ENTER_EASE$3
    };
    var fakeOpacity$1 = Timing_Prediction.Fake_Opacity;

    var ThermometerGauge =
    /*#__PURE__*/
    function (_Component) {
      _inheritsLoose(ThermometerGauge, _Component);

      function ThermometerGauge(props, context) {
        var _this;

        _this = _Component.call(this, props, context) || this;

        _this.updateState(props);

        return _this;
      }

      var _proto = ThermometerGauge.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.row !== this.props.row) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var axis = props.axis,
            horizontal = props.horizontal;
        var tickSize = getTickSize(axis, horizontal);
        var radius = props.radius - THERMOMETER_WIDTH / 2; // 这里cache一下，render的时候就不用一直算了

        var axisNode = renderAxis$1(props, radius);
        this.setState({
          tickSize: tickSize,
          radius: radius,
          axisNode: axisNode
        });
      };

      _proto.render = function render$$1(_ref) {
        var center = _ref.center,
            animation = _ref.animation;
        return h('group', {
          position: center,
          transition: animation ? GROUP_TRANSITION$3 : null
        }, this.renderEle());
      };

      _proto.renderEle = function renderEle() {
        var _this$state = this.state,
            axisNode = _this$state.axisNode,
            tickSize = _this$state.tickSize;
        var horizontal = this.props.horizontal;
        var offset = horizontal ? [0, tickSize / 2] : [-tickSize / 2, 0];
        return h('group', {
          position: offset
        }, axisNode, this.renderPlotBackground(), this.renderDataLabel(), this.renderNoodle());
      };

      _proto.renderDataLabel = function renderDataLabel$$2() {
        var _this$props = this.props,
            horizontal = _this$props.horizontal,
            row = _this$props.row,
            dataLabel = _this$props.dataLabel;
        var tickSize = this.state.tickSize;
        if (!row.dataLabel) return null;
        var _row$dataLabel$bounds = row.dataLabel.bounds,
            width = _row$dataLabel$bounds.width,
            height = _row$dataLabel$bounds.height;
        return renderDataLabel$$1({
          row: row,
          dataLabel: dataLabel,
          position: horizontal ? [0, -tickSize - THERMOMETER_WIDTH - height / 2] : [-THERMOMETER_WIDTH - width / 2, 0]
        });
      }
      /**
       * 底盘绘制
       * @private
       */
      ;

      _proto.renderPlotBackground = function renderPlotBackground() {
        var _this$props2 = this.props,
            horizontal = _this$props2.horizontal,
            tickSlotColor = _this$props2.gaugeColor.tickSlotColor,
            fake = _this$props2.fake,
            z = _this$props2.z,
            row = _this$props2.row,
            isFade = _this$props2.isFade;
        var radius = this.state.radius;
        var key = row.id;
        return h('rect', {
          id: key,
          key: key,
          z: z,
          silent: isFade,
          shape: getRectShape(radius, horizontal),
          style: {
            fill: getColor(tickSlotColor, DEFAULT_BACKGROUND$3, fake ? fakeOpacity$1 : 1)
          }
        });
      }
      /**
       * noodle = pointer + endPoint(with animate)
       * @private
       */
      ;

      _proto.renderNoodle = function renderNoodle() {
        var _this2 = this;

        var _this$props3 = this.props,
            pointers = _this$props3.pointers,
            color = _this$props3.color,
            horizontal = _this$props3.horizontal,
            gradient = _this$props3.gradient,
            isFade = _this$props3.isFade,
            isHovered = _this$props3.isHovered,
            animation = _this$props3.animation;
        var radius = this.state.radius;

        if (pointers.length === 0) {
          return null;
        }

        var _pointers$ = pointers[0],
            key = _pointers$.key,
            percent = _pointers$.percent,
            zero = _pointers$.zero;
        var backShape = getRectShape(radius, horizontal);
        var isGradient = !isFade && gradient && typeof gradient !== 'string'; // colorScale存在这里，renderEndPoint的时候直接用，不需要每animate都创建

        var colorScale = isGradient ? createColorScale(gradient) : function () {
          return gradient || color;
        };
        var pointerFill = isGradient ? createGradientPalette$1(gradient) : gradient || color;
        return h(Animate$$1, {
          start: {
            pct: zero
          },
          enter: {
            pct: animation ? [percent] : percent,
            timing: {
              duration: ENTER_DURATION$4,
              ease: ENTER_EASE$3
            }
          },
          update: {
            pct: animation ? [percent] : percent,
            timing: {
              duration: ENTER_DURATION$4,
              ease: ENTER_EASE$3
            }
          },
          leave: {}
        }, function (_ref2) {
          var pct = _ref2.pct;
          var shape = getRectShape(radius, horizontal, pct, zero);
          var fill = pointerFill;

          if (isFade) {
            fill = Fade.Color;
          } else if (isHovered) {
            fill = highlight(fill);
          }

          return h('group', null, _this2.renderPointer({
            shape: shape,
            backShape: backShape,
            isGradient: isGradient,
            fill: fill,
            key: key,
            isFade: isFade
          }), _this2.renderEndPoint({
            radius: radius,
            pct: pct,
            colorScale: colorScale
          }));
        });
      }
      /**
       * 指针
       */
      ;

      _proto.renderPointer = function renderPointer(_ref3) {
        var shape = _ref3.shape,
            backShape = _ref3.backShape,
            isGradient = _ref3.isGradient,
            fill = _ref3.fill,
            key = _ref3.key;
        var _this$props4 = this.props,
            opacity = _this$props4.opacity,
            fake = _this$props4.fake,
            _this$props4$center = _this$props4.center,
            cx = _this$props4$center[0],
            cy = _this$props4$center[1],
            horizontal = _this$props4.horizontal,
            axis = _this$props4.axis,
            z = _this$props4.z;
        var tickSize = getTickSize(axis, horizontal);
        var props = {
          key: key + '_pointer',
          z: z,
          shape: isGradient ? backShape : shape,
          silent: true,
          pos: [cx + (horizontal ? 0 : tickSize + TOOLTIP_GAP), cy + (horizontal ? TOOLTIP_GAP : 0)],
          style: {
            fill: fill,
            opacity: opacity * (fake ? 0.5 : 1)
          }
        }; // 渐变色填充则使用clip

        if (isGradient) {
          props.clip = {
            type: 'rect',
            shape: shape
          };
        }

        return h('rect', props);
      }
      /**
       * 内白外圈的端点绘制
       */
      ;

      _proto.renderEndPoint = function renderEndPoint(_ref4) {
        var radius = _ref4.radius,
            pct = _ref4.pct,
            colorScale = _ref4.colorScale;
        var _this$props5 = this.props,
            fake = _this$props5.fake,
            opacity = _this$props5.opacity;
        var _this$props6 = this.props,
            horizontal = _this$props6.horizontal,
            pointerColor = _this$props6.gaugeColor.pointerColor,
            z = _this$props6.z,
            isFade = _this$props6.isFade;
        var pos = radius * 2 * (pct - 0.5);
        return h('circle', {
          z: z,
          silent: true,
          shape: {
            cx: horizontal ? pos : 0,
            cy: horizontal ? 0 : -pos,
            r: 4.5
          },
          style: {
            fill: pointerColor || DEFAULT_POINTER_COLOR$1,
            stroke: isFade ? Fade.Color : colorScale(pct),
            lineWidth: 3,
            shadowColor: 'rgba(0,0,0,0.2)',
            shadowOffsetX: horizontal ? -1 : 0,
            shadowOffsetY: horizontal ? 0 : 1,
            opacity: opacity * (fake ? 0.5 : 1)
          }
        });
      };

      return ThermometerGauge;
    }(Component);

    var adjust$6 = function adjust(geom, chart) {
      var _diffFacet = diffFacet(chart),
          baseFacet = _diffFacet.baseFacet,
          geomFacet = _diffFacet.geomFacet;

      if (!isGeomUsePercentSize(baseFacet, geomFacet)) {
        return;
      }

      var unitX = baseFacet.unit,
          unitY = geomFacet.unit;
      var unit;

      if (geom.type === ChartLibrary.THERMOMETER_GAUGE) {
        var horizontal = geom.horizontal;
        unit = horizontal || geomFacet.hasMeasure ? unitX : unitY;
      } else {
        unit = geomFacet.hasMeasure ? unitX : Math.min(unitX, unitY);
      }

      unit /= 2;
      var data = geom.data;
      var sizeCol = data.getColById('size');

      _.each(sizeCol, function (value, index) {
        return sizeCol[index] = value * unit;
      });
    };

    var lastEl = function lastEl(arr) {
      return arr[arr.length - 1];
    };

    var getStepGradient = function getStepGradient(gradient, domain) {
      var type = gradient.type,
          colors = gradient.colors,
          min = domain[0],
          max = domain[1];
      var firstColor = colors[0],
          lastColor = lastEl(colors);

      if (firstColor.from >= max) {
        return firstColor.color;
      }

      if (lastColor.to <= min) {
        return lastColor.color;
      }

      var newColors = [],
          len = colors.length;

      var toPercent = function toPercent(value) {
        return (value - min) / (max - min);
      };

      _.each(colors, function (_ref, index) {
        var from = _ref.from,
            to = _ref.to,
            color = _ref.color;

        if (min <= from && to <= max) {
          newColors.push({
            from: toPercent(from),
            to: toPercent(to),
            color: color
          });
        } else {
          if (index === 0 && min < to || min > from && min < to) {
            newColors.unshift({
              from: 0,
              to: toPercent(min < from ? from : to),
              color: color
            });
          } else if (index === len - 1 && max > from || from < max && max < to) {
            newColors.push({
              from: toPercent(max > to ? to : from),
              to: 1,
              color: color
            });
          }
        }
      });

      if (newColors.length) {
        newColors[0].from = 0;
        newColors[newColors.length - 1].to = 1;
      }

      return {
        type: type,
        colors: newColors
      };
    };
    /**
     * 基于配置界面上的数值在满足min < max的情况下可以随便写，这边需要将出递过来的渐变配置与实际的domain统一整理一下
     * 得到最后绘制使用的gradient
     * @param gradient
     * @param domain
     */


    var getContinuousGradient = function getContinuousGradient(gradient, domain) {
      var min = domain[0],
          max = domain[1],
          type = gradient.type,
          colors = gradient.colors;
      var firstColor = colors[0],
          lastColor = colors[1];

      if (firstColor.value >= max) {
        return firstColor.color;
      }

      if (lastColor.value <= min) {
        return lastColor.color;
      }

      var toPercent = function toPercent(v) {
        return (v - min) / (max - min);
      };

      var newColors = [],
          len = colors.length;

      _.each(colors, function (_ref2, index) {
        var value = _ref2.value,
            color = _ref2.color;

        // 过滤掉在min & max之外的颜色
        if (min <= value && value <= max) {
          newColors.push({
            value: toPercent(value),
            color: color
          });
        } else {
          var next = colors[index + 1]; // 0值对应的颜色

          if (value < min && (index === 0 || next && next.value > min)) {
            newColors.unshift({
              value: 0,
              color: color
            });
          } // 1值对应的颜色
          else if (value < max && (index === len - 1 || next && next.value > max)) {
              newColors.push({
                value: 1,
                color: color
              });
            }
        }
      });

      if (newColors.length) {
        newColors[0].value = 0;
        newColors[newColors.length - 1].value = 1;
      }

      return {
        type: type,
        colors: newColors
      };
    };

    var getGaugeGradient = function getGaugeGradient(gauge, axisDomain) {
      var type = gauge.color.style;

      if (!type || type === ColorStyle.NORMAL) {
        return;
      }

      var aes = getAesInstance(AesTypes.COLOR, gauge, gauge.color);
      var domain = aes.domain,
          range = aes.range;
      var i = 0,
          len = domain.length;
      var colors = [];

      if (type === ColorStyle.STEP) {
        for (i = 1; i < len; i++) {
          var from = domain[i - 1],
              to = domain[i];
          colors.push({
            from: from,
            to: to,
            color: range[i]
          });
        }
      } else if (type === ColorStyle.CONTINUOUS) {
        for (i = 0; i < len; i++) {
          colors.push({
            value: domain[i],
            color: range[i]
          });
        }
      }

      var gradient = {
        colors: colors,
        type: type
      };
      return formatGradient(gradient, axisDomain);
    };
    var formatGradient = function formatGradient(gradient, domain) {
      if (!domain.length) {
        return null;
      }

      var type = gradient.type;
      return type === 'continuous' ? getContinuousGradient(gradient, domain) : getStepGradient(gradient, domain);
    };
    var getDomainAndTickFromGaugeFields = function getDomainAndTickFromGaugeFields(pointers, target, needAxis) {
      var _minMax = minMax(_.filter(pointers, function (p) {
        return p !== NULL_VALUE;
      })),
          _min = _minMax[0],
          _max = _minMax[1];

      var fixedMin = false,
          fixedMax = false;

      if (target != null && target !== NULL_VALUE) {
        if (target >= 0) {
          fixedMax = true;
          _max = target;
          _min = Math.min(_min, 0);
        } else {
          fixedMin = true;
          _min = target;
          _max = Math.max(_max, 0);
        }
      }

      if (_min === _max) {
        _max = 100;
      }

      var interval = linearTickInterval(_min, _max);
      var domain = linearNiceDomain(_min, _max, interval);
      var min = domain[0],
          max = domain[1];
      domain[0] = fixedMin ? _min : min;
      domain[1] = fixedMax ? _max : max;
      var ticks = [];

      if (needAxis) {
        var start = min,
            end = domain[1];

        if (fixedMin) {
          var diff = accMul(Math.ceil(accDiv(accAdd(_min, -start), interval)), interval);
          start = accAdd(start, diff);
        }

        while (start <= end) {
          ticks.push(start);
          start = accAdd(start, interval);
        }
      }

      return {
        domain: domain,
        ticks: ticks
      };
    };

    var _GaugeFactory;
    var GaugeFactory = (_GaugeFactory = {}, _GaugeFactory[ChartLibrary.POINTER_GAUGE] = PointerGauge, _GaugeFactory[ChartLibrary.RING_GAUGE] = RingGauge, _GaugeFactory[ChartLibrary.SLOT_GAUGE] = SlotGauge, _GaugeFactory[ChartLibrary.THERMOMETER_GAUGE] = ThermometerGauge, _GaugeFactory);
    var MIN_GAUGE_RADIUS = 1;

    var Gauge =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(Gauge, _Geometry);

      function Gauge() {
        return _Geometry.apply(this, arguments) || this;
      }

      var _proto = Gauge.prototype;

      _proto.renderGraphic = function renderGraphic(node) {
        var row = node.data,
            key = node.key;

        if (row.vanish) {
          return null;
        }

        var type = this.props.type;
        var needAxis = type === ChartLibrary.POINTER_GAUGE || type === ChartLibrary.THERMOMETER_GAUGE;
        var GaugeGeometry = GaugeFactory[type];

        var gaugeProps = this._formatGaugeProps({
          row: row,
          needAxis: needAxis
        });

        gaugeProps.id = gaugeProps.key = key;
        return h(GaugeGeometry, _extends({}, this.props, gaugeProps));
      };

      _proto._formatGaugeProps = function _formatGaugeProps(_ref) {
        var row = _ref.row,
            needAxis = _ref.needAxis;
        var _this$props = this.props,
            fixedTarget = _this$props.fixedTarget,
            targetFormat = _this$props.targetFormat,
            fadeChecker = _this$props.fadeChecker,
            highlights = _this$props.highlights,
            _this$props$sizeScale = _this$props.sizeScale,
            sizeScale = _this$props$sizeScale === void 0 ? 1 : _this$props$sizeScale;
        var x = row.x,
            y = row.y,
            radius = row.size,
            color = row.color,
            fake = row.fake;

        var pointers = _.filter(row.pointers, function (v) {
          return v !== NULL_VALUE && isFinite(v);
        });

        var target = row.target; // Cmen@BI-24966 target为null时，domain从pointerValues中计算获取

        var _ref2 = target ? getDomainAndTickFromGaugeFields(pointers, target, needAxis) : fixedTarget || {
          domain: [],
          ticks: []
        },
            domain = _ref2.domain,
            _ref2$domain = _ref2.domain,
            min = _ref2$domain[0],
            max = _ref2$domain[1],
            ticks = _ref2.ticks;

        var axisScale = function axisScale(value) {
          value = clamp(value, min, max);
          return (value - min) / (max - min);
        };

        forEach(pointers, function (value, i) {
          pointers[i] = {
            key: row.id + SEPARATOR + i,
            value: value,
            percent: axisScale(value),
            zero: axisScale(0) // for animation start

          };
        });
        var isHovered = highlights[row.id];
        return {
          row: row,
          isFade: fadeChecker(row),
          isHovered: isHovered,
          z: isHovered ? HoverLayerZ : NormalLayerZ,
          center: [x, y],
          radius: Math.max(radius * sizeScale - 1, MIN_GAUGE_RADIUS),
          // BI-36361
          pointers: pointers,
          color: color,
          gradient: getGaugeGradient(this.props, domain),
          start: min,
          fake: fake,
          axis: {
            targetFormat: targetFormat,
            domain: domain,
            enabled: true,
            labelContent: pointers.length === 0 ? [] : ticks // http://www.finedevelop.com/pages/viewpage.action?pageId=24067976

          }
        };
      }
      /**
       * rendered in children gauge
       * @returns {null}
       */
      ;

      _proto.renderGuides = function renderGuides() {
        return null;
      };

      return Gauge;
    }(Geometry);

    Gauge.usePercentSize = isGeomUsePercentSize;
    Gauge.adjust = adjust$6;

    Gauge.updateGeometryWhileZoomScale = function (_ref3) {
      var geom = _ref3.geom,
          facetX = _ref3.facetX,
          facetY = _ref3.facetY,
          zoom = _ref3.zoom,
          inverted = _ref3.inverted;
      var type = geom.type,
          xUnit = facetX.unit,
          yUnit = facetY.unit;

      var _diffFacet = diffFacet(facetX, facetY),
          geomFacet = _diffFacet.geomFacet;

      if (type === ChartLibrary.THERMOMETER_GAUGE) {
        var horizontal = geom.horizontal;
        geom.sizeScale = zoom[(horizontal || geomFacet.measures.length > 0) ^ inverted ? 'x' : 'y'];
      } else {
        geom.sizeScale = geomFacet.measures.length ? zoom[inverted ? 'y' : 'x'] : Math.min(zoom.x * xUnit, zoom.y * yUnit) / Math.min(xUnit, yUnit);
      }
    };

    Geom.registerGeom('pointerGauge', Gauge);
    Geom.registerGeom('ringGauge', Gauge);
    Geom.registerGeom('slotGauge', Gauge);
    Geom.registerGeom('thermometerGauge', Gauge);

    var appear$6 = function appear(_ref) {
      var style = _ref.style;
      return {
        style: _extends({}, style, {
          opacity: 0
        })
      };
    };

    var Timing$b = {
      INIT: {
        duration: 1200,
        ease: Ease.EaseOutCubic,
        appear: appear$6
      },
      SHOW_ENTER: {
        duration: 1000,
        ease: Ease.EaseOutCubic,
        appear: appear$6
      },
      SHOW_UPDATE: {
        duration: 300,
        ease: Ease.EaseOutCubic
      },
      HIDE_UPDATE: {
        duration: 300,
        ease: Ease.EaseOutCubic
      },
      HOVER: {
        duration: 300,
        ease: Ease.Default
      },
      HIDE_LEAVE: {
        duration: 300,
        ease: Ease.EaseOutCubic
      }
    };

    var FEATURE_FILL = '#d4d4d4';
    var FEATURE_STROKE = '#fff';
    var FEATURE_OPACITY = 0.75;

    var vanishStyle = function vanishStyle(style) {
      style.fill = FEATURE_FILL;
      style.opacity = 0;
    };

    var SHADOW_BLUR = 4;
    var SHADOW_OFFSET_X = 1;
    var SHADOW_OFFSET_Y = 2;
    var SHADOW_COLOR = 'rgba(0,0,0, 0.15)';

    var hoverStyle$2 = function hoverStyle$$1(style) {
      hoverStyle(style);
      style.shadowBlur = SHADOW_BLUR;
      style.shadowOffsetX = SHADOW_OFFSET_X;
      style.shadowOffsetY = SHADOW_OFFSET_Y;
      style.shadowColor = SHADOW_COLOR;
    };

    var getTransitionProps$c = getGeomTransitionProps(Timing$b);

    var AreaMap$1 =
    /*#__PURE__*/
    function (_Geometry) {
      _inheritsLoose(AreaMap, _Geometry);

      function AreaMap(props) {
        var _this;

        _this = _Geometry.call(this, props) || this;
        _this.state = {
          data: []
        };

        _this.updateState(props);

        _this.getTransitionProps = getTransitionProps$c;
        return _this;
      }

      var _proto = AreaMap.prototype;

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (nextProps.rows !== this.props.rows) {
          this.updateState(nextProps);
        }
      };

      _proto.updateState = function updateState(props) {
        var rows = props.rows,
            _props$mapConfig = props.mapConfig,
            zoom = _props$mapConfig.zoom,
            crs = _props$mapConfig.crs,
            features = _props$mapConfig.features,
            imageBackground = _props$mapConfig.imageBackground,
            nameMatched = _props$mapConfig.nameMatched,
            latLngMatched = _props$mapConfig.latLngMatched,
            facetX = props.facetX,
            facetY = props.facetY;
        var Crs = CRS[crs];
        var data = rows.filter(function (row) {
          return row.rings;
        });
        var featureRings = [];
        var imageScale = imageBackground ? imageBackground.imageScale : 1;

        _.each(features, function (feature) {
          var _collectRings = collectRings(feature, Crs, zoom, imageScale),
              rings = _collectRings.rings;

          featureRings.push(rings);
        }); // 力学区域点图的判断依据为非名称匹配或者横纵轴上有指标字段


        var force = !(nameMatched || latLngMatched || facetX.hasMeasure || facetY.hasMeasure);
        this.setState({
          data: data,
          featureRings: featureRings,
          force: force
        });
      };

      _proto.render = function render() {
        var _this$props = this.props,
            bounds = _this$props.bounds,
            nameMatched = _this$props.mapConfig.nameMatched;
        var force = this.state.force; // 名称匹配为地图，否则为中国形状的点图

        return nameMatched ? h('group', {
          clip: {
            type: 'rect',
            shape: _extends({}, bounds)
          }
        }, this.renderFeatures(), _Geometry.prototype.render.call(this)) : h(Geom.getGeom(force ? ChartLibrary.FORCE_POINT : ChartLibrary.POINT), _extends({}, this.props, {
          gradual: false,
          areaMap: true
        }));
      };

      _proto.renderFeatures = function renderFeatures() {
        var featureRings = this.state.featureRings;
        return _.map(featureRings, function (rings) {
          return h('areaMap', {
            shape: {
              rings: rings
            },
            silent: true,
            style: {
              fill: FEATURE_FILL,
              silent: true,
              stroke: FEATURE_STROKE,
              opacity: FEATURE_OPACITY
            }
          });
        });
      };

      _proto.renderGraphic = function renderGraphic(node, transitionProps) {
        var key = node.key,
            data = node.data;
        var _this$props2 = this.props,
            opacity = _this$props2.opacity,
            borderColor = _this$props2.borderColor;
        var rings = data.rings,
            x = data.x,
            y = data.y,
            fill = data.color,
            vanish = data.vanish;
        var transition = transitionProps.transition,
            transitionEnd = transitionProps.transitionEnd,
            silent = transitionProps.silent,
            isFade = transitionProps.isFade,
            isHover = transitionProps.isHover,
            z = transitionProps.z;
        var style = {
          fill: fill,
          shadowBlur: 0,
          opacity: opacity,
          stroke: borderColor,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: SHADOW_COLOR
        };
        isFade && fadeStyle(style);
        isHover && hoverStyle$2(style);
        vanish && vanishStyle(style);

        if (transition) {
          transition.properties = {
            style: 1
          };
        }

        return h('areaMap', {
          key: key,
          id: key,
          transition: transition,
          transitionEnd: transitionEnd,
          silent: silent || vanish,
          tooltipPos: [x, y],
          z: z,
          origin: [x, y],
          shape: {
            rings: rings
          },
          style: style
        });
      };

      _proto.addExtraGuideReferProps = function addExtraGuideReferProps(refer, node) {
        var _node$data = node.data,
            x = _node$data.x,
            y = _node$data.y;
        refer.applyTheme = true;
        refer.startPos = [x, y];
      };

      _proto.showEffect = function showEffect(id, effect) {
        showScaledEffect.call(this, id, effect);
      };

      return AreaMap;
    }(Geometry);

    Geom.registerGeom('areaMap', AreaMap$1);

    // Geometry

    /**
     * Created by Jeffrey on 2018/7/12.
     */

    var BISupported = function BISupported() {
      return typeof BI !== 'undefined' && BI.Func;
    };

    Request.urls.image = function () {
      var _BI$Func;

      return BISupported() && (_BI$Func = BI.Func).getCompleteImageUrl.apply(_BI$Func, arguments);
    };

    Request.urls.tileImage = function () {
      var _BI$Func2;

      return BISupported() && (_BI$Func2 = BI.Func).getCompleteTileImageUrl.apply(_BI$Func2, arguments);
    }; // api.requestData

    if (env$2.touchEventsSupported) {
      // BI 版本号应该放在哪这是个问题
      // 为了统一，移动端都放`getCompleteUrl`处理
      var URL = {
        IMAGE: '/design/image/',
        TILE_IMAGE: '/design/widget/chart/tiles/',
        DATA: '/design/widget/data',
        TOOLTIP: '/design/widget/chart/tooltip'
      };

      var completeUrlGenerator = function completeUrlGenerator(url) {
        return function (id) {
          return Request.getCompleteUrl(url + id);
        };
      };

      Request.urls.image = completeUrlGenerator(URL.IMAGE);
      Request.urls.tileImage = completeUrlGenerator(URL.TILE_IMAGE);

      Request.services.refresh = function (data, success) {
        var setting = Request.getSetting(); // mutate setting
        // shall we ?

        if (data) {
          data = assign(setting, data);
        }

        Request.requestData({
          url: URL.DATA,
          data: data,
          success: success
        });
      };

      Request.services.filter = function (data, success) {
        var setting = Request.getSetting(data.wId); // mutate

        assign(setting, {
          chartFilter: data
        });
        Request.requestData({
          url: URL.DATA,
          data: setting,
          success: success
        });
      };

      Request.services.tooltipInfo = function (data, success) {
        Request.requestData({
          url: URL.TOOLTIP,
          data: data,
          success: success
        });
      };
    }

    var Van$1 = global$1.Van || {};

    var formatOptions2State = function formatOptions2State(data) {
      return data;
    };

    assign(Van$1, {
      version: '1.3.1',
      hash: '50816ed',
      buildTime: '5/7/2019, 5:29:17 PM',
      VanChart: Chart$1,
      TileChart: TileChart,
      Request: Request,
      $overrideText: $override$1,
      formatOptions2State: formatOptions2State,
      $override: $override,
      env: env$1
    });
    global$1.Van = Van$1;

    return Van$1;

}));
